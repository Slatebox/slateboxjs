<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div style="border: 1px solid red; width: 100%; height: 800px" id="slateCanvas"></div>
    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"knIEI":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "51221d3ac2cb24fb";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        if (e.message) console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"620jy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _indexJs = require("./index.js");
var _attemptJs = require("./plugins/node/attempt.js");
var _secondJs = require("./plugins/slate/second.js");
var _utilsJs = require("./helpers/utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
async function load() {
    const s = await new (0, _indexJs.Slatebox).slate({
        name: "New Slate",
        id: "collab-demo",
        description: "",
        defaultLineColor: "#333",
        container: "slateCanvas",
        basedOnThemeId: "",
        syncWithTheme: false,
        viewPort: {
            useInertiaScrolling: true,
            showGrid: false,
            snapToObjects: true,
            gridSize: 50,
            width: 50000,
            height: 50000,
            left: 25000,
            top: 25000
        },
        enabled: true,
        allowDrag: true,
        showbirdsEye: true,
        sizeOfbirdsEye: 150,
        showMultiSelect: true,
        showZoom: true,
        showUndoRedo: true,
        showStatus: true,
        showLocks: true,
        mindMapMode: true,
        isPublic: true,
        isUnlisted: false,
        autoEnableDefaultFilters: true,
        allowCollaboration: true,
        followMe: false,
        containerStyle: {
            backgroundColor: "",
            backgroundImage: "",
            backgroundSize: "",
            backgroundEffect: "",
            backgroundColorAsGradient: true,
            backgroundGradientType: "radial",
            backgroundGradientColors: [
                "#fff",
                "#333"
            ],
            backgroundGradientStrategy: "shades"
        }
    }, {
        onInitCollaboration: async ()=>{
            return {
                websocketUrl: `ws://localhost:1122`,
                // DEMO (in mongo)
                websocketParams: {
                    bearer: "xxx",
                    timestamp: "2024-01-29T03:19:34.877Z"
                },
                userName: "guest1",
                color: "#000",
                x: 0,
                y: 0
            };
        },
        onCollaborationUsersRemoved: (users)=>{
            console.log("collab users removed", users);
        },
        onCollaborationUsersAdded: (users)=>{
            console.log("collab users added", users);
        },
        onConfirmRequested: async (title, msg, cb)=>{
        // implement confirmation dialog
        },
        onTakeSnapshot: async (opts)=>{
        // implement slate snapshot
        },
        onTextPaneRequested: (node, cb)=>{
        // implement text pane
        },
        onLineMenuRequested: (node, association, cb)=>{
        // implement line menu request
        },
        onMenuRequested: (node, cb)=>{
        // implement menu request
        },
        onBase64ImageRequested: (imgUrl, imageType, cb)=>{
        // implement base64 image request
        },
        // onOptimizeSVG: (svg, cb) => {
        //   // implement SVG optimization
        // },
        isReadOnly: ()=>{
            // is the slate read only for this user?
            return false;
        },
        isCommentOnly: ()=>{
            // does the user have comment only access to this slate?
            return false;
        },
        canRemoveComments: ()=>{
        // can the user remove comments?
        },
        onThemeRequired: (opts, cb)=>{
        // expirmental: provide a them in the cb
        }
    }).init();
    // await s.collab.init()
    //this is a new slate
    // s.shareId = 'test'
    // const defaultNodeOpts = {
    //   name: 'MASTER_NODE',
    //   text: 'Welcome to Slatebox!',
    //   xPos: 5500,
    //   yPos: 5300,
    //   height: 100,
    //   width: 175,
    //   vectorPath: 'roundedrectangle',
    //   backgroundColor: '90-#031634-#2D579A', //blue default
    //   foregroundColor: '#fff',
    //   lineColor: '#333',
    //   lineWidth: 5,
    //   allowDrag: true,
    // }
    // const n = new Slatebox.node(defaultNodeOpts)
    // s.nodes.add(n)
    const nodes = [
        new (0, _indexJs.Slatebox).node({
            id: "first_node",
            name: "first_node",
            text: "drag me",
            xPos: 25110,
            yPos: 25120,
            height: 60,
            width: 120,
            vectorPath: "roundedrectangle",
            backgroundColor: "#24A8E0",
            lineColor: "#333",
            lineWidth: 5,
            allowMenu: false,
            link: {
                show: true,
                type: "currentSlate",
                data: "second_node"
            },
            filters: {
                vect: "dropShadow"
            }
        }),
        new (0, _indexJs.Slatebox).node({
            id: "second_node",
            name: "second_node",
            text: "drag me",
            xPos: 25310,
            yPos: 25220,
            height: 60,
            width: 120,
            vectorPath: "roundedrectangle",
            backgroundColor: "#24A8E0",
            lineColor: "#333",
            lineWidth: 5,
            allowMenu: false,
            link: {
                show: true,
                type: "url",
                data: "https://slatebox.com"
            }
        })
    ];
    s.nodes.addRange(nodes);
    nodes[0].relationships.addAssociation(nodes[1], {
        showChildArrow: true,
        showParentArrow: true
    });
}
load();
// setTimeout(() => {
//   s.svg()
// }, 1000)
// console.log('node plugins ', n.plugins)
// n.plugins.attempt.doAttempt()
// s.plugins.attempt.doSecond()
const largePath = `M 0 84.500 L 0 151 3.500 151 L 7 151 7 84.500 L 7 18 3.500 18 L 0 18 0 84.500 M 57 85.500 L 57 152 139 152 L 221 152 221 119.500 L 221 87 240.500 87 L 260 87 260 119.500 L 260 152 342 152 L 424 152 424 119.500 L 424 87 449 87 L 474 87 474 119.500 L 474 152 486.500 152 L 499 152 499 119.500 L 499 87 524.500 87 L 550 87 550 119.500 L 550 152 632 152 L 714 152 714 119.500 L 714 87 739.500 87 L 765 87 765 120 L 765 153 777 153 L 789 153 789 120 L 789 87 814.500 87 L 840 87 840 119.500 L 840 152 922 152 L 1004 152 1004 119.500 L 1004 87 1023.500 87 L 1043 87 1043 119.500 L 1043 152 1121.500 152 L 1200 152 1200 85.500 L 1200 19 1121.500 19 L 1043 19 1043 51.500 L 1043 84 1023.500 84 L 1004 84 1004 51.500 L 1004 19 922 19 L 840 19 840 51.500 L 840 84 814.500 84 L 789 84 789 51.500 L 789 19 777 19 L 765 19 765 51.500 L 765 84 739.500 84 L 714 84 714 51.500 L 714 19 632 19 L 550 19 550 51.500 L 550 84 524.500 84 L 499 84 499 51.500 L 499 19 486.500 19 L 474 19 474 51.500 L 474 84 449 84 L 424 84 424 51.500 L 424 19 342 19 L 260 19 260 51.500 L 260 84 240.500 84 L 221 84 221 51.500 L 221 19 139 19 L 57 19 57 85.500 M 133.533 58.082 C 122.206 60.871, 118.314 74.231, 126.317 82.852 C 127.517 84.146, 131.940 86.939, 136.144 89.060 C 147.744 94.911, 150.832 100.596, 145.669 106.598 C 142.376 110.427, 133.984 111.139, 127.745 108.119 C 121.956 105.316, 121 105.438, 121 108.977 C 121 112.696, 123.746 114.633, 131.251 116.207 C 145.629 119.223, 156.832 111.049, 155.776 98.314 C 155.214 91.533, 152.426 88.438, 142.223 83.269 C 138.132 81.196, 133.708 78.426, 132.392 77.114 C 129.248 73.977, 129.273 69.636, 132.455 66.455 C 135.535 63.374, 141.620 63.191, 147.793 65.992 C 151.460 67.657, 152.168 67.726, 152.651 66.468 C 153.635 63.904, 152.137 60.384, 149.564 59.211 C 145.867 57.527, 138.032 56.975, 133.533 58.082 M 913.500 63.881 C 906.055 67.299, 903.056 73.063, 902.841 84.365 C 902.730 90.193, 903.178 92.737, 904.965 96.427 C 907.660 101.995, 909.787 103.547, 916.782 105.047 C 926.732 107.181, 935.255 102.540, 938.604 93.164 C 940.233 88.601, 940.372 78.414, 938.866 73.899 C 935.532 63.906, 923.658 59.216, 913.500 63.881 M 339 83.934 L 339 105 342.020 105 L 345.041 105 344.770 84.250 L 344.500 63.500 341.750 63.184 L 339 62.867 339 83.934 M 1124 65.677 C 1119.641 66.556, 1114.859 71.066, 1112.253 76.758 C 1107.439 87.274, 1110.780 101.807, 1118.974 105.987 C 1126.535 109.844, 1140.068 107.526, 1140.820 102.245 C 1141.190 99.643, 1139.661 99.407, 1136 101.500 C 1131.773 103.916, 1124.631 103.402, 1121.096 100.427 C 1112.967 93.587, 1115.182 74.505, 1124.496 71.138 C 1128.851 69.563, 1130.486 69.697, 1135 72 C 1139.988 74.545, 1140 74.543, 1140 71.161 C 1140 69.065, 1139.311 68.007, 1137.373 67.124 C 1134.252 65.702, 1127.501 64.972, 1124 65.677 M 620 87 L 620 108 623 108 L 626 108 626 100 L 626 92 630.750 91.996 C 641.593 91.988, 648.619 82.205, 644.634 72.666 C 642.549 67.676, 638.375 66, 628.032 66 L 620 66 620 87 M 916.030 68.223 C 912.474 70.103, 909.023 75.718, 908.855 79.898 C 908.438 90.233, 910.462 96.839, 914.751 99.134 C 916.155 99.885, 919.227 100.500, 921.578 100.500 C 929.670 100.500, 933.777 94.918, 933.924 83.718 C 934.008 77.328, 932.374 72.478, 929.179 69.632 C 926.530 67.272, 919.295 66.497, 916.030 68.223 M 626 78.562 L 626 87 630.277 87 C 635.534 87, 638.629 84.967, 639.515 80.933 C 640.577 76.098, 638.417 72.171, 634.131 71.140 C 625.945 69.172, 626 69.122, 626 78.562 M 144 181.917 C 144 188.533, 144.280 190, 145.542 190 C 146.823 190, 147.035 188.700, 146.792 182.330 C 146.601 177.303, 146.069 174.518, 145.250 174.247 C 144.319 173.939, 144 175.896, 144 181.917 M 98.750 176.077 C 96.155 177.593, 96.561 181.667, 99.500 183.592 C 102.722 185.703, 102.710 187.369, 99.476 186.751 C 96.614 186.204, 95.037 187.776, 97.122 189.096 C 99.281 190.464, 102.706 190.151, 104.429 188.429 C 106.888 185.969, 106.321 183.217, 103 181.500 C 99.320 179.597, 98.985 177.528, 102.500 178.411 C 104.345 178.874, 105 178.640, 105 177.519 C 105 176.684, 104.587 176, 104.082 176 C 103.577 176, 102.564 175.787, 101.832 175.527 C 101.099 175.267, 99.713 175.514, 98.750 176.077 M 149 176.500 C 149 177.325, 149.675 178, 150.500 178 C 151.325 178, 152 177.325, 152 176.500 C 152 175.675, 151.325 175, 150.500 175 C 149.675 175, 149 175.675, 149 176.500 M 314.639 175.694 C 314.288 176.046, 314 179.408, 314 183.167 C 314 188.574, 314.313 190, 315.500 190 C 316.689 190, 317 188.562, 317 183.059 C 317 176.626, 316.201 174.133, 314.639 175.694 M 598.667 175.667 C 598.300 176.033, 598 179.408, 598 183.167 C 598 189.333, 598.195 190, 600 190 C 601.467 190, 602 189.333, 602 187.500 C 602 185.759, 602.547 185, 603.800 185 C 606.403 185, 608 183.014, 608 179.775 C 608 177.663, 607.353 176.704, 605.435 175.975 C 602.458 174.843, 599.619 174.714, 598.667 175.667 M 888.500 176.171 C 885.628 177.834, 885.033 179.034, 885.015 183.193 C 884.990 189.250, 891.200 192.088, 895.989 188.210 C 898.549 186.137, 899.070 179.622, 896.850 177.452 C 894.837 175.483, 890.765 174.859, 888.500 176.171 M 1080.280 176.019 C 1078.102 176.897, 1076.508 180.678, 1076.763 184.362 C 1076.987 187.584, 1080.108 190.125, 1083.441 189.799 C 1087.801 189.371, 1088.096 186.474, 1083.777 186.489 C 1080.925 186.499, 1080.458 186.136, 1080.178 183.690 C 1079.752 179.976, 1081.700 177.708, 1084.676 178.455 C 1086.344 178.873, 1087 178.609, 1087 177.519 C 1087 176.684, 1086.587 176, 1086.082 176 C 1085.577 176, 1084.564 175.803, 1083.832 175.563 C 1083.099 175.322, 1081.501 175.527, 1080.280 176.019 M 355.700 178.037 C 353.826 180.227, 353.485 182, 354.940 182 C 355.456 182, 356.019 183.688, 356.190 185.750 C 356.439 188.762, 356.943 189.563, 358.750 189.820 C 360.263 190.034, 361 189.625, 361 188.570 C 361 187.706, 360.550 187, 360 187 C 359.450 187, 359 185.875, 359 184.500 C 359 183.125, 359.450 182, 360 182 C 361.557 182, 361.180 180.110, 359.200 177.984 C 357.422 176.075, 357.379 176.076, 355.700 178.037 M 912.044 177.918 C 910.996 179.877, 911.569 185.105, 913.176 188.250 C 914.268 190.387, 918 190.581, 918 188.500 C 918 187.675, 917.550 187, 917 187 C 916.450 187, 916 185.875, 916 184.500 C 916 183.125, 916.450 182, 917 182 C 918.709 182, 918.101 179.822, 915.847 177.867 C 913.205 175.576, 913.298 175.575, 912.044 177.918 M 943.261 178.954 C 942.493 180.184, 942.404 181.131, 943.020 181.513 C 943.559 181.846, 944 183.681, 944 185.590 C 944 189.299, 945.706 190.716, 948.750 189.536 C 950.417 188.889, 950.417 188.796, 948.750 187.568 C 946.535 185.937, 946.481 182.413, 948.657 181.578 C 950.133 181.012, 950.083 180.726, 948.199 178.971 C 945.554 176.507, 944.791 176.504, 943.261 178.954 M 1109.651 178.750 C 1109.385 179.713, 1109.467 182.525, 1109.833 185 C 1110.412 188.908, 1110.818 189.500, 1112.917 189.500 C 1114.246 189.500, 1115.521 188.938, 1115.750 188.250 C 1115.979 187.563, 1115.454 187, 1114.583 187 C 1113.561 187, 1113 186.114, 1113 184.500 C 1113 182.944, 1113.567 182, 1114.500 182 C 1116.569 182, 1116.377 180.767, 1113.989 178.722 C 1111.436 176.537, 1110.261 176.544, 1109.651 178.750 M 602 180 C 602 181.289, 602.506 181.998, 603.250 181.750 C 603.938 181.521, 604.500 180.733, 604.500 180 C 604.500 179.267, 603.938 178.479, 603.250 178.250 C 602.506 178.002, 602 178.711, 602 180 M 889.005 179.991 C 887.148 183.461, 888.118 186.456, 891.215 186.813 C 893.452 187.071, 894.050 186.648, 894.612 184.408 C 895.853 179.465, 891.234 175.826, 889.005 179.991 M 108.198 184.250 L 108.500 189.500 112.750 189.592 L 117 189.685 117 184.342 C 117 180.260, 116.646 179, 115.500 179 C 114.417 179, 114 180.111, 114 183 C 114 185.889, 113.583 187, 112.500 187 C 111.417 187, 111 185.889, 111 183 C 111 180.051, 110.592 179, 109.448 179 C 108.203 179, 107.955 180.042, 108.198 184.250 M 120 186.687 C 120 192.224, 120.325 194.060, 121.250 193.755 C 121.938 193.529, 122.637 192.415, 122.805 191.280 C 123.019 189.834, 123.658 189.359, 124.938 189.694 C 126.088 189.995, 127.366 189.315, 128.383 187.864 C 131.645 183.207, 129.862 179.712, 124.075 179.416 L 120 179.208 120 186.687 M 132 186.632 C 132 192.515, 132.302 194, 133.500 194 C 134.418 194, 135 193.066, 135 191.594 C 135 189.744, 135.428 189.299, 136.851 189.671 C 140.560 190.641, 143.442 184.826, 141.092 181.114 C 140.609 180.352, 138.366 179.624, 136.107 179.497 L 132 179.265 132 186.632 M 149 184.500 C 149 188.722, 149.348 190, 150.500 190 C 151.652 190, 152 188.722, 152 184.500 C 152 180.278, 151.652 179, 150.500 179 C 149.348 179, 149 180.278, 149 184.500 M 155.750 180.056 C 153.260 181.541, 153.386 187.601, 155.934 188.965 C 158.860 190.531, 163 190.258, 163 188.500 C 163 187.501, 161.914 186.956, 159.750 186.868 L 156.500 186.737 159.989 186.118 C 163.447 185.505, 164.725 183.622, 163.239 181.329 C 162.118 179.600, 157.758 178.859, 155.750 180.056 M 165.343 180.550 C 164.276 183.329, 165.502 189.484, 167.186 189.803 C 168.488 190.049, 168.943 189.254, 169.186 186.311 C 169.383 183.919, 169.965 182.593, 170.750 182.750 C 171.438 182.887, 172 182.130, 172 181.067 C 172 179.554, 171.328 179.153, 168.909 179.222 C 167.209 179.270, 165.604 179.868, 165.343 180.550 M 174.238 180.162 C 172.408 181.992, 172.725 183.694, 175.223 185.443 L 177.445 187 175.223 187 C 173.874 187, 173 187.614, 173 188.563 C 173 189.725, 173.836 190.046, 176.250 189.813 C 178.898 189.558, 179.556 189.023, 179.800 186.925 C 180.017 185.051, 179.473 184.048, 177.800 183.243 L 175.500 182.135 177.833 182.068 C 179.233 182.027, 180.002 181.500, 179.755 180.750 C 179.187 179.026, 175.742 178.658, 174.238 180.162 M 320 184.667 C 320 188.741, 320.354 190, 321.500 190 C 322.583 190, 323 188.889, 323 186 C 323 183.111, 323.417 182, 324.500 182 C 325.583 182, 326 183.111, 326 186 C 326 188.889, 326.417 190, 327.500 190 C 328.605 190, 329 188.847, 329 185.622 C 329 180.582, 327.798 179.260, 323.250 179.303 L 320 179.333 320 184.667 M 331.803 182.395 C 331.026 190.369, 333.210 197.737, 334.682 192.107 C 334.964 191.030, 336.379 189.974, 337.968 189.656 C 341.001 189.050, 342.354 186.072, 341.347 182.220 C 340.695 179.724, 340.846 179.799, 335.803 179.505 C 332.344 179.304, 332.086 179.490, 331.803 182.395 M 343.688 179.646 C 342.660 180.673, 342.858 185.867, 344.007 188.012 C 344.761 189.422, 346.015 189.854, 349.007 189.734 L 353 189.575 353 184.288 C 353 180.254, 352.644 179, 351.500 179 C 350.417 179, 350 180.111, 350 183 C 350 188.347, 347.258 188.628, 346.810 183.327 C 346.513 179.806, 345.143 178.191, 343.688 179.646 M 364.238 180.162 C 362.408 181.992, 362.725 183.694, 365.223 185.443 L 367.445 187 365.223 187 C 363.914 187, 363 187.617, 363 188.500 C 363 189.486, 363.986 190, 365.878 190 C 371.143 190, 372.356 185.449, 367.692 183.194 L 365.500 182.135 367.833 182.068 C 369.233 182.027, 370.002 181.500, 369.755 180.750 C 369.187 179.026, 365.742 178.658, 364.238 180.162 M 610 184.617 C 610 188.735, 610.352 190, 611.500 190 C 612.555 190, 613 188.934, 613 186.406 C 613 183.630, 613.464 182.691, 615.041 182.279 C 618.065 181.488, 616.830 179.578, 613.176 179.394 L 610 179.234 610 184.617 M 618.557 181.223 C 616.507 184.148, 616.590 186.319, 618.829 188.345 C 621.228 190.516, 624.287 190.445, 626.345 188.171 C 628.650 185.625, 628.409 182.400, 625.777 180.557 C 622.696 178.398, 620.386 178.611, 618.557 181.223 M 630.625 180.518 C 627.216 183.927, 629.844 190.451, 634.364 189.803 C 637.367 189.373, 637.753 186.308, 634.791 186.416 C 633.139 186.477, 632.500 185.942, 632.500 184.500 C 632.500 183.058, 633.139 182.523, 634.791 182.584 C 636.367 182.642, 636.988 182.173, 636.781 181.084 C 636.365 178.896, 632.593 178.550, 630.625 180.518 M 640 181 C 636.039 184.961, 638.677 190.365, 644.298 189.804 C 648.548 189.380, 648.906 187.232, 644.811 186.728 L 641.500 186.320 644.750 186.160 C 647.494 186.025, 648 185.617, 648 183.535 C 648 181.225, 645.579 179, 643.066 179 C 642.480 179, 641.100 179.900, 640 181 M 650.667 180.476 C 648.749 182.393, 649.362 184.382, 652.308 185.806 C 654.426 186.829, 654.407 186.867, 651.750 186.932 C 648.803 187.005, 648.027 188.689, 650.502 189.639 C 651.328 189.956, 653.128 189.934, 654.502 189.589 C 657.661 188.796, 657.803 185.676, 654.777 183.557 L 652.555 182 654.861 182 C 656.258 182, 657.005 181.508, 656.755 180.750 C 656.131 178.856, 652.453 178.690, 650.667 180.476 M 660.250 179.662 C 658.139 180.514, 658.808 184.602, 661.250 185.780 C 663.460 186.845, 663.451 186.866, 660.750 186.932 C 657.803 187.005, 657.027 188.689, 659.502 189.639 C 660.328 189.956, 662.128 189.934, 663.502 189.589 C 666.661 188.796, 666.803 185.676, 663.777 183.557 L 661.555 182 663.777 182 C 666.343 182, 666.745 180.500, 664.418 179.607 C 662.647 178.927, 662.052 178.935, 660.250 179.662 M 900 183.378 C 900 188.575, 901.213 189.813, 906.299 189.806 L 910.098 189.800 909.799 184.729 C 909.439 178.620, 907.272 177.133, 906.814 182.680 C 906.593 185.352, 905.980 186.582, 904.750 186.815 C 903.315 187.087, 903 186.412, 903 183.073 C 903 180.119, 902.588 179, 901.500 179 C 900.395 179, 900 180.153, 900 183.378 M 920 186.604 C 920 192.512, 920.302 194, 921.500 194 C 922.428 194, 923 193.059, 923 191.531 C 923 189.721, 923.410 189.220, 924.537 189.653 C 926.568 190.432, 930.004 187.241, 929.985 184.595 C 929.959 181.058, 928.333 179.634, 924.075 179.416 L 920 179.208 920 186.604 M 931.841 180.709 C 931.613 181.694, 931.669 184.075, 931.964 186 C 932.477 189.348, 932.685 189.504, 936.750 189.592 L 941 189.685 941 184.342 C 941 180.260, 940.646 179, 939.500 179 C 938.417 179, 938 180.111, 938 183 C 938 188.347, 935.258 188.628, 934.810 183.327 C 934.481 179.425, 932.534 177.709, 931.841 180.709 M 952.238 180.162 C 950.408 181.992, 950.725 183.694, 953.223 185.443 L 955.445 187 953.223 187 C 951.914 187, 951 187.617, 951 188.500 C 951 190.720, 956.678 190.469, 957.895 188.196 C 958.996 186.138, 958.365 184.819, 955.500 183.195 C 953.571 182.101, 953.583 182.060, 955.833 182.030 C 957.244 182.012, 958.004 181.506, 957.755 180.750 C 957.187 179.026, 953.742 178.658, 952.238 180.162 M 1089 183.378 C 1089 188.550, 1090.268 189.870, 1095 189.622 C 1098.497 189.439, 1098.500 189.436, 1098.500 184.553 C 1098.500 178.585, 1096.280 177.037, 1095.814 182.680 C 1095.593 185.352, 1094.980 186.582, 1093.750 186.815 C 1092.315 187.087, 1092 186.412, 1092 183.073 C 1092 180.119, 1091.588 179, 1090.500 179 C 1089.395 179, 1089 180.153, 1089 183.378 M 1101.667 180.476 C 1099.749 182.393, 1100.362 184.382, 1103.308 185.806 C 1105.410 186.821, 1105.384 186.867, 1102.667 186.932 C 1098.911 187.022, 1099.690 189.500, 1103.474 189.500 C 1105.111 189.500, 1106.745 188.744, 1107.391 187.687 C 1108.294 186.211, 1108.062 185.515, 1106.139 183.937 L 1103.778 182 1105.973 182 C 1107.281 182, 1108 181.495, 1107.755 180.750 C 1107.131 178.856, 1103.453 178.690, 1101.667 180.476 M 1118 181 C 1115.593 183.407, 1115.499 184.840, 1117.557 187.777 C 1120.474 191.943, 1127 189.678, 1127 184.500 C 1127 179.447, 1121.638 177.362, 1118 181 M 1129 184.698 C 1129 188.645, 1129.368 190, 1130.440 190 C 1131.375 190, 1131.988 188.713, 1132.190 186.327 C 1132.635 181.052, 1135 180.706, 1135 185.917 C 1135 191.332, 1137.737 191.684, 1138.190 186.327 C 1138.615 181.292, 1140.785 180.823, 1141.186 185.680 C 1141.407 188.352, 1142.020 189.582, 1143.250 189.815 C 1144.671 190.084, 1144.997 189.429, 1144.985 186.323 C 1144.960 180.241, 1144.005 179.507, 1136.037 179.448 L 1129 179.396 1129 184.698 M 1148 181 C 1144.039 184.961, 1146.677 190.365, 1152.298 189.804 C 1156.548 189.380, 1156.906 187.232, 1152.811 186.728 L 1149.500 186.320 1152.750 186.160 C 1155.494 186.025, 1156 185.617, 1156 183.535 C 1156 181.225, 1153.579 179, 1151.066 179 C 1150.480 179, 1149.100 179.900, 1148 181 M 1158 184.617 C 1158 188.635, 1158.365 190, 1159.440 190 C 1160.374 190, 1160.988 188.715, 1161.190 186.340 C 1161.408 183.762, 1162.018 182.605, 1163.250 182.428 C 1164.213 182.290, 1165 182.573, 1165 183.057 C 1165 183.540, 1166.237 184.607, 1167.750 185.428 L 1170.500 186.920 1167.667 186.960 C 1164.144 187.010, 1164.556 189.368, 1168.163 189.801 C 1173.172 190.401, 1174.474 184.928, 1169.772 183.039 L 1167.500 182.127 1169.750 182.063 C 1171.055 182.027, 1172 181.370, 1172 180.500 C 1172 178.833, 1169.289 178.532, 1167.048 179.949 C 1166.249 180.455, 1165.124 180.569, 1164.548 180.202 C 1163.971 179.836, 1162.263 179.469, 1160.750 179.385 C 1158.072 179.238, 1158 179.375, 1158 184.617 M 123 184.500 C 123 186.056, 123.567 187, 124.500 187 C 125.433 187, 126 186.056, 126 184.500 C 126 182.944, 125.433 182, 124.500 182 C 123.567 182, 123 182.944, 123 184.500 M 135.688 182.646 C 134.216 184.117, 134.990 187.149, 136.750 186.810 C 137.713 186.624, 138.500 185.616, 138.500 184.570 C 138.500 182.580, 136.869 181.464, 135.688 182.646 M 157.813 182.683 C 158.534 182.972, 159.397 182.936, 159.729 182.604 C 160.061 182.272, 159.471 182.036, 158.417 182.079 C 157.252 182.127, 157.015 182.364, 157.813 182.683 M 335 184.500 C 335 186.056, 335.567 187, 336.500 187 C 337.433 187, 338 186.056, 338 184.500 C 338 182.944, 337.433 182, 336.500 182 C 335.567 182, 335 182.944, 335 184.500 M 620.364 183.493 C 620.018 184.396, 620.214 185.614, 620.800 186.200 C 622.324 187.724, 625.210 186.331, 624.812 184.265 C 624.369 181.963, 621.165 181.407, 620.364 183.493 M 642.813 182.683 C 643.534 182.972, 644.397 182.936, 644.729 182.604 C 645.061 182.272, 644.471 182.036, 643.417 182.079 C 642.252 182.127, 642.015 182.364, 642.813 182.683 M 923.667 182.667 C 922.409 183.925, 923 187, 924.500 187 C 925.433 187, 926 186.056, 926 184.500 C 926 182.072, 925.026 181.307, 923.667 182.667 M 1120 184.500 C 1120 186.482, 1120.439 187.062, 1121.750 186.810 C 1122.713 186.624, 1123.500 185.585, 1123.500 184.500 C 1123.500 183.415, 1122.713 182.376, 1121.750 182.190 C 1120.439 181.938, 1120 182.518, 1120 184.500 M 1150.813 182.683 C 1151.534 182.972, 1152.397 182.936, 1152.729 182.604 C 1153.061 182.272, 1152.471 182.036, 1151.417 182.079 C 1150.252 182.127, 1150.015 182.364, 1150.813 182.683 M 81.208 208.750 C 81.519 217.002, 83.291 219.388, 83.807 212.250 C 84.056 208.814, 84.487 208, 86.057 208 C 87.657 208, 88 208.706, 88 212 C 88 214.200, 88.475 216, 89.055 216 C 89.689 216, 89.988 214.107, 89.805 211.250 C 89.526 206.900, 89.268 206.473, 86.750 206.184 C 84.590 205.935, 84 205.345, 84 203.434 C 84 201.908, 83.425 201, 82.458 201 C 81.176 201, 80.965 202.308, 81.208 208.750 M 161 203.500 C 161 205.490, 160.498 206, 158.535 206 C 156.051 206, 154 208.458, 154 211.434 C 154 214.071, 157.794 217.175, 159.773 216.158 C 160.723 215.670, 162.063 215.472, 162.750 215.718 C 163.680 216.052, 164 214.222, 164 208.583 C 164 202.509, 163.701 201, 162.500 201 C 161.567 201, 161 201.944, 161 203.500 M 203.667 201.667 C 203.300 202.033, 203 203.121, 203 204.083 C 203 205.046, 202.438 206.096, 201.750 206.417 C 200.750 206.883, 200.750 207.117, 201.750 207.583 C 202.438 207.904, 203 209.928, 203 212.083 C 203 214.238, 203.450 216, 204 216 C 204.550 216, 205 214.238, 205 212.083 C 205 209.928, 205.562 207.904, 206.250 207.583 C 207.250 207.117, 207.250 206.883, 206.250 206.417 C 204.497 205.599, 204.687 203, 206.500 203 C 207.325 203, 208 202.550, 208 202 C 208 200.883, 204.704 200.629, 203.667 201.667 M 369 208.500 C 369 212.833, 369.422 216, 370 216 C 370.578 216, 371 212.833, 371 208.500 C 371 204.167, 370.578 201, 370 201 C 369.422 201, 369 204.167, 369 208.500 M 668 203.906 C 668 206.323, 667.662 206.724, 665.995 206.288 C 663.090 205.529, 661 207.746, 661 211.587 C 661 215.471, 663.140 217.078, 667.261 216.291 C 669.952 215.776, 670 215.637, 670 208.383 C 670 204.128, 669.576 201, 669 201 C 668.450 201, 668 202.308, 668 203.906 M 862.208 208.750 C 862.514 216.883, 864.122 218.922, 865 212.293 C 865.338 209.746, 866.069 208.411, 867.250 208.186 C 868.685 207.913, 869 208.587, 869 211.927 C 869 214.167, 869.475 216, 870.055 216 C 870.689 216, 870.988 214.107, 870.805 211.250 C 870.526 206.900, 870.268 206.473, 867.750 206.184 C 865.590 205.935, 865 205.345, 865 203.434 C 865 201.908, 864.425 201, 863.458 201 C 862.176 201, 861.965 202.308, 862.208 208.750 M 927 203.417 C 927 205.496, 926.519 206, 924.535 206 C 920.528 206, 918.348 212.384, 921.470 214.975 C 922.278 215.646, 924.303 216.289, 925.970 216.405 C 929.292 216.635, 929.129 217.101, 929.240 207.050 C 929.276 203.782, 928.840 201.447, 928.150 201.217 C 927.481 200.994, 927 201.914, 927 203.417 M 1066 209 C 1066 217.331, 1067.656 220.163, 1068.193 212.750 C 1068.444 209.269, 1068.862 208.500, 1070.500 208.500 C 1072.138 208.500, 1072.556 209.269, 1072.807 212.750 C 1073.213 218.348, 1075 218.244, 1075 212.622 C 1075 207.760, 1073.184 205.457, 1070.005 206.288 C 1068.338 206.724, 1068 206.323, 1068 203.906 C 1068 202.308, 1067.550 201, 1067 201 C 1066.417 201, 1066 204.333, 1066 209 M 1190.670 203.750 C 1189.149 206.776, 1189.754 215.903, 1191.500 216.283 C 1192.050 216.402, 1192.646 214.706, 1192.824 212.513 C 1193.003 210.320, 1193.678 208.148, 1194.324 207.687 C 1195.215 207.051, 1195.197 206.725, 1194.250 206.341 C 1192.492 205.627, 1192.688 203, 1194.500 203 C 1195.325 203, 1196 202.550, 1196 202 C 1196 199.807, 1191.989 201.124, 1190.670 203.750 M 69 203 C 69 203.550, 70.125 204, 71.500 204 C 73.886 204, 74 204.271, 74 209.941 C 74 213.209, 74.450 216.160, 75 216.500 C 75.628 216.888, 76 214.677, 76 210.559 C 76 204.667, 76.203 204, 78 204 C 79.100 204, 80 203.550, 80 203 C 80 202.450, 77.525 202, 74.500 202 C 71.475 202, 69 202.450, 69 203 M 150 203.500 C 150 204.325, 150.450 205, 151 205 C 151.550 205, 152 204.325, 152 203.500 C 152 202.675, 151.550 202, 151 202 C 150.450 202, 150 202.675, 150 203.500 M 298.415 203.362 C 297.550 205.615, 298.424 216.005, 299.500 216.262 C 300.050 216.393, 300.653 214.250, 300.841 211.500 L 301.181 206.500 302.968 211 C 305.443 217.232, 307.170 217.175, 309.541 210.783 L 311.500 205.500 311.802 210.750 C 312.249 218.518, 314 217.124, 314 209 C 314 200.182, 312.062 199.555, 308.597 207.250 L 306.232 212.500 304.764 209 C 303.956 207.075, 303.018 204.713, 302.679 203.750 C 301.949 201.676, 299.159 201.422, 298.415 203.362 M 353.553 202.915 C 353.231 203.436, 353.394 204.125, 353.915 204.447 C 354.436 204.769, 355.125 204.606, 355.447 204.085 C 355.769 203.564, 355.606 202.875, 355.085 202.553 C 354.564 202.231, 353.875 202.394, 353.553 202.915 M 564.310 203.750 C 563.966 204.713, 562.838 207.696, 561.805 210.380 C 559.860 215.432, 560.206 217.806, 562.442 214.748 C 564.214 212.326, 567.815 212.563, 570.056 215.250 C 572.652 218.361, 572.553 216.041, 569.759 208.250 C 567.536 202.051, 565.516 200.383, 564.310 203.750 M 850 203 C 850 203.550, 850.879 204, 851.952 204 C 853.649 204, 853.944 204.819, 854.202 210.250 C 854.366 213.688, 854.950 216.500, 855.500 216.500 C 856.050 216.500, 856.634 213.688, 856.798 210.250 C 857.056 204.819, 857.351 204, 859.048 204 C 860.121 204, 861 203.550, 861 203 C 861 202.450, 858.525 202, 855.500 202 C 852.475 202, 850 202.450, 850 203 M 1054 203 C 1054 203.550, 1054.900 204, 1056 204 C 1057.776 204, 1058 204.667, 1058 209.941 C 1058 213.209, 1058.450 216.160, 1059 216.500 C 1059.628 216.888, 1060 214.677, 1060 210.559 C 1060 204.229, 1060.087 204, 1062.500 204 C 1063.875 204, 1065 203.550, 1065 203 C 1065 202.450, 1062.525 202, 1059.500 202 C 1056.475 202, 1054 202.450, 1054 203 M 1122 203.559 C 1122 204.416, 1122.450 204.840, 1123 204.500 C 1123.550 204.160, 1124 203.459, 1124 202.941 C 1124 202.423, 1123.550 202, 1123 202 C 1122.450 202, 1122 202.702, 1122 203.559 M 1138.150 202.950 C 1138.370 203.610, 1138.876 204.116, 1139.275 204.075 C 1140.471 203.951, 1140.239 202.580, 1138.950 202.150 C 1138.290 201.930, 1137.930 202.290, 1138.150 202.950 M 328 204.417 C 328 205.196, 327.438 206.096, 326.750 206.417 C 325.799 206.860, 325.786 207.135, 326.694 207.565 C 327.350 207.875, 327.639 208.776, 327.336 209.567 C 326.274 212.335, 327.916 216, 330.219 216 C 331.915 216, 332.133 215.733, 331.200 214.800 C 329.434 213.034, 329.740 208.918, 331.750 207.392 C 333.417 206.127, 333.417 206.062, 331.750 206.032 C 330.788 206.014, 330 205.325, 330 204.500 C 330 203.675, 329.550 203, 329 203 C 328.450 203, 328 203.637, 328 204.417 M 588 204.500 C 588 205.325, 587.460 206, 586.800 206 C 585.867 206, 585.867 206.267, 586.800 207.200 C 587.460 207.860, 588 210.062, 588 212.093 C 588 214.546, 588.534 215.991, 589.590 216.396 C 591.889 217.278, 593.625 215.929, 591.628 214.812 C 589.514 213.629, 589.408 208, 591.500 208 C 592.325 208, 593 207.550, 593 207 C 593 206.450, 592.325 206, 591.500 206 C 590.675 206, 590 205.325, 590 204.500 C 590 203.675, 589.550 203, 589 203 C 588.450 203, 588 203.675, 588 204.500 M 624 204.500 C 624 206.070, 623.184 206.319, 618.920 206.048 C 615.554 205.835, 613.786 208.084, 614.182 212.077 C 614.570 215.987, 617.809 217.651, 620.652 215.401 C 622.434 213.991, 622.429 213.944, 620.500 214.085 C 616.411 214.383, 615.864 214.028, 616.184 211.286 C 616.435 209.131, 617.163 208.437, 619.716 207.919 C 623.632 207.124, 624 207.443, 624 211.631 C 624 214.809, 626.832 217.835, 628.369 216.298 C 629.441 215.226, 629.066 213.987, 627.750 214.250 C 627.002 214.400, 626.374 213.196, 626.187 211.250 C 625.954 208.836, 626.275 208, 627.437 208 C 628.296 208, 629 207.550, 629 207 C 629 206.450, 628.325 206, 627.500 206 C 626.675 206, 626 205.325, 626 204.500 C 626 203.675, 625.550 203, 625 203 C 624.450 203, 624 203.675, 624 204.500 M 698 204.500 C 698 205.325, 697.460 206, 696.800 206 C 695.867 206, 695.867 206.267, 696.800 207.200 C 697.460 207.860, 698 209.830, 698 211.578 C 698 215.119, 699.881 217.310, 701.867 216.082 C 702.889 215.451, 702.828 215.148, 701.584 214.671 C 699.478 213.862, 699.404 208, 701.500 208 C 702.325 208, 703 207.550, 703 207 C 703 206.450, 702.325 206, 701.500 206 C 700.675 206, 700 205.325, 700 204.500 C 700 203.675, 699.550 203, 699 203 C 698.450 203, 698 203.675, 698 204.500 M 954 204.417 C 954 205.196, 953.438 206.096, 952.750 206.417 C 951.750 206.883, 951.750 207.117, 952.750 207.583 C 953.438 207.904, 954 209.881, 954 211.976 C 954 215.862, 955.577 217.498, 957.925 216.047 C 958.861 215.468, 958.777 215.128, 957.584 214.671 C 955.478 213.862, 955.404 208, 957.500 208 C 958.325 208, 959 207.550, 959 207 C 959 206.450, 958.325 206, 957.500 206 C 956.675 206, 956 205.325, 956 204.500 C 956 203.675, 955.550 203, 955 203 C 954.450 203, 954 203.637, 954 204.417 M 1165.860 204.750 C 1165.246 212.435, 1167.576 218.824, 1170.080 216.320 C 1170.867 215.533, 1170.869 215.037, 1170.087 214.554 C 1168.635 213.657, 1168.692 208.269, 1170.159 207.780 C 1170.924 207.525, 1170.678 206.647, 1169.437 205.197 C 1167.166 202.545, 1166.047 202.406, 1165.860 204.750 M 93.536 207.960 C 91.417 210.301, 92.102 214.449, 94.850 215.920 C 96.924 217.030, 101 216.272, 101 214.776 C 101 214.232, 100.325 214.045, 99.500 214.362 C 97.720 215.045, 95 214.157, 95 212.893 C 95 212.402, 96.323 212, 97.941 212 C 101.486 212, 102.463 210.734, 101.011 208.021 C 99.632 205.444, 95.841 205.414, 93.536 207.960 M 109 213.162 C 109 218.574, 109.313 220, 110.500 220 C 111.359 220, 112 219.099, 112 217.893 C 112 216.417, 112.456 215.961, 113.523 216.370 C 115.577 217.159, 119 213.567, 119 210.622 C 119 207.387, 117.054 206.021, 112.676 206.186 L 109 206.324 109 213.162 M 121 211 C 121 213.750, 121.450 216, 122 216 C 122.550 216, 123 214.383, 123 212.406 C 123 209.654, 123.468 208.690, 125 208.290 C 128.040 207.495, 127.388 206, 124 206 C 121.067 206, 121 206.111, 121 211 M 129.278 207.250 C 127.600 209.418, 127.236 211.427, 128.099 213.750 C 129.357 217.132, 135.605 216.960, 137.182 213.500 C 138.904 209.721, 136.900 206, 133.144 206 C 131.549 206, 129.810 206.563, 129.278 207.250 M 139.993 210.750 C 142.346 216.959, 144.247 217.261, 146.347 211.760 C 148.233 206.824, 148.345 206, 147.136 206 C 146.660 206, 145.618 207.688, 144.820 209.750 L 143.368 213.500 142.106 209.750 C 141.413 207.688, 140.248 206, 139.519 206 C 138.485 206, 138.589 207.044, 139.993 210.750 M 150 211.559 C 150 215.010, 150.379 216.884, 151 216.500 C 151.550 216.160, 152 213.659, 152 210.941 C 152 208.223, 151.550 206, 151 206 C 150.450 206, 150 208.502, 150 211.559 M 167.200 207.200 C 166.540 207.860, 166 209.896, 166 211.725 C 166 214.396, 166.518 215.246, 168.632 216.050 C 171.443 217.119, 175 216.484, 175 214.914 C 175 214.390, 173.954 214.224, 172.676 214.545 C 171.201 214.916, 169.877 214.557, 169.053 213.564 C 167.916 212.194, 168.205 212, 171.378 212 C 174.199 212, 175 211.602, 175 210.200 C 175 207.796, 173.076 206, 170.500 206 C 169.345 206, 167.860 206.540, 167.200 207.200 M 177.812 208.250 C 177.335 211.528, 178.086 216, 179.113 216 C 179.601 216, 180 214.383, 180 212.406 C 180 209.654, 180.468 208.690, 182 208.290 C 185.012 207.502, 184.401 206, 181.070 206 C 178.794 206, 178.066 206.503, 177.812 208.250 M 190.997 207.503 C 189.478 209.334, 189.364 213.764, 190.800 215.200 C 193.743 218.143, 200 215.205, 200 210.880 C 200 206.739, 193.619 204.345, 190.997 207.503 M 317 207 C 317 207.550, 318.125 208, 319.500 208 C 320.875 208, 322 208.450, 322 209 C 322 209.550, 321.155 210, 320.122 210 C 317.723 210, 315.604 212.525, 316.357 214.487 C 316.742 215.491, 318.293 216, 320.969 216 C 324.970 216, 325 215.972, 325 212.200 C 325 210.110, 324.460 207.860, 323.800 207.200 C 322.351 205.751, 317 205.593, 317 207 M 335.200 207.200 C 333.851 208.549, 333.626 212.864, 334.809 214.725 C 336.074 216.716, 343 216.856, 343 214.892 C 343 214.223, 342.054 214.021, 340.614 214.382 C 339.105 214.761, 337.775 214.433, 336.992 213.490 C 335.935 212.217, 336.281 212, 339.378 212 C 342.199 212, 343 211.602, 343 210.200 C 343 207.796, 341.076 206, 338.500 206 C 337.345 206, 335.860 206.540, 335.200 207.200 M 346 211.152 C 346 213.818, 346.450 216, 347 216 C 347.550 216, 348 214.383, 348 212.406 C 348 209.654, 348.468 208.690, 350 208.290 C 353.046 207.493, 352.385 206.123, 349 206.219 C 346.091 206.302, 346 206.451, 346 211.152 M 353 211 C 353 214.778, 353.367 216, 354.500 216 C 355.633 216, 356 214.778, 356 211 C 356 207.222, 355.633 206, 354.500 206 C 353.367 206, 353 207.222, 353 211 M 358 206.940 C 358 207.523, 359.350 208, 361 208 C 364.761 208, 364.962 209.756, 361.250 210.184 C 359.128 210.428, 358.431 211.098, 358.196 213.122 C 357.848 216.121, 359.353 217.038, 363.363 216.271 C 365.931 215.780, 366.081 215.464, 365.800 211.124 C 365.504 206.564, 365.448 206.496, 361.750 206.190 C 359.579 206.010, 358 206.326, 358 206.940 M 374.667 206.667 C 373.253 208.080, 374.080 211.208, 376 211.710 C 377.100 211.998, 378 212.864, 378 213.636 C 378 214.632, 377.277 214.857, 375.500 214.411 C 374.080 214.054, 373 214.216, 373 214.785 C 373 217.316, 379.399 217.010, 380.388 214.430 C 380.931 213.016, 378.576 210, 376.929 210 C 376.418 210, 376 209.550, 376 209 C 376 208.450, 376.900 208, 378 208 C 379.100 208, 380 207.550, 380 207 C 380 205.888, 375.714 205.620, 374.667 206.667 M 565.221 208 C 564.465 209.939, 564.573 210.576, 565.701 210.838 C 567.811 211.329, 568.163 210.600, 567.119 207.895 L 566.196 205.500 565.221 208 M 579.667 206.667 C 578.078 208.255, 579.158 211.110, 581.716 212.082 C 583.772 212.864, 584.098 213.321, 583.057 213.965 C 582.300 214.432, 581.078 214.583, 580.341 214.300 C 579.603 214.018, 579 214.298, 579 214.924 C 579 216.682, 581.615 217.276, 583.922 216.042 C 586.730 214.539, 586.541 212.204, 583.500 210.818 C 580.495 209.449, 580.238 208, 583 208 C 584.100 208, 585 207.550, 585 207 C 585 205.888, 580.714 205.620, 579.667 206.667 M 595 211.152 C 595 213.818, 595.450 216, 596 216 C 596.550 216, 597 214.383, 597 212.406 C 597 209.654, 597.468 208.690, 599 208.290 C 602.046 207.493, 601.385 206.123, 598 206.219 C 595.091 206.302, 595 206.451, 595 211.152 M 603 210.465 C 603 215.271, 604.249 216.525, 609 216.489 C 611.307 216.472, 611.523 216.066, 611.802 211.235 C 612.044 207.040, 611.796 206, 610.552 206 C 609.415 206, 609 207.041, 609 209.893 C 609 212.310, 608.468 213.990, 607.598 214.324 C 605.559 215.106, 605 214.140, 605 209.833 C 605 207.725, 604.550 206, 604 206 C 603.450 206, 603 208.009, 603 210.465 M 631.015 209.750 C 631.036 214.824, 632.132 216.210, 636.390 216.548 L 640 216.834 640 211.417 C 640 208.438, 639.550 206, 639 206 C 638.450 206, 638 207.520, 638 209.378 C 638 212.663, 635.983 215.649, 634.658 214.325 C 634.296 213.963, 634 211.942, 634 209.833 C 634 207.093, 633.572 206, 632.500 206 C 631.431 206, 631.004 207.077, 631.015 209.750 M 643 211.152 C 643 213.818, 643.450 216, 644 216 C 644.550 216, 645 214.383, 645 212.406 C 645 209.654, 645.468 208.690, 647 208.290 C 650.046 207.493, 649.385 206.123, 646 206.219 C 643.091 206.302, 643 206.451, 643 211.152 M 651.278 207.250 C 649.685 209.309, 649.025 211.902, 649.668 213.577 C 650.839 216.629, 658 217.668, 658 214.786 C 658 214.236, 657.325 214.045, 656.500 214.362 C 654.720 215.045, 652 214.157, 652 212.893 C 652 212.402, 653.364 212, 655.031 212 C 658.447 212, 659.898 209.787, 657.989 207.487 C 656.486 205.676, 652.602 205.539, 651.278 207.250 M 678.667 206.667 C 677.253 208.080, 678.080 211.208, 680 211.710 C 681.100 211.998, 682 212.864, 682 213.636 C 682 214.632, 681.277 214.857, 679.500 214.411 C 676.810 213.736, 675.970 215.391, 678.509 216.365 C 680.699 217.206, 685 215.310, 685 213.503 C 685 212.653, 683.875 211.445, 682.500 210.818 C 679.495 209.449, 679.238 208, 682 208 C 683.100 208, 684 207.550, 684 207 C 684 205.888, 679.714 205.620, 678.667 206.667 M 687.200 207.200 C 685.173 209.227, 685.768 213.802, 688.272 215.443 C 690.616 216.978, 695 216.543, 695 214.775 C 695 214.229, 693.927 214.052, 692.614 214.382 C 691.105 214.761, 689.775 214.433, 688.992 213.490 C 687.935 212.217, 688.281 212, 691.378 212 C 694.199 212, 695 211.602, 695 210.200 C 695 207.796, 693.076 206, 690.500 206 C 689.345 206, 687.860 206.540, 687.200 207.200 M 874.200 207.200 C 872.100 209.300, 872.774 213.806, 875.451 215.560 C 877.944 217.193, 882 216.763, 882 214.865 C 882 214.315, 881.189 214.123, 880.198 214.437 C 879.206 214.752, 877.519 214.347, 876.448 213.536 C 874.620 212.154, 874.730 212.062, 878.250 212.032 C 881.530 212.004, 882 211.700, 882 209.607 C 882 206.198, 876.805 204.595, 874.200 207.200 M 890 213.164 C 890 217.055, 890.431 220, 891 220 C 891.550 220, 892 219.048, 892 217.883 C 892 216.234, 892.458 215.886, 894.074 216.309 C 897.190 217.124, 900.199 213.677, 899.377 210.235 C 898.400 206.144, 898.214 206.006, 893.947 206.173 L 890 206.328 890 213.164 M 902 211.152 C 902 213.818, 902.450 216, 903 216 C 903.550 216, 904 214.383, 904 212.406 C 904 209.654, 904.468 208.690, 906 208.290 C 909.046 207.493, 908.385 206.123, 905 206.219 C 902.091 206.302, 902 206.451, 902 211.152 M 909.571 207.571 C 905.987 211.156, 908.751 216.336, 913.978 215.829 C 916.682 215.566, 917.512 214.958, 918.078 212.822 C 919.500 207.462, 913.428 203.715, 909.571 207.571 M 932 209.929 C 932 214.850, 933.851 216.822, 937.911 216.226 C 940.880 215.791, 941 215.583, 941 210.887 C 941 208.199, 940.550 206, 940 206 C 939.450 206, 939 207.520, 939 209.378 C 939 211.235, 938.365 213.282, 937.589 213.926 C 935.913 215.317, 935.482 214.718, 934.586 209.750 C 933.696 204.818, 932 204.935, 932 209.929 M 943.950 208.093 C 941.702 212.294, 945.631 217.829, 949.750 216.262 C 951.798 215.482, 951.166 213.813, 949.074 214.476 C 946.786 215.203, 945.011 212.673, 945.771 209.768 C 946.143 208.346, 946.917 207.942, 948.640 208.272 C 950.185 208.567, 951 208.253, 951 207.361 C 951 205.075, 945.246 205.673, 943.950 208.093 M 960.902 207.618 C 959.742 209.016, 959.945 209.544, 962.388 211.492 C 965.198 213.733, 964.690 215.586, 961.590 214.396 C 960.716 214.061, 960 214.236, 960 214.786 C 960 216.201, 962.435 216.960, 964.904 216.315 C 967.688 215.587, 967.758 211.375, 965 210.500 C 962.385 209.670, 962.425 208, 965.059 208 C 966.191 208, 966.840 207.550, 966.500 207 C 965.551 205.464, 962.401 205.812, 960.902 207.618 M 975.200 207.200 C 973.874 208.526, 973.617 212.895, 974.765 214.573 C 977.401 218.422, 984 215.995, 984 211.177 C 984 207.703, 982.355 206, 979 206 C 977.570 206, 975.860 206.540, 975.200 207.200 M 986 211.236 C 986 216.672, 988.289 217.695, 988.693 212.439 C 988.815 210.842, 989.610 209.027, 990.458 208.407 C 992.750 206.731, 992.346 206.124, 989 206.219 C 986.084 206.302, 986 206.442, 986 211.236 M 1078.200 207.200 C 1076.851 208.549, 1076.626 212.864, 1077.809 214.725 C 1079.056 216.688, 1086 216.864, 1086 214.933 C 1086 214.346, 1085.189 214.123, 1084.198 214.437 C 1083.206 214.752, 1081.519 214.347, 1080.448 213.536 C 1078.620 212.154, 1078.730 212.062, 1082.250 212.032 C 1085.183 212.007, 1086 211.608, 1086 210.200 C 1086 207.796, 1084.076 206, 1081.500 206 C 1080.345 206, 1078.860 206.540, 1078.200 207.200 M 1094 211.152 C 1094 213.818, 1094.450 216, 1095 216 C 1095.550 216, 1096 214.383, 1096 212.406 C 1096 209.654, 1096.468 208.690, 1098 208.290 C 1101.046 207.493, 1100.385 206.123, 1097 206.219 C 1094.091 206.302, 1094 206.451, 1094 211.152 M 1102.278 207.250 C 1100.685 209.309, 1100.025 211.902, 1100.668 213.577 C 1101.839 216.629, 1109 217.668, 1109 214.786 C 1109 214.236, 1108.325 214.045, 1107.500 214.362 C 1105.720 215.045, 1103 214.157, 1103 212.893 C 1103 212.402, 1104.364 212, 1106.031 212 C 1109.447 212, 1110.898 209.787, 1108.989 207.487 C 1107.486 205.676, 1103.602 205.539, 1102.278 207.250 M 1113.187 206.863 C 1111.769 207.763, 1111.260 212.994, 1112.411 214.856 C 1113.308 216.307, 1118.663 216.354, 1119.550 214.919 C 1119.949 214.273, 1119.469 213.916, 1118.359 214.034 C 1114.498 214.442, 1113.865 214.020, 1114.184 211.250 C 1114.433 209.085, 1115.089 208.432, 1117.267 208.182 C 1118.789 208.007, 1119.775 207.445, 1119.458 206.932 C 1118.747 205.781, 1114.960 205.739, 1113.187 206.863 M 1122 211 C 1122 213.750, 1122.450 216, 1123 216 C 1123.550 216, 1124 213.750, 1124 211 C 1124 208.250, 1123.550 206, 1123 206 C 1122.450 206, 1122 208.250, 1122 211 M 1126.765 206.565 C 1126.045 207.274, 1127.295 220, 1128.085 220 C 1128.588 220, 1129 219.156, 1129 218.125 C 1129 216.770, 1129.725 216.250, 1131.614 216.250 C 1133.051 216.250, 1134.619 215.631, 1135.098 214.875 C 1136.397 212.826, 1136.179 208.393, 1134.721 207.183 C 1133.623 206.272, 1127.541 205.800, 1126.765 206.565 M 1138 210.941 C 1138 213.659, 1138.450 216.160, 1139 216.500 C 1139.621 216.884, 1140 215.010, 1140 211.559 C 1140 208.502, 1139.550 206, 1139 206 C 1138.450 206, 1138 208.223, 1138 210.941 M 1144.200 207.200 C 1143.540 207.860, 1143 209.896, 1143 211.725 C 1143 214.311, 1143.531 215.251, 1145.393 215.959 C 1148.093 216.986, 1152 216.281, 1152 214.767 C 1152 214.217, 1151.057 214.013, 1149.904 214.315 C 1147.510 214.941, 1145 214.213, 1145 212.893 C 1145 212.402, 1146.575 212, 1148.500 212 C 1151.204 212, 1152 211.590, 1152 210.200 C 1152 207.796, 1150.076 206, 1147.500 206 C 1146.345 206, 1144.860 206.540, 1144.200 207.200 M 1154 211.189 C 1154 214.729, 1154.361 216.045, 1155.250 215.745 C 1155.938 215.513, 1156.568 214.238, 1156.651 212.912 C 1156.735 211.585, 1156.847 209.938, 1156.901 209.250 C 1156.956 208.563, 1157.900 208, 1159 208 C 1160.667 208, 1161 208.667, 1161 212 C 1161 214.200, 1161.475 216, 1162.055 216 C 1162.689 216, 1162.988 214.107, 1162.805 211.250 L 1162.500 206.500 1158.250 206.356 L 1154 206.211 1154 211.189 M 1179.200 207.200 C 1178.540 207.860, 1178 209.900, 1178 211.732 C 1178 214.258, 1178.536 215.263, 1180.213 215.883 C 1185.290 217.761, 1189.412 213.394, 1187.182 208.500 C 1185.930 205.752, 1181.388 205.012, 1179.200 207.200 M 95 209 C 95 209.550, 95.900 210, 97 210 C 98.100 210, 99 209.550, 99 209 C 99 208.450, 98.100 208, 97 208 C 95.900 208, 95 208.450, 95 209 M 112.187 211.250 C 112.387 213.333, 113.039 214.500, 114 214.500 C 114.961 214.500, 115.613 213.333, 115.813 211.250 C 116.078 208.504, 115.797 208, 114 208 C 112.203 208, 111.922 208.504, 112.187 211.250 M 130.667 208.667 C 129.522 209.812, 129.938 213.812, 131.250 214.269 C 133.576 215.081, 135 213.799, 135 210.893 C 135 208.754, 134.522 208, 133.167 208 C 132.158 208, 131.033 208.300, 130.667 208.667 M 157 210.833 C 157 214.161, 157.671 215.063, 159.598 214.324 C 160.369 214.028, 161 212.484, 161 210.893 C 161 208.667, 160.539 208, 159 208 C 157.471 208, 157 208.667, 157 210.833 M 168.500 209 C 168.148 209.569, 169.009 210, 170.500 210 C 171.991 210, 172.852 209.569, 172.500 209 C 172.160 208.450, 171.260 208, 170.500 208 C 169.740 208, 168.840 208.450, 168.500 209 M 192.667 208.667 C 191.390 209.943, 192.011 213.790, 193.590 214.396 C 195.948 215.301, 197 214.236, 197 210.941 C 197 208.756, 196.529 208, 195.167 208 C 194.158 208, 193.033 208.300, 192.667 208.667 M 336.500 209 C 336.148 209.569, 337.009 210, 338.500 210 C 339.991 210, 340.852 209.569, 340.500 209 C 340.160 208.450, 339.260 208, 338.500 208 C 337.740 208, 336.840 208.450, 336.500 209 M 652 209 C 652 209.550, 652.900 210, 654 210 C 655.100 210, 656 209.550, 656 209 C 656 208.450, 655.100 208, 654 208 C 652.900 208, 652 208.450, 652 209 M 663.701 208.632 C 662.459 209.874, 662.955 213.769, 664.427 214.334 C 666.248 215.032, 668.269 212.636, 667.821 210.310 C 667.463 208.450, 664.919 207.414, 663.701 208.632 M 688.500 209 C 688.149 209.567, 688.990 210, 690.441 210 C 691.848 210, 693 209.550, 693 209 C 693 208.450, 692.127 208, 691.059 208 C 689.991 208, 688.840 208.450, 688.500 209 M 876 209 C 876 209.550, 876.900 210, 878 210 C 879.100 210, 880 209.550, 880 209 C 880 208.450, 879.100 208, 878 208 C 876.900 208, 876 208.450, 876 209 M 892.667 208.667 C 891.355 209.978, 892.033 212.947, 893.869 213.930 C 896.222 215.189, 897 214.420, 897 210.833 C 897 208.753, 896.513 208, 895.167 208 C 894.158 208, 893.033 208.300, 892.667 208.667 M 911 210.823 C 911 214.138, 913.236 215.625, 915.009 213.489 C 916.737 211.408, 915.782 208.543, 913.240 208.180 C 911.352 207.911, 911 208.327, 911 210.823 M 922.503 209.991 C 921.699 212.522, 923.566 215.104, 925.627 214.313 C 927.636 213.542, 926.997 208.611, 924.835 208.202 C 923.848 208.014, 922.899 208.742, 922.503 209.991 M 976.483 210.053 C 975.502 213.146, 978.260 215.859, 980.498 214.002 C 982.724 212.154, 982.007 208.572, 979.336 208.192 C 977.836 207.978, 976.960 208.550, 976.483 210.053 M 1079.500 209 C 1079.149 209.567, 1079.990 210, 1081.441 210 C 1082.848 210, 1084 209.550, 1084 209 C 1084 208.450, 1083.127 208, 1082.059 208 C 1080.991 208, 1079.840 208.450, 1079.500 209 M 1103 209 C 1103 209.550, 1103.900 210, 1105 210 C 1106.100 210, 1107 209.550, 1107 209 C 1107 208.450, 1106.100 208, 1105 208 C 1103.900 208, 1103 208.450, 1103 209 M 1129.667 208.667 C 1128.453 209.881, 1128.975 213.777, 1130.427 214.334 C 1132.423 215.099, 1134.294 212.503, 1133.515 210.048 C 1132.877 208.036, 1130.979 207.354, 1129.667 208.667 M 1145.500 209 C 1145.149 209.567, 1145.990 210, 1147.441 210 C 1148.848 210, 1150 209.550, 1150 209 C 1150 208.450, 1149.127 208, 1148.059 208 C 1146.991 208, 1145.840 208.450, 1145.500 209 M 1180.667 208.667 C 1179.390 209.943, 1180.011 213.790, 1181.590 214.396 C 1183.948 215.301, 1185 214.236, 1185 210.941 C 1185 208.756, 1184.529 208, 1183.167 208 C 1182.158 208, 1181.033 208.300, 1180.667 208.667 M 319 213.583 C 319 214.454, 319.534 214.989, 320.188 214.771 C 322.042 214.153, 322.349 212, 320.583 212 C 319.712 212, 319 212.713, 319 213.583 M 360 212.833 C 360 214.242, 361.126 214.889, 362.598 214.324 C 364.685 213.523, 364.293 212, 362 212 C 360.900 212, 360 212.375, 360 212.833 M 382.306 217 C 381.128 220.122, 381.740 220.860, 383.800 218.800 C 385.135 217.465, 385.438 214, 384.219 214 C 383.790 214, 382.929 215.350, 382.306 217 M 575.137 227.916 C 573.422 228.975, 570.880 234, 572.059 234 C 572.577 234, 573 236.025, 573 238.500 C 573 240.975, 573.450 243, 574 243 C 574.550 243, 575 240.975, 575 238.500 C 575 234.893, 575.347 233.994, 576.750 233.968 C 578.417 233.938, 578.417 233.873, 576.750 232.608 C 574.604 230.979, 574.510 230, 576.500 230 C 577.325 230, 578 229.577, 578 229.059 C 578 227.620, 576.551 227.042, 575.137 227.916 M 676.639 227.694 C 675.648 228.685, 675.885 243, 676.893 243 C 678.136 243, 678.977 240.475, 678.521 238.110 C 678.092 235.883, 680.358 233.485, 681.956 234.473 C 682.530 234.828, 683 236.891, 683 239.059 C 683 241.227, 683.450 243, 684 243 C 684.550 243, 685 240.997, 685 238.550 C 685 233.714, 683.290 231.850, 679.712 232.786 C 677.995 233.235, 677.781 232.926, 678.220 230.631 C 678.724 227.993, 677.890 226.443, 676.639 227.694 M 950.750 227.571 C 949.609 228.730, 949.841 243, 951 243 C 951.550 243, 952 241.480, 952 239.622 C 952 236.124, 954.134 233.346, 955.956 234.473 C 956.530 234.828, 957 236.891, 957 239.059 C 957 241.227, 957.450 243, 958 243 C 958.550 243, 959 240.991, 959 238.535 C 959 233.823, 956.795 231.374, 953.642 232.584 C 952.531 233.010, 952.055 232.331, 951.819 229.985 C 951.644 228.238, 951.163 227.152, 950.750 227.571 M 1082 235.500 C 1082 239.833, 1082.422 243, 1083 243 C 1083.550 243, 1084 241.248, 1084 239.107 C 1084 236.690, 1084.532 235.010, 1085.402 234.676 C 1087.441 233.894, 1088 234.860, 1088 239.167 C 1088 241.275, 1088.450 243, 1089 243 C 1089.550 243, 1090 240.798, 1090 238.107 C 1090 233.059, 1088.657 231.427, 1085.500 232.638 C 1084.403 233.059, 1084 232.513, 1084 230.607 C 1084 229.173, 1083.550 228, 1083 228 C 1082.422 228, 1082 231.167, 1082 235.500 M 77 230 C 77 230.550, 77.450 231, 78 231 C 78.550 231, 79 230.550, 79 230 C 79 229.450, 78.550 229, 78 229 C 77.450 229, 77 229.450, 77 230 M 611 230 C 611 230.550, 611.675 231, 612.500 231 C 613.325 231, 614 230.550, 614 230 C 614 229.450, 613.325 229, 612.500 229 C 611.675 229, 611 229.450, 611 230 M 626 230 C 626 230.550, 626.675 231, 627.500 231 C 628.325 231, 629 230.550, 629 230 C 629 229.450, 628.325 229, 627.500 229 C 626.675 229, 626 229.450, 626 230 M 639 230 C 639 230.550, 639.450 231, 640 231 C 640.550 231, 641 230.550, 641 230 C 641 229.450, 640.550 229, 640 229 C 639.450 229, 639 229.450, 639 230 M 903 230 C 903 230.550, 903.675 231, 904.500 231 C 905.325 231, 906 230.550, 906 230 C 906 229.450, 905.325 229, 904.500 229 C 903.675 229, 903 229.450, 903 230 M 116.232 232 C 115.545 233.100, 115.411 234, 115.934 234 C 116.457 234, 117.023 235.912, 117.193 238.250 C 117.448 241.783, 117.880 242.554, 119.750 242.820 C 122.265 243.177, 122.831 241.533, 120.500 240.638 C 119.623 240.302, 119 238.803, 119 237.031 C 119 235.003, 119.497 234, 120.500 234 C 121.325 234, 122 233.550, 122 233 C 122 232.450, 121.325 232, 120.500 232 C 119.675 232, 119 231.550, 119 231 C 119 229.349, 117.564 229.868, 116.232 232 M 137.232 232 C 136.545 233.100, 136.411 234, 136.934 234 C 137.457 234, 138.023 235.912, 138.193 238.250 C 138.448 241.783, 138.880 242.554, 140.750 242.820 C 143.265 243.177, 143.831 241.533, 141.500 240.638 C 140.623 240.302, 140 238.803, 140 237.031 C 140 235.003, 140.497 234, 141.500 234 C 142.325 234, 143 233.550, 143 233 C 143 232.450, 142.325 232, 141.500 232 C 140.675 232, 140 231.550, 140 231 C 140 229.349, 138.564 229.868, 137.232 232 M 603.708 231.318 C 603.430 232.044, 603.587 234.631, 604.058 237.068 C 604.528 239.506, 604.932 241.838, 604.956 242.250 C 605.021 243.365, 608.784 243.158, 609.500 242 C 609.840 241.450, 609.416 241, 608.559 241 C 607.444 241, 607 240.003, 607 237.500 C 607 234.882, 607.425 234, 608.689 234 C 610.121 234, 610.051 233.696, 608.230 232 C 605.732 229.673, 604.416 229.474, 603.708 231.318 M 631.232 232 C 630.545 233.100, 630.411 234, 630.934 234 C 631.457 234, 632.023 235.912, 632.193 238.250 C 632.448 241.783, 632.880 242.554, 634.750 242.820 C 635.987 242.995, 637 242.658, 637 242.070 C 637 241.481, 636.550 241, 636 241 C 635.450 241, 635 239.425, 635 237.500 C 635 235.575, 635.450 234, 636 234 C 636.550 234, 637 233.550, 637 233 C 637 232.450, 636.325 232, 635.500 232 C 634.675 232, 634 231.550, 634 231 C 634 229.349, 632.564 229.868, 631.232 232 M 668.760 231.250 C 668.511 231.938, 668.575 234.750, 668.903 237.500 C 669.405 241.705, 669.858 242.551, 671.750 242.820 C 674.286 243.180, 674.822 241.530, 672.463 240.624 C 670.612 239.914, 670.971 235.254, 672.973 234.017 C 674.085 233.330, 674.042 232.899, 672.734 231.591 C 670.822 229.679, 669.376 229.555, 668.760 231.250 M 698.356 231.383 C 697.575 232.274, 697.482 234.088, 698.062 237.094 C 698.530 239.518, 698.932 241.838, 698.956 242.250 C 699.021 243.365, 702.784 243.158, 703.500 242 C 703.840 241.450, 703.416 241, 702.559 241 C 701.444 241, 701 240.003, 701 237.500 C 701 234.882, 701.425 234, 702.689 234 C 704.121 234, 704.051 233.696, 702.230 232 C 699.732 229.672, 699.839 229.689, 698.356 231.383 M 942.760 231.250 C 942.511 231.938, 942.575 234.750, 942.903 237.500 C 943.405 241.705, 943.858 242.551, 945.750 242.820 C 946.987 242.995, 948 242.658, 948 242.070 C 948 241.481, 947.550 241, 947 241 C 945.546 241, 945.771 234.243, 947.241 233.753 C 948.144 233.452, 948.027 232.884, 946.813 231.670 C 944.827 229.684, 943.383 229.534, 942.760 231.250 M 971.708 231.318 C 971.430 232.044, 971.587 234.631, 972.058 237.068 C 972.528 239.506, 972.932 241.838, 972.956 242.250 C 973.021 243.365, 976.784 243.158, 977.500 242 C 977.840 241.450, 977.416 241, 976.559 241 C 975.444 241, 975 240.003, 975 237.500 C 975 234.882, 975.425 234, 976.689 234 C 978.121 234, 978.051 233.696, 976.230 232 C 973.732 229.673, 972.416 229.474, 971.708 231.318 M 1074.312 231.872 C 1073.661 232.915, 1073.523 234.132, 1074 234.622 C 1074.472 235.105, 1075.002 237.075, 1075.179 239 C 1075.431 241.748, 1075.983 242.569, 1077.750 242.820 C 1078.987 242.995, 1080 242.658, 1080 242.070 C 1080 241.481, 1079.325 241, 1078.500 241 C 1077.452 241, 1077 239.944, 1077 237.500 C 1077 234.882, 1077.425 234, 1078.689 234 C 1080.121 234, 1080.051 233.696, 1078.230 232 C 1075.619 229.567, 1075.749 229.571, 1074.312 231.872 M 77 237.441 C 77 240.498, 77.450 243, 78 243 C 78.550 243, 79 240.777, 79 238.059 C 79 235.341, 78.550 232.840, 78 232.500 C 77.379 232.116, 77 233.990, 77 237.441 M 82 237.583 C 82 240.562, 82.450 243, 83 243 C 83.550 243, 84 241.515, 84 239.700 C 84 237.885, 84.529 235.871, 85.176 235.224 C 87.004 233.396, 89 235.692, 89 239.622 C 89 241.480, 89.450 243, 90 243 C 91.394 243, 91.259 234.278, 89.851 233.408 C 89.219 233.017, 87.194 232.578, 85.351 232.432 L 82 232.166 82 237.583 M 94 239.750 C 94 243.917, 94.425 247, 95 247 C 95.550 247, 96 246.100, 96 245 C 96 243.580, 96.667 243, 98.300 243 C 101.310 243, 103.004 241.211, 102.985 238.050 C 102.961 234.068, 101.421 232.500, 97.535 232.500 L 94.001 232.500 94 239.750 M 105.750 232.572 C 104.512 233.829, 104.904 240.676, 106.279 241.817 C 106.983 242.401, 109.008 242.838, 110.779 242.787 C 113.994 242.696, 114 242.686, 114 237.348 C 114 231.007, 112.250 230.131, 111.807 236.250 C 111.556 239.731, 111.138 240.500, 109.500 240.500 C 107.884 240.500, 107.404 239.667, 107 236.155 C 106.725 233.766, 106.162 232.153, 105.750 232.572 M 125.200 233.200 C 123.432 234.968, 123.736 236.788, 126 238 C 128.780 239.488, 128.498 241, 125.441 241 C 123.990 241, 123.149 241.433, 123.500 242 C 124.465 243.562, 128.611 243.174, 130.098 241.382 C 131.257 239.986, 131.068 239.466, 128.721 237.594 C 125.514 235.037, 125.190 233.555, 128 234.290 C 130.362 234.907, 130.714 233.488, 128.418 232.607 C 126.404 231.834, 126.602 231.798, 125.200 233.200 M 146 234 C 143.767 236.233, 143.499 238.195, 145.035 241.066 C 146.208 243.258, 150.899 243.701, 152.800 241.800 C 154.754 239.846, 154.283 234.222, 152.066 233.035 C 149.318 231.565, 148.269 231.731, 146 234 M 161 233.532 C 161 234.375, 161.697 236.732, 162.549 238.771 C 163.400 240.809, 163.831 243.539, 163.505 244.836 C 163.103 246.440, 163.302 247.066, 164.129 246.790 C 165.297 246.401, 169.842 235.826, 169.948 233.250 C 170.065 230.423, 167.997 232.279, 166.881 236.003 L 165.682 240.005 163.890 236.003 C 162.014 231.813, 161 230.946, 161 233.532 M 173.223 233.557 C 170.774 235.272, 170.211 239.811, 172.200 241.800 C 175.224 244.824, 181 241.992, 181 237.485 C 181 235.472, 177.835 232, 176 232 C 175.695 232, 174.445 232.701, 173.223 233.557 M 183.840 232.494 C 183.598 232.735, 183.648 235.085, 183.950 237.716 C 184.494 242.445, 184.543 242.502, 188.250 242.650 L 192 242.800 192 237.200 C 192 231.126, 190.375 230.970, 189.821 236.992 C 189.603 239.362, 188.938 240.590, 187.750 240.815 C 186.319 241.086, 186 240.415, 186 237.132 C 186 233.508, 184.991 231.342, 183.840 232.494 M 197.250 232.706 C 195.279 233.085, 195 233.752, 195 238.070 C 195 240.781, 195.450 243, 196 243 C 196.550 243, 197 241.480, 197 239.622 C 197 236.337, 199.017 233.351, 200.342 234.675 C 200.704 235.037, 201 234.583, 201 233.667 C 201 232.750, 200.662 232.061, 200.250 232.136 C 199.838 232.211, 198.488 232.467, 197.250 232.706 M 284.419 232.917 C 284.188 233.146, 284 235.508, 284 238.167 C 284 241.796, 284.374 243, 285.500 243 C 286.583 243, 287 241.889, 287 239 C 287 236.111, 287.417 235, 288.500 235 C 289.325 235, 290 234.373, 290 233.606 C 290 232.340, 285.550 231.790, 284.419 232.917 M 293 234 C 290.598 236.402, 290.431 239.288, 292.571 241.429 C 294.299 243.156, 300 243.595, 300 242 C 300 241.450, 298.650 241, 297 241 C 295 241, 294 240.500, 294 239.500 C 294 238.452, 295.056 238, 297.500 238 C 301.474 238, 301.891 236.891, 299 234 C 297.900 232.900, 296.550 232, 296 232 C 295.450 232, 294.100 232.900, 293 234 M 304.250 232.662 C 302.192 233.493, 302.753 237.702, 305 238.290 C 307.872 239.041, 307.468 241, 304.441 241 C 302.990 241, 302.149 241.433, 302.500 242 C 303.465 243.562, 307.611 243.174, 309.098 241.382 C 310.257 239.986, 310.068 239.466, 307.721 237.594 C 304.514 235.037, 304.190 233.555, 307 234.290 C 309.362 234.907, 309.714 233.488, 307.418 232.607 C 306.548 232.273, 305.761 232.036, 305.668 232.079 C 305.576 232.122, 304.938 232.385, 304.250 232.662 M 313.223 233.557 C 309.199 236.375, 311.032 243, 315.835 243 C 319.489 243, 321 241.325, 321 237.275 C 321 234.626, 320.478 233.752, 318.435 232.975 C 315.284 231.777, 315.854 231.713, 313.223 233.557 M 323.639 232.694 C 322.648 233.686, 322.885 238.917, 324.019 241.035 C 324.746 242.395, 326.030 242.900, 328.519 242.807 L 332 242.676 332 237.138 C 332 231.112, 330.372 231.003, 329.821 236.992 C 329.603 239.362, 328.938 240.590, 327.750 240.815 C 326.319 241.086, 326 240.415, 326 237.132 C 326 233.271, 324.980 231.353, 323.639 232.694 M 335 237.667 C 335 240.600, 335.450 243, 336 243 C 336.550 243, 337 241.429, 337 239.508 C 337 237.100, 337.620 235.630, 339 234.768 C 341.785 233.029, 341.500 232.333, 338 232.333 C 335.042 232.333, 335 232.407, 335 237.667 M 343.571 233.571 C 341.602 235.540, 341.530 240.365, 343.445 241.954 C 345.141 243.362, 349.181 242.993, 349.711 241.381 C 349.943 240.676, 349.145 240.441, 347.552 240.745 C 345.767 241.086, 344.828 240.714, 344.353 239.478 C 343.421 237.049, 345.360 234.452, 347.891 234.738 C 350.352 235.016, 350.728 233.493, 348.418 232.607 C 346.049 231.698, 345.295 231.848, 343.571 233.571 M 353.223 233.557 C 348.837 236.629, 351.072 243, 356.535 243 C 358.441 243, 360 242.550, 360 242 C 360 241.450, 358.698 241, 357.107 241 C 355.458 241, 353.966 240.355, 353.638 239.500 C 353.186 238.322, 353.915 238, 357.031 238 C 361.456 238, 361.966 236.966, 359 234 C 356.592 231.592, 356.083 231.553, 353.223 233.557 M 363.664 233.479 C 361.784 235.359, 362.443 237.688, 365.092 238.529 C 367.854 239.406, 367.434 241, 364.441 241 C 362.990 241, 362.149 241.433, 362.500 242 C 363.465 243.562, 367.611 243.174, 369.098 241.382 C 370.257 239.986, 370.068 239.466, 367.721 237.594 C 364.490 235.018, 364.195 233.556, 367.057 234.305 C 368.366 234.647, 368.972 234.416, 368.724 233.671 C 368.115 231.842, 365.404 231.739, 363.664 233.479 M 383.524 233.358 C 381.298 234.986, 381.006 240.758, 383.083 242.073 C 385.568 243.645, 388.838 243.070, 390.443 240.777 C 392.501 237.840, 392.407 236.407, 390 234 C 387.652 231.652, 386.072 231.496, 383.524 233.358 M 394 237.717 C 394 240.623, 394.450 243, 395 243 C 395.550 243, 396 241.480, 396 239.622 C 396 236.210, 398.015 233.393, 399.479 234.759 C 399.916 235.166, 400.075 234.863, 399.832 234.085 C 399.589 233.307, 398.177 232.617, 396.695 232.552 C 394.094 232.438, 394 232.617, 394 237.717 M 562.223 233.557 C 558.199 236.375, 560.032 243, 564.835 243 C 568.489 243, 570 241.325, 570 237.275 C 570 234.626, 569.478 233.752, 567.435 232.975 C 564.284 231.777, 564.854 231.713, 562.223 233.557 M 585.250 232.662 C 582.938 233.595, 583.974 235.045, 586.500 234.411 C 588.021 234.029, 589 234.210, 589 234.873 C 589 235.472, 587.908 236.236, 586.572 236.571 C 581.194 237.921, 582.848 243.020, 588.594 242.804 C 591.921 242.679, 592 242.576, 592 238.373 C 592 233.214, 589.379 230.996, 585.250 232.662 M 595.571 233.571 C 593.602 235.540, 593.530 240.365, 595.445 241.954 C 597.141 243.362, 601.181 242.993, 601.711 241.381 C 601.943 240.676, 601.145 240.441, 599.552 240.745 C 597.767 241.086, 596.828 240.714, 596.353 239.478 C 595.421 237.049, 597.360 234.452, 599.891 234.738 C 602.352 235.016, 602.728 233.493, 600.418 232.607 C 598.049 231.698, 597.295 231.848, 595.571 233.571 M 611.695 232.639 C 611.313 233.021, 611 235.546, 611 238.250 C 611 244.125, 613.319 244.488, 613.809 238.690 C 614.130 234.906, 612.912 231.422, 611.695 232.639 M 615.676 232.734 C 614.859 234.088, 618.498 242.472, 620.031 242.767 C 621.014 242.957, 622.123 241.332, 623.330 237.934 C 624.330 235.118, 624.920 232.586, 624.641 232.307 C 623.638 231.304, 622.247 233.014, 621.654 235.979 C 620.882 239.841, 619.347 239.856, 618.503 236.011 C 617.826 232.933, 616.490 231.384, 615.676 232.734 M 626.884 232.191 C 626.821 232.361, 626.673 234.863, 626.556 237.750 C 626.401 241.556, 626.708 243, 627.671 243 C 629.269 243, 629.568 233.469, 628 232.500 C 627.450 232.160, 626.948 232.021, 626.884 232.191 M 639 237.500 C 639 240.525, 639.450 243, 640 243 C 640.550 243, 641 240.525, 641 237.500 C 641 234.475, 640.550 232, 640 232 C 639.450 232, 639 234.475, 639 237.500 M 645.566 233.328 C 643.477 234.856, 643.168 239.293, 644.997 241.497 C 646.371 243.152, 651.545 243.546, 652.460 242.065 C 652.778 241.550, 651.602 240.988, 649.846 240.815 C 645.248 240.361, 644.888 238, 649.417 238 C 653.358 238, 654.139 236.282, 651.429 233.571 C 649.509 231.652, 647.947 231.587, 645.566 233.328 M 656.250 232.662 C 654.316 233.443, 654.773 236.842, 657 238.232 C 659.726 239.935, 659.511 241, 656.441 241 C 654.990 241, 654.149 241.433, 654.500 242 C 655.465 243.562, 659.611 243.174, 661.098 241.382 C 662.257 239.986, 662.068 239.466, 659.721 237.594 C 656.514 235.037, 656.190 233.555, 659 234.290 C 661.362 234.907, 661.714 233.488, 659.418 232.607 C 658.548 232.273, 657.761 232.036, 657.668 232.079 C 657.576 232.122, 656.938 232.385, 656.250 232.662 M 688.667 232.667 C 687.209 234.125, 688.133 235.005, 690.500 234.411 C 694.100 233.507, 693.615 235.590, 689.927 236.876 C 687.531 237.711, 686.925 238.449, 687.177 240.223 C 687.447 242.125, 688.201 242.551, 691.750 242.807 L 696 243.115 696 239.129 C 696 236.839, 695.332 234.474, 694.429 233.571 C 692.811 231.954, 689.845 231.488, 688.667 232.667 M 866.614 233.529 C 864.778 235.365, 865.468 237.696, 868.092 238.529 C 870.854 239.406, 870.434 241, 867.441 241 C 865.990 241, 865.149 241.433, 865.500 242 C 866.465 243.562, 870.611 243.174, 872.098 241.382 C 873.257 239.986, 873.068 239.466, 870.721 237.594 C 867.514 235.037, 867.190 233.555, 870 234.290 C 872.362 234.907, 872.714 233.488, 870.418 232.607 C 868.304 231.796, 868.361 231.782, 866.614 233.529 M 875.655 233.829 C 873.719 235.968, 873.484 240.084, 875.200 241.800 C 876.620 243.220, 881.633 243.403, 882.460 242.065 C 882.778 241.550, 881.602 240.988, 879.846 240.815 C 875.248 240.361, 874.888 238, 879.417 238 C 882.312 238, 883 237.623, 883 236.035 C 883 234.222, 880.369 232, 878.221 232 C 877.720 232, 876.565 232.823, 875.655 233.829 M 886 237.703 C 886 240.616, 886.450 243, 887 243 C 887.550 243, 888 241.480, 888 239.622 C 888 236.655, 890.261 233.156, 891.843 233.676 C 892.137 233.773, 893.138 235.798, 894.067 238.176 C 894.995 240.554, 896.372 242.624, 897.127 242.775 C 898.780 243.106, 902.345 233.945, 901.062 232.662 C 900.581 232.181, 899.627 233.388, 898.900 235.401 C 897.296 239.835, 896.553 239.919, 895.370 235.796 C 894.529 232.863, 894.093 232.583, 890.226 232.499 L 886 232.406 886 237.703 M 903.451 234.338 C 902.587 237.781, 903.280 242.274, 904.750 242.756 C 905.639 243.048, 906 241.714, 906 238.142 C 906 232.724, 904.440 230.397, 903.451 234.338 M 909.655 233.829 C 907.615 236.083, 907.505 240.344, 909.445 241.954 C 911.141 243.362, 915.181 242.993, 915.711 241.381 C 915.943 240.676, 915.145 240.441, 913.552 240.745 C 911.767 241.086, 910.828 240.714, 910.353 239.478 C 909.421 237.049, 911.360 234.452, 913.891 234.738 C 916.352 235.016, 916.728 233.493, 914.418 232.607 C 912.031 231.691, 911.456 231.839, 909.655 233.829 M 918.557 234.223 C 916.575 237.052, 916.580 239.437, 918.571 241.429 C 920.299 243.156, 926 243.595, 926 242 C 926 241.450, 924.650 241, 923 241 C 921 241, 920 240.500, 920 239.500 C 920 238.452, 921.056 238, 923.500 238 C 927.474 238, 927.891 236.891, 925 234 C 922.404 231.404, 920.485 231.470, 918.557 234.223 M 930.250 232.662 C 928.306 233.447, 928.779 236.811, 931 238 C 933.780 239.488, 933.498 241, 930.441 241 C 928.990 241, 928.149 241.433, 928.500 242 C 929.465 243.562, 933.611 243.174, 935.098 241.382 C 936.257 239.986, 936.068 239.466, 933.721 237.594 C 930.514 235.037, 930.190 233.555, 933 234.290 C 935.362 234.907, 935.714 233.488, 933.418 232.607 C 932.548 232.273, 931.761 232.036, 931.668 232.079 C 931.576 232.122, 930.938 232.385, 930.250 232.662 M 963.250 232.662 C 960.872 233.622, 962.010 235.036, 964.630 234.378 C 966.622 233.878, 967.148 234.056, 966.798 235.109 C 966.543 235.874, 965.472 236.656, 964.417 236.847 C 961.586 237.360, 960.721 238.544, 961.465 240.890 C 962.003 242.584, 962.875 242.951, 966.064 242.826 C 969.921 242.675, 970 242.597, 970 238.907 C 970 233.669, 967.192 231.072, 963.250 232.662 M 1094.750 233.080 C 1092.713 234.266, 1092.355 239.955, 1094.200 241.800 C 1095.620 243.220, 1100.633 243.403, 1101.460 242.065 C 1101.778 241.550, 1100.602 240.988, 1098.846 240.815 C 1094.248 240.361, 1093.888 238, 1098.417 238 C 1101.312 238, 1102 237.623, 1102 236.035 C 1102 234.955, 1101.130 233.605, 1100.066 233.035 C 1097.702 231.770, 1096.988 231.776, 1094.750 233.080 M 1109.417 232.917 C 1109.188 233.146, 1109 236.446, 1109 240.250 C 1109 245.339, 1109.330 247.057, 1110.250 246.750 C 1110.938 246.521, 1111.500 245.696, 1111.500 244.917 C 1111.500 244.137, 1112.625 243.356, 1114 243.179 C 1118.635 242.585, 1120.751 236.698, 1117.346 233.872 C 1115.821 232.607, 1110.382 231.951, 1109.417 232.917 M 1121 237.667 C 1121 240.600, 1121.450 243, 1122 243 C 1122.550 243, 1123 241.480, 1123 239.622 C 1123 236.337, 1125.017 233.351, 1126.342 234.675 C 1126.704 235.037, 1127 234.658, 1127 233.833 C 1127 232.833, 1126 232.333, 1124 232.333 C 1121.042 232.333, 1121 232.407, 1121 237.667 M 1129.750 233.080 C 1127.713 234.266, 1127.355 239.955, 1129.200 241.800 C 1132.056 244.656, 1138 242.041, 1138 237.929 C 1138 235.750, 1134.648 231.984, 1132.750 232.030 C 1132.063 232.047, 1130.713 232.519, 1129.750 233.080 M 1141 234 C 1137.167 237.833, 1139.411 243.421, 1144.549 242.836 C 1147.944 242.449, 1148.101 240.571, 1144.742 240.528 C 1143.150 240.508, 1142.402 239.808, 1142.163 238.113 C 1141.805 235.588, 1143.657 233.712, 1145.750 234.479 C 1146.438 234.731, 1147 234.549, 1147 234.076 C 1147 233.336, 1144.695 232, 1143.418 232 C 1143.188 232, 1142.100 232.900, 1141 234 M 1150.750 233.080 C 1148.713 234.266, 1148.355 239.955, 1150.200 241.800 C 1151.620 243.220, 1156.633 243.403, 1157.460 242.065 C 1157.778 241.550, 1156.602 240.988, 1154.846 240.815 C 1150.248 240.361, 1149.888 238, 1154.417 238 C 1157.312 238, 1158 237.623, 1158 236.035 C 1158 234.955, 1157.130 233.605, 1156.066 233.035 C 1153.702 231.770, 1152.988 231.776, 1150.750 233.080 M 1161.750 233.080 C 1159.249 234.537, 1159.590 236.856, 1162.500 238.182 C 1163.875 238.808, 1165 239.699, 1165 240.161 C 1165 240.622, 1163.875 241, 1162.500 241 C 1161.125 241, 1160 241.479, 1160 242.063 C 1160 242.661, 1161.424 242.989, 1163.250 242.813 C 1167.622 242.392, 1168.464 238.507, 1164.509 237.003 C 1161.558 235.882, 1162.093 233.577, 1165.084 234.527 C 1167.378 235.255, 1167.687 233.478, 1165.418 232.607 C 1163.527 231.881, 1163.888 231.835, 1161.750 233.080 M 1170.250 232.662 C 1168.316 233.443, 1168.773 236.842, 1171 238.232 C 1172.100 238.919, 1173 239.823, 1173 240.241 C 1173 240.658, 1172.100 241, 1171 241 C 1169.900 241, 1169 241.450, 1169 242 C 1169 243.615, 1173.634 243.146, 1175.098 241.382 C 1176.257 239.986, 1176.068 239.466, 1173.721 237.594 C 1170.514 235.037, 1170.190 233.555, 1173 234.290 C 1175.362 234.907, 1175.714 233.488, 1173.418 232.607 C 1172.548 232.273, 1171.761 232.036, 1171.668 232.079 C 1171.576 232.122, 1170.938 232.385, 1170.250 232.662 M 97.163 234.899 C 95.350 236.020, 96.094 240.402, 98.165 240.797 C 100.394 241.221, 101.651 237.222, 99.853 235.425 C 99.040 234.612, 97.966 234.402, 97.163 234.899 M 147.701 234.632 C 147.316 235.018, 147 236.640, 147 238.236 C 147 240.675, 147.360 241.088, 149.250 240.820 C 151.010 240.570, 151.500 239.849, 151.500 237.514 C 151.500 234.631, 149.340 232.993, 147.701 234.632 M 174.040 235.452 C 172.293 237.557, 173.176 240.451, 175.674 240.808 C 178.279 241.181, 179.785 237.651, 177.960 235.452 C 176.442 233.622, 175.558 233.622, 174.040 235.452 M 294.500 235 C 294.160 235.550, 294.835 236, 296 236 C 297.165 236, 297.840 235.550, 297.500 235 C 297.160 234.450, 296.485 234, 296 234 C 295.515 234, 294.840 234.450, 294.500 235 M 314.067 235.419 C 312.384 237.447, 313.678 241, 316.099 241 C 318.459 241, 319.698 238.330, 318.338 236.174 C 316.941 233.960, 315.491 233.704, 314.067 235.419 M 354.500 235 C 354.160 235.550, 354.835 236, 356 236 C 357.165 236, 357.840 235.550, 357.500 235 C 357.160 234.450, 356.485 234, 356 234 C 355.515 234, 354.840 234.450, 354.500 235 M 384.412 235.368 C 383.406 237.989, 384.434 240.500, 386.514 240.500 C 388.052 240.500, 388.500 239.826, 388.500 237.514 C 388.500 234.242, 385.457 232.645, 384.412 235.368 M 563.071 235.867 C 561.684 238.459, 562.708 241, 565.138 241 C 567.465 241, 568.689 238.315, 567.338 236.174 C 565.833 233.788, 564.245 233.674, 563.071 235.867 M 646.500 235 C 646.160 235.550, 646.809 236, 647.941 236 C 649.073 236, 650 235.550, 650 235 C 650 234.450, 649.352 234, 648.559 234 C 647.766 234, 646.840 234.450, 646.500 235 M 877 235 C 875.835 235.753, 876.128 235.973, 878.309 235.985 C 879.930 235.994, 880.857 235.577, 880.500 235 C 879.733 233.758, 878.921 233.758, 877 235 M 920.667 234.667 C 919.358 235.975, 920.033 236.804, 921.989 236.293 C 923.083 236.007, 923.731 235.374, 923.430 234.886 C 922.780 233.835, 921.593 233.740, 920.667 234.667 M 1095.500 235 C 1095.148 235.569, 1096.009 236, 1097.500 236 C 1098.991 236, 1099.852 235.569, 1099.500 235 C 1099.160 234.450, 1098.260 234, 1097.500 234 C 1096.740 234, 1095.840 234.450, 1095.500 235 M 1113.154 234.905 C 1111.399 235.990, 1112.080 240.500, 1114 240.500 C 1115.655 240.500, 1116.663 236.263, 1115.326 234.926 C 1114.863 234.463, 1113.885 234.453, 1113.154 234.905 M 1130.412 235.368 C 1129.406 237.989, 1130.434 240.500, 1132.514 240.500 C 1134.052 240.500, 1134.500 239.826, 1134.500 237.514 C 1134.500 234.242, 1131.457 232.645, 1130.412 235.368 M 1151.500 235 C 1151.148 235.569, 1152.009 236, 1153.500 236 C 1154.991 236, 1155.852 235.569, 1155.500 235 C 1155.160 234.450, 1154.260 234, 1153.500 234 C 1152.740 234, 1151.840 234.450, 1151.500 235 M 586.667 238.667 C 585.545 239.788, 585.923 241, 587.393 241 C 588.159 241, 589.045 240.325, 589.362 239.500 C 589.939 237.996, 587.951 237.382, 586.667 238.667 M 690.244 238.664 C 688.668 239.300, 689.626 241, 691.559 241 C 692.352 241, 693 240.325, 693 239.500 C 693 237.958, 692.427 237.784, 690.244 238.664 M 964.244 238.664 C 962.668 239.300, 963.626 241, 965.559 241 C 966.352 241, 967 240.325, 967 239.500 C 967 237.958, 966.427 237.784, 964.244 238.664 M 372 241.918 C 372 242.423, 371.691 243.661, 371.313 244.668 C 370.708 246.281, 370.828 246.336, 372.313 245.128 C 374.157 243.627, 374.595 241, 373 241 C 372.450 241, 372 241.413, 372 241.918 M 289 256.906 C 289 259.323, 288.662 259.724, 286.995 259.288 C 284.111 258.534, 282 260.738, 282 264.500 C 282 268.432, 283.444 269.737, 287.750 269.697 L 291 269.667 291 261.833 C 291 257.278, 290.582 254, 290 254 C 289.450 254, 289 255.308, 289 256.906 M 399 256.906 C 399 259.323, 398.662 259.724, 396.995 259.288 C 394.090 258.529, 392 260.746, 392 264.587 C 392 268.348, 393.929 269.911, 398.263 269.659 C 400.995 269.500, 400.999 269.489, 400.999 261.750 C 401 257.250, 400.581 254, 400 254 C 399.450 254, 399 255.308, 399 256.906 M 599.667 254.667 C 599.300 255.033, 599 256.121, 599 257.083 C 599 258.046, 598.438 259.096, 597.750 259.417 C 596.750 259.883, 596.750 260.117, 597.750 260.583 C 598.473 260.921, 599 263.028, 599 265.583 C 599 268.012, 599.450 270, 600 270 C 600.550 270, 601 268.137, 601 265.860 C 601 263.090, 601.579 261.281, 602.750 260.392 C 604.417 259.127, 604.417 259.062, 602.750 259.032 C 600.624 258.993, 600.377 256, 602.500 256 C 603.325 256, 604 255.550, 604 255 C 604 253.883, 600.704 253.629, 599.667 254.667 M 707.433 256.250 C 707.046 257.488, 706.229 258.872, 705.615 259.326 C 704.811 259.922, 704.849 260.294, 705.750 260.659 C 706.485 260.958, 707 262.987, 707 265.583 C 707 268.012, 707.450 270, 708 270 C 708.550 270, 709 268.137, 709 265.860 C 709 263.090, 709.579 261.281, 710.750 260.392 C 712.417 259.127, 712.417 259.062, 710.750 259.032 C 708.624 258.993, 708.377 256, 710.500 256 C 711.325 256, 712 255.550, 712 255 C 712 252.973, 708.124 254.034, 707.433 256.250 M 894 262 C 894 266.667, 894.417 270, 895 270 C 895.583 270, 896 266.667, 896 262 C 896 257.333, 895.583 254, 895 254 C 894.417 254, 894 257.333, 894 262 M 912.667 254.667 C 912.300 255.033, 912 256.121, 912 257.083 C 912 258.046, 911.438 259.096, 910.750 259.417 C 909.750 259.883, 909.750 260.117, 910.750 260.583 C 911.473 260.921, 912 263.028, 912 265.583 C 912 268.012, 912.450 270, 913 270 C 913.550 270, 914 268.137, 914 265.860 C 914 263.090, 914.579 261.281, 915.750 260.392 C 917.417 259.127, 917.417 259.062, 915.750 259.032 C 913.624 258.993, 913.377 256, 915.500 256 C 916.325 256, 917 255.550, 917 255 C 917 253.883, 913.704 253.629, 912.667 254.667 M 968 262.200 C 968 270.333, 969.510 272.279, 970.179 265.008 C 970.397 262.638, 971.062 261.410, 972.250 261.185 C 973.681 260.914, 974 261.585, 974 264.868 C 974 267.076, 974.419 269.141, 974.931 269.457 C 976.527 270.444, 976.974 268.455, 976.181 263.891 C 975.497 259.957, 975.136 259.504, 972.709 259.539 C 970.402 259.573, 970 259.165, 970 256.789 C 970 255.255, 969.550 254, 969 254 C 968.415 254, 968 257.400, 968 262.200 M 368.597 255.844 C 368.251 256.404, 368.455 257.163, 369.050 257.531 C 370.588 258.481, 371.580 257.180, 370.296 255.896 C 369.578 255.178, 369.019 255.161, 368.597 255.844 M 304.126 257.764 C 303.190 259.514, 303.998 266.569, 305.393 268.827 C 306.277 270.257, 309 270.388, 309 269 C 309 268.450, 308.550 268, 308 268 C 306.275 268, 306.886 261.807, 308.750 260.392 C 310.417 259.127, 310.417 259.062, 308.750 259.032 C 307.788 259.014, 307 258.325, 307 257.500 C 307 255.451, 305.280 255.609, 304.126 257.764 M 553 258 C 552.257 259.388, 552.246 260.591, 552.965 261.934 C 553.534 262.998, 554 265.037, 554 266.466 C 554 269.340, 556.498 270.902, 558.267 269.133 C 559.111 268.289, 558.966 268, 557.700 268 C 555.352 268, 555.390 262.183, 557.750 260.392 C 559.417 259.127, 559.417 259.062, 557.750 259.032 C 556.788 259.014, 556 258.325, 556 257.500 C 556 255.357, 554.259 255.647, 553 258 M 682.259 257.570 C 679.730 262.429, 683.953 272.447, 687.172 269.228 C 688.143 268.257, 688.043 268, 686.700 268 C 684.352 268, 684.390 262.183, 686.750 260.392 C 688.028 259.422, 688.125 259.055, 687.110 259.032 C 686.346 259.014, 685.168 258.244, 684.492 257.320 C 683.355 255.765, 683.188 255.783, 682.259 257.570 M 899.213 257.654 C 896.979 261.952, 900.954 272.510, 903.702 269.578 C 904.141 269.109, 903.938 268.525, 903.250 268.280 C 901.647 267.707, 901.611 261.296, 903.207 260.764 C 904.015 260.495, 903.712 259.607, 902.294 258.085 C 900.280 255.923, 900.124 255.902, 899.213 257.654 M 960.104 258.205 C 959.125 259.773, 959.056 260.519, 959.864 260.788 C 960.489 260.996, 961 262.943, 961 265.115 C 961 269.288, 963.118 271.282, 965.267 269.133 C 966.111 268.289, 965.966 268, 964.700 268 C 962.352 268, 962.390 262.183, 964.750 260.392 C 966.417 259.127, 966.417 259.062, 964.750 259.032 C 963.788 259.014, 963 258.325, 963 257.500 C 963 255.338, 961.697 255.655, 960.104 258.205 M 1119 257.500 C 1119 258.325, 1118.460 259, 1117.800 259 C 1116.867 259, 1116.867 259.267, 1117.800 260.200 C 1118.460 260.860, 1119 262.830, 1119 264.578 C 1119 268.008, 1121.190 270.619, 1123.085 269.448 C 1123.920 268.931, 1123.789 268.462, 1122.628 267.812 C 1120.514 266.629, 1120.408 261, 1122.500 261 C 1123.325 261, 1124 260.550, 1124 260 C 1124 259.450, 1123.325 259, 1122.500 259 C 1121.675 259, 1121 258.325, 1121 257.500 C 1121 256.675, 1120.550 256, 1120 256 C 1119.450 256, 1119 256.675, 1119 257.500 M 1150 257.417 C 1150 258.196, 1149.438 259.096, 1148.750 259.417 C 1147.750 259.883, 1147.750 260.117, 1148.750 260.583 C 1149.440 260.906, 1150 262.934, 1150 265.115 C 1150 269.288, 1152.118 271.282, 1154.267 269.133 C 1155.111 268.289, 1154.966 268, 1153.700 268 C 1152.424 268, 1152 267.127, 1152 264.500 C 1152 262.056, 1152.452 261, 1153.500 261 C 1154.325 261, 1155 260.550, 1155 260 C 1155 259.450, 1154.325 259, 1153.500 259 C 1152.675 259, 1152 258.325, 1152 257.500 C 1152 256.675, 1151.550 256, 1151 256 C 1150.450 256, 1150 256.637, 1150 257.417 M 106 266.711 C 106 271.394, 106.368 273.891, 107 273.500 C 107.550 273.160, 108 272.051, 108 271.035 C 108 269.729, 108.543 269.329, 109.851 269.671 C 112.372 270.331, 115 267.462, 115 264.051 C 115 260.508, 113.314 259.096, 109.221 259.213 L 106 259.304 106 266.711 M 117 264.652 C 117 267.593, 117.450 270, 118 270 C 118.550 270, 119 268.429, 119 266.508 C 119 264.100, 119.620 262.630, 121 261.768 C 123.829 260.001, 123.483 259.120, 120 259.219 C 117.051 259.303, 117 259.396, 117 264.652 M 125.571 260.571 C 122.429 263.714, 124.886 270, 129.257 270 C 133.164 270, 135.669 263.069, 132.800 260.200 C 131.117 258.517, 127.436 258.706, 125.571 260.571 M 137.243 260.157 C 135.526 261.874, 135.682 267.491, 137.487 268.989 C 139.082 270.313, 144 269.598, 144 268.043 C 144 267.537, 142.762 267.208, 141.250 267.312 C 138.819 267.478, 138.500 267.152, 138.500 264.500 C 138.500 262.067, 138.924 261.495, 140.742 261.472 C 141.975 261.456, 143.001 261.006, 143.023 260.472 C 143.083 258.990, 138.651 258.749, 137.243 260.157 M 146.200 260.200 C 144.164 262.236, 144.724 267.782, 147.093 269.050 C 149.389 270.279, 154 269.552, 154 267.962 C 154 267.412, 152.954 267.224, 151.676 267.545 C 150.201 267.916, 148.877 267.557, 148.053 266.564 C 146.916 265.194, 147.205 265, 150.378 265 C 153.199 265, 154 264.602, 154 263.200 C 154 260.796, 152.076 259, 149.500 259 C 148.345 259, 146.860 259.540, 146.200 260.200 M 156.902 260.618 C 155.743 262.014, 155.932 262.534, 158.279 264.406 C 161.676 267.114, 161.766 268.409, 158.500 267.589 C 156.015 266.966, 155.036 268.286, 157.057 269.535 C 158.858 270.649, 163 269.069, 163 267.269 C 163 266.337, 161.762 264.562, 160.250 263.324 L 157.500 261.072 160.309 261.036 C 161.920 261.015, 162.854 260.573, 162.500 260 C 161.551 258.464, 158.401 258.812, 156.902 260.618 M 165.667 259.667 C 164.124 261.209, 165.148 264.106, 167.560 265.023 C 170.477 266.132, 169.836 268.452, 166.830 267.666 C 165.620 267.349, 165.033 267.600, 165.276 268.329 C 165.836 270.010, 168.848 270.371, 170.548 268.960 C 172.724 267.155, 172.304 265.096, 169.500 263.818 C 166.273 262.348, 166.301 261, 169.559 261 C 171.010 261, 171.851 260.567, 171.500 260 C 170.806 258.877, 166.692 258.642, 165.667 259.667 M 294 260.361 C 294 261.274, 294.824 261.565, 296.500 261.245 C 297.959 260.966, 299 261.232, 299 261.883 C 299 262.498, 298.155 263, 297.122 263 C 296.090 263, 294.653 263.713, 293.930 264.584 C 291.898 267.033, 294.026 269.509, 298.115 269.454 C 301.170 269.413, 301.530 269.101, 301.810 266.251 C 302.263 261.636, 300.502 259, 296.965 259 C 295.130 259, 294 259.519, 294 260.361 M 311.535 259.944 C 311.131 260.598, 312.047 261, 313.941 261 C 317.869 261, 317.908 262.568, 314 263.350 C 311.617 263.827, 311 264.469, 311 266.475 C 311 269.111, 311.107 269.172, 316.044 269.375 C 319.083 269.500, 319.087 269.492, 318.794 264.500 C 318.511 259.693, 318.378 259.488, 315.344 259.194 C 313.608 259.025, 311.894 259.363, 311.535 259.944 M 327 264.652 C 327 267.593, 327.450 270, 328 270 C 328.550 270, 329 268.687, 329 267.082 C 329 263.155, 329.924 261, 331.607 261 C 332.373 261, 333 260.580, 333 260.067 C 333 259.554, 331.650 259.172, 330 259.219 C 327.051 259.303, 327 259.396, 327 264.652 M 335.200 260.200 C 333.164 262.236, 333.724 267.782, 336.093 269.050 C 338.389 270.279, 343 269.552, 343 267.962 C 343 267.412, 341.954 267.224, 340.676 267.545 C 339.201 267.916, 337.877 267.557, 337.053 266.564 C 335.916 265.194, 336.205 265, 339.378 265 C 342.199 265, 343 264.602, 343 263.200 C 343 260.796, 341.076 259, 338.500 259 C 337.345 259, 335.860 259.540, 335.200 260.200 M 346.019 260.965 C 343.721 265.259, 346.292 270.680, 350.149 269.671 C 351.472 269.325, 352 269.731, 352 271.094 C 352 272.142, 352.450 273, 353 273 C 353.569 273, 354 270.054, 354 266.162 L 354 259.324 350.519 259.193 C 348.030 259.100, 346.746 259.605, 346.019 260.965 M 357 262.566 C 357 268.050, 358.455 269.960, 362.519 269.807 L 366 269.676 366 264.338 C 366 261.402, 365.550 259, 365 259 C 364.450 259, 364 260.752, 364 262.893 C 364 265.607, 363.494 266.980, 362.330 267.427 C 360.212 268.240, 359.035 266.401, 359.015 262.250 C 359.007 260.462, 358.550 259, 358 259 C 357.450 259, 357 260.605, 357 262.566 M 369 264.500 C 369 267.525, 369.450 270, 370 270 C 370.550 270, 371 267.525, 371 264.500 C 371 261.475, 370.550 259, 370 259 C 369.450 259, 369 261.475, 369 264.500 M 374 264.652 C 374 267.593, 374.450 270, 375 270 C 375.550 270, 376 268.158, 376 265.906 C 376 262.654, 376.411 261.705, 378 261.290 C 381.046 260.493, 380.385 259.123, 377 259.219 C 374.051 259.303, 374 259.396, 374 264.652 M 382.200 260.200 C 380.164 262.236, 380.724 267.782, 383.093 269.050 C 385.449 270.311, 390 269.536, 390 267.874 C 390 267.276, 389.262 267.069, 388.359 267.416 C 386.387 268.173, 383 267.235, 383 265.933 C 383 265.420, 384.575 265, 386.500 265 C 389.204 265, 390 264.590, 390 263.200 C 390 260.796, 388.076 259, 385.500 259 C 384.345 259, 382.860 259.540, 382.200 260.200 M 561 264.619 C 561 268.030, 561.380 269.883, 562 269.500 C 562.550 269.160, 563 267.319, 563 265.409 C 563 262.742, 563.522 261.726, 565.250 261.031 C 567.764 260.021, 567.658 259.909, 563.750 259.446 C 561.044 259.125, 561 259.208, 561 264.619 M 568 260 C 568 260.550, 569.125 261, 570.500 261 C 571.875 261, 573 261.450, 573 262 C 573 262.550, 572.155 263, 571.122 263 C 570.090 263, 568.653 263.713, 567.930 264.584 C 565.898 267.033, 568.026 269.510, 572.115 269.454 C 575.299 269.411, 575.519 269.184, 575.815 265.634 C 575.988 263.559, 575.595 261.217, 574.942 260.430 C 573.600 258.813, 568 258.466, 568 260 M 578.201 264.355 C 578.545 270.280, 580.263 270.855, 581 265.293 C 581.338 262.746, 582.069 261.411, 583.250 261.186 C 584.710 260.909, 585 261.611, 585 265.427 C 585 267.960, 585.469 270, 586.052 270 C 586.693 270, 586.986 267.949, 586.802 264.750 L 586.500 259.500 582.201 259.355 L 577.903 259.210 578.201 264.355 M 590.667 259.667 C 589.319 261.014, 590.056 263.960, 592 265 C 594.876 266.539, 594.526 268.349, 591.500 267.589 C 588.758 266.901, 587.962 268.665, 590.564 269.663 C 592.716 270.489, 597 268.383, 597 266.500 C 597 265.651, 595.875 264.445, 594.500 263.818 C 591.495 262.449, 591.238 261, 594 261 C 595.100 261, 596 260.550, 596 260 C 596 258.888, 591.714 258.620, 590.667 259.667 M 605.200 260.200 C 603.501 261.899, 603.712 266.569, 605.571 268.429 C 608.917 271.774, 614 269.180, 614 264.129 C 614 260.701, 612.341 259, 609 259 C 607.570 259, 605.860 259.540, 605.200 260.200 M 617 264.711 C 617 268.061, 617.380 269.883, 618 269.500 C 618.550 269.160, 619 267.291, 619 265.347 C 619 262.654, 619.476 261.688, 621 261.290 C 624.046 260.493, 623.385 259.123, 620 259.219 C 617.047 259.303, 617 259.389, 617 264.711 M 624.876 259.462 C 624.808 259.483, 624.632 261.300, 624.485 263.500 C 624.187 267.977, 625.461 271.657, 626.390 269 C 626.678 268.175, 627.046 266.150, 627.207 264.500 C 627.678 259.673, 630.437 260.631, 630.807 265.750 C 631.205 271.242, 632.795 271.248, 633.193 265.759 C 633.417 262.665, 633.973 261.427, 635.250 261.185 C 636.681 260.914, 637 261.585, 637 264.868 C 637 267.076, 637.475 269.176, 638.055 269.534 C 638.759 269.969, 639.009 268.405, 638.805 264.843 L 638.500 259.500 631.750 259.462 C 628.038 259.441, 624.944 259.441, 624.876 259.462 M 647 260 C 647 260.550, 648.125 261, 649.500 261 C 650.875 261, 652 261.450, 652 262 C 652 262.550, 651.155 263, 650.122 263 C 649.090 263, 647.653 263.713, 646.930 264.584 C 644.898 267.033, 647.026 269.510, 651.115 269.454 C 654.299 269.411, 654.519 269.184, 654.815 265.634 C 654.988 263.559, 654.595 261.217, 653.942 260.430 C 652.600 258.813, 647 258.466, 647 260 M 662.902 260.618 C 661.743 262.014, 661.932 262.534, 664.279 264.406 C 667.676 267.114, 667.766 268.409, 664.500 267.589 C 663.125 267.244, 662 267.394, 662 267.922 C 662 269.524, 663.974 270.223, 666.622 269.559 C 669.791 268.763, 669.558 264.964, 666.250 263.513 C 663.251 262.197, 663.398 261, 666.559 261 C 668.010 261, 668.851 260.567, 668.500 260 C 667.551 258.464, 664.401 258.812, 662.902 260.618 M 672.200 260.200 C 670.164 262.236, 670.724 267.782, 673.093 269.050 C 675.459 270.316, 680.406 269.466, 679.472 267.954 C 679.136 267.412, 678.439 267.229, 677.922 267.548 C 676.673 268.320, 673 267.114, 673 265.933 C 673 265.420, 674.575 265, 676.500 265 C 679.204 265, 680 264.590, 680 263.200 C 680 260.796, 678.076 259, 675.500 259 C 674.345 259, 672.860 259.540, 672.200 260.200 M 695.200 260.200 C 692.300 263.100, 695.098 270, 699.174 270 C 701.285 270, 704 266.761, 704 264.243 C 704 259.978, 698.122 257.278, 695.200 260.200 M 855.315 260.623 C 854.539 262.644, 855.454 269.500, 856.500 269.500 C 857.050 269.500, 857.643 267.762, 857.817 265.639 C 858.047 262.831, 858.658 261.641, 860.056 261.275 C 861.113 260.999, 861.735 260.381, 861.439 259.902 C 860.672 258.661, 855.850 259.228, 855.315 260.623 M 863.571 260.571 C 859.884 264.259, 863.455 270.856, 868.460 269.599 C 869.857 269.249, 871 268.512, 871 267.962 C 871 267.412, 869.954 267.224, 868.676 267.545 C 867.201 267.916, 865.877 267.557, 865.053 266.564 C 863.916 265.194, 864.205 265, 867.378 265 C 870.199 265, 871 264.602, 871 263.200 C 871 259.265, 866.478 257.665, 863.571 260.571 M 873.902 260.618 C 872.743 262.014, 872.932 262.534, 875.279 264.406 C 878.676 267.114, 878.766 268.409, 875.500 267.589 C 874.125 267.244, 873 267.394, 873 267.922 C 873 269.512, 874.966 270.225, 877.557 269.575 C 880.679 268.792, 881.004 264.496, 878 263.710 C 875.375 263.024, 875.419 261, 878.059 261 C 879.191 261, 879.840 260.550, 879.500 260 C 878.551 258.464, 875.401 258.812, 873.902 260.618 M 882.015 262.750 C 882.036 267.830, 883.190 269.301, 887.418 269.633 L 891 269.916 891 264.458 C 891 261.456, 890.550 259, 890 259 C 889.450 259, 889 260.752, 889 262.893 C 889 265.310, 888.468 266.990, 887.598 267.324 C 885.559 268.106, 885 267.140, 885 262.833 C 885 260.093, 884.572 259, 883.500 259 C 882.431 259, 882.004 260.077, 882.015 262.750 M 918 264.652 C 918 267.593, 918.450 270, 919 270 C 919.550 270, 920 268.429, 920 266.508 C 920 264.100, 920.620 262.630, 922 261.768 C 924.829 260.001, 924.483 259.120, 921 259.219 C 918.051 259.303, 918 259.396, 918 264.652 M 926.571 260.571 C 923.429 263.714, 925.886 270, 930.257 270 C 934.164 270, 936.669 263.069, 933.800 260.200 C 932.117 258.517, 928.436 258.706, 926.571 260.571 M 937.352 260.525 C 936.536 262.651, 937.436 269.514, 938.500 269.283 C 939.050 269.164, 939.725 267.364, 940 265.283 C 940.722 259.822, 943.402 260.151, 943.807 265.750 C 944.205 271.242, 945.795 271.248, 946.193 265.759 C 946.417 262.665, 946.973 261.427, 948.250 261.185 C 949.681 260.914, 950 261.585, 950 264.868 C 950 267.076, 950.475 269.176, 951.055 269.534 C 951.759 269.969, 952.009 268.405, 951.805 264.843 L 951.500 259.500 944.669 259.380 C 939.990 259.298, 937.685 259.658, 937.352 260.525 M 979.997 260.503 C 976.898 264.237, 979.862 270.467, 984.414 269.788 C 987.402 269.342, 987.358 267.414, 984.361 267.460 C 982.895 267.482, 981.501 266.938, 981.264 266.250 C 980.982 265.431, 981.875 265, 983.858 265 C 987.482 265, 988.472 263.751, 987.011 261.021 C 985.735 258.637, 981.788 258.345, 979.997 260.503 M 1095.440 261.451 C 1093.537 264.356, 1094.266 267.537, 1097.194 269.104 C 1099.835 270.517, 1103.568 268.936, 1104.496 266.012 C 1105.441 263.035, 1102.566 259, 1099.500 259 C 1097.999 259, 1096.422 259.952, 1095.440 261.451 M 1107 263.378 C 1107 268.418, 1108.202 269.740, 1112.750 269.697 L 1116 269.667 1116 264.333 C 1116 261.400, 1115.550 259, 1115 259 C 1114.450 259, 1114 260.520, 1114 262.378 C 1114 266.347, 1111.408 269.257, 1109.939 266.936 C 1109.439 266.146, 1109.024 264.038, 1109.015 262.250 C 1109.007 260.462, 1108.550 259, 1108 259 C 1107.450 259, 1107 260.970, 1107 263.378 M 1126 266.162 C 1126 270.054, 1126.431 273, 1127 273 C 1127.550 273, 1128 272.091, 1128 270.981 C 1128 269.367, 1128.467 269.079, 1130.324 269.545 C 1133.313 270.295, 1135.331 267.930, 1135.214 263.813 C 1135.109 260.136, 1133.687 259.035, 1129.255 259.202 L 1126 259.324 1126 266.162 M 1138 263.378 C 1138 268.448, 1139.414 270.033, 1143.546 269.592 C 1146.364 269.292, 1146.500 269.057, 1146.500 264.472 C 1146.500 258.235, 1144.245 257.158, 1143.811 263.187 C 1143.592 266.216, 1143.053 267.500, 1142 267.500 C 1140.950 267.500, 1140.408 266.224, 1140.193 263.250 C 1139.787 257.652, 1138 257.756, 1138 263.378 M 108.667 261.667 C 107.600 262.734, 107.897 266.819, 109.096 267.559 C 110.860 268.649, 113.294 265.501, 112.535 263.112 C 111.879 261.045, 109.993 260.340, 108.667 261.667 M 126.483 263.053 C 125.502 266.146, 128.260 268.859, 130.498 267.002 C 132.724 265.154, 132.007 261.572, 129.336 261.192 C 127.836 260.978, 126.960 261.550, 126.483 263.053 M 147.500 262 C 147.149 262.567, 147.990 263, 149.441 263 C 150.848 263, 152 262.550, 152 262 C 152 261.450, 151.127 261, 150.059 261 C 148.991 261, 147.840 261.450, 147.500 262 M 284.701 261.632 C 283.629 262.704, 283.867 266.800, 285.044 267.527 C 286.651 268.520, 289.132 265.924, 288.798 263.598 C 288.499 261.513, 286.013 260.320, 284.701 261.632 M 336.500 262 C 336.148 262.569, 337.009 263, 338.500 263 C 339.991 263, 340.852 262.569, 340.500 262 C 340.160 261.450, 339.260 261, 338.500 261 C 337.740 261, 336.840 261.450, 336.500 262 M 347.563 262.802 C 346.709 265.492, 347.946 268.157, 349.876 267.785 C 352.138 267.350, 352.103 261.643, 349.835 261.207 C 348.884 261.024, 347.910 261.708, 347.563 262.802 M 383.500 262 C 383.148 262.569, 384.009 263, 385.500 263 C 386.991 263, 387.852 262.569, 387.500 262 C 387.160 261.450, 386.260 261, 385.500 261 C 384.740 261, 383.840 261.450, 383.500 262 M 394.563 262.802 C 393.931 264.792, 394.735 268.011, 395.857 267.985 C 397.718 267.940, 399.136 265.996, 398.837 263.897 C 398.419 260.951, 395.396 260.176, 394.563 262.802 M 606.483 263.053 C 605.502 266.146, 608.260 268.859, 610.498 267.002 C 612.724 265.154, 612.007 261.572, 609.336 261.192 C 607.836 260.978, 606.960 261.550, 606.483 263.053 M 673.500 262 C 673.148 262.569, 674.009 263, 675.500 263 C 676.991 263, 677.852 262.569, 677.500 262 C 677.160 261.450, 676.260 261, 675.500 261 C 674.740 261, 673.840 261.450, 673.500 262 M 696.667 261.667 C 695.485 262.849, 695.956 265.719, 697.550 267.042 C 699.712 268.836, 702.484 266.102, 701.535 263.112 C 700.895 261.094, 698.076 260.257, 696.667 261.667 M 864.500 262 C 864.149 262.567, 864.990 263, 866.441 263 C 867.848 263, 869 262.550, 869 262 C 869 261.450, 868.127 261, 867.059 261 C 865.991 261, 864.840 261.450, 864.500 262 M 927.483 263.053 C 926.502 266.146, 929.260 268.859, 931.498 267.002 C 933.724 265.154, 933.007 261.572, 930.336 261.192 C 928.836 260.978, 927.960 261.550, 927.483 263.053 M 981.500 262 C 981.148 262.569, 982.009 263, 983.500 263 C 984.991 263, 985.852 262.569, 985.500 262 C 985.160 261.450, 984.260 261, 983.500 261 C 982.740 261, 981.840 261.450, 981.500 262 M 1097.412 262.368 C 1096.406 264.989, 1097.434 267.500, 1099.514 267.500 C 1101.052 267.500, 1101.500 266.826, 1101.500 264.514 C 1101.500 261.242, 1098.457 259.645, 1097.412 262.368 M 1129.250 261.667 C 1127.515 262.361, 1127.685 265.494, 1129.542 267.035 C 1131.545 268.697, 1133.290 267.059, 1132.835 263.944 C 1132.484 261.548, 1131.349 260.827, 1129.250 261.667 M 295.543 265.931 C 295.226 266.443, 295.425 267.144, 295.984 267.490 C 297.177 268.227, 299 267.291, 299 265.941 C 299 264.724, 296.293 264.716, 295.543 265.931 M 313 266.573 C 313 267.505, 313.680 268.015, 314.667 267.823 C 317.176 267.337, 317.520 265, 315.083 265 C 313.855 265, 313 265.646, 313 266.573 M 570 266.583 C 570 268.349, 572.153 268.042, 572.771 266.188 C 572.989 265.534, 572.454 265, 571.583 265 C 570.712 265, 570 265.712, 570 266.583 M 649 266.583 C 649 268.349, 651.153 268.042, 651.771 266.188 C 651.989 265.534, 651.454 265, 650.583 265 C 649.712 265, 649 265.712, 649 266.583 M 585 283.441 C 585 284.298, 585.450 285, 586 285 C 586.550 285, 587 284.577, 587 284.059 C 587 283.541, 586.550 282.840, 586 282.500 C 585.450 282.160, 585 282.584, 585 283.441 M 273.213 284.654 C 270.979 288.952, 274.954 299.510, 277.702 296.578 C 278.141 296.109, 277.938 295.525, 277.250 295.280 C 275.647 294.707, 275.611 288.296, 277.207 287.764 C 278.015 287.495, 277.712 286.607, 276.294 285.085 C 274.280 282.923, 274.124 282.902, 273.213 284.654 M 349.213 284.654 C 346.979 288.952, 350.954 299.510, 353.702 296.578 C 354.141 296.109, 353.938 295.525, 353.250 295.280 C 351.647 294.707, 351.611 288.296, 353.207 287.764 C 354.015 287.495, 353.712 286.607, 352.294 285.085 C 350.280 282.923, 350.124 282.902, 349.213 284.654 M 625 284.417 C 625 285.196, 624.438 286.062, 623.750 286.341 C 622.803 286.725, 622.785 287.051, 623.676 287.687 C 624.322 288.148, 624.997 290.320, 625.176 292.513 C 625.440 295.766, 625.914 296.559, 627.750 296.820 C 630.265 297.177, 630.831 295.533, 628.500 294.638 C 627.623 294.302, 627 292.803, 627 291.031 C 627 289.003, 627.497 288, 628.500 288 C 629.325 288, 630 287.550, 630 287 C 630 286.450, 629.325 286, 628.500 286 C 627.675 286, 627 285.325, 627 284.500 C 627 283.675, 626.550 283, 626 283 C 625.450 283, 625 283.637, 625 284.417 M 646 284 C 646 284.550, 646.450 285, 647 285 C 647.550 285, 648 284.550, 648 284 C 648 283.450, 647.550 283, 647 283 C 646.450 283, 646 283.450, 646 284 M 663.032 284.167 C 663.014 285.083, 662.438 286.096, 661.750 286.417 C 660.750 286.883, 660.750 287.117, 661.750 287.583 C 662.440 287.906, 663 289.934, 663 292.115 C 663 296.288, 665.118 298.282, 667.267 296.133 C 668.111 295.289, 667.966 295, 666.700 295 C 665.424 295, 665 294.127, 665 291.500 C 665 289.056, 665.452 288, 666.500 288 C 667.325 288, 668 287.550, 668 287 C 668 286.450, 667.487 286, 666.860 286 C 666.233 286, 665.123 285.212, 664.392 284.250 C 663.184 282.659, 663.061 282.651, 663.032 284.167 M 280.997 287.503 C 279.150 289.729, 279.485 294.150, 281.618 295.710 C 284.283 297.659, 287.198 296.921, 288.907 293.865 C 290.228 291.504, 290.203 290.959, 288.667 288.615 C 286.742 285.677, 282.967 285.130, 280.997 287.503 M 297.381 288.541 C 296.056 290.564, 295.942 291.577, 296.824 293.513 C 297.952 295.989, 302.028 297.719, 303.943 296.535 C 305.812 295.380, 305.074 294.420, 302.348 294.461 C 300.889 294.482, 299.501 293.938, 299.264 293.250 C 298.972 292.402, 299.987 292, 302.417 292 C 306.358 292, 307.139 290.282, 304.429 287.571 C 302.119 285.262, 299.273 285.654, 297.381 288.541 M 307 286.453 C 307 286.702, 307.496 287.995, 308.103 289.326 C 308.920 291.120, 308.899 292.320, 308.022 293.959 C 306.468 296.862, 307.740 298.069, 309.644 295.498 C 311.041 293.612, 311.196 293.598, 312.422 295.250 C 314.653 298.257, 316.319 297.349, 314.432 294.155 C 312.853 291.481, 312.856 291.149, 314.491 288.655 C 316.333 285.842, 315.125 284.939, 312.979 287.525 C 311.845 288.892, 311.538 288.892, 310.028 287.525 C 308.382 286.035, 307 285.546, 307 286.453 M 317.655 287.829 C 314.204 291.642, 316.860 297.394, 321.799 296.804 C 325.236 296.394, 325.713 294.409, 322.361 294.460 C 320.895 294.482, 319.501 293.938, 319.264 293.250 C 318.982 292.431, 319.875 292, 321.858 292 C 325.689 292, 326.693 290.423, 324.443 287.937 C 322.243 285.506, 319.792 285.467, 317.655 287.829 M 329.265 286.794 C 328.586 287.237, 327.763 288.937, 327.435 290.573 C 326.992 292.792, 327.349 294.006, 328.846 295.361 C 330.978 297.290, 334.077 297.273, 334.724 295.329 C 334.968 294.596, 334.377 294.350, 333.143 294.673 C 330.469 295.372, 328.291 291.560, 330.111 289.367 C 330.798 288.538, 332.205 288.082, 333.237 288.352 C 334.387 288.653, 334.965 288.389, 334.729 287.671 C 334.255 286.232, 330.942 285.700, 329.265 286.794 M 337.015 289.667 C 337.036 294.885, 338.289 296.481, 342.463 296.606 L 346 296.712 346 291.356 C 346 288.410, 345.550 286, 345 286 C 344.450 286, 344 287.752, 344 289.893 C 344 292.607, 343.494 293.980, 342.330 294.427 C 340.174 295.254, 338.905 293.267, 339.237 289.584 C 339.386 287.933, 338.958 286.487, 338.250 286.251 C 337.393 285.965, 337.005 287.039, 337.015 289.667 M 357.278 287.250 C 353.924 291.585, 356.017 297.371, 360.735 296.810 C 364.219 296.396, 364.748 294.408, 361.361 294.460 C 359.895 294.482, 358.501 293.938, 358.264 293.250 C 357.972 292.402, 358.987 292, 361.417 292 C 364.312 292, 365 291.623, 365 290.035 C 365 286.743, 359.269 284.676, 357.278 287.250 M 371 286.878 C 371 287.361, 371.701 289.433, 372.558 291.484 C 373.414 293.534, 373.977 296.268, 373.808 297.560 C 373.208 302.134, 375.412 300.418, 377.690 294.536 C 380.217 288.011, 380.526 286, 379 286 C 378.450 286, 378 286.421, 378 286.935 C 378 287.449, 377.509 289.137, 376.909 290.685 L 375.819 293.500 374.302 289.750 C 372.930 286.355, 371 284.677, 371 286.878 M 382.655 287.829 C 380.424 290.294, 380.570 293.301, 383.030 295.527 C 386.214 298.408, 390.398 296.530, 390.829 292.026 C 391.347 286.610, 386.166 283.950, 382.655 287.829 M 394 290.378 C 394 295.418, 395.202 296.740, 399.750 296.697 L 403 296.667 403 291.250 C 403 284.813, 400.798 284.320, 400 290.578 C 399.288 296.166, 396.604 295.935, 396.193 290.250 C 395.787 284.652, 394 284.756, 394 290.378 M 405 291.652 C 405 294.593, 405.450 297, 406 297 C 406.550 297, 407 295.650, 407 294 C 407 292.333, 407.889 290.111, 409 289 C 411.633 286.367, 411.544 286.118, 408 286.219 C 405.051 286.303, 405 286.396, 405 291.652 M 585 291.500 C 585 294.525, 585.450 297, 586 297 C 586.550 297, 587 294.525, 587 291.500 C 587 288.475, 586.550 286, 586 286 C 585.450 286, 585 288.475, 585 291.500 M 590 291.667 C 590 294.600, 590.450 297, 591 297 C 591.550 297, 592 295.248, 592 293.107 C 592 290.471, 592.513 289.017, 593.590 288.604 C 596.101 287.640, 597 288.815, 597 293.059 C 597 295.227, 597.450 297, 598 297 C 599.450 297, 599.230 288.426, 597.750 287.259 C 597.063 286.716, 595.038 286.286, 593.250 286.303 L 590 286.333 590 291.667 M 602 293.711 C 602 298.394, 602.368 300.891, 603 300.500 C 603.550 300.160, 604 299.051, 604 298.035 C 604 296.678, 604.533 296.327, 606.005 296.712 C 608.889 297.466, 611 295.262, 611 291.500 C 611 287.519, 609.441 286.093, 605.221 286.213 L 602 286.304 602 293.711 M 613 289.566 C 613 295.050, 614.455 296.960, 618.519 296.807 L 622 296.676 622 291.338 C 622 285.010, 620.250 284.134, 619.807 290.241 C 619.583 293.335, 619.027 294.573, 617.750 294.815 C 616.290 295.092, 616 294.389, 616 290.573 C 616 287.175, 615.615 286, 614.500 286 C 613.447 286, 613 287.063, 613 289.566 M 633.250 286.662 C 631.103 287.529, 631.867 290.982, 634.469 292.168 C 637.253 293.436, 636.790 295.440, 633.887 294.681 C 632.698 294.370, 632 294.708, 632 295.594 C 632 297.319, 636.133 297.467, 637.800 295.800 C 639.695 293.905, 639.211 292.053, 636.500 290.818 C 633.523 289.462, 633.144 287.543, 636 288.290 C 637.300 288.630, 638 288.320, 638 287.406 C 638 286.025, 635.715 285.667, 633.250 286.662 M 646 291.500 C 646 294.525, 646.450 297, 647 297 C 647.550 297, 648 294.525, 648 291.500 C 648 288.475, 647.550 286, 647 286 C 646.450 286, 646 288.475, 646 291.500 M 651 291.652 C 651 294.593, 651.450 297, 652 297 C 652.550 297, 653 295.480, 653 293.622 C 653 290.124, 655.134 287.346, 656.956 288.473 C 657.530 288.828, 658 290.891, 658 293.059 C 658 295.227, 658.450 297, 659 297 C 660.466 297, 660.222 288.429, 658.721 287.183 C 658.017 286.599, 655.992 286.162, 654.221 286.213 C 651.006 286.304, 651 286.314, 651 291.652 M 670.571 287.571 C 667.373 290.770, 669.638 297, 674 297 C 676.732 297, 679 294.262, 679 290.964 C 679 286.496, 673.757 284.386, 670.571 287.571 M 888.322 287.612 C 887.517 289.693, 888.496 300.023, 889.500 300.051 C 890.050 300.067, 890.637 299.210, 890.805 298.148 C 891.012 296.843, 891.693 296.369, 892.906 296.686 C 895.125 297.266, 898 294.544, 898 291.863 C 898 287.818, 896.157 285.991, 892.342 286.253 C 890.368 286.389, 888.558 287, 888.322 287.612 M 900 291.652 C 900 294.593, 900.450 297, 901 297 C 901.550 297, 902 295.429, 902 293.508 C 902 291.100, 902.620 289.630, 904 288.768 C 906.829 287.001, 906.483 286.120, 903 286.219 C 900.051 286.303, 900 286.396, 900 291.652 M 908.571 287.571 C 906.342 289.801, 906.553 294.690, 908.934 295.965 C 911.647 297.417, 913.602 297.255, 915.429 295.429 C 918.627 292.230, 916.362 286, 912 286 C 910.979 286, 909.436 286.707, 908.571 287.571 M 919.997 287.503 C 916.715 291.458, 919.779 297.774, 924.415 296.611 C 927.850 295.748, 927.730 294.074, 924.250 294.312 C 921.819 294.478, 921.500 294.152, 921.500 291.500 C 921.500 288.848, 921.819 288.522, 924.250 288.688 C 927.235 288.893, 927.969 287.586, 925.418 286.607 C 922.888 285.636, 921.334 285.893, 919.997 287.503 M 929.655 287.829 C 927.550 290.154, 927.538 293.395, 929.626 295.483 C 931.394 297.252, 936.122 297.184, 936.713 295.381 C 936.938 294.692, 936.176 294.435, 934.729 294.712 C 933.340 294.977, 931.842 294.514, 931.067 293.580 C 929.913 292.190, 930.184 292, 933.319 292 C 937.627 292, 938.408 291.028, 936.402 288.163 C 934.550 285.519, 931.866 285.386, 929.655 287.829 M 939.942 287.570 C 938.731 289.029, 938.897 289.506, 941.279 291.406 C 944.676 294.114, 944.766 295.409, 941.500 294.589 C 940.125 294.244, 939 294.394, 939 294.922 C 939 296.512, 940.966 297.225, 943.557 296.575 C 946.829 295.754, 946.795 292.319, 943.500 290.818 C 940.248 289.336, 940.275 287.628, 943.540 288.252 C 945.142 288.559, 945.944 288.325, 945.711 287.619 C 945.113 285.800, 941.437 285.769, 939.942 287.570 M 949.250 286.662 C 947.239 287.474, 947.782 291.130, 950 291.710 C 951.100 291.998, 952 292.908, 952 293.733 C 952 294.741, 951.344 295.062, 950 294.710 C 948.700 294.370, 948 294.680, 948 295.594 C 948 297.319, 952.133 297.467, 953.800 295.800 C 955.695 293.905, 955.211 292.053, 952.500 290.818 C 949.495 289.449, 949.238 288, 952 288 C 953.100 288, 954 287.550, 954 287 C 954 285.964, 951.433 285.782, 949.250 286.662 M 282.412 289.368 C 281.406 291.989, 282.434 294.500, 284.514 294.500 C 286.052 294.500, 286.500 293.826, 286.500 291.514 C 286.500 288.242, 283.457 286.645, 282.412 289.368 M 299.500 289 C 299.160 289.550, 299.809 290, 300.941 290 C 302.073 290, 303 289.550, 303 289 C 303 288.450, 302.352 288, 301.559 288 C 300.766 288, 299.840 288.450, 299.500 289 M 319 289 C 319 289.550, 319.900 290, 321 290 C 322.100 290, 323 289.550, 323 289 C 323 288.450, 322.100 288, 321 288 C 319.900 288, 319 288.450, 319 289 M 358.500 289 C 358.148 289.569, 359.009 290, 360.500 290 C 361.991 290, 362.852 289.569, 362.500 289 C 362.160 288.450, 361.260 288, 360.500 288 C 359.740 288, 358.840 288.450, 358.500 289 M 384.412 289.368 C 383.406 291.989, 384.434 294.500, 386.514 294.500 C 388.052 294.500, 388.500 293.826, 388.500 291.514 C 388.500 288.242, 385.457 286.645, 384.412 289.368 M 604.384 289.442 C 603.483 291.789, 604.398 294.453, 606.226 294.805 C 608.054 295.157, 609.729 290.988, 608.535 289.057 C 607.588 287.524, 605.029 287.761, 604.384 289.442 M 671.545 289.859 C 670.695 292.536, 671.914 295, 674.088 295 C 676.062 295, 677.720 290.973, 676.535 289.057 C 675.467 287.328, 672.180 287.856, 671.545 289.859 M 891.384 289.442 C 890.602 291.479, 891.286 294.263, 892.682 294.728 C 894.236 295.245, 896.160 291.581, 895.389 289.572 C 894.634 287.603, 892.121 287.521, 891.384 289.442 M 909.465 290.112 C 909.037 291.460, 909.374 292.802, 910.397 293.826 C 911.868 295.296, 912.132 295.296, 913.603 293.826 C 915.630 291.799, 914.585 288, 912 288 C 910.974 288, 909.833 288.950, 909.465 290.112 M 931 289 C 931 289.550, 931.900 290, 933 290 C 934.100 290, 935 289.550, 935 289 C 935 288.450, 934.100 288, 933 288 C 931.900 288, 931 288.450, 931 289 M 599.667 308.667 C 599.300 309.033, 599 310.158, 599 311.167 C 599 312.175, 598.460 313, 597.800 313 C 596.867 313, 596.867 313.267, 597.800 314.200 C 598.460 314.860, 599 317.110, 599 319.200 C 599 321.290, 599.450 323, 600 323 C 600.550 323, 601 321.362, 601 319.360 C 601 317.067, 601.647 315.229, 602.750 314.392 C 604.417 313.127, 604.417 313.062, 602.750 313.032 C 600.624 312.993, 600.377 310, 602.500 310 C 603.325 310, 604 309.550, 604 309 C 604 307.883, 600.704 307.629, 599.667 308.667 M 628 310.500 C 628 312.608, 627.532 313, 625.019 313 C 621.808 313, 620.499 315.429, 621.167 320.148 C 621.448 322.136, 622.158 322.548, 625.750 322.807 L 630 323.115 630 315.557 C 630 311.186, 629.578 308, 629 308 C 628.450 308, 628 309.125, 628 310.500 M 593.500 310 C 593.160 310.550, 593.584 311, 594.441 311 C 595.298 311, 596 310.550, 596 310 C 596 309.450, 595.577 309, 595.059 309 C 594.541 309, 593.840 309.450, 593.500 310 M 605 310 C 605 310.550, 605.702 311, 606.559 311 C 607.416 311, 607.840 310.550, 607.500 310 C 607.160 309.450, 606.459 309, 605.941 309 C 605.423 309, 605 309.450, 605 310 M 662 311.417 C 662 312.196, 661.438 313.096, 660.750 313.417 C 659.750 313.883, 659.750 314.117, 660.750 314.583 C 661.438 314.904, 662 316.928, 662 319.083 C 662 322.697, 662.213 322.998, 664.750 322.968 C 667.250 322.939, 667.341 322.816, 665.750 321.608 C 664.788 320.877, 664 319.254, 664 318 C 664 316.746, 664.788 315.123, 665.750 314.392 C 667.417 313.127, 667.417 313.062, 665.750 313.032 C 664.788 313.014, 664 312.325, 664 311.500 C 664 310.675, 663.550 310, 663 310 C 662.450 310, 662 310.637, 662 311.417 M 691.769 311.774 C 691.514 312.750, 691.574 315.562, 691.903 318.024 C 692.391 321.684, 692.910 322.558, 694.750 322.820 C 695.987 322.995, 697 322.658, 697 322.070 C 697 321.481, 696.550 321, 696 321 C 694.598 321, 694.745 315.252, 696.159 314.780 C 696.924 314.525, 696.678 313.647, 695.437 312.197 C 693.158 309.536, 692.378 309.446, 691.769 311.774 M 309 320.162 C 309 324.054, 309.431 327, 310 327 C 310.550 327, 311 326.100, 311 325 C 311 323.580, 311.667 323, 313.300 323 C 316.310 323, 318.004 321.211, 317.985 318.050 C 317.961 314.148, 316.751 313.033, 312.705 313.185 L 309 313.324 309 320.162 M 320 318 C 320 321.778, 320.367 323, 321.500 323 C 322.555 323, 323 321.934, 323 319.406 C 323 316.654, 323.468 315.690, 325 315.290 C 328.237 314.443, 327.291 313, 323.500 313 L 320 313 320 318 M 327.818 315.500 C 326.115 319.238, 328.101 323, 331.779 323 C 335.456 323, 337 321.346, 337 317.407 C 337 314.031, 335.689 313, 331.397 313 C 329.765 313, 328.580 313.828, 327.818 315.500 M 340.200 314.200 C 339.540 314.860, 339 316.570, 339 318 C 339 321.193, 340.677 323, 343.641 323 C 346.961 323, 347.481 321.187, 344.267 320.818 C 342.067 320.565, 341.500 319.988, 341.500 318 C 341.500 316.016, 342.068 315.435, 344.250 315.184 C 345.762 315.010, 347 314.447, 347 313.934 C 347 312.577, 341.612 312.788, 340.200 314.200 M 349.200 314.200 C 348.540 314.860, 348 316.570, 348 318 C 348 319.430, 348.540 321.140, 349.200 321.800 C 350.648 323.248, 357 323.411, 357 322 C 357 321.450, 355.650 321, 354 321 C 351.906 321, 351 320.513, 351 319.387 C 351 318.157, 351.725 317.879, 354.044 318.220 C 357.628 318.746, 358.501 317.804, 357.011 315.021 C 355.794 312.746, 351.143 312.257, 349.200 314.200 M 359.649 314.471 C 359.077 315.963, 361.371 319, 363.071 319 C 363.582 319, 364 319.450, 364 320 C 364 320.550, 362.875 321, 361.500 321 C 360.125 321, 359 321.450, 359 322 C 359 323.458, 365.752 323.227, 366.282 321.750 C 366.928 319.947, 365.180 317, 363.465 317 C 362.659 317, 362 316.550, 362 316 C 362 315.450, 362.900 315, 364 315 C 365.100 315, 366 314.550, 366 314 C 366 312.409, 360.278 312.833, 359.649 314.471 M 368.300 314.660 C 367.872 315.776, 368.619 317.085, 370.582 318.655 L 373.500 320.990 370.750 320.995 C 369.238 320.998, 368 321.479, 368 322.063 C 368 322.661, 369.424 322.989, 371.250 322.813 C 375.662 322.388, 376.277 318.951, 372.296 316.975 L 369.500 315.588 372.250 315.227 C 375.973 314.740, 375.753 313, 371.969 313 C 370.067 313, 368.700 313.618, 368.300 314.660 M 552.357 314.513 C 551.675 316.290, 553.647 319, 555.622 319 C 556.380 319, 557 319.450, 557 320 C 557 320.550, 555.875 321, 554.500 321 C 553.125 321, 552 321.479, 552 322.063 C 552 322.661, 553.424 322.989, 555.250 322.813 C 559.662 322.388, 560.277 318.951, 556.296 316.975 L 553.500 315.588 556.250 315.227 C 559.973 314.740, 559.753 313, 555.969 313 C 554.185 313, 552.698 313.623, 552.357 314.513 M 561 320.106 C 561 325.567, 561.312 327, 562.500 327 C 563.325 327, 564 326.130, 564 325.066 C 564 323.704, 564.807 323.039, 566.732 322.816 C 568.680 322.591, 569.744 321.697, 570.443 319.697 C 571.886 315.570, 570.183 313.531, 565.142 313.356 L 561 313.211 561 320.106 M 572.818 315.500 C 570.959 319.579, 573.085 323, 577.479 323 C 579.415 323, 581 322.550, 581 322 C 581 321.450, 579.650 321, 578 321 C 576.062 321, 575 320.493, 575 319.567 C 575 318.621, 576.024 318.163, 578.014 318.219 C 581.827 318.328, 582.441 317.693, 581.046 315.086 C 579.386 311.984, 574.304 312.240, 572.818 315.500 M 583.916 315.722 C 582.367 319.795, 584.156 323, 587.979 323 C 589.640 323, 591 322.550, 591 322 C 591 321.450, 589.875 321, 588.500 321 C 586.368 321, 586 320.541, 586 317.883 C 586 315.098, 586.266 314.818, 588.500 315.245 C 590.176 315.565, 591 315.274, 591 314.361 C 591 313.513, 589.860 313, 587.975 313 C 585.603 313, 584.727 313.587, 583.916 315.722 M 593 318 C 593 321.778, 593.367 323, 594.500 323 C 595.633 323, 596 321.778, 596 318 C 596 314.222, 595.633 313, 594.500 313 C 593.367 313, 593 314.222, 593 318 M 605 318 C 605 320.750, 605.450 323, 606 323 C 606.550 323, 607 320.750, 607 318 C 607 315.250, 606.550 313, 606 313 C 605.450 313, 605 315.250, 605 318 M 611.054 314.435 C 610.399 315.224, 610.007 317.361, 610.182 319.185 C 610.466 322.144, 610.863 322.535, 613.877 322.823 C 615.735 323, 617.737 322.663, 618.327 322.073 C 619.091 321.309, 618.334 321, 615.700 321 C 613.078 321, 612 320.563, 612 319.500 C 612 318.452, 613.056 318, 615.500 318 C 617.705 318, 619 317.519, 619 316.700 C 619 313.288, 613.344 311.676, 611.054 314.435 M 637.845 315.440 C 636.097 319.277, 638.072 323, 641.856 323 C 645.589 323, 647.217 320.970, 646.818 316.815 C 646.526 313.775, 646.190 313.474, 642.756 313.190 C 639.561 312.925, 638.841 313.255, 637.845 315.440 M 650.195 317.750 L 650.500 322.500 654.669 322.804 C 658.232 323.063, 658.789 322.845, 658.496 321.304 C 658.307 320.312, 658.119 318.038, 658.077 316.250 C 657.966 311.538, 656 312.248, 656 317 C 656 320.333, 655.667 321, 654 321 C 652.333 321, 652 320.333, 652 317 C 652 314.800, 651.525 313, 650.945 313 C 650.311 313, 650.012 314.893, 650.195 317.750 M 669 320 C 669 324, 669.429 327, 670 327 C 670.550 327, 671 326.100, 671 325 C 671 323.580, 671.667 323, 673.300 323 C 676.319 323, 678 321.212, 678 318 C 678 314.514, 676.275 313, 672.300 313 L 669 313 669 320 M 680 316.800 C 680 321.466, 681.410 323, 685.700 323 C 688.993 323, 689 322.990, 689 318 C 689 315.250, 688.550 313, 688 313 C 687.450 313, 687 314.589, 687 316.531 C 687 318.792, 686.445 320.276, 685.457 320.655 C 683.327 321.472, 682.782 320.670, 682.672 316.550 C 682.539 311.557, 680 311.795, 680 316.800 M 699.300 314.660 C 698.872 315.776, 699.619 317.085, 701.582 318.655 L 704.500 320.990 701.750 320.995 C 700.237 320.998, 699 321.479, 699 322.063 C 699 322.661, 700.424 322.989, 702.250 322.813 C 706.548 322.399, 707.313 318.919, 703.489 317.177 C 700.464 315.799, 700.981 313.921, 704.157 314.751 C 705.634 315.138, 706.087 314.951, 705.597 314.158 C 704.515 312.407, 700.028 312.765, 699.300 314.660 M 311.390 316.426 C 310.480 318.797, 311.767 321.191, 313.747 320.810 C 314.854 320.597, 315.500 319.561, 315.500 318 C 315.500 315.149, 312.344 313.941, 311.390 316.426 M 329.753 316.837 C 329.062 319.480, 330.347 321.272, 332.620 320.835 C 335.384 320.302, 335.184 315.598, 332.380 315.198 C 330.966 314.996, 330.092 315.541, 329.753 316.837 M 351 316 C 351 316.550, 351.900 317, 353 317 C 354.100 317, 355 316.550, 355 316 C 355 315.450, 354.100 315, 353 315 C 351.900 315, 351 315.450, 351 316 M 564 318 C 564 320.333, 564.444 321, 566 321 C 567.556 321, 568 320.333, 568 318 C 568 315.667, 567.556 315, 566 315 C 564.444 315, 564 315.667, 564 318 M 575 316 C 575 316.550, 575.900 317, 577 317 C 578.100 317, 579 316.550, 579 316 C 579 315.450, 578.100 315, 577 315 C 575.900 315, 575 315.450, 575 316 M 612 316 C 612 316.550, 612.900 317, 614 317 C 615.100 317, 616 316.550, 616 316 C 616 315.450, 615.100 315, 614 315 C 612.900 315, 612 315.450, 612 316 M 623.701 315.632 C 623.316 316.018, 623 317.415, 623 318.736 C 623 320.656, 623.452 321.075, 625.250 320.820 C 626.894 320.586, 627.500 319.831, 627.500 318.014 C 627.500 315.600, 625.185 314.149, 623.701 315.632 M 640 318 C 640 320.683, 640.327 321.093, 642.250 320.820 C 643.898 320.585, 644.500 319.831, 644.500 318 C 644.500 316.169, 643.898 315.415, 642.250 315.180 C 640.327 314.907, 640 315.317, 640 318 M 671.390 316.426 C 670.480 318.797, 671.767 321.191, 673.747 320.810 C 674.854 320.597, 675.500 319.561, 675.500 318 C 675.500 315.149, 672.344 313.941, 671.390 316.426 M 707.705 323.750 C 707.414 325.262, 707.367 326.692, 707.599 326.927 C 708.200 327.535, 710.930 323.746, 710.968 322.250 C 711.031 319.772, 708.221 321.064, 707.705 323.750 M 617 336.906 C 617 339.323, 616.662 339.724, 614.995 339.288 C 612.111 338.534, 610 340.738, 610 344.500 C 610 348.481, 611.559 349.907, 615.779 349.787 L 619 349.696 619 341.848 C 619 337.283, 618.582 334, 618 334 C 617.450 334, 617 335.308, 617 336.906 M 674.667 334.667 C 673.583 335.750, 673.893 350, 675 350 C 675.583 350, 676 346.667, 676 342 C 676 333.976, 675.901 333.432, 674.667 334.667 M 605 337 C 605 337.550, 605.423 338, 605.941 338 C 606.459 338, 607.160 337.550, 607.500 337 C 607.840 336.450, 607.416 336, 606.559 336 C 605.702 336, 605 336.450, 605 337 M 622 337 C 622 337.550, 622.450 338, 623 338 C 623.550 338, 624 337.550, 624 337 C 624 336.450, 623.550 336, 623 336 C 622.450 336, 622 336.450, 622 337 M 564.832 343.500 C 564.359 349.199, 564.970 354.137, 566.065 353.460 C 566.579 353.142, 567 352.051, 567 351.035 C 567 349.729, 567.543 349.329, 568.851 349.671 C 571.117 350.264, 574 347.571, 574 344.863 C 574 340.898, 572.147 338.991, 568.549 339.253 C 565.372 339.485, 565.144 339.745, 564.832 343.500 M 576 344.667 C 576 347.600, 576.450 350, 577 350 C 577.550 350, 578 348.429, 578 346.508 C 578 344.100, 578.620 342.630, 580 341.768 C 582.785 340.029, 582.500 339.333, 579 339.333 C 576.042 339.333, 576 339.407, 576 344.667 M 584.571 340.571 C 582.712 342.431, 582.501 347.101, 584.200 348.800 C 584.860 349.460, 586.403 350, 587.629 350 C 592.469 350, 594.775 343.916, 591.171 340.655 C 588.875 338.577, 586.595 338.548, 584.571 340.571 M 593.995 339.750 C 593.980 341.988, 597.571 350, 598.589 350 C 599.815 350, 603 343.126, 603 340.480 C 603 337.823, 601.175 338.925, 600.503 341.989 C 599.549 346.328, 598.324 346.511, 597.003 342.509 C 595.992 339.447, 594.009 337.627, 593.995 339.750 M 605 344.500 C 605 347.525, 605.450 350, 606 350 C 606.550 350, 607 347.525, 607 344.500 C 607 341.475, 606.550 339, 606 339 C 605.450 339, 605 341.475, 605 344.500 M 622 344.500 C 622 347.525, 622.450 350, 623 350 C 623.550 350, 624 347.525, 624 344.500 C 624 341.475, 623.550 339, 623 339 C 622.450 339, 622 341.475, 622 344.500 M 627 344.667 C 627 347.600, 627.450 350, 628 350 C 628.550 350, 629 348.186, 629 345.969 C 629 343.195, 629.499 341.746, 630.601 341.323 C 632.656 340.534, 633.965 342.634, 633.985 346.750 C 633.993 348.538, 634.450 350, 635 350 C 636.450 350, 636.230 341.426, 634.750 340.259 C 634.063 339.716, 632.038 339.286, 630.250 339.303 L 627 339.333 627 344.667 M 639.158 340.310 C 638.560 341.030, 638.102 344.183, 638.139 347.317 C 638.202 352.565, 638.408 353.064, 640.758 353.654 C 646.751 355.158, 648.823 349.292, 643 347.306 C 639.742 346.196, 639.686 346.109, 642.191 346.056 C 645.166 345.994, 645.432 345.722, 646.381 341.750 C 647 339.161, 646.840 339, 643.641 339 C 641.773 339, 639.756 339.589, 639.158 340.310 M 653 339.822 C 653 342.294, 656.375 350, 657.458 350 C 658.663 350, 662 342.812, 662 340.217 C 662 337.436, 659.991 339.297, 658.838 343.145 L 657.597 347.290 656.215 343.145 C 655.011 339.532, 653 337.454, 653 339.822 M 664.250 339.662 C 661.994 340.573, 662.944 342.052, 665.391 341.438 C 666.706 341.108, 668.060 341.288, 668.400 341.838 C 668.739 342.387, 667.638 343.140, 665.951 343.511 C 663.353 344.081, 662.932 344.590, 663.192 346.842 C 663.461 349.160, 663.980 349.519, 667.250 349.650 L 671 349.800 671 345.600 C 671 339.925, 668.673 337.878, 664.250 339.662 M 679 342.566 C 679 348.050, 680.455 349.960, 684.519 349.807 L 688 349.676 688 344.338 C 688 341.402, 687.550 339, 687 339 C 686.450 339, 686 340.814, 686 343.031 C 686 345.805, 685.501 347.254, 684.399 347.677 C 682.344 348.466, 681.035 346.366, 681.015 342.250 C 681.007 340.462, 680.550 339, 680 339 C 679.450 339, 679 340.605, 679 342.566 M 691.655 340.829 C 689.569 343.133, 689.533 346.391, 691.571 348.429 C 693.330 350.187, 697.551 350.535, 698.500 349 C 698.861 348.417, 697.844 348, 696.059 348 C 694.007 348, 693 347.506, 693 346.500 C 693 345.452, 694.056 345, 696.500 345 C 700.442 345, 701.095 343.301, 698.171 340.655 C 695.794 338.504, 693.709 338.560, 691.655 340.829 M 568.163 341.878 C 566.352 343.026, 567.093 347.402, 569.165 347.797 C 571.055 348.157, 572.374 345.137, 571.416 342.641 C 570.708 340.797, 570.096 340.653, 568.163 341.878 M 585.384 342.442 C 584.402 345.001, 585.465 347.492, 587.674 347.808 C 589.147 348.019, 590.040 347.451, 590.497 346.010 C 591.661 342.343, 586.740 338.908, 585.384 342.442 M 612.412 342.368 C 611.406 344.989, 612.434 347.500, 614.514 347.500 C 616.052 347.500, 616.500 346.826, 616.500 344.514 C 616.500 341.242, 613.457 339.645, 612.412 342.368 M 640.496 342.007 C 640.153 342.561, 640.596 343.292, 641.480 343.631 C 643.394 344.365, 644.461 343.556, 643.541 342.067 C 642.711 340.723, 641.306 340.696, 640.496 342.007 M 693 342 C 693 342.550, 693.927 343, 695.059 343 C 696.191 343, 696.840 342.550, 696.500 342 C 696.160 341.450, 695.234 341, 694.441 341 C 693.648 341, 693 341.450, 693 342 M 665.459 346.067 C 665.096 346.653, 665.050 347.384, 665.357 347.690 C 666.179 348.513, 669 347.229, 669 346.031 C 669 344.674, 666.303 344.701, 665.459 346.067 M 640.701 349.632 C 639.334 350.999, 640.028 352.135, 642.040 351.820 C 643.161 351.644, 644.085 351.050, 644.092 350.500 C 644.109 349.283, 641.674 348.660, 640.701 349.632 M 706 363.500 C 706 365.442, 705.487 366, 703.700 366 C 700.690 366, 698.996 367.789, 699.015 370.950 C 699.038 374.776, 700.270 376.027, 704.327 376.346 L 708 376.636 708 368.818 C 708 364.273, 707.581 361, 707 361 C 706.450 361, 706 362.125, 706 363.500 M 555.126 364.764 C 553.933 366.993, 555.319 374.961, 557.090 376.056 C 558.858 377.148, 560.454 376.054, 559.087 374.687 C 557.419 373.019, 557.796 368.876, 559.750 367.392 C 561.417 366.127, 561.417 366.062, 559.750 366.032 C 558.788 366.014, 558 365.325, 558 364.500 C 558 362.451, 556.280 362.609, 555.126 364.764 M 609 364.417 C 609 365.196, 608.438 366.096, 607.750 366.417 C 606.750 366.883, 606.750 367.117, 607.750 367.583 C 608.438 367.904, 609 369.928, 609 372.083 C 609 375.697, 609.213 375.998, 611.750 375.970 C 614.101 375.944, 614.246 375.791, 612.750 374.920 C 611.788 374.359, 611 372.735, 611 371.311 C 611 369.886, 611.788 368.123, 612.750 367.392 C 614.417 366.127, 614.417 366.062, 612.750 366.032 C 611.788 366.014, 611 365.325, 611 364.500 C 611 363.675, 610.550 363, 610 363 C 609.450 363, 609 363.637, 609 364.417 M 563.200 367.200 C 562.540 367.860, 562 369.900, 562 371.732 C 562 374.258, 562.536 375.263, 564.213 375.883 C 569.290 377.761, 573.412 373.394, 571.182 368.500 C 569.930 365.752, 565.388 365.012, 563.200 367.200 M 579.184 368.496 C 577.917 371.276, 578.977 375.396, 581.173 376.232 C 581.903 376.510, 583.625 376.257, 585 375.670 L 587.500 374.603 584.250 374.238 C 581.373 373.915, 581 373.523, 581 370.820 C 581 368.103, 581.275 367.819, 583.500 368.245 C 585.176 368.565, 586 368.274, 586 367.361 C 586 366.533, 584.889 366, 583.161 366 C 581.103 366, 580.008 366.688, 579.184 368.496 M 589 370.441 C 589 375.467, 589.178 375.670, 594 376.151 L 597.500 376.500 597.500 371.583 C 597.500 368.539, 597.024 366.508, 596.250 366.250 C 595.390 365.963, 595 367.073, 595 369.810 C 595 372.298, 594.475 373.987, 593.598 374.324 C 591.559 375.106, 591 374.140, 591 369.833 C 591 367.725, 590.550 366, 590 366 C 589.450 366, 589 367.998, 589 370.441 M 600.667 366.667 C 599.253 368.080, 600.080 371.208, 602 371.710 C 603.100 371.998, 604 372.864, 604 373.636 C 604 374.632, 603.277 374.857, 601.500 374.411 C 598.815 373.737, 597.968 375.390, 600.500 376.362 C 603.055 377.342, 606.936 375.167, 606.985 372.729 C 606.993 372.304, 605.875 371.445, 604.500 370.818 C 601.495 369.449, 601.238 368, 604 368 C 605.100 368, 606 367.550, 606 367 C 606 365.888, 601.714 365.620, 600.667 366.667 M 616.035 367.934 C 613.679 372.336, 615.480 376, 620 376 C 621.430 376, 623.140 375.460, 623.800 374.800 C 624.460 374.140, 625 372.430, 625 371 C 625 369.570, 624.460 367.860, 623.800 367.200 C 621.899 365.299, 617.208 365.742, 616.035 367.934 M 628 371.149 C 628 376.838, 629.737 377.718, 630.190 372.258 C 630.407 369.643, 631.027 368.417, 632.250 368.185 C 633.685 367.913, 634 368.588, 634 371.927 C 634 374.167, 634.450 376, 635 376 C 635.550 376, 636 374.411, 636 372.469 C 636 370.208, 636.555 368.724, 637.543 368.345 C 639.754 367.497, 640.437 368.586, 640.171 372.535 C 639.999 375.081, 640.343 376, 641.469 376 C 643.389 376, 643.622 368.742, 641.750 367.245 C 641.063 366.695, 637.688 366.257, 634.250 366.272 L 628 366.297 628 371.149 M 646.054 367.435 C 645.399 368.224, 645.007 370.361, 645.182 372.185 C 645.482 375.311, 645.742 375.518, 649.750 375.807 C 652.404 376, 654 375.694, 654 374.995 C 654 374.378, 653.212 373.954, 652.250 374.052 C 648.945 374.388, 647 373.999, 647 373 C 647 372.450, 648.575 372, 650.500 372 C 653.204 372, 654 371.590, 654 370.200 C 654 366.343, 648.538 364.442, 646.054 367.435 M 656.450 366.883 C 656.203 367.131, 656 369.283, 656 371.667 C 656 374.852, 656.397 376, 657.500 376 C 658.555 376, 659 374.934, 659 372.406 C 659 369.654, 659.468 368.690, 661 368.290 C 664.119 367.474, 663.348 365.942, 659.950 366.201 C 658.273 366.328, 656.698 366.636, 656.450 366.883 M 663.545 367.744 C 663.083 368.947, 663.704 370.150, 665.546 371.618 C 668.233 373.761, 667.615 375.557, 664.590 374.396 C 663.695 374.053, 663 374.297, 663 374.956 C 663 375.674, 664.256 376.006, 666.250 375.813 C 670.204 375.432, 671.508 371.613, 668.058 370.519 C 665.396 369.674, 665.397 368, 668.059 368 C 669.191 368, 669.840 367.550, 669.500 367 C 668.476 365.343, 664.264 365.870, 663.545 367.744 M 677 366.940 C 677 367.523, 678.350 368, 680 368 C 683.761 368, 683.962 369.756, 680.250 370.184 C 678.114 370.429, 677.431 371.096, 677.192 373.165 C 676.859 376.045, 678.522 376.934, 682.800 376.163 C 684.863 375.791, 685.068 375.272, 684.800 371.124 C 684.504 366.564, 684.448 366.496, 680.750 366.190 C 678.579 366.010, 677 366.326, 677 366.940 M 688 371.152 C 688 373.818, 688.450 376, 689 376 C 689.550 376, 690 374.411, 690 372.469 C 690 370.208, 690.555 368.724, 691.543 368.345 C 693.659 367.533, 694.425 368.547, 694.466 372.215 C 694.485 373.929, 695.063 375.520, 695.750 375.749 C 697.456 376.319, 697.429 368.601, 695.721 367.183 C 695.017 366.599, 692.992 366.162, 691.221 366.213 C 688.049 366.303, 688 366.378, 688 371.152 M 564.667 368.667 C 563.630 369.703, 563.881 372.481, 565.122 373.722 C 566.930 375.530, 569 374.021, 569 370.893 C 569 368.754, 568.522 368, 567.167 368 C 566.158 368, 565.033 368.300, 564.667 368.667 M 617.483 370.053 C 616.502 373.146, 619.260 375.859, 621.498 374.002 C 623.724 372.154, 623.007 368.572, 620.336 368.192 C 618.836 367.978, 617.960 368.550, 617.483 370.053 M 647.500 369 C 647.148 369.569, 648.009 370, 649.500 370 C 650.991 370, 651.852 369.569, 651.500 369 C 651.160 368.450, 650.260 368, 649.500 368 C 648.740 368, 647.840 368.450, 647.500 369 M 701.503 369.991 C 700.594 372.854, 702.741 375.460, 704.681 373.850 C 705.460 373.204, 705.962 371.740, 705.798 370.598 C 705.392 367.765, 702.346 367.335, 701.503 369.991 M 679 372.941 C 679 374.673, 680.760 374.994, 682.009 373.489 C 683.038 372.250, 682.889 372, 681.122 372 C 679.955 372, 679 372.423, 679 372.941 M 624.750 387.571 C 623.609 388.730, 623.841 403, 625 403 C 625.550 403, 626 401.480, 626 399.622 C 626 396.124, 628.134 393.346, 629.956 394.473 C 630.530 394.828, 631 396.891, 631 399.059 C 631 401.227, 631.450 403, 632 403 C 632.550 403, 633 400.991, 633 398.535 C 633 393.823, 630.795 391.374, 627.642 392.584 C 626.531 393.010, 626.055 392.331, 625.819 389.985 C 625.644 388.238, 625.163 387.152, 624.750 387.571 M 648.667 387.667 C 647.583 388.750, 647.893 403, 649 403 C 649.583 403, 650 399.667, 650 395 C 650 386.976, 649.901 386.432, 648.667 387.667 M 584 395.500 C 584 403.453, 585.673 405.933, 586.193 398.750 C 586.408 395.776, 586.950 394.500, 588 394.500 C 589.050 394.500, 589.592 395.776, 589.807 398.750 C 590.233 404.628, 592 404.110, 592 398.107 C 592 393.059, 590.657 391.427, 587.500 392.638 C 586.403 393.059, 586 392.513, 586 390.607 C 586 389.173, 585.550 388, 585 388 C 584.422 388, 584 391.167, 584 395.500 M 659 390.406 C 659 392.256, 658.572 392.701, 657.149 392.329 C 654.628 391.669, 652 394.538, 652 397.949 C 652 401.604, 653.794 402.984, 658.324 402.814 L 662 402.676 662 395.338 C 662 389.482, 661.697 388, 660.500 388 C 659.582 388, 659 388.934, 659 390.406 M 575.614 393.529 C 573.778 395.365, 574.468 397.696, 577.092 398.529 C 579.829 399.398, 579.445 401, 576.500 401 C 575.125 401, 574 401.479, 574 402.063 C 574 402.661, 575.424 402.989, 577.250 402.813 C 581.239 402.429, 582.374 398.806, 579.061 397.032 C 576.420 395.619, 576.375 393.603, 579 394.290 C 581.362 394.907, 581.714 393.488, 579.418 392.607 C 577.304 391.796, 577.361 391.782, 575.614 393.529 M 595.667 392.667 C 594.232 394.101, 595.116 395.009, 597.391 394.438 C 598.706 394.108, 600.082 394.324, 600.450 394.919 C 600.817 395.514, 600.466 396, 599.670 396 C 598.873 396, 597.174 396.848, 595.893 397.885 C 593.919 399.484, 593.765 400.012, 594.877 401.351 C 595.654 402.288, 597.577 402.880, 599.594 402.804 C 602.921 402.679, 603 402.576, 603 398.373 C 603 395.143, 602.518 393.812, 601.066 393.035 C 598.849 391.849, 596.635 391.698, 595.667 392.667 M 606 397.704 C 606 400.617, 606.450 403, 607 403 C 607.550 403, 608 401.480, 608 399.622 C 608 396.210, 610.015 393.393, 611.479 394.759 C 611.916 395.166, 612.062 394.825, 611.804 394 C 611.545 393.175, 610.134 392.479, 608.667 392.454 C 606.108 392.409, 606 392.621, 606 397.704 M 614.750 393.080 C 612.713 394.266, 612.355 399.955, 614.200 401.800 C 615.620 403.220, 620.633 403.403, 621.460 402.065 C 621.778 401.550, 620.602 400.988, 618.846 400.815 C 614.248 400.361, 613.888 398, 618.417 398 C 621.312 398, 622 397.623, 622 396.035 C 622 394.955, 621.130 393.605, 620.066 393.035 C 617.702 391.770, 616.988 391.776, 614.750 393.080 M 637 394 C 634.767 396.233, 634.499 398.195, 636.035 401.066 C 637.208 403.258, 641.899 403.701, 643.800 401.800 C 645.754 399.846, 645.283 394.222, 643.066 393.035 C 640.318 391.565, 639.269 391.731, 637 394 M 665.750 393.080 C 663.713 394.266, 663.355 399.955, 665.200 401.800 C 666.620 403.220, 671.633 403.403, 672.460 402.065 C 672.778 401.550, 671.602 400.988, 669.846 400.815 C 665.248 400.361, 664.888 398, 669.417 398 C 672.312 398, 673 397.623, 673 396.035 C 673 394.955, 672.130 393.605, 671.066 393.035 C 668.702 391.770, 667.988 391.776, 665.750 393.080 M 675.573 392.953 C 675.412 393.254, 675.213 395.637, 675.132 398.250 C 675.021 401.802, 675.350 403, 676.434 403 C 677.426 403, 677.982 401.657, 678.193 398.759 C 678.531 394.084, 681.302 392.225, 682.466 395.892 C 682.816 396.995, 683.979 398.176, 685.051 398.516 C 687.822 399.396, 687.466 401, 684.500 401 C 683.125 401, 682 401.479, 682 402.063 C 682 402.661, 683.424 402.989, 685.250 402.813 C 689.561 402.398, 690.421 398.605, 686.600 396.863 C 683.731 395.557, 684.139 393.592, 687.084 394.527 C 688.138 394.861, 689 394.703, 689 394.174 C 689 392.645, 686.022 391.918, 684.059 392.968 C 683.071 393.497, 681.941 393.608, 681.549 393.215 C 680.703 392.369, 675.998 392.163, 675.573 392.953 M 615.500 395 C 615.148 395.569, 616.009 396, 617.500 396 C 618.991 396, 619.852 395.569, 619.500 395 C 619.160 394.450, 618.260 394, 617.500 394 C 616.740 394, 615.840 394.450, 615.500 395 M 638.040 395.452 C 636.413 397.412, 637.686 401, 640.008 401 C 642.464 401, 643.332 399.459, 642.575 396.443 C 641.888 393.705, 639.858 393.262, 638.040 395.452 M 655.130 396.166 C 654.023 399.146, 654.794 401.186, 656.876 400.785 C 657.930 400.582, 658.500 399.454, 658.500 397.570 C 658.500 393.951, 656.295 393.033, 655.130 396.166 M 666.500 395 C 666.148 395.569, 667.009 396, 668.500 396 C 669.991 396, 670.852 395.569, 670.500 395 C 670.160 394.450, 669.260 394, 668.500 394 C 667.740 394, 666.840 394.450, 666.500 395 M 597.459 399.067 C 597.096 399.653, 597.050 400.384, 597.357 400.690 C 598.179 401.513, 601 400.229, 601 399.031 C 601 397.674, 598.303 397.701, 597.459 399.067 M 626.174 416.314 C 623.429 419.237, 623.452 419.646, 626.407 420.387 C 627.731 420.720, 629.492 421.251, 630.319 421.569 C 631.607 422.063, 631.675 421.558, 630.791 418.073 C 630.222 415.833, 629.440 414, 629.053 414 C 628.665 414, 627.370 415.042, 626.174 416.314 M 624 429.610 C 620.425 430.878, 602.200 437.370, 583.500 444.037 C 564.800 450.703, 534.200 461.572, 515.500 468.190 C 479.084 481.078, 462.965 486.808, 440 495.025 C 432.025 497.879, 423.025 501.030, 420 502.028 C 416.975 503.026, 405.050 507.300, 393.500 511.526 C 381.950 515.751, 371.600 519.458, 370.500 519.763 C 369.400 520.068, 354.775 525.237, 338 531.251 C 321.225 537.264, 306.150 542.648, 304.500 543.216 C 297.462 545.635, 218.529 573.661, 192.169 583.099 L 172.838 590.021 169.931 587.951 C 164.829 584.318, 152.367 579.054, 144.816 577.341 C 134.040 574.898, 113.796 575.126, 103.864 577.802 C 83.995 583.157, 68.121 595.356, 60.670 611 C 56.687 619.363, 55.737 632.616, 58.511 641.146 C 62.999 654.949, 73.263 666.096, 88.272 673.466 C 102.359 680.384, 107.746 681.509, 126.500 681.449 C 141.965 681.399, 142.829 681.285, 152.333 678.045 C 172.620 671.128, 187.274 657.784, 192.127 641.808 C 195.066 632.131, 194.498 619.906, 190.728 611.698 C 187.811 605.348, 185.931 602.682, 179.805 596.211 C 177.572 593.852, 175.915 591.791, 176.123 591.631 C 176.330 591.470, 180.100 590.087, 184.500 588.556 C 188.900 587.026, 205.775 581.047, 222 575.270 C 257.666 562.570, 274.699 556.519, 294.500 549.513 C 317.627 541.330, 339.212 533.654, 353.500 528.530 C 360.650 525.966, 371.450 522.144, 377.500 520.037 C 383.550 517.929, 404.475 510.491, 424 503.508 C 443.525 496.524, 464.450 489.097, 470.500 487.003 C 476.550 484.909, 494.325 478.611, 510 473.007 C 525.675 467.403, 545.250 460.433, 553.500 457.517 C 561.750 454.602, 571.650 451.092, 575.500 449.718 C 579.350 448.344, 593.502 443.330, 606.949 438.577 C 620.396 433.824, 631.616 429.717, 631.883 429.451 C 632.149 429.184, 631.947 428.592, 631.433 428.135 C 630.920 427.677, 627.575 428.341, 624 429.610 M 635.245 429.236 C 635.472 429.916, 640.347 432.131, 646.079 434.158 C 655.190 437.380, 675.506 444.615, 727 462.975 C 734.425 465.623, 763.450 475.963, 791.500 485.954 C 819.550 495.945, 844.975 505.034, 848 506.152 C 851.025 507.271, 870.375 514.180, 891 521.507 C 911.625 528.833, 930.975 535.739, 934 536.853 C 941.079 539.460, 1039.276 574.474, 1048.500 577.680 C 1060.795 581.954, 1086.486 591.278, 1086.882 591.610 C 1087.092 591.786, 1084.930 594.484, 1082.078 597.605 C 1059.265 622.566, 1067.610 657.324, 1100.268 673.363 C 1114.534 680.369, 1119.802 681.482, 1138.500 681.435 C 1153.251 681.399, 1155.164 681.178, 1163 678.607 C 1167.675 677.073, 1174.366 674.232, 1177.868 672.294 C 1186.505 667.514, 1198.660 655.884, 1199.978 651.138 C 1201.198 646.747, 1201.357 603.661, 1200.151 604.407 C 1199.684 604.696, 1198.684 603.779, 1197.930 602.369 C 1197.176 600.960, 1194.037 597.488, 1190.956 594.653 C 1167.153 572.759, 1126.388 568.963, 1096.887 585.893 C 1090.668 589.462, 1090.073 589.612, 1086.887 588.418 C 1085.024 587.719, 1075.625 584.375, 1066 580.986 C 1056.375 577.597, 994.500 555.553, 928.500 531.999 C 862.500 508.445, 795.225 484.448, 779 478.672 C 762.775 472.896, 743.875 466.140, 737 463.658 C 699.434 450.098, 636.762 428, 635.868 428 C 635.299 428, 635.019 428.556, 635.245 429.236 M 560.838 561.902 C 560.489 565.560, 560.676 565.937, 562.969 566.206 C 564.416 566.375, 565.624 567.243, 565.815 568.250 C 566.073 569.609, 565.460 570, 563.073 570 C 559.872 570, 558.897 571.639, 561.502 572.639 C 563.888 573.555, 567.846 572.156, 569.006 569.988 C 570.505 567.189, 568.619 564, 565.465 564 C 562.024 564, 562.273 561.216, 565.750 560.816 C 569.737 560.358, 569.124 558.552, 564.860 558.196 C 561.282 557.898, 561.214 557.960, 560.838 561.902 M 578 559.500 C 578 560.494, 578.994 561, 580.945 561 L 583.890 561 581.445 566.529 C 578.556 573.060, 578.565 573, 580.555 573 C 582.227 573, 587 563.352, 587 559.971 C 587 558.302, 586.312 558, 582.500 558 C 579.167 558, 578 558.389, 578 559.500 M 595 565.500 C 595 571.500, 595.300 573, 596.500 573 C 597.615 573, 598.014 571.781, 598.056 568.250 L 598.112 563.500 599.936 568 C 600.939 570.475, 602.363 572.500, 603.101 572.500 C 603.839 572.500, 605.219 570.475, 606.167 568 L 607.891 563.500 607.946 568.250 C 608.023 574.999, 610.574 574.783, 611.229 567.972 C 611.936 560.609, 611.202 557.828, 608.648 558.197 C 607.193 558.407, 606.046 559.865, 604.909 562.949 L 603.270 567.399 601.191 562.699 C 599.687 559.298, 598.545 558, 597.056 558 C 595.164 558, 595 558.598, 595 565.500 M 625 559.500 C 625 560.325, 625.675 561, 626.500 561 C 627.325 561, 628 560.325, 628 559.500 C 628 558.675, 627.325 558, 626.500 558 C 625.675 558, 625 558.675, 625 559.500 M 656.544 559.344 C 654.069 561.154, 655.139 565.286, 658.476 566.807 C 662.034 568.428, 661.703 570.330, 657.959 569.781 C 655.584 569.432, 654.984 569.681, 655.219 570.917 C 655.598 572.906, 659.229 573.483, 662.008 571.996 C 665.053 570.366, 664.333 565.912, 660.750 564.203 C 657.307 562.560, 657.142 560.603, 660.500 561.245 C 663.300 561.780, 664.052 559.618, 661.418 558.607 C 659.174 557.746, 658.614 557.831, 656.544 559.344 M 666.044 560.918 C 664.996 562.877, 665.569 568.105, 667.176 571.250 C 668.268 573.387, 672 573.581, 672 571.500 C 672 570.675, 671.550 570, 671 570 C 670.450 570, 670 568.875, 670 567.500 C 670 566.125, 670.450 565, 671 565 C 672.709 565, 672.101 562.822, 669.847 560.867 C 667.205 558.576, 667.298 558.575, 666.044 560.918 M 614.667 562.667 C 613.281 564.053, 614.095 565.003, 616.750 565.100 C 619.437 565.197, 619.445 565.215, 617.095 565.872 C 615.772 566.243, 614.197 567.349, 613.595 568.331 C 612.126 570.727, 614.890 572.800, 619.554 572.800 C 622.956 572.800, 623 572.744, 623 568.435 C 623 565.143, 622.525 563.816, 621.066 563.035 C 618.869 561.860, 615.658 561.675, 614.667 562.667 M 625 568 C 625 571.333, 624.556 574, 624 574 C 623.450 574, 623 574.675, 623 575.500 C 623 576.325, 623.585 577, 624.300 577 C 626.934 577, 628 574.494, 628 568.300 C 628 563.367, 627.675 562, 626.500 562 C 625.333 562, 625 563.333, 625 568 M 631.655 563.829 C 629.310 566.420, 629.538 570.682, 632.093 572.050 C 637.346 574.861, 642.809 569.410, 639.619 564.541 C 637.645 561.528, 634.029 561.205, 631.655 563.829 M 642.343 563.550 C 642.081 564.232, 642.009 566.490, 642.183 568.568 C 642.575 573.239, 645 574.551, 645 570.092 C 645 568.100, 645.704 566.577, 647 565.768 C 648.100 565.081, 649 563.982, 649 563.326 C 649 561.740, 642.959 561.943, 642.343 563.550 M 674.750 563.080 C 672.187 564.573, 672.390 570.603, 675.052 572.028 C 677.559 573.370, 681.196 572.948, 681.755 571.250 C 682.025 570.431, 681.103 570, 679.083 570 C 677.388 570, 676 569.550, 676 569 C 676 568.450, 677.575 568, 679.500 568 C 683.359 568, 684.117 566.259, 681.429 563.571 C 679.634 561.776, 677.285 561.604, 674.750 563.080 M 684.360 563.504 C 683.377 566.065, 684.505 576.344, 685.816 576.776 C 686.540 577.015, 687.380 576.263, 687.683 575.105 C 687.994 573.917, 689.043 573, 690.094 573 C 692.761 573, 695.236 568.787, 694.437 565.606 C 693.705 562.688, 693.914 562.801, 688.664 562.502 C 686.387 562.373, 684.638 562.780, 684.360 563.504 M 697.238 563.162 C 695.413 564.987, 695.721 566.561, 698.250 568.326 L 700.500 569.895 698.250 569.948 C 697.013 569.976, 696 570.423, 696 570.941 C 696 572.513, 697.978 573.222, 700.557 572.575 C 703.782 571.766, 703.905 567.742, 700.750 566.220 L 698.500 565.135 700.833 565.068 C 702.233 565.027, 703.002 564.500, 702.755 563.750 C 702.187 562.026, 698.742 561.658, 697.238 563.162 M 633.380 566.452 C 632.668 568.308, 633.707 570, 635.559 570 C 636.429 570, 637 569.010, 637 567.500 C 637 564.752, 634.329 563.979, 633.380 566.452 M 676.813 565.683 C 677.534 565.972, 678.397 565.936, 678.729 565.604 C 679.061 565.272, 678.471 565.036, 677.417 565.079 C 676.252 565.127, 676.015 565.364, 676.813 565.683 M 688 567.500 C 688 569.056, 688.567 570, 689.500 570 C 690.433 570, 691 569.056, 691 567.500 C 691 565.944, 690.433 565, 689.500 565 C 688.567 565, 688 565.944, 688 567.500 M 571 567 C 571 567.550, 572.350 568, 574 568 C 575.650 568, 577 567.550, 577 567 C 577 566.450, 575.650 566, 574 566 C 572.350 566, 571 566.450, 571 567 M 616.500 569 C 616.160 569.550, 616.610 570, 617.500 570 C 618.390 570, 618.840 569.550, 618.500 569 C 618.160 568.450, 617.710 568, 617.500 568 C 617.290 568, 616.840 568.450, 616.500 569 M 274 642.500 L 274 682 327 682 L 380 682 380 662.500 L 380 643 398.500 643 C 414.278 643, 417 643.221, 417 644.500 C 417 645.325, 417.210 646, 417.466 646 C 418.550 646, 425 642.576, 425 642 C 425 641.424, 418.550 638, 417.466 638 C 417.210 638, 417 638.675, 417 639.500 C 417 640.779, 414.278 641, 398.500 641 L 380 641 380 622 L 380 603 327 603 L 274 603 274 642.500 M 426 642.500 L 426 682 479.500 682 L 533 682 533 662.500 L 533 643 550.500 643 C 565.389 643, 568 643.224, 568 644.500 C 568 645.325, 568.435 646, 568.966 646 C 570.418 646, 577 642.723, 577 642 C 577 641.654, 575.333 640.576, 573.296 639.604 C 569.934 638.001, 569.485 637.984, 568.436 639.419 C 567.459 640.754, 564.612 641, 550.140 641 L 533 641 533 622 L 533 603 479.500 603 L 426 603 426 642.500 M 578.749 642.250 L 578.999 681.500 631.999 681.759 L 685 682.018 685 662.509 L 685 643 703 643 C 718.333 643, 721 643.222, 721 644.500 C 721 645.325, 721.210 646, 721.466 646 C 722.550 646, 729 642.576, 729 642 C 729 641.424, 722.550 638, 721.466 638 C 721.210 638, 721 638.675, 721 639.500 C 721 640.778, 718.333 641, 703 641 L 685 641 685 622 L 685 603 631.750 603 L 578.500 602.999 578.749 642.250 M 731 642.500 L 731 682 784 682 L 837 682 837 662.500 L 837 643 856 643 C 872.222 643, 875 643.219, 875 644.500 C 875 645.325, 875.210 646, 875.466 646 C 876.550 646, 883 642.576, 883 642 C 883 641.424, 876.550 638, 875.466 638 C 875.210 638, 875 638.675, 875 639.500 C 875 640.781, 872.222 641, 856 641 L 837 641 837 622 L 837 603 784 603 L 731 603 731 642.500 M 884 642.500 L 884 682 937 682 L 990 682 990 662.500 L 990 643 1013.500 643 C 1033.722 643, 1037 643.209, 1037 644.500 C 1037 645.325, 1037.210 646, 1037.466 646 C 1038.550 646, 1045 642.576, 1045 642 C 1045 641.424, 1038.550 638, 1037.466 638 C 1037.210 638, 1037 638.675, 1037 639.500 C 1037 640.791, 1033.722 641, 1013.500 641 L 990 641 990 622 L 990 603 937 603 L 884 603 884 642.500 M 1.106 627.500 L 1.169 649.500 3.208 645.054 C 7.962 634.687, 7.902 620.617, 3.057 609.939 L 1.044 605.500 1.106 627.500 M 103.853 620.670 C 99.898 621.720, 101.105 628.329, 105.561 630.023 C 108.143 631.005, 108.851 633.534, 106.750 634.273 C 106.063 634.515, 104.454 634.326, 103.176 633.853 C 101.257 633.143, 100.910 633.299, 101.184 634.747 C 101.588 636.879, 107.433 637.715, 109.565 635.946 C 112.147 633.803, 111.330 629.308, 108 627.341 C 106.350 626.366, 105 624.955, 105 624.205 C 105 623.210, 105.811 623.019, 108 623.500 C 111.125 624.186, 111.855 623.255, 109.800 621.200 C 108.598 619.998, 106.937 619.850, 103.853 620.670 M 1152.820 622.250 C 1152.577 623.960, 1151.946 624.423, 1150.190 624.177 C 1146.677 623.686, 1145 625.729, 1145 630.500 C 1145 635.687, 1146.546 637.145, 1151.634 636.758 L 1155.500 636.464 1155.790 628.232 C 1156.027 621.522, 1155.809 620, 1154.610 620 C 1153.801 620, 1152.995 621.013, 1152.820 622.250 M 1120 629 L 1120 637 1124.500 637 C 1129.620 637, 1131.065 634.370, 1126.250 633.816 C 1122.824 633.422, 1122.601 630.802, 1125.926 630.018 C 1129.355 629.208, 1129.644 627.206, 1126.386 626.822 C 1122.450 626.358, 1122.058 624, 1125.917 624 C 1127.991 624, 1129 623.509, 1129 622.500 C 1129 621.389, 1127.833 621, 1124.500 621 L 1120 621 1120 629 M 114 623.417 C 114 624.196, 113.438 625.023, 112.750 625.254 C 111.786 625.578, 111.769 626.001, 112.675 627.100 C 113.322 627.884, 113.997 630.320, 114.175 632.513 C 114.461 636.024, 114.829 636.538, 117.250 636.816 C 119.214 637.042, 120 636.685, 120 635.566 C 120 634.705, 119.325 634, 118.500 634 C 116.430 634, 116.546 629.052, 118.652 627.512 C 120.164 626.407, 120.122 626.122, 118.152 624.152 C 115.672 621.672, 114 621.376, 114 623.417 M 143.599 623.604 C 143.245 624.526, 142.344 624.962, 141.481 624.631 C 140.654 624.314, 138.633 624.323, 136.989 624.652 C 134.077 625.235, 134 625.402, 134 631.125 C 134 635.681, 134.337 637, 135.500 637 C 136.507 637, 137 635.993, 137 633.934 C 137 629.820, 138.641 627, 141.035 627 C 142.561 627, 143 627.685, 143 630.066 C 143 634.147, 144.636 637, 146.976 637 C 149.459 637, 150.577 635.159, 148.563 634.386 C 146.446 633.573, 146.389 627, 148.500 627 C 149.325 627, 150 626.550, 150 626 C 150 625.450, 149.325 625, 148.500 625 C 147.675 625, 147 624.325, 147 623.500 C 147 621.497, 144.376 621.577, 143.599 623.604 M 122.667 624.667 C 120.861 626.472, 122.124 627.925, 125 627.350 C 129.040 626.542, 128.837 628.340, 124.752 629.543 C 118.341 631.432, 120.470 637.249, 127.393 636.761 L 131.500 636.471 131.207 631.537 C 131.046 628.822, 130.429 626.016, 129.835 625.301 C 128.708 623.944, 123.822 623.511, 122.667 624.667 M 1134.250 624.706 C 1132.218 625.097, 1132 625.715, 1132 631.070 C 1132 635.674, 1132.335 637, 1133.500 637 C 1134.606 637, 1135 635.845, 1135 632.607 C 1135 628.678, 1136.055 627, 1138.527 627 C 1138.727 627, 1139.028 629.138, 1139.195 631.750 C 1139.415 635.170, 1139.920 636.500, 1141 636.500 C 1142.118 636.500, 1142.488 635.354, 1142.453 632 C 1142.371 624.159, 1141.430 623.323, 1134.250 624.706 M 1148.667 627.667 C 1148.300 628.033, 1148 629.608, 1148 631.167 C 1148 633.305, 1148.476 634, 1149.941 634 C 1152.573 634, 1153.204 632.667, 1152.032 629.584 C 1151.057 627.019, 1149.947 626.387, 1148.667 627.667 M 125.029 631.961 C 124.220 632.473, 123.863 633.196, 124.236 633.569 C 125.151 634.484, 128 633.320, 128 632.031 C 128 630.761, 126.965 630.737, 125.029 631.961 M 265 639.500 C 265 640.790, 261.778 641, 242 641 C 227.333 641, 219 641.362, 219 642 C 219 642.638, 227.333 643, 242 643 C 261.778 643, 265 643.210, 265 644.500 C 265 645.325, 265.210 646, 265.466 646 C 266.550 646, 273 642.576, 273 642 C 273 641.424, 266.550 638, 265.466 638 C 265.210 638, 265 638.675, 265 639.500 M 1.762 736.707 C 3.006 736.946, 4.806 736.937, 5.762 736.687 C 6.718 736.437, 5.700 736.241, 3.500 736.252 C 1.300 736.263, 0.518 736.468, 1.762 736.707 M 12.750 736.737 C 15.638 736.939, 20.363 736.939, 23.250 736.737 C 26.138 736.535, 23.775 736.370, 18 736.370 C 12.225 736.370, 9.863 736.535, 12.750 736.737`;
console.log("subpaths are", (0, _utilsJsDefault.default).splitPath(largePath));

},{"./index.js":"8lqZg","./plugins/node/attempt.js":"c8dkR","./plugins/slate/second.js":"evEf8","./helpers/utils.js":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8lqZg":[function(require,module,exports) {
/* eslint-disable import/prefer-default-export */ /* eslint-disable import/no-cycle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Slatebox", ()=>Slatebox);
var _slate = require("./core/slate");
var _slateDefault = parcelHelpers.interopDefault(_slate);
var _node = require("./core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
var _base = require("./core/base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _utils = require("./helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
const Slatebox = {
    slate: (0, _slateDefault.default),
    node: (0, _nodeDefault.default),
    base: (0, _baseDefault.default),
    utils: (0, _utilsDefault.default)
};

},{"./core/slate":"khicH","./core/node":"bAVQb","./core/base":"cmkOb","./helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"khicH":[function(require,module,exports) {
/* eslint-disable no-template-curly-in-string */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ /* eslint-disable no-unused-expressions */ /* eslint-disable new-cap */ /* eslint-disable import/no-cycle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _deepmerge = require("deepmerge");
var _deepmergeDefault = parcelHelpers.interopDefault(_deepmerge);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _canvas = require("../slate/canvas");
var _canvasDefault = parcelHelpers.interopDefault(_canvas);
var _collab = require("../slate/collab");
var _collabDefault = parcelHelpers.interopDefault(_collab);
var _nodeController = require("../slate/nodeController");
var _nodeControllerDefault = parcelHelpers.interopDefault(_nodeController);
var _multiSelection = require("../slate/multiSelection");
var _multiSelectionDefault = parcelHelpers.interopDefault(_multiSelection);
var _birdsEye = require("../slate/birdsEye");
var _birdsEyeDefault = parcelHelpers.interopDefault(_birdsEye);
var _inertia = require("../slate/inertia");
var _inertiaDefault = parcelHelpers.interopDefault(_inertia);
var _controller = require("../slate/controller");
var _controllerDefault = parcelHelpers.interopDefault(_controller);
var _zoomSlider = require("../slate/zoomSlider");
var _zoomSliderDefault = parcelHelpers.interopDefault(_zoomSlider);
var _undoRedo = require("../slate/undoRedo");
var _undoRedoDefault = parcelHelpers.interopDefault(_undoRedo);
var _grid = require("../slate/grid");
var _gridDefault = parcelHelpers.interopDefault(_grid);
var _comments = require("../slate/comments");
var _commentsDefault = parcelHelpers.interopDefault(_comments);
var _keyboard = require("../slate/keyboard");
var _keyboardDefault = parcelHelpers.interopDefault(_keyboard);
var _filters = require("../slate/filters");
var _filtersDefault = parcelHelpers.interopDefault(_filters);
var _base = require("./base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _node = require("./node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class slate extends (0, _baseDefault.default) {
    constructor(_options, events){
        super(_options);
        this.options = {
            id: _options.id || (0, _utilsDefault.default).guid(),
            container: "",
            name: "",
            description: "",
            basedOnThemeId: "",
            syncWithTheme: false,
            tags: [],
            templateMarkdown: "",
            containerStyle: {
                backgroundColor: "transparent",
                backgroundImage: "",
                backgroundSize: "",
                backgroundEffect: "",
                backgroundColorAsGradient: null,
                backgroundGradientType: null,
                backgroundGradientColors: [],
                backgroundGradientStrategy: null
            },
            viewPort: {
                useInertiaScrolling: true,
                showGrid: false,
                snapToObjects: true,
                gridSize: 50,
                width: 50000,
                height: 50000,
                left: 5000,
                top: 5000
            },
            enabled: true,
            allowDrag: true,
            showbirdsEye: true,
            sizeOfbirdsEye: 200,
            showMultiSelect: true,
            showZoom: true,
            showUndoRedo: true,
            showStatus: true,
            showLocks: true,
            mindMapMode: true,
            isPublic: true,
            isUnlisted: false,
            autoEnableDefaultFilters: true,
            autoResizeNodesBasedOnText: true,
            disableAutoLayoutOfManuallyPositionedNodes: false,
            followMe: false,
            useLayoutQuandrants: false,
            huddleType: "disabled",
            allowCollaboration: true
        };
        this.options = (0, _deepmergeDefault.default)(this.options, _options);
        this.events = events || {
            onNodeDragged: null,
            onCanvasClicked: null,
            onImagesRequested: null,
            onRequestSave: null,
            onInitCollaboration: null,
            isReadOnly: null
        };
        // console.log("SLATE - share details are", this.options.shareId, this.options.userId, this.options.orgId);
        // ensure container is always an object
        if (!(0, _utilsDefault.default).isElement(this.options.container)) this.options.container = (0, _utilsDefault.default).el(this.options.container);
        this.constants = {
            statusPanelAtRest: 33,
            statusPanelExpanded: 200
        };
        this.glows = [];
        this.tips = [];
        this.tempNodeId = (0, _utilsDefault.default).guid();
        this.allLines = [];
        this.candidatesForSelection = {};
    }
    prep() {
        const self = this;
        // instantiate all the dependencies for the slate -- order here is importantish
        // (birdsEye, undoRedo, zoomSlider are used in canvas, and inertia uses canvas)
        self.nodes = new (0, _nodeControllerDefault.default)(self);
        self.collab = new (0, _collabDefault.default)(self);
        self.birdsEye = new (0, _birdsEyeDefault.default)(self);
        self.zoomSlider = new (0, _zoomSliderDefault.default)(self);
        if (!self.isReadOnly() && !self.isCommentOnly()) {
            self.undoRedo = new (0, _undoRedoDefault.default)(self);
            self.multiSelection = new (0, _multiSelectionDefault.default)(self);
        }
        self.controller = new (0, _controllerDefault.default)(self);
        self.filters = new (0, _filtersDefault.default)(self);
        self.canvas = new (0, _canvasDefault.default)(self);
        self.canvas.init();
        self.inertia = new (0, _inertiaDefault.default)(self);
        self.grid = new (0, _gridDefault.default)(self);
        self.comments = new (0, _commentsDefault.default)(self);
        self.keyboard = new (0, _keyboardDefault.default)(self);
        self.autoLoadFilters();
        if (self.options.onInitCompleted) self.options.onInitCompleted.apply(self);
    }
    initPlain() {
        const self = this;
        self.prep();
        return self;
    }
    async init() {
        const self = this;
        self.prep();
        if (self.multiSelection) await self.multiSelection.init();
        if (self.options.allowCollaboration ?? true) setTimeout(async ()=>{
            await self.collab.init();
        }, 100);
        return self;
    }
    url(opt) {
        return this.options.ajax.rootUrl + this.options.ajax.urlFlavor + opt;
    }
    glow(obj) {
        this.glows.push(obj.glow());
    }
    cursor(obj) {
        const self = this;
        const c = self.options.container;
        const ele = self.canvas.internal;
        if (!self.cursors) {
            self.offsetsForCursor = {
                container: (0, _utilsDefault.default).positionedOffset(c),
                canvas: (0, _utilsDefault.default).positionedOffset(ele)
            };
            self.cursorTimeouts = {};
            self.cursors = {};
            // create observer
            const observer = new MutationObserver(()=>{
                self.offsetsForCursor.canvas = (0, _utilsDefault.default).positionedOffset(ele);
            });
            observer.observe(ele, {
                attributes: true,
                childList: false,
                subtree: false
            });
        }
        if (!self.cursors[obj.clientID]) {
            const pos = document.createElement("div");
            pos.setAttribute("class", "slateCursor");
            pos.style.position = "absolute";
            pos.style.padding = "0px";
            pos.style.margin = "0px;";
            pos.style.display = "block";
            pos.style["user-select"] = "none";
            pos.style.zIndex = "0";
            const flex = document.createElement("div");
            flex.style.display = "flex";
            flex.style.padding = 0;
            flex.style.margin = 0;
            const dot = document.createElement("div");
            dot.innerHTML = `
        <svg width="30px" height="30px" viewBox="-2.4 -2.4 28.80 28.80" role="img" xmlns="http://www.w3.org/2000/svg" stroke="${obj.color}" stroke-width="2.4" stroke-linecap="square" stroke-linejoin="miter" fill="${obj.color}" color="${obj.color}" transform="matrix(1, 0, 0, 1, 0, 0)"><g><polygon points="7 20 7 4 19 16 12 16 7 21"></polygon> </g></svg>`;
            // dot.style.backgroundColor = obj.color || '#000'
            flex.appendChild(dot);
            const txt = document.createElement("div");
            txt.style.fontSize = "11pt";
            txt.style.height = "25px";
            txt.style.whiteSpace = "nowrap";
            txt.style.backgroundColor = "#fff";
            txt.style.padding = "1px 7px 1px 7px";
            txt.style.border = "1px solid #000";
            txt.style.borderRadius = "5px";
            txt.style.fontFamily = "trebuchet ms";
            txt.innerHTML = `${obj.userName || "Guest"}`;
            flex.appendChild(txt);
            pos.appendChild(flex);
            self.cursors[obj.clientID] = pos;
            c.appendChild(pos);
        }
        const multiplier = self.options.viewPort.zoom.r / obj.currentZoom;
        const top = obj.y * multiplier + obj.top * multiplier - Math.abs(self.offsetsForCursor.canvas?.top || 0) - self.offsetsForCursor.container?.top || 0;
        const left = obj.x * multiplier + obj.left * multiplier - Math.abs(self.offsetsForCursor.canvas?.left || 0) - self.offsetsForCursor.container?.left || 0;
        self.cursors[obj.clientID].style.top = `${top}px`;
        self.cursors[obj.clientID].style.left = `${left}px`;
        // expire after 10 of no activity
        clearTimeout(self.cursorTimeouts[obj.clientID]);
        self.cursorTimeouts[obj.clientID] = setTimeout(()=>{
            c.removeChild(self.cursors[obj.clientID]);
            delete self.cursors[obj.clientID];
        }, 2000);
    }
    unglow() {
        this.glows.forEach((glow)=>{
            glow.remove();
        });
        this.glows = [];
    }
    addtip(tip) {
        if (tip) this.tips.push(tip);
    }
    untooltip() {
        this.tips.forEach((tip)=>{
            tip && tip.remove();
        });
    }
    toggleFilters(blnHide, nodeId, esc) {
        // hide filters during dragging
        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile()) {
            if (this.nodes.allNodes.length > 20) {
                this.nodes.allNodes.forEach((n)=>{
                    if (!nodeId || n.options.id === nodeId) n.toggleFilters(blnHide);
                });
                this.allLines.filter((l)=>l.lineEffect).forEach((c)=>{
                    if (blnHide) c.line.attr("filter", "");
                    else c.line.attr("filter", `url(#${c.lineEffect})`);
                });
                if (blnHide) this.canvas.hideBg();
                if (esc) setTimeout(()=>{
                    this.toggleFilters(!blnHide);
                    this.canvas.hideBg(1);
                }, 500);
            }
        }
    }
    removeContextMenus() {
        const _cm = (0, _utilsDefault.default).select("div.sb_cm");
        _cm.forEach((elem)=>{
            document.body.removeChild(elem);
        });
    }
    remove() {
        this.nodes.allNodes.forEach((nn)=>{
            nn.del();
        });
        this.paper.remove();
    // delete self;
    }
    zoom(x, y, w, h, fit) {
        this.nodes.closeAllLineOptions();
        this.paper.setViewBox(x, y, w, h, fit);
    }
    png(ropts, cb) {
        const self = this;
        self.svg({
            useDataImageUrls: true,
            backgroundOnly: ropts?.backgroundOnly
        }, (opts)=>{
            function makeTransparent(ctx, alpha, cnvs) {
                // get the image data object
                const imageData = ctx.getImageData(0, 0, cnvs.width, cnvs.height);
                const data = imageData.data;
                // if it is a background defined of #f3f3f3 then it can be transparent here
                for(let ix = 3; ix < data.length; ix += 4){
                    const isBg = [
                        data[ix - 3],
                        data[ix - 2],
                        data[ix - 1]
                    ].every((v)=>v === 243);
                    // console.log('isBg', alpha, isBg, data[ix - 3])
                    if ([
                        data[ix - 3],
                        data[ix - 2],
                        data[ix - 1]
                    ].every((v)=>v === 243)) data[ix] = alpha;
                }
                // and put the imagedata back to the canvas
                ctx.putImageData(imageData, 0, 0);
            }
            if (self.events.onCreateImage) self.events.onCreateImage({
                svg: opts.svg,
                orient: opts.orient,
                type: "png"
            }, (err, base64)=>{
                if (err) console.error("Unable to create png server side", svg, err);
                else if (ropts?.base64) cb(base64);
                else {
                    const img = new Image();
                    img.src = base64;
                    img.onload = ()=>{
                        const cnvs = document.createElement("canvas");
                        cnvs.width = img.naturalWidth;
                        cnvs.height = img.naturalHeight;
                        const ctx = cnvs.getContext("2d");
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0);
                        if (ropts?.alpha != null) makeTransparent(ctx, ropts.alpha, cnvs);
                        const link = document.createElement("a");
                        link.setAttribute("download", `${(self.options.name || "slate").replace(/[^a-z0-9]/gi, "_").toLowerCase()}_${self.options.id}.png`);
                        cnvs.toBlob((blob)=>{
                            link.href = URL.createObjectURL(blob);
                            const event = new MouseEvent("click");
                            link.dispatchEvent(event);
                            cb && cb();
                        });
                    };
                }
            });
            else {
                const cnvs = document.createElement("canvas");
                cnvs.width = opts.orient.width;
                cnvs.height = opts.orient.height;
                const blb = new Blob([
                    opts.svg
                ], {
                    type: "image/svg+xml;charset=utf8"
                });
                const url = URL.createObjectURL(blb);
                const ctx = cnvs.getContext("2d");
                const img = document.createElement("img");
                img.src = url;
                img.onload = ()=>{
                    ctx.drawImage(img, 0, 0);
                    if (ropts?.alpha != null) makeTransparent(ctx, ropts.alpha, cnvs);
                    const imgsrc = cnvs.toDataURL("image/png");
                    if (ropts?.base64) {
                        cb(imgsrc);
                        URL.revokeObjectURL(img.src);
                    } else {
                        const a = document.createElement("a");
                        a.download = `${(self.options.name || "slate").replace(/[^a-z0-9]/gi, "_").toLowerCase()}_${self.options.id}.png`;
                        a.href = imgsrc;
                        a.click();
                        URL.revokeObjectURL(img.src);
                        cb && cb();
                    }
                };
                img.onerror = (err)=>{
                    console.log("error loading image", err);
                };
            }
        });
    }
    async pngSync(ropts) {
        const self = this;
        return new Promise((resolve, reject)=>{
            self.png(ropts, (base64)=>{
                resolve(base64);
            });
        });
    }
    copy(opts) {
        const self = this;
        if (!self.copySlate) self.copySlate = new slate({
            container: opts.container,
            containerStyle: this.options.containerStyle,
            defaultLineColor: this.options.defaultLineColor,
            viewPort: this.options.viewPort,
            name: this.options.name,
            description: this.options.description,
            allowCollaboration: false,
            showbirdsEye: false,
            showMultiSelect: false,
            showUndoRedo: false,
            showZoom: false
        }).initPlain();
        const _json = JSON.parse(this.exportJSON());
        _json.nodes.forEach((nde)=>{
            const _mpkg = opts.moves ? opts.moves.find((m)=>m.id === nde.options.id || m.id === "*") : null;
            if (_mpkg) {
                nde.options.xPos += _mpkg.x;
                nde.options.yPos += _mpkg.y;
                const _transforms = [
                    `t${_mpkg.x}, ${_mpkg.y}`
                ];
                nde.options.vectorPath = (0, _getTransformedPathDefault.default)(nde.options.vectorPath, _transforms);
            }
        });
        self.copySlate.loadJSON(JSON.stringify(_json));
        self.copySlate.nodes.refreshAllRelationships();
        return self.copySlate;
    }
    svg(opts, cb) {
        const self = this;
        const nodesToOrient = opts?.nodes ? self.nodes.allNodes.filter((n)=>opts?.nodes.indexOf(n.options.id) > -1) : null;
        const _orient = self.getOrientation(nodesToOrient, true);
        const _r = 1 // this.options.viewPort.zoom.r || 1;
        ;
        const _resizedSlate = JSON.parse(self.exportJSON());
        if (opts?.backgroundOnly) _resizedSlate.nodes = [];
        _resizedSlate.nodes.forEach((n)=>{
            const _ty = n.options.yPos * _r;
            const _tx = n.options.xPos * _r;
            const _width = n.options.width;
            const _height = n.options.height;
            n.options.yPos = _ty - _orient.top;
            n.options.xPos = _tx - _orient.left;
            n.options.width = _width * _r;
            n.options.height = _height * _r;
            if (n.options.rotate && n.options.rotate.point) {
                n.options.rotate.point.x = n.options.rotate.point.x * _r - _orient.left;
                n.options.rotate.point.y = n.options.rotate.point.y * _r - _orient.top;
            }
            const _updatedPath = (0, _utilsDefault.default)._transformPath(n.options.vectorPath, [
                "T",
                _orient.left / _r * -1,
                ",",
                _orient.top / _r * -1,
                "s",
                ",",
                _r,
                ",",
                _r
            ].join(""));
            n.options.vectorPath = _updatedPath;
        });
        const _div = document.createElement("div");
        _div.setAttribute("id", "tempSvgSlate");
        _div.style.width = `${_orient.width}px`;
        _div.style.height = `${_orient.height}px`;
        _div.style.visibility = "hidden";
        document.body.appendChild(_div);
        const exportOptions = (0, _deepmergeDefault.default)(_resizedSlate.options, {
            container: "tempSvgSlate",
            containerStyle: {
                backgroundColor: _resizedSlate.options.containerStyle.backgroundColor,
                backgroundColorAsGradient: _resizedSlate.options.containerStyle.backgroundColorAsGradient,
                backgroundGradientType: _resizedSlate.options.containerStyle.backgroundGradientType,
                backgroundGradientColors: _resizedSlate.options.containerStyle.backgroundGradientColors,
                backgroundGradientStrategy: _resizedSlate.options.containerStyle.backgroundGradientStrategy
            },
            defaultLineColor: _resizedSlate.options.defaultLineColor,
            viewPort: {
                allowDrag: false,
                originalWidth: _orient.width,
                width: _orient.width,
                height: _orient.height,
                left: 0,
                top: 0,
                zoom: {
                    w: _orient.width * 1.5,
                    h: _orient.height * 1.5
                },
                showGrid: false
            },
            name: _resizedSlate.options.name,
            description: _resizedSlate.options.description,
            showbirdsEye: false,
            showMultiSelect: false,
            showUndoRedo: false,
            showZoom: false,
            showLocks: false,
            isEmbedding: true,
            allowCollaboration: false
        });
        async function execute() {
            // we don't yet load the nodes by default even though they're passed in on the options below...
            const _exportCanvas = await new slate(exportOptions).init();
            // ...that's done in the loadJSON...which seems weird
            _exportCanvas.loadJSON(JSON.stringify({
                options: exportOptions,
                nodes: _resizedSlate.nodes
            }), false, true);
            // events don't serialize, so add them explicitly
            _exportCanvas.events = self.events;
            _exportCanvas.nodes.refreshAllRelationships();
            // add the bgColor (this is done on html styling in slatebox proper view)
            let bg = null;
            if (_resizedSlate.options.containerStyle.backgroundImage) {
                const img = document.createElement("img");
                img.setAttribute("src", _resizedSlate.options.containerStyle.backgroundImage);
                img.style.visibility = "hidden";
                document.body.appendChild(img);
                let bw = img.naturalWidth;
                let bh = img.naturalHeight;
                if (self.options.containerStyle.backgroundSize === "cover") {
                    const ratio = self.canvas.internal.parentElement.offsetWidth / bw;
                    bw *= ratio;
                    bh *= ratio;
                }
                img.remove();
                const iw = Math.max(bw, _orient.width);
                const ih = Math.max(bh, _orient.height);
                bg = _exportCanvas.paper.image(_resizedSlate.options.containerStyle.backgroundImage, 0, 0, iw, ih);
            } else bg = _exportCanvas.paper.rect(0, 0, _orient.width, _orient.height).attr({
                fill: _resizedSlate.options.containerStyle.backgroundColor,
                stroke: "none"
            });
            bg.toBack();
            // the timeout is critical to ensure that the SVG canvas settles
            // and the url-fill images appear.
            setTimeout(async ()=>{
                _exportCanvas.canvas.rawSVG((svg1)=>{
                    if (!opts) {
                        // presume download if no opts are sent
                        const svgBlob = new Blob([
                            svg1
                        ], {
                            type: "image/svg+xml;charset=utf-8"
                        });
                        const svgUrl = URL.createObjectURL(svgBlob);
                        const dl = document.createElement("a");
                        dl.href = svgUrl;
                        dl.download = `${(self.options.name || "slate").replace(/[^a-z0-9]/gi, "_").toLowerCase()}_${self?.shareId}.svg`;
                        dl.click();
                        cb && cb();
                    } else cb && cb({
                        svg: svg1,
                        orient: _orient
                    });
                    _div.remove();
                });
            }, 100);
        }
        execute();
    }
    autoLoadFilters() {
        const self = this;
        // if auto filter is on, then these filters become immediately availalbe in their default form
        if (self.options.autoEnableDefaultFilters && self.filters?.availableFilters) Object.keys(self.filters.availableFilters).forEach((type)=>{
            self.filters.add({
                id: type,
                filters: self.filters.availableFilters[type].filters
            }, true);
            if (self.filters.availableFilters[type].deps) self.filters.addDeps(self.filters.availableFilters[type].deps);
        });
    }
    loadJSON(_jsonSlate, blnPreserve, blnSkipZoom, useMainCanvas = false) {
        const self = this;
        if (blnPreserve === undefined) {
            self.paper && self.paper.clear();
            if (self.nodes) self.nodes.allNodes = [];
        }
        const loadedSlate = JSON.parse(_jsonSlate);
        Object.assign(self.options, loadedSlate.options);
        self.autoLoadFilters();
        // bgcolor set
        self.canvas?.refreshBackground();
        // grid
        if (self.options.viewPort.showGrid) self.grid?.show();
        else self.grid?.destroy();
        // zoom
        if (!blnSkipZoom) self.zoomSlider?.set(self.options.viewPort.zoom.w || 50000);
        // sort nodes by their last painted order to honor toBack/toFront
        loadedSlate.nodes.sort((n1, n2)=>{
            const i1 = loadedSlate.options.nodeOrder?.findIndex((n)=>n === n1.options.id);
            const i2 = loadedSlate.options.nodeOrder?.findIndex((n)=>n === n2.options.id);
            return i1 - i2;
        });
        const deferredRelationships = [];
        loadedSlate.nodes.forEach((n)=>{
            n.options.allowDrag = true // must default
            ;
            n.options.allowMenu = true;
            const _boundTo = new (0, _nodeDefault.default)(n.options);
            self.nodes.add(_boundTo, useMainCanvas);
            deferredRelationships.push({
                bt: _boundTo,
                json: n
            });
        });
        deferredRelationships.forEach((relationship)=>{
            const _bounded = relationship;
            _bounded.bt.addRelationships(_bounded.json);
        });
        if (self.options.showLocks) self.displayLocks();
        // refreshes all relationships
        self.nodes.allNodes.forEach((_node)=>{
            _node.relationships.updateAssociationsWith({
                activeNode: _node.options.id,
                currentDx: 0,
                currentDy: 0
            });
        });
        self.nodes.refreshAllRelationships();
        // finally invoke toFront in order
        self.nodes.allNodes.forEach((n)=>n.toFront());
        // always add style tag to the <defs> for font embedding
        self.paper.def({
            tag: "style",
            type: "text/css",
            id: `embeddedSBStyles_${self.options.id}`
        });
        self.paper.def({
            tag: "path",
            id: `raphael-marker-classic`,
            "stroke-linecap": "round",
            d: "M5,0 0,2.5 5,5 3.5,3 3.5,2z"
        });
        self.loadAllFonts();
        if (!blnSkipZoom) self.controller.centerOnNodes({
            dur: 0
        });
    }
    loadAllFonts() {
        // load all fonts
        const fonts = (0, _lodashUniqDefault.default)(this.nodes.allNodes.map((n)=>n.options.fontFamily)).join("|");
        if (document.getElementById("googleFonts")) document.getElementById("googleFonts").setAttribute("href", `https://fonts.googleapis.com/css?family=${fonts}`);
        else {
            const sc = document.createElement("link");
            sc.setAttribute("src", "https://fonts.googleapis.com/css?family=${fonts}");
            sc.setAttribute("id", "googleFonts");
            sc.setAttribute("rel", "stylesheet");
            sc.setAttribute("type", "text/css");
            document.head.appendChild(sc);
        }
    }
    displayLocks() {
        this.nodes.allNodes.forEach((nd)=>{
            nd.initLock();
        });
    }
    hideLocks() {
        this.nodes.allNodes.forEach((nd)=>{
            nd.hideLock();
        });
    }
    isReadOnly() {
        return !this.events.isReadOnly || this.events.isReadOnly && this.events.isReadOnly();
    }
    isCommentOnly() {
        return !this.events.isCommentOnly || this.events.isCommentOnly && this.events.isCommentOnly();
    }
    canRemoveComments() {
        return !this.events.canRemoveComments || this.events.canRemoveComments && this.events.canRemoveComments();
    }
    // the granularity is at the level of the node...
    exportDifference(compare, lineWidthOverride) {
        const _difOpts = {
            ...this.options
        };
        delete _difOpts.container;
        // birdsEye specific -- if this is not here, then locks
        // show up on the birdsEye
        _difOpts.showLocks = compare.options.showLocks;
        const jsonSlate = {
            options: JSON.parse(JSON.stringify(_difOpts)),
            nodes: []
        };
        const tnid = this.tempNodeId;
        this.nodes.allNodes.forEach((nd)=>{
            let _exists = false;
            const pn = nd;
            if (pn.options.id !== tnid) {
                compare.nodes.allNodes.forEach((nodeInner)=>{
                    if (nodeInner.options.id === pn.options.id) _exists = true;
                });
                if (!_exists) jsonSlate.nodes.push(pn.serialize(lineWidthOverride));
            }
        });
        return JSON.stringify(jsonSlate);
    }
    exportJSON() {
        const _cont = this.options.container;
        const _opts = this.options;
        delete _opts.container;
        const jsonSlate = {
            options: JSON.parse(JSON.stringify(_opts)),
            nodes: []
        };
        this.options.container = _cont;
        delete jsonSlate.options.ajax;
        delete jsonSlate.options.container;
        const tnid = this.tempNodeId;
        this.nodes.allNodes.forEach((nd)=>{
            if (nd.options.id !== tnid) jsonSlate.nodes.push(nd.serialize());
        });
        jsonSlate.shareId = this.shareId;
        return JSON.stringify(jsonSlate);
    }
    snapshot() {
        const _snap = JSON.parse(this.exportJSON());
        _snap.nodes.allNodes = _snap.nodes;
        return _snap;
    }
    getOrientation(nodesToOrient, alwaysOne) {
        let orient = "landscape";
        let sWidth = this.options.viewPort.width;
        let sHeight = this.options.viewPort.height;
        const bb = [];
        bb.left = 99999;
        bb.right = 0;
        bb.top = 99999;
        bb.bottom = 0;
        const an = nodesToOrient || this.nodes.allNodes;
        if (an.length > 0) {
            for(let _px = 0; _px < an.length; _px += 1){
                const sbw = 10;
                const _bb = an[_px].vect.getBBox();
                if (_bb) {
                    const _r = alwaysOne ? 1 : this.options.viewPort.zoom.r || 1;
                    const x = _bb.x * _r;
                    const y = _bb.y * _r;
                    const w = _bb.width * _r;
                    const h = _bb.height * _r;
                    bb.left = Math.abs(Math.min(bb.left, x - sbw));
                    bb.right = Math.abs(Math.max(bb.right, x + w + sbw));
                    bb.top = Math.abs(Math.min(bb.top, y - sbw));
                    bb.bottom = Math.abs(Math.max(bb.bottom, y + h + sbw));
                }
            }
            sWidth = bb.right - bb.left;
            sHeight = bb.bottom - bb.top;
            if (sHeight > sWidth) orient = "portrait";
        }
        return {
            orientation: orient,
            height: sHeight,
            width: sWidth,
            left: bb.left,
            top: bb.top
        };
    }
    resize(_size, dur, pad) {
        let _p = pad || 0;
        if (_p < 6) _p = 6;
        _size -= _p * 2 || 0;
        const orx = this.getOrientation();
        const wp = orx.width / _size * this.options.viewPort.width;
        const hp = orx.height / _size * this.options.viewPort.height;
        const sp = Math.max(wp, hp);
        const _r = Math.max(this.options.viewPort.width, this.options.viewPort.height) / sp;
        const l = orx.left * _r - _p;
        const t = orx.top * _r - _p;
        this.zoom(0, 0, sp, sp, true);
        this.options.viewPort.zoom = {
            w: sp,
            h: sp,
            l: parseInt(l * -1, 10),
            t: parseInt(t * -1, 10),
            r: this.options.viewPort.originalWidth / sp
        };
        this.canvas.move({
            x: l,
            y: t,
            dur,
            isAbsolute: true
        });
    }
    disable(exemptSlate, exemptNodes, full) {
        if (!exemptNodes) this.nodes.allNodes.forEach((nd)=>{
            nd.disable();
        });
        if (!exemptSlate) {
            this.options.enabled = false;
            this.options.allowDrag = false;
            if (full) {
                this.multiSelection?.hideIcons();
                this.undoRedo?.hide();
                this.birdsEye?.disable();
                this.zoomSlider?.hide();
            }
        }
    }
    enable(exemptSlate, exemptNodes) {
        if (!exemptNodes) this.nodes.allNodes.forEach((nd)=>{
            !nd.options.isLocked && nd.enable();
        });
        if (!exemptSlate) {
            this.options.enabled = true;
            this.options.allowDrag = true;
        }
    }
    reorderNodes() {
        // these ids will come out in the order that they are painted on the screen - toFront and toBack adjusts this, so we need
        // to always keep this hand so that when the slate is reloaded, it can order the nodes by these ids (which are going to be dif
        // from the saved JSON order of arrays)
        const ids = Array.from(this.canvas.internal.querySelector("svg").querySelectorAll("path")).map((a)=>a.getAttribute("rel")).filter((r)=>!!r);
        // console.log("order of nodes", ids);
        this.options.nodeOrder = ids;
    }
    findChildren(nodeIds, allChildren = []) {
        const self = this;
        // get his node's children - then recursively call findChildren on that node
        const nodes = self.nodes.allNodes.filter((n)=>nodeIds.includes(n.options.id));
        allChildren = allChildren.concat(nodes.map((n)=>n.options.id));
        const children = [];
        nodes.forEach((n)=>{
            n.relationships.associations.filter((a)=>a.parent.options.id === n.options.id).forEach((a)=>children.push(a.child.options.id));
        });
        if (children.length) return self.findChildren(children, allChildren);
        return allChildren;
    }
    applyTheme(theme, syncWithTheme, revertTheme) {
        const self = this;
        if (!revertTheme) {
            self.options.basedOnThemeId = theme.themeId || theme._id;
            self.options.syncWithTheme = syncWithTheme;
        } else {
            self.options.basedOnThemeId = null;
            self.options.syncWithTheme = null;
        }
        const nodeStyle = {};
        const currentNodesByColor = {};
        const totChildren = [];
        // first apply slate
        if (theme.containerStyle.backgroundImage) self.collab.invoke({
            type: "onSlateBackgroundImageChanged",
            data: {
                bg: {
                    size: theme.containerStyle.backgroundSize,
                    url: theme.containerStyle.backgroundImage
                }
            }
        });
        else if (theme.containerStyle.backgroundEffect) self.collab.invoke({
            type: "onSlateBackgroundEffectChanged",
            data: {
                effect: theme.containerStyle.backgroundEffect
            }
        });
        else self.collab.invoke({
            type: "onSlateBackgroundColorChanged",
            data: {
                color: theme.containerStyle.backgroundColor,
                asGradient: theme.containerStyle.backgroundColorAsGradient,
                gradientType: theme.containerStyle.backgroundGradientType,
                gradientColors: theme.containerStyle.backgroundGradientColors,
                gradientStrategy: theme.containerStyle.backgroundGradientStrategy
            }
        });
        self.collab.invoke({
            type: "onLineColorChanged",
            data: {
                color: theme.defaultLineColor
            }
        });
        function applyStyle(id) {
            const allKeys = Object.keys(theme.styles);
            const lastStyle = theme.styles[allKeys[allKeys.length - 1]];
            const styleBase = theme.styles[nodeStyle[id]] || lastStyle;
            // borders
            self.collab.invoke({
                type: "onNodeBorderPropertiesChanged",
                data: {
                    id,
                    prop: "borderWidth",
                    val: styleBase.borderWidth
                }
            });
            self.collab.invoke({
                type: "onNodeBorderPropertiesChanged",
                data: {
                    id,
                    prop: "borderColor",
                    val: styleBase.borderColor
                }
            });
            self.collab.invoke({
                type: "onNodeBorderPropertiesChanged",
                data: {
                    id,
                    prop: "borderOpacity",
                    val: styleBase.borderOpacity
                }
            });
            self.collab.invoke({
                type: "onNodeBorderPropertiesChanged",
                data: {
                    id,
                    prop: "borderStyle",
                    val: styleBase.borderStyle
                }
            });
            // shape
            if (styleBase.vectorPath && syncWithTheme) // const node = self.nodes.one(id);
            // const sendPath = utils._transformPath(styleBase.vectorPath, `T${node.options.xPos},${node.options.xPos}`);
            self.collab.invoke({
                type: "onNodeShapeChanged",
                data: {
                    id,
                    hint: styleBase.hint,
                    shape: styleBase.vectorPath
                }
            });
            // text
            if (syncWithTheme) self.collab.invoke({
                type: "onNodeTextChanged",
                data: {
                    id,
                    fontSize: styleBase.fontSize,
                    fontFamily: styleBase.fontFamily,
                    fontColor: styleBase.foregroundColor,
                    textOpacity: styleBase.textOpacity
                }
            });
            // effects
            self.collab.invoke({
                type: "onNodeEffectChanged",
                data: {
                    id,
                    filter: {
                        apply: "text",
                        id: styleBase.filters.text
                    }
                }
            });
            // background color
            self.collab.invoke({
                type: "onNodeColorChanged",
                data: {
                    id,
                    opacity: styleBase.opacity,
                    color: styleBase.backgroundColor
                }
            });
            // effects
            self.collab.invoke({
                type: "onNodeEffectChanged",
                data: {
                    id,
                    filter: {
                        apply: "vect",
                        id: styleBase.filters.vect
                    }
                }
            });
            // lines
            const styleNode = self.nodes.one(id);
            // console.log("node is ", id, node);
            styleNode.relationships.associations.forEach((a, ind)=>{
                self.collab.invoke({
                    type: "onLineColorChanged",
                    data: {
                        id,
                        color: styleBase.lineColor
                    }
                });
                self.collab.invoke({
                    type: "onLinePropertiesChanged",
                    data: {
                        id,
                        prop: "lineOpacity",
                        val: a.lineOpacity === 0 ? 0 : styleBase.lineOpacity,
                        associationId: a.id,
                        index: ind
                    }
                });
                self.collab.invoke({
                    type: "onLinePropertiesChanged",
                    data: {
                        id,
                        prop: "lineEffect",
                        val: styleBase.lineEffect,
                        associationId: a.id,
                        index: ind
                    }
                });
                self.collab.invoke({
                    type: "onLinePropertiesChanged",
                    data: {
                        id,
                        prop: "lineWidth",
                        val: styleBase.lineWidth,
                        associationId: a.id,
                        index: ind
                    }
                });
            });
        }
        self.nodes.allNodes.forEach((nd)=>{
            if (self.options.mindMapMode || syncWithTheme) {
                const children = self.findChildren([
                    nd.options.id
                ]);
                totChildren.push(children);
            } else {
                if (!currentNodesByColor[nd.options.backgroundColor]) currentNodesByColor[nd.options.backgroundColor] = [];
                currentNodesByColor[nd.options.backgroundColor].push(nd.options.id);
            }
        });
        if (self.options.mindMapMode || syncWithTheme) {
            totChildren.sort((a, b)=>a.length - b.length);
            totChildren.forEach((t)=>{
                t.forEach((n, ind)=>{
                    nodeStyle[n] = ind === 0 ? `parent` : `child_${ind}`;
                });
            });
        } else {
            const colorsByUsage = Object.keys(currentNodesByColor).sort((a, b)=>currentNodesByColor[b].length - currentNodesByColor[a].length);
            let styleIndex = -1;
            colorsByUsage.forEach((c, index)=>{
                if (Object.keys(theme.styles).length < index) styleIndex = -1;
                styleIndex += 1;
                currentNodesByColor[c].forEach((id)=>{
                    nodeStyle[id] = styleIndex === 0 ? `parent` : `child_${styleIndex}`;
                });
            });
        }
        Object.keys(nodeStyle).forEach((id)=>{
            applyStyle(id);
        });
    }
}
exports.default = slate;

},{"lodash.uniq":"iDalh","lodash.clonedeep":"i3u1q","deepmerge":"ck1Q2","../helpers/utils":"8QI6M","../helpers/getTransformedPath":"6wubb","../slate/canvas":"kpLaV","../slate/collab":"eYgJm","../slate/nodeController":"6wl7A","../slate/multiSelection":"kpcw7","../slate/birdsEye":"bRqCq","../slate/inertia":"l9OwD","../slate/controller":"2xnBR","../slate/zoomSlider":"6TbYF","../slate/undoRedo":"78ZfO","../slate/grid":"ixIFt","../slate/comments":"g3tty","../slate/keyboard":"fRVV4","../slate/filters":"JAVXJ","./base":"cmkOb","./node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDalh":[function(require,module,exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) return baseFindIndex(array, baseIsNaN, fromIndex);
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") try {
        result = !!(value + "");
    } catch (e) {}
    return result;
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var splice = arrayProto.splice;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map"), Set = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length)this.add(values[index]);
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */ function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) return setToArray(set);
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
    } else seen = iteratee ? [] : result;
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) continue outer;
            }
            if (iteratee) seen.push(computed);
            result.push(value);
        } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) seen.push(computed);
            result.push(value);
        }
    }
    return result;
}
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */ var createSet = !(Set && 1 / setToArray(new Set([
    ,
    -0
]))[1] == INFINITY) ? noop : function(values) {
    return new Set(values);
};
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */ function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */ function noop() {
// No operation performed.
}
module.exports = uniq;

},{}],"i3u1q":[function(require,module,exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/** Detect free variable `exports`. */ var freeExports = exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && true && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */ function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
}
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */ function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
}
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */ function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) break;
    }
    return array;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */ function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") try {
        result = !!(value + "");
    } catch (e) {}
    return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    return this.__data__["delete"](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */ function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
    if (result !== undefined) return result;
    if (!isObject(value)) return value;
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray(value, result);
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) return cloneBuffer(value, isDeep);
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) return object ? value : {};
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) return copySymbols(value, baseAssign(result, value));
        } else {
            if (!cloneableTags[tag]) return object ? value : {};
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
    arrayEach(props || value, function(subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
}
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */ function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    return objectToString.call(value);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
    return result;
}
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */ function cloneBuffer(buffer, isDeep) {
    if (isDeep) return buffer.slice();
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
}
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */ function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */ function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */ function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
}
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */ function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */ function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
}
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */ function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */ function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */ function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
            return new Ctor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
            return new Ctor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
            return cloneSymbol(object);
    }
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */ function cloneDeep(value) {
    return baseClone(value, true, true);
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = cloneDeep;

},{}],"ck1Q2":[function(require,module,exports) {
"use strict";
var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
    return !!value && typeof value === "object";
}
function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === "function" && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 0xeac7;
function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) return deepmerge;
    var customMerge = options.customMerge(key);
    return typeof customMerge === "function" ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
    }) : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    } catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
     && Object.propertyIsEnumerable.call(target, key) // and also unsafe if they're nonenumerable.
    );
}
function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
    getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) return;
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        else destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    });
    return destination;
}
function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) return cloneUnlessOtherwiseSpecified(source, options);
    else if (sourceIsArray) return options.arrayMerge(target, source, options);
    else return mergeObject(target, source, options);
}
deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) throw new Error("first argument should be an array");
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
    }, {});
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;

},{}],"8QI6M":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ /* eslint-disable no-param-reassign */ /* eslint-disable no-return-assign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class utils {
    static easing = {
        elastic (pos) {
            return -1 * 4 ** (-8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
        },
        swingFromTo (pos) {
            let s = 1.70158;
            return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
        },
        swingFrom (pos) {
            const s = 1.70158;
            return pos * pos * ((s + 1) * pos - s);
        },
        swingTo (pos) {
            const s = 1.70158;
            return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
        },
        bounce (pos) {
            if (pos < 1 / 2.75) return 7.5625 * pos * pos;
            if (pos < 2 / 2.75) return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
            if (pos < 2.5 / 2.75) return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
            return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
        },
        bouncePast (pos) {
            if (pos < 1 / 2.75) return 7.5625 * pos * pos;
            if (pos < 2 / 2.75) return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
            if (pos < 2.5 / 2.75) return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
            return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
        },
        easeFromTo (pos) {
            if ((pos /= 0.5) < 1) return 0.5 * pos ** 4;
            return -0.5 * ((pos -= 2) * pos ** 3 - 2);
        },
        easeFrom (pos) {
            return pos ** 4;
        },
        easeTo (pos) {
            return pos ** 0.25;
        },
        none (pos) {
            return -Math.cos(pos * Math.PI) / 2 + 0.5;
        }
    };
    static availColors = [
        {
            hex: "000000",
            to: "575757",
            fore: "fff"
        },
        {
            hex: "FFFFFF",
            to: "d9d9d9",
            fore: "000"
        },
        {
            hex: "FF0000",
            to: "a31616",
            fore: "000"
        },
        {
            hex: "C3FF68",
            to: "afff68",
            fore: "000"
        },
        {
            hex: "0B486B",
            to: "3B88B5",
            fore: "fff"
        },
        {
            hex: "FBB829",
            to: "cd900e",
            fore: "000"
        },
        {
            hex: "BFF202",
            to: "D1F940",
            fore: "000"
        },
        {
            hex: "FF0066",
            to: "aa1d55",
            fore: "000"
        },
        {
            hex: "800F25",
            to: "3d0812",
            fore: "fff"
        },
        {
            hex: "A40802",
            to: "d70b03",
            fore: "fff"
        },
        {
            hex: "FF5EAA",
            to: "cf5d93",
            fore: "000"
        },
        {
            hex: "740062",
            to: "D962C6",
            fore: "fff"
        },
        {
            hex: "FF4242",
            to: "A61515",
            fore: "fff"
        },
        {
            hex: "D15C57",
            to: "9D5C58",
            fore: "000"
        },
        {
            hex: "FCFBE3",
            to: "c9c56f",
            fore: "000"
        },
        {
            hex: "FF9900",
            to: "c98826",
            fore: "000"
        },
        {
            hex: "369001",
            to: "9CEE6C",
            fore: "000"
        },
        {
            hex: "9E906E",
            to: "675324",
            fore: "fff"
        },
        {
            hex: "F3D915",
            to: "F9EA7C",
            fore: "000"
        },
        {
            hex: "031634",
            to: "2D579A",
            fore: "fff"
        },
        {
            hex: "556270",
            to: "7b92ab",
            fore: "fff"
        },
        {
            hex: "1693A5",
            to: "23aad6",
            fore: "fff"
        },
        {
            hex: "ADD8C7",
            to: "59a989",
            fore: "000"
        },
        {
            special: {
                // line options display only colors; node menu displays colors and transparent button
                color: {
                    hex: "8D5800",
                    to: "EB9605"
                },
                other: {
                    transparent: true
                }
            }
        }
    ];
    static polygonCache = {};
    static async pause(millis) {
        return new Promise((resolve)=>{
            window.setTimeout(()=>{
                resolve();
            }, millis);
        });
    }
    static windowSize() {
        let w = 0;
        let h = 0;
        // IE
        if (!window.innerWidth) {
            // strict mode
            if (!(document.documentElement.clientWidth == 0)) {
                w = document.documentElement.clientWidth;
                h = document.documentElement.clientHeight;
            } else {
                w = document.body.clientWidth;
                h = document.body.clientHeight;
            }
        } else {
            w = window.innerWidth;
            h = window.innerHeight;
        }
        return {
            width: w,
            height: h
        };
    }
    static isElement(o) {
        return typeof HTMLElement === "object" ? o instanceof HTMLElement // DOM2
         : typeof o === "object" && o.nodeType === 1 && typeof o.nodeName === "string";
    }
    // convenience
    static el(id) {
        if (id.indexOf("#") > -1 || id.indexOf(".") > -1) return document.querySelector(id);
        return document.getElementById(id);
    }
    // let arr = select("elem.className");
    static select(query) {
        const els = [];
        const index = query.indexOf(".");
        if (index !== -1) {
            const tag = query.slice(0, index) || "*";
            const klass = query.slice(index + 1, query.length);
            const all = document.getElementsByTagName(tag);
            for(let d = 0; d < all.length; d += 1){
                const elem = all[d];
                if (elem.className && elem.className.indexOf(klass) !== -1) els.push(elem);
            }
        }
        return els;
    }
    static getKey(e) {
        let keyCode = 0;
        try {
            keyCode = e.keyCode;
        } catch (Err) {
            keyCode = e.which;
        }
        return keyCode;
    }
    // fix event inconsistencies across browsers
    static stopEvent(e) {
        e = e || window.event;
        if (e.preventDefault) {
            e.stopPropagation();
            e.preventDefault();
        } else {
            e.returnValue = false;
            e.cancelBubble = true;
        }
        return false;
    }
    static toShortDateString(jsonDate) {
        let date = jsonDate;
        try {
            const d = new Date(parseInt(jsonDate.substr(6), 10));
            date = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        } catch (Err) {}
        return date;
    }
    static addEvent(obj, type, fn) {
        obj.addEventListener(type, fn);
    }
    static removeEvent(obj, type, fn) {
        obj.removeEventListener(type, fn);
    }
    // push an event listener into existing array of listeners
    static bind(to, evt, fn) {
        to[evt] = to[evt] || [];
        to[evt].push(fn);
    }
    static imageExists(u, cb, id) {
        const iid = `temp_${utils.guid()}`;
        const img = document.body.appendChild(document.createElement("img"));
        img.style.position = "absolute";
        img.style.top = "-10000px";
        img.style.left = "-10000px";
        img.setAttribute("src", u);
        img.setAttribute("id", iid);
        this.addEvent(img, "load", function(e) {
            const d = getDimensions(img);
            document.body.removeChild(img);
            cb.apply(this, [
                true,
                d.width,
                d.height,
                id
            ]);
        });
        this.addEvent(img, "error", function(e) {
            document.body.removeChild(img);
            cb.apply(this, [
                false,
                0,
                0,
                id
            ]);
        });
    }
    static ajax(u, f, d, v, x, h) {
        x = this.ActiveXObject;
        // the guid is essential to break the cache because ie8< seems to want to cache this. argh.
        u = [
            u,
            u.indexOf("?") === -1 ? "?" : "&",
            `guid=${utils.guid()}`
        ].join("");
        x = new (x || XMLHttpRequest)("Microsoft.XMLHTTP");
        const vx = d ? v || "POST" : v || "GET";
        x.open(vx, u, 1);
        x.setRequestHeader("Content-type", "application/json; charset=utf-8");
        h.forEach((hElem)=>{
            x.setRequestHeader(hElem.n, hElem.v);
        });
        x.onreadystatechange = ()=>{
            // eslint-disable-next-line no-unused-expressions
            x.readyState > 3 && f && f(x.responseText, x);
        };
        x.send(d);
    }
    static randomInt(min, max) {
        return Math.floor(min + Math.random() * (max - min + 1));
    }
    static isMobile() {
        return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    }
    static isSafari() {
        const isSafari = navigator.vendor.match(/apple/i) && !navigator.userAgent.match(/crios/i) && !navigator.userAgent.match(/fxios/i) && !navigator.userAgent.match(/Opera|OPT\//);
        return isSafari;
    }
    static hasClass(el, className) {
        if (el.classList) el.classList.contains(className);
        else new RegExp(`(^| )${className}( |$)`, "gi").test(el.className);
    }
    static addClass(el, className) {
        if (el.classList) el.classList.add(className);
        else el.className += ` ${className}`;
    }
    static S4() {
        // eslint-disable-next-line no-bitwise
        return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
    }
    static guid(len) {
        let g = this.S4() + this.S4() + this.S4();
        if (len) g = g.replace(/-/gi, "").substring(0, len).toUpperCase();
        return g;
    }
    static getJSON(url, callback) {
        const id = this.S4() + this.S4();
        let script = document.createElement("script");
        const token = `__jsonp${id}`;
        // callback should be a global function
        window[token] = callback;
        // url should have "?" parameter which is to be replaced with a global callback name
        script.src = url.replace(/\?(&|$)/, `__jsonp${id}$1`);
        // clean up on load: remove script tag, null script variable and delete global callback function
        script.onload = ()=>{
            script = null;
        };
        document.getElementsByTagName("head")[0].appendChild(script);
    }
    static getBBox(opts) {
        const cont = document.createElement("div");
        cont.setAttribute("id", "hiddenPaper");
        cont.style.display = "none";
        document.body.appendChild(cont);
        const pp = new (0, _raphaelSvg.Raphael)(cont);
        const bb = pp.path(opts.path).getBBox();
        document.body.removeChild(cont);
        return bb;
    }
    static obtainProportionateWidthAndHeightForResizing(dx, dy, currentVectWidth, currentVectHeight, origVectWidth, origVectHeight, isCtrl, isCustom) {
        let transWidth = currentVectWidth + dx * 2;
        let transHeight = currentVectHeight + dy * 2;
        const useOrigVectorWidth = origVectWidth ?? currentVectWidth;
        const useOrigVectorHeight = origVectHeight ?? currentVectHeight;
        if (!isCtrl && isCustom && useOrigVectorWidth && useOrigVectorHeight) {
            // const max = Math.max(transWidth, transHeight)
            // // keep it proportional to the original dimensions unless ctrl is pressed while resizing
            // if (max === transWidth) {
            // change width
            transHeight = useOrigVectorHeight * transWidth / useOrigVectorWidth;
            transWidth = useOrigVectorWidth * transHeight / useOrigVectorHeight;
        // } else {
        //   // change height
        //   transWidth = (useOrigVectorWidth * transHeight) / useOrigVectorHeight
        //   transHeight = (useOrigVectorHeight * transWidth) / useOrigVectorWidth
        // }
        }
        return {
            transWidth,
            transHeight
        };
    }
    static positionedOffset(obj) {
        let curleft = 0;
        let curtop = 0;
        if (obj.offsetParent) do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        // eslint-disable-next-line no-cond-assign
        }while (obj = obj.offsetParent);
        return {
            left: curleft,
            top: curtop
        };
    }
    static getDimensions(ele) {
        let width = 0;
        let height = 0;
        if (typeof ele.clip !== "undefined") {
            width = ele.clip.width;
            height = ele.clip.height;
        } else if (ele.style?.pixelWidth) {
            width = ele.style.pixelWidth;
            height = ele.style.pixelHeight;
        } else {
            width = ele.offsetWidth;
            height = ele.offsetHeight;
        }
        return {
            width,
            height
        };
    }
    static mousePos(e) {
        let mouseX = null;
        let mouseY = null;
        const allTouches = [];
        if (e.targetTouches) {
            if (e.targetTouches.length) {
                const t = e.targetTouches[0];
                mouseX = t.clientX;
                mouseY = t.clientY;
                e.targetTouches.forEach((tx)=>{
                    allTouches.push({
                        x: e.targetTouches[tx].clientX,
                        y: e.targetTouches[tx].clientY
                    });
                });
            }
        } else {
            mouseX = e.pageX;
            mouseY = e.pageY;
        }
        return {
            x: mouseX,
            y: mouseY,
            allTouches
        };
    }
    static centerAndScalePathToFitContainer(opts) {
        // scale and transform the path to fit the box...
        // first get the bbox of the untouched path
        let bb = this.getBBox({
            path: opts.path
        });
        // calculate the scale of the path
        const scale = opts.scaleSize / Math.max(bb.width, bb.height);
        // scale the untouched path
        let newPath = this._transformPath(opts.path, [
            "s",
            scale,
            ",",
            scale
        ].join(""));
        // go get the bbox of the scaled path
        bb = this.getBBox({
            path: newPath
        });
        // finally, move the scaled vector to the centered x,y coords
        // of the enclosed box
        const tp = [
            "T",
            bb.x * -1 + (opts.containerSize - bb.width) / 2,
            ",",
            bb.y * -1 + (opts.containerSize - bb.height) / 2
        ].join("");
        newPath = this._transformPath(newPath, tp);
        return {
            path: newPath,
            width: bb.width,
            height: bb.height
        };
    }
    static buildStyle(_styles) {
        let _str = "";
        Object.keys(_styles).forEach((k)=>{
            _str += `${k}:${_styles[k]};`;
        });
        return _str;
    }
    static getRGBComponents(bgColor) {
        const r = bgColor.substring(1, 3);
        const g = bgColor.substring(3, 5);
        const b = bgColor.substring(5, 7);
        return {
            R: parseInt(r, 16),
            G: parseInt(g, 16),
            B: parseInt(b, 16)
        };
    }
    static whiteOrBlack(hex) {
        function getRGB(c) {
            return parseInt(c, 16) || c;
        }
        function getsRGB(c) {
            return getRGB(c) / 255 <= 0.03928 ? getRGB(c) / 255 / 12.92 : Math.pow((getRGB(c) / 255 + 0.055) / 1.055, 2.4);
        }
        function getLuminance(hexColor) {
            return 0.2126 * getsRGB(hexColor.substr(1, 2)) + 0.7152 * getsRGB(hexColor.substr(3, 2)) + 0.0722 * getsRGB(hexColor.substr(-2));
        }
        function getContrast(f, b) {
            const L1 = getLuminance(f);
            const L2 = getLuminance(b);
            return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
        }
        const whiteContrast = getContrast(hex || "#fff", "#ffffff");
        const blackContrast = getContrast(hex || "#fff", "#000000");
        return whiteContrast > blackContrast ? "#ffffff" : "#000000";
    }
    // https://gist.github.com/iconifyit/958e7abba71806d663de6c2c273dc0da
    static splitPath(pathData) {
        function pathToAbsoluteSubPaths(path_string) {
            var path_commands = (0, _raphaelSvg.Raphael).parsePathString(path_string), end_point = [
                0,
                0
            ], sub_paths = [], command = [], i = 0;
            while(i < path_commands.length){
                command = path_commands[i];
                end_point = getNextEndPoint(end_point, command);
                if (command[0] === "m") command = [
                    "M",
                    end_point[0],
                    end_point[1]
                ];
                var sub_path = [
                    command.join(" ")
                ];
                i++;
                while(!endSubPath(path_commands, i)){
                    command = path_commands[i];
                    sub_path.push(command.join(" "));
                    end_point = getNextEndPoint(end_point, command);
                    i++;
                }
                sub_paths.push(sub_path.join(" "));
            }
            return sub_paths;
        }
        function getNextEndPoint(end_point, command) {
            var x = end_point[0], y = end_point[1];
            if (isRelative(command)) switch(command[0]){
                case "h":
                    x += command[1];
                    break;
                case "v":
                    y += command[1];
                    break;
                case "z":
                    // back to [0,0]?
                    x = 0;
                    y = 0;
                    break;
                default:
                    x += command[command.length - 2];
                    y += command[command.length - 1];
            }
            else switch(command[0]){
                case "H":
                    x = command[1];
                    break;
                case "V":
                    y = command[1];
                    break;
                case "Z":
                    // back to [0,0]?
                    x = 0;
                    y = 0;
                    break;
                default:
                    x = command[command.length - 2];
                    y = command[command.length - 1];
            }
            return [
                x,
                y
            ];
        }
        function isRelative(command) {
            return command[0] === command[0].toLowerCase();
        }
        function endSubPath(commands, index) {
            if (index >= commands.length) return true;
            else return commands[index][0].toLowerCase() === "m";
        }
        return pathToAbsoluteSubPaths(pathData);
    }
    static _transformPath(original, transform) {
        const rpath = (0, _raphaelSvg.Raphael).transformPath(original, transform).toString();
        return rpath;
    }
    static transformPath(_node, _transformation) {
        const _path = (0, _raphaelSvg.Raphael).transformPath(_node.vect.attr("path").toString(), _transformation).toString();
        _node.options.vectorPath = _path;
        _node.vect.transform("");
        _node.vect.attr({
            path: _node.options.vectorPath
        });
        const bb = _node.vect.getBBox();
        const rotationContext = {
            point: {
                x: bb.cx,
                y: bb.cy
            }
        };
        Object.assign(_node.options.rotate, rotationContext);
        const transformString = _node.getTransformString();
        _node.vect.transform(transformString);
        _node.text.transform("");
        // xPos and yPos are updated in the setPosition in Slatebox.node.js
        _node.text.attr(_node.textCoords({
            x: _node.options.xPos,
            y: _node.options.yPos
        }));
        _node.text.transform(transformString);
    }
    static htmlToElement(html) {
        const template = document.createElement("template");
        html = html.trim();
        template.innerHTML = html;
        return template.content.firstChild;
    }
    static buildNodeStyleFromTheme({ theme, childNumber = 1 }) {
        const allKeys = Object.keys(theme.styles);
        const lastStyle = theme.styles[allKeys[allKeys.length - 1]];
        const styleBase = theme.styles[`child_${childNumber}`] || lastStyle;
        const configurableProps = [
            "borderWidth",
            "borderColor",
            "borderOpacity",
            "borderStyle",
            "fontSize",
            "fontFamily",
            "fontColor",
            "textOpacity",
            "filter.vect",
            "filter.text",
            "opacity",
            "backgroundColor",
            "lineOpacity",
            "lineWidth",
            "lineEffect"
        ] // vectorPath
        ;
        const nodeOptions = {};
        configurableProps.forEach((p)=>{
            if (styleBase[p] != null) nodeOptions[p] = styleBase[p];
            else switch(p){
                case "filter.vect":
                case "filter.text":
                    nodeOptions.filter ??= {};
                    nodeOptions.filter[p.split(".")[1]] = styleBase.filters[p.split(".")[1]];
                    break;
            }
        });
        return nodeOptions;
    }
    // https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
    static getTextWidth(text, font) {
        const splitText = text.split("\n");
        const textWidthCanvas = document.createElement("canvas");
        const metrics = [];
        splitText.forEach((t)=>{
            // textWidthCanvas.setAttribute('id', `measuretext`)
            const context = textWidthCanvas.getContext("2d");
            context.font = font;
            metrics.push(context.measureText(t));
        });
        textWidthCanvas.remove();
        let height = 0;
        metrics.forEach((m)=>height += m.fontBoundingBoxAscent + m.fontBoundingBoxDescent);
        const red = {
            width: Math.max(...metrics.map((m)=>m.width)),
            height
        };
        return red;
    }
    static chunk(arr, chunkSize = 1, cache = []) {
        const tmp = [
            ...arr
        ];
        if (chunkSize <= 0) return cache;
        while(tmp.length)cache.push(tmp.splice(0, chunkSize));
        return cache;
    }
    static createMultiLineText(text, lineCount) {
        const words = text.split(/ /g);
        const chars = text.split("");
        const charsPerLine = chars.length / lineCount;
        const lines = [];
        let wordsOnLine = [];
        let curCharCount = 0;
        // console.log(
        //   'words are 1',
        //   words.length,
        //   chars.length,
        //   charsPerLine,
        //   lines.length,
        //   lineCount,
        //   curCharCount
        // )
        words.forEach((w)=>{
            curCharCount += w.length;
            // console.log(
            //   'words are 2',
            //   words.length,
            //   chars.length,
            //   charsPerLine,
            //   lines.length,
            //   lineCount,
            //   curCharCount
            // )
            if (curCharCount < charsPerLine || lines.length === lineCount - 1) wordsOnLine.push(w);
            else {
                lines.push(wordsOnLine.join(" "));
                curCharCount = w.length;
                wordsOnLine = [
                    w
                ];
            }
        });
        if (wordsOnLine.length > 0) lines.push(wordsOnLine.join(" "));
        return lines.join("\n");
    }
    static toDataUrl = (url)=>fetch(url, {
            mode: "cors"
        }).then((response)=>response.blob()).then((blob)=>new Promise((resolve, reject)=>{
                const reader = new FileReader();
                reader.onloadend = ()=>resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            }));
}
exports.default = utils;

},{"../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jK21R":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Raphael", ()=>Raphael);
var _eveJs = require("../eve.js");
var _raphaelCoreJs = require("./raphael.core.js");
const Raphael = function() {
    const has = "hasOwnProperty";
    const Str = String;
    const toFloat = parseFloat;
    const toInt = parseInt;
    const math = Math;
    const mmax = math.max;
    const { abs } = math;
    const { pow } = math;
    const separator = /[, ]+/;
    const E = "";
    const S = " ";
    const xlink = "http://www.w3.org/1999/xlink";
    const markers = {
        block: "M5,0 0,2.5 5,5z",
        classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
        diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
        open: "M6,1 1,3.5 6,6",
        oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
    };
    const markerCounter = {};
    var $ = function(el, attr) {
        if (attr) {
            if (typeof el === "string") el = $(el);
            for(const key in attr)if (attr[has](key)) {
                if (key.substring(0, 6) == "xlink:") el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                else el.setAttribute(key, Str(attr[key]));
            }
        } else {
            el = (0, _raphaelCoreJs.R)._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
            el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
        }
        return el;
    };
    const addGradientFill = function(element, gradient) {
        let type = "linear";
        let id = element.id + gradient;
        let fx = 0.5;
        let fy = 0.5;
        const o = element.node;
        const SVG = element.paper;
        const s = o.style;
        let el = (0, _raphaelCoreJs.R)._g.doc.getElementById(id);
        if (!el) {
            gradient = Str(gradient).replace((0, _raphaelCoreJs.R)._radial_gradient, (all, _fx, _fy)=>{
                type = "radial";
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    const dir = (fy > 0.5) * 2 - 1(fx - 0.5) ** 2 + (fy - 0.5) ** 2 > 0.25 && (fy = math.sqrt(0.25 - (fx - 0.5) ** 2) * dir + 0.5) && fy != 0.5 && (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == "linear") {
                let angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) return null;
                var vector = [
                    0,
                    0,
                    math.cos((0, _raphaelCoreJs.R).rad(angle)),
                    math.sin((0, _raphaelCoreJs.R).rad(angle))
                ];
                const max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            const dots = (0, _raphaelCoreJs.R)._parseDots(gradient);
            if (!dots) return null;
            id = id.replace(/[\(\)\s,\xb0#]/g, "_");
            if (element.gradient && id != element.gradient.id) {
                SVG.defs.removeChild(element.gradient);
                delete element.gradient;
            }
            if (!element.gradient) {
                el = $(`${type}Gradient`, {
                    id
                });
                element.gradient = el;
                $(el, type == "radial" ? {
                    fx,
                    fy
                } : {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3],
                    gradientTransform: element.matrix.invert()
                });
                SVG.defs.appendChild(el);
                for(let i = 0, ii = dots.length; i < ii; i++)el.appendChild($("stop", {
                    offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                    "stop-color": dots[i].color || "#fff",
                    "stop-opacity": isFinite(dots[i].opacity) ? dots[i].opacity : 1
                }));
            }
        }
        $(o, {
            fill: fillurl(id),
            opacity: 1,
            "fill-opacity": 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
    };
    const isIE9or10 = function() {
        const mode = document.documentMode;
        return mode && (mode === 9 || mode === 10);
    };
    var fillurl = function(id) {
        // SLATEBOX - always make the fillurl relative to the page, makes svg exports work
        return `url('#${id}')`;
    // if (isIE9or10()) {
    //     return "url('#" + id + "')";
    // }
    // var location = document.location;
    // var locationString = (
    //     location.protocol + '//' +
    //     location.host +
    //     location.pathname +
    //     location.search
    // );
    // return "url('" + locationString + "#" + id + "')";
    };
    // SLATEBOX - edit for image filling (not tiling patterns) of path elements
    const updatePosition = function(o) {
        if (!o.data("relativeFill")) {
            const bbox = o.getBBox(1);
            $(o.pattern, {
                patternTransform: `${o.matrix.invert()} translate(${bbox.x},${bbox.y})`
            });
        }
    };
    const addArrow = function(o, value, isEnd) {
        if (o.type == "path") {
            const values = Str(value).toLowerCase().split("-");
            const p = o.paper;
            const se = isEnd ? "end" : "start";
            const { node } = o;
            const { attrs } = o;
            const stroke = attrs["stroke-width"];
            let i = values.length;
            let type = "classic";
            let from;
            let to;
            let dx;
            let refX;
            let attr;
            let w = 3;
            let h = 3;
            let t = 5;
            while(i--)switch(values[i]){
                case "block":
                case "classic":
                case "oval":
                case "diamond":
                case "open":
                case "none":
                    type = values[i];
                    break;
                case "wide":
                    h = 5;
                    break;
                case "narrow":
                    h = 2;
                    break;
                case "long":
                    w = 5;
                    break;
                case "short":
                    w = 2;
                    break;
            }
            if (type == "open") {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: "none",
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: "none"
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else o._.arrows = {};
            if (type != "none") {
                const pathId = `raphael-marker-${type}`;
                const markerId = `raphael-marker-${se}${type}${w}${h}-obj${o.id}`;
                // SLATEBOX - addition to make sure arrows show in svg extract
                if (!(0, _raphaelCoreJs.R)._g.doc.getElementById(pathId) || (0, _raphaelCoreJs.R)._g.doc.getElementById(pathId) && getComputedStyle((0, _raphaelCoreJs.R)._g.doc.getElementById(pathId)).display === "none") {
                    p.defs.appendChild($($("path"), {
                        "stroke-linecap": "round",
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else markerCounter[pathId]++;
                let marker = (0, _raphaelCoreJs.R)._g.doc.getElementById(markerId);
                let use;
                if (!marker) {
                    marker = $($("marker"), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: "auto",
                        refX,
                        refY: h / 2
                    });
                    use = $($("use"), {
                        "xlink:href": `#${pathId}`,
                        transform: `${isEnd ? `rotate(180 ${w / 2} ${h / 2}) ` : E}scale(${w / t},${h / t})`,
                        "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName("use")[0];
                }
                $(use, attr);
                const delta = dx * (type != "diamond" && type != "oval");
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {};
                attr[`marker-${se}`] = `url(#${markerId})`;
                if (to || from) attr.d = (0, _raphaelCoreJs.R).getSubpath(attrs.path, from, to);
                $(node, attr);
                o._.arrows[`${se}Path`] = pathId;
                o._.arrows[`${se}Marker`] = markerId;
                o._.arrows[`${se}dx`] = delta;
                o._.arrows[`${se}Type`] = type;
                o._.arrows[`${se}String`] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[`${se}Path`] && $(node, {
                    d: (0, _raphaelCoreJs.R).getSubpath(attrs.path, from, to)
                });
                delete o._.arrows[`${se}Path`];
                delete o._.arrows[`${se}Marker`];
                delete o._.arrows[`${se}dx`];
                delete o._.arrows[`${se}Type`];
                delete o._.arrows[`${se}String`];
            }
            for(attr in markerCounter)if (markerCounter[has](attr) && !markerCounter[attr]) {
                const item = (0, _raphaelCoreJs.R)._g.doc.getElementById(attr);
                item && item.parentNode.removeChild(item);
            }
        }
    };
    const dasharray = {
        "-": [
            3,
            1
        ],
        ".": [
            1,
            1
        ],
        "-.": [
            3,
            1,
            1,
            1
        ],
        "-..": [
            3,
            1,
            1,
            1,
            1,
            1
        ],
        ". ": [
            1,
            3
        ],
        "- ": [
            4,
            3
        ],
        "--": [
            8,
            3
        ],
        "- .": [
            4,
            3,
            1,
            3
        ],
        "--.": [
            8,
            3,
            1,
            3
        ],
        "--..": [
            8,
            3,
            1,
            3,
            1,
            3
        ]
    };
    const addDashes = function(o, value, params) {
        value = dasharray[Str(value).toLowerCase()];
        if (value) {
            const width = o.attrs["stroke-width"] || "1";
            const butt = {
                round: width,
                square: width,
                butt: 0
            }[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0;
            const dashes = [];
            let i = value.length;
            while(i--)dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
            $(o.node, {
                "stroke-dasharray": dashes.join(",")
            });
        } else $(o.node, {
            "stroke-dasharray": "none"
        });
    };
    const setFillAndStroke = function(o, params) {
        const { node } = o;
        const { attrs } = o;
        const vis = node.style.visibility;
        node.style.visibility = "hidden";
        for(let att in params)if (params[has](att)) {
            if (!(0, _raphaelCoreJs.R)._availableAttrs[has](att)) continue;
            let value = params[att];
            attrs[att] = value;
            switch(att){
                case "blur":
                    o.blur(value);
                    break;
                case "title":
                    var title = node.getElementsByTagName("title");
                    // Use the existing <title>.
                    if (title.length && (title = title[0])) title.firstChild.nodeValue = value;
                    else {
                        title = $("title");
                        const val = (0, _raphaelCoreJs.R)._g.doc.createTextNode(value);
                        title.appendChild(val);
                        node.appendChild(title);
                    }
                    break;
                case "href":
                case "target":
                    var pn = node.parentNode;
                    if (pn.tagName.toLowerCase() != "a") {
                        const hl = $("a");
                        pn.insertBefore(hl, node);
                        hl.appendChild(node);
                        pn = hl;
                    }
                    if (att == "target") pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                    else pn.setAttributeNS(xlink, att, value);
                    break;
                case "cursor":
                    node.style.cursor = value;
                    break;
                case "transform":
                    o.transform(value);
                    break;
                case "arrow-start":
                    addArrow(o, value);
                    break;
                case "arrow-end":
                    addArrow(o, value, 1);
                    break;
                case "clip-rect":
                    var rect = Str(value).split(separator);
                    if (rect.length == 4) {
                        o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                        var el = $("clipPath");
                        const rc = $("rect");
                        el.id = (0, _raphaelCoreJs.R).createUUID();
                        $(rc, {
                            x: rect[0],
                            y: rect[1],
                            width: rect[2],
                            height: rect[3]
                        });
                        el.appendChild(rc);
                        o.paper.defs.appendChild(el);
                        $(node, {
                            "clip-path": `url(#${el.id})`
                        });
                        o.clip = rc;
                    }
                    if (!value) {
                        const path = node.getAttribute("clip-path");
                        if (path) {
                            const clip = (0, _raphaelCoreJs.R)._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                            clip && clip.parentNode.removeChild(clip);
                            $(node, {
                                "clip-path": E
                            });
                            delete o.clip;
                        }
                    }
                    break;
                case "path":
                    // SLATEBOX - changed "$(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});"
                    // to $(node, {d: value ? attrs.path = value : "M0,0"}); in the line below -->
                    if (o.type == "path") {
                        $(node, {
                            d: value ? attrs.path = value : "M0,0"
                        }) // <--
                        ;
                        o._.dirty = 1;
                        if (o._.arrows) {
                            "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                            "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                    }
                    break;
                case "width":
                    node.setAttribute(att, value);
                    o._.dirty = 1;
                    if (attrs.fx) {
                        att = "x";
                        value = attrs.x;
                    } else break;
                case "x":
                    if (attrs.fx) value = -attrs.x - (attrs.width || 0);
                case "rx":
                    if (att == "rx" && o.type == "rect") break;
                case "cx":
                    node.setAttribute(att, value);
                    o.pattern && updatePosition(o);
                    o._.dirty = 1;
                    break;
                case "height":
                    node.setAttribute(att, value);
                    o._.dirty = 1;
                    if (attrs.fy) {
                        att = "y";
                        value = attrs.y;
                    } else break;
                case "y":
                    if (attrs.fy) value = -attrs.y - (attrs.height || 0);
                case "ry":
                    if (att == "ry" && o.type == "rect") break;
                case "cy":
                    node.setAttribute(att, value);
                    o.pattern && updatePosition(o);
                    o._.dirty = 1;
                    break;
                case "r":
                    if (o.type == "rect") $(node, {
                        rx: value,
                        ry: value
                    });
                    else node.setAttribute(att, value);
                    o._.dirty = 1;
                    break;
                case "src":
                    if (o.type == "image") node.setAttributeNS(xlink, "href", value);
                    break;
                case "stroke-width":
                    if (o._.sx != 1 || o._.sy != 1) value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                    node.setAttribute(att, value);
                    if (attrs["stroke-dasharray"]) addDashes(o, attrs["stroke-dasharray"], params);
                    if (o._.arrows) {
                        "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                        "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                    }
                    break;
                case "stroke-dasharray":
                    addDashes(o, value, params);
                    break;
                case "fill":
                    // SLATEBOX a few edits for image filling (not tiling patterns) of path elements
                    var relativeFill = o.data("relativeFill");
                    var isURL = Str(value).match((0, _raphaelCoreJs.R)._ISURL);
                    if (isURL) {
                        if (value.indexOf("(#") > -1) // internal reference
                        $(node, {
                            fill: value
                        });
                        else {
                            // image, external
                            el = $("pattern");
                            var ig = $("image");
                            el.id = (0, _raphaelCoreJs.R).createUUID();
                            $(el, {
                                x: 0,
                                y: 0,
                                patternUnits: relativeFill ? "objectBoundingBox" : "userSpaceOnUse",
                                height: 1,
                                width: 1
                            });
                            $(ig, {
                                x: 0,
                                y: 0,
                                "xlink:href": isURL[1]
                            });
                            el.appendChild(ig);
                            (function(el) {
                                (0, _raphaelCoreJs.R)._preload(isURL[1], function() {
                                    const w = this.offsetWidth;
                                    const h = this.offsetHeight;
                                    const tempPath = o.paper.path(o.attr("path"));
                                    const bbox = tempPath.getBBox();
                                    $(el, {
                                        width: relativeFill ? 1 : w,
                                        height: relativeFill ? 1 : h
                                    });
                                    // SLATEBOX - image fixes for FF/safari
                                    $(ig, {
                                        width: relativeFill ? o.imageOrigWidth || bbox.width : w,
                                        height: relativeFill ? o.imageOrigHeight || bbox.height : h
                                    });
                                    delete o.imageOrigHeight;
                                    delete o.imageOrigWidth;
                                    tempPath.remove();
                                // end image fixes for SB
                                });
                            })(el);
                            o.paper.defs.appendChild(el);
                            $(node, {
                                fill: `url(#${el.id})`
                            });
                            o.pattern = el;
                            o.pattern && updatePosition(o);
                        }
                        break;
                    }
                    var clr = (0, _raphaelCoreJs.R).getRGB(value);
                    if (!clr.error) {
                        delete params.gradient;
                        delete attrs.gradient;
                        !(0, _raphaelCoreJs.R).is(attrs.opacity, "undefined") && (0, _raphaelCoreJs.R).is(params.opacity, "undefined") && $(node, {
                            opacity: attrs.opacity
                        });
                        !(0, _raphaelCoreJs.R).is(attrs["fill-opacity"], "undefined") && (0, _raphaelCoreJs.R).is(params["fill-opacity"], "undefined") && $(node, {
                            "fill-opacity": attrs["fill-opacity"]
                        });
                    } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                        if ("opacity" in attrs || "fill-opacity" in attrs) {
                            var gradient = (0, _raphaelCoreJs.R)._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                var stops = gradient.getElementsByTagName("stop");
                                $(stops[stops.length - 1], {
                                    "stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)
                                });
                            }
                        }
                        attrs.gradient = value;
                        attrs.fill = "none";
                        break;
                    }
                    clr[has]("opacity") && $(node, {
                        "fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                    });
                case "stroke":
                    clr = (0, _raphaelCoreJs.R).getRGB(value);
                    node.setAttribute(att, clr.hex);
                    att == "stroke" && clr[has]("opacity") && $(node, {
                        "stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                    });
                    if (att == "stroke" && o._.arrows) {
                        "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                        "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                    }
                    break;
                case "gradient":
                    (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                    break;
                case "opacity":
                    if (attrs.gradient && !attrs[has]("stroke-opacity")) $(node, {
                        "stroke-opacity": value > 1 ? value / 100 : value
                    });
                // fall
                case "fill-opacity":
                    if (attrs.gradient) {
                        gradient = (0, _raphaelCoreJs.R)._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                        if (gradient) {
                            stops = gradient.getElementsByTagName("stop");
                            $(stops[stops.length - 1], {
                                "stop-opacity": value
                            });
                        }
                        break;
                    }
                default:
                    att == "font-size" && (value = `${toInt(value, 10)}px`);
                    var cssrule = att.replace(/(\-.)/g, (w)=>w.substring(1).toUpperCase());
                    node.style[cssrule] = value;
                    o._.dirty = 1;
                    node.setAttribute(att, value);
                    break;
            }
        }
        tuneText(o, params);
        node.style.visibility = vis;
    };
    const leading = 1.2;
    var tuneText = function(el, params) {
        if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) return;
        const a = el.attrs;
        const { node } = el;
        const fontSize = node.firstChild ? toInt((0, _raphaelCoreJs.R)._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;
        if (params[has]("text")) {
            a.text = params.text;
            while(node.firstChild)node.removeChild(node.firstChild);
            const texts = Str(params.text).split("\n");
            var tspans = [];
            let tspan;
            for(var i = 0, ii = texts.length; i < ii; i++){
                tspan = $("tspan");
                i && $(tspan, {
                    dy: fontSize * leading,
                    x: a.x
                });
                tspan.appendChild((0, _raphaelCoreJs.R)._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
        } else {
            tspans = node.getElementsByTagName("tspan");
            for(i = 0, ii = tspans.length; i < ii; i++)if (i) $(tspans[i], {
                dy: fontSize * leading,
                x: a.x
            });
            else $(tspans[0], {
                dy: 0
            });
        }
        $(node, {
            x: a.x,
            y: a.y
        });
        el._.dirty = 1;
        const bb = el._getBBox();
        const dif = a.y - (bb.y + bb.height / 2);
        dif && (0, _raphaelCoreJs.R).is(dif, "finite") && $(tspans[0], {
            dy: dif
        });
    };
    const getRealNode = function(node) {
        if (node.parentNode && node.parentNode.tagName.toLowerCase() === "a") return node.parentNode;
        return node;
    };
    const Element = function(node, svg) {
        const X = 0;
        const Y = 0;
        /* \
       * Element.node
       [ property (object) ]
       **
       * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
       **
       * Note: Dont mess with it.
       > Usage
       | // draw a circle at coordinate 10,10 with radius of 10
       | var c = paper.circle(10, 10, 10);
       | c.node.onclick = function () {
       |     c.attr("fill", "red");
       | };
      \ */ this[0] = this.node = node;
        /* \
       * Element.raphael
       [ property (object) ]
       **
       * Internal reference to @Raphael object. In case it is not available.
       > Usage
       | Raphael.el.red = function () {
       |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
       |     hsb.h = 1;
       |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
       | }
      \ */ node.raphael = true;
        /* \
       * Element.id
       [ property (number) ]
       **
       * Unique id of the element. Especially useful when you want to listen to events of the element,
       * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
      \ */ this.id = guid();
        node.raphaelid = this.id;
        /**
     * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements
     * @returns {string} id
     */ function guid() {
            return `0000${(Math.random() * 36 ** 5 << 0).toString(36)}`.slice(-5);
        }
        this.matrix = (0, _raphaelCoreJs.R).matrix();
        this.realPath = null;
        /* \
       * Element.paper
       [ property (object) ]
       **
       * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.
       > Usage
       | Raphael.el.cross = function () {
       |     this.attr({fill: "red"});
       |     this.paper.path("M10,10L50,50M50,10L10,50")
       |         .attr({stroke: "red"});
       | }
      \ */ this.paper = svg;
        this.attrs = this.attrs || {};
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };
        !svg.bottom && (svg.bottom = this);
        /* \
       * Element.prev
       [ property (object) ]
       **
       * Reference to the previous element in the hierarchy.
      \ */ this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        /* \
       * Element.next
       [ property (object) ]
       **
       * Reference to the next element in the hierarchy.
      \ */ this.next = null;
    };
    const elproto = (0, _raphaelCoreJs.R).el;
    Element.prototype = elproto;
    elproto.constructor = Element;
    (0, _raphaelCoreJs.R)._engine.path = function(pathString, SVG) {
        const el = $("path");
        SVG.canvas && SVG.canvas.appendChild(el);
        const p = new Element(el, SVG);
        p.type = "path";
        setFillAndStroke(p, {
            fill: "none",
            stroke: "#000",
            path: pathString
        });
        return p;
    };
    /* \
   * Element.rotate
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds rotation by given angle around given point to the list of
   * transformations of the element.
   > Parameters
   - deg (number) angle in degrees
   - cx (number) #optional x coordinate of the centre of rotation
   - cy (number) #optional y coordinate of the centre of rotation
   * If cx & cy arent specified centre of the shape is used as a point of rotation.
   = (object) @Element
  \ */ elproto.rotate = function(deg, cx, cy) {
        if (this.removed) return this;
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            const bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([
            [
                "r",
                deg,
                cx,
                cy
            ]
        ]));
        return this;
    };
    /* \
   * Element.scale
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds scale by given amount relative to given point to the list of
   * transformations of the element.
   > Parameters
   - sx (number) horisontal scale amount
   - sy (number) vertical scale amount
   - cx (number) #optional x coordinate of the centre of scale
   - cy (number) #optional y coordinate of the centre of scale
   * If cx & cy arent specified centre of the shape is used instead.
   = (object) @Element
  \ */ elproto.scale = function(sx, sy, cx, cy) {
        if (this.removed) return this;
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        sy == null && (sy = sx);
        cy == null && (cx = cy);
        if (cx == null || cy == null) var bbox = this.getBBox(1);
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([
            [
                "s",
                sx,
                sy,
                cx,
                cy
            ]
        ]));
        return this;
    };
    /* \
   * Element.translate
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds translation by given amount to the list of transformations of the element.
   > Parameters
   - dx (number) horisontal shift
   - dy (number) vertical shift
   = (object) @Element
  \ */ elproto.translate = function(dx, dy) {
        if (this.removed) return this;
        dx = Str(dx).split(separator);
        if (dx.length - 1) dy = toFloat(dx[1]);
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([
            [
                "t",
                dx,
                dy
            ]
        ]));
        return this;
    };
    /* \
   * Element.transform
   [ method ]
   **
   * Adds transformation to the element which is separate to other attributes,
   * i.e. translation doesnt change `x` or `y` of the rectange. The format
   * of transformation string is similar to the path string syntax:
   | "t100,100r30,100,100s2,2,100,100r45s1.5"
   * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
   * scale and `m` is for matrix.
   *
   * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
   *
   * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;
   * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin
   * coordinates as optional parameters, the default is the centre point of the element.
   * Matrix accepts six parameters.
   > Usage
   | var el = paper.rect(10, 20, 300, 200);
   | // translate 100, 100, rotate 45, translate -100, 0
   | el.transform("t100,100r45t-100,0");
   | // if you want you can append or prepend transformations
   | el.transform("...t50,50");
   | el.transform("s2...");
   | // or even wrap
   | el.transform("t50,50...t-50-50");
   | // to reset transformation call method with empty string
   | el.transform("");
   | // to get current value call it without parameters
   | console.log(el.transform());
   > Parameters
   - tstr (string) #optional transformation string
   * If tstr isnt specified
   = (string) current transformation string
   * else
   = (object) @Element
  \ */ elproto.transform = function(tstr) {
        const { _ } = this;
        if (tstr == null) return _.transform;
        (0, _raphaelCoreJs.R)._extractTransform(this, tstr);
        this.clip && $(this.clip, {
            transform: this.matrix.invert()
        });
        this.pattern && updatePosition(this);
        this.node && $(this.node, {
            transform: this.matrix
        });
        if (_.sx != 1 || _.sy != 1) {
            const sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
            this.attr({
                "stroke-width": sw
            });
        }
        return this;
    };
    /* \
   * Element.hide
   [ method ]
   **
   * Makes element invisible. See @Element.show.
   = (object) @Element
  \ */ elproto.hide = function() {
        if (!this.removed) this.node.style.display = "none";
        return this;
    };
    /* \
   * Element.show
   [ method ]
   **
   * Makes element visible. See @Element.hide.
   = (object) @Element
  \ */ elproto.show = function() {
        if (!this.removed) this.node.style.display = "";
        return this;
    };
    /* \
   * Element.remove
   [ method ]
   **
   * Removes element from the paper.
  \ */ elproto.remove = function() {
        const node = getRealNode(this.node);
        if (this.removed || !node.parentNode) return;
        const { paper } = this;
        paper.__set__ && paper.__set__.exclude(this);
        (0, _eveJs.eve).unbind(`raphael.*.*.${this.id}`);
        if (this.gradient) paper.defs.removeChild(this.gradient);
        (0, _raphaelCoreJs.R)._tear(this, paper);
        node.parentNode.removeChild(node);
        // Remove custom data for element
        this.removeData();
        for(const i in this)this[i] = typeof this[i] === "function" ? (0, _raphaelCoreJs.R)._removedFactory(i) : null;
        this.removed = true;
    };
    elproto._getBBox = function() {
        if (this.node.style.display == "none") {
            this.show();
            var hide = true;
        }
        let canvasHidden = false;
        let containerStyle;
        if (this.paper.canvas.parentElement) containerStyle = this.paper.canvas.parentElement.style;
        else if (this.paper.canvas.parentNode) containerStyle = this.paper.canvas.parentNode.style;
        if (containerStyle && containerStyle.display == "none") {
            canvasHidden = true;
            containerStyle.display = "";
        }
        let bbox = {};
        try {
            bbox = this.node.getBBox();
        } catch (e) {
            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
            bbox = {
                x: this.node.clientLeft,
                y: this.node.clientTop,
                width: this.node.clientWidth,
                height: this.node.clientHeight
            };
        } finally{
            bbox = bbox || {};
            if (canvasHidden) containerStyle.display = "none";
        }
        hide && this.hide();
        return bbox;
    };
    /* \
   * Element.attr
   [ method ]
   **
   * Sets the attributes of the element.
   > Parameters
   - attrName (string) attributes name
   - value (string) value
   * or
   - params (object) object of name/value pairs
   * or
   - attrName (string) attributes name
   * or
   - attrNames (array) in this case method returns array of current values for given attribute names
   = (object) @Element if attrsName & value or params are passed in.
   = (...) value of the attribute if only attrsName is passed in.
   = (array) array of values of the attribute if attrsNames is passed in.
   = (object) object of attributes if nothing is passed in.
   > Possible parameters
   # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
   o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
   o clip-rect (string) comma or space separated values: x, y, width and height
   o cursor (string) CSS type of the cursor
   o cx (number) the x-axis coordinate of the center of the circle, or ellipse
   o cy (number) the y-axis coordinate of the center of the circle, or ellipse
   o fill (string) colour, gradient or image
   o fill-opacity (number)
   o font (string)
   o font-family (string)
   o font-size (number) font size in pixels
   o font-weight (string)
   o height (number)
   o href (string) URL, if specified element behaves as hyperlink
   o opacity (number)
   o path (string) SVG path string format
   o r (number) radius of the circle, ellipse or rounded corner on the rect
   o rx (number) horisontal radius of the ellipse
   o ry (number) vertical radius of the ellipse
   o src (string) image URL, only works for @Element.image element
   o stroke (string) stroke colour
   o stroke-dasharray (string) [, none, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]
   o stroke-linecap (string) [`butt`, `square`, `round`]
   o stroke-linejoin (string) [`bevel`, `round`, `miter`]
   o stroke-miterlimit (number)
   o stroke-opacity (number)
   o stroke-width (number) stroke width in pixels, default is '1'
   o target (string) used with href
   o text (string) contents of the text element. Use `\n` for multiline text
   o text-anchor (string) [`start`, `middle`, `end`], default is `middle`
   o title (string) will create tooltip with a given text
   o transform (string) see @Element.transform
   o width (number)
   o x (number)
   o y (number)
   > Gradients
   * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90
   * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.
   *
   * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` 
   * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point
   * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
   > Path String
   # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a paths data attributes format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphal fully supports it.</p>
   > Colour Parsing
   # <ul>
   #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
   #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
   #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
   #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
   #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
   #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>
   #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>
   #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
   #     <li>hsb(%, %, %)  same as above, but in %</li>
   #     <li>hsba(, , , )  same as above, but with opacity</li>
   #     <li>hsl(, , )  almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
   #     <li>hsl(%, %, %)  same as above, but in %</li>
   #     <li>hsla(, , , )  same as above, but with opacity</li>
   #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>
   # </ul>
  \ */ elproto.attr = function(name, value) {
        if (this.removed) return this;
        if (name == null) {
            const res = {};
            for(const a in this.attrs)if (this.attrs[has](a)) res[a] = this.attrs[a];
            res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && (0, _raphaelCoreJs.R).is(name, "string")) {
            if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) return this.attrs.gradient;
            if (name == "transform") return this._.transform;
            const names = name.split(separator);
            var out = {};
            for(var i = 0, ii = names.length; i < ii; i++){
                name = names[i];
                if (name in this.attrs) out[name] = this.attrs[name];
                else if ((0, _raphaelCoreJs.R).is(this.paper.customAttributes[name], "function")) out[name] = this.paper.customAttributes[name].def;
                else out[name] = (0, _raphaelCoreJs.R)._availableAttrs[name];
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && (0, _raphaelCoreJs.R).is(name, "array")) {
            out = {};
            for(i = 0, ii = name.length; i < ii; i++)out[name[i]] = this.attr(name[i]);
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && (0, _raphaelCoreJs.R).is(name, "object")) params = name;
        for(var key in params)(0, _eveJs.eve)(`raphael.attr.${key}.${this.id}`, this, params[key]);
        for(key in this.paper.customAttributes)if (this.paper.customAttributes[has](key) && params[has](key) && (0, _raphaelCoreJs.R).is(this.paper.customAttributes[key], "function")) {
            const par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for(const subkey in par)if (par[has](subkey)) params[subkey] = par[subkey];
        }
        setFillAndStroke(this, params);
        return this;
    };
    /* \
   * Element.toFront
   [ method ]
   **
   * Moves the element so it is the closest to the viewers eyes, on top of other elements.
   = (object) @Element
  \ */ elproto.toFront = function() {
        if (this.removed) return this;
        const node = getRealNode(this.node);
        node.parentNode.appendChild(node);
        const svg = this.paper;
        svg.top != this && (0, _raphaelCoreJs.R)._tofront(this, svg);
        return this;
    };
    /* \
   * Element.toBack
   [ method ]
   **
   * Moves the element so it is the furthest from the viewers eyes, behind other elements.
   = (object) @Element
  \ */ elproto.toBack = function() {
        if (this.removed) return this;
        const node = getRealNode(this.node);
        const { parentNode } = node;
        parentNode.insertBefore(node, parentNode.firstChild);
        (0, _raphaelCoreJs.R)._toback(this, this.paper);
        const svg = this.paper;
        return this;
    };
    /* \
   * Element.insertAfter
   [ method ]
   **
   * Inserts current object after the given one.
   = (object) @Element
  \ */ elproto.insertAfter = function(element) {
        if (this.removed || !element) return this;
        const node = getRealNode(this.node);
        const afterNode = getRealNode(element.node || element[element.length - 1].node);
        if (afterNode.nextSibling) afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
        else afterNode.parentNode.appendChild(node);
        (0, _raphaelCoreJs.R)._insertafter(this, element, this.paper);
        return this;
    };
    /* \
   * Element.insertBefore
   [ method ]
   **
   * Inserts current object before the given one.
   = (object) @Element
  \ */ elproto.insertBefore = function(element) {
        if (this.removed || !element) return this;
        const node = getRealNode(this.node);
        const beforeNode = getRealNode(element.node || element[0].node);
        beforeNode.parentNode.insertBefore(node, beforeNode);
        (0, _raphaelCoreJs.R)._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function(size) {
        // Experimental. No Safari support. Use it on your own risk.
        const t = this;
        if (+size !== 0) {
            const fltr = $("filter");
            const blur = $("feGaussianBlur");
            t.attrs.blur = size;
            fltr.id = (0, _raphaelCoreJs.R).createUUID();
            $(blur, {
                stdDeviation: +size || 1.5
            });
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {
                filter: `url(#${fltr.id})`
            });
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute("filter");
        }
        return t;
    };
    (0, _raphaelCoreJs.R)._engine.circle = function(svg, x, y, r) {
        const el = $("circle");
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            cx: x,
            cy: y,
            r,
            fill: "none",
            stroke: "#000"
        };
        res.type = "circle";
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.rect = function(svg, x, y, w, h, r) {
        const el = $("rect");
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            width: w,
            height: h,
            rx: r || 0,
            ry: r || 0,
            fill: "none",
            stroke: "#000"
        };
        res.type = "rect";
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.g = function(svg) {
        const el = $("g");
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.type = "g";
        res.canvas = res.node;
        // adding support for adding elements inside <g>
        const elements = [
            "circle",
            "rect",
            "ellipse",
            "image",
            "text",
            "g",
            "path"
        ];
        elements.forEach((element)=>{
            res[element] = function() {
                const args = [
                    res
                ];
                for(let i = 0; i < arguments.length; i++)args.push(arguments[i]);
                const out = (0, _raphaelCoreJs.R)._engine[element].apply(this, args);
                return out;
            };
        });
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.def = function(def) {
        // SLATEBOX - add ability to programattically add defs
        // {
        //   type: "pattern",
        //   id: "smallGrid",
        //   height: 10,
        //   width: 10,
        //   patternUnits: "userSpaceOnUse",
        //   inside: {
        //     type: "path",
        //     attrs: {
        //       d: "M 10 0 L 0 0 0 10",
        //       fill: "none",
        //       stroke: "gray",
        //       "stroke-width": "0.5"
        //     }
        //   }
        // }
        /*
      <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
        <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" stroke-width="0.5"/>
      </pattern>
    */ const id = def.id || `raphael-def-${(0, _raphaelCoreJs.R).createUUID()}`;
        // if exists, remove and rebuild
        const exists = Array.prototype.slice.call(this.defs.children).find((c)=>c.getAttribute("id") === id);
        exists && this.defs.removeChild(exists);
        const defOpts = {
            id
        };
        Object.assign(defOpts, {
            ...def
        });
        // no need to have inside=[object object] as it is used elsewhere below
        delete defOpts.inside;
        // if (def.height != null) defOpts.height = def.height;
        // if (def.width != null) defOpts.width = def.width;
        // switch (def.type) {
        //   case "pattern": {
        //     defOpts.patternUnits = def.patternUnits || "userSpaceOnUse";
        //     break;
        //   }
        //   case "filter": {
        //     if (def.x != null) defOpts.x = def.x;
        //     if (def.y != null) defOpts.y = def.y;
        //     break;
        //   }
        //   case "style": {
        //     defOpts.type = "text/css";
        //     break;
        //   }
        //   case "path": {
        //     Object.assign(defOpts, {...def});
        //     break;
        //   }
        // }
        // always rebuild
        const rDef = $($(def.tag || "pattern"), defOpts);
        if (def.inside) def.inside.forEach((i)=>{
            const ins = $($(i.type), i.attrs || {});
            rDef.appendChild(ins);
            if (i.nested) {
                if (i.nested.forEach) i.nested.forEach((nx)=>{
                    const nest = $($(nx.type), nx.attrs || {});
                    ins.appendChild(nest);
                });
                else Object.keys(i.nested).forEach((n)=>{
                    const nest = $($(n), i.nested[n] || {});
                    ins.appendChild(nest);
                });
            }
        });
        this.defs.appendChild(rDef);
    };
    (0, _raphaelCoreJs.R)._engine.ellipse = function(svg, x, y, rx, ry) {
        const el = $("ellipse");
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            cx: x,
            cy: y,
            rx,
            ry,
            fill: "none",
            stroke: "#000"
        };
        res.type = "ellipse";
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.image = function(svg, src, x, y, w, h) {
        const el = $("image");
        $(el, {
            x,
            y,
            width: w,
            height: h,
            preserveAspectRatio: "none"
        });
        el.setAttributeNS(xlink, "href", src);
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            width: w,
            height: h,
            src
        };
        res.type = "image";
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.text = function(svg, x, y, text) {
        const el = $("text");
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            "text-anchor": "middle",
            text,
            "font-family": (0, _raphaelCoreJs.R)._availableAttrs["font-family"],
            "font-size": (0, _raphaelCoreJs.R)._availableAttrs["font-size"],
            stroke: "none",
            fill: "#000"
        };
        res.type = "text";
        setFillAndStroke(res, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.setSize = function(width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute("width", this.width);
        this.canvas.setAttribute("height", this.height);
        if (this._viewBox) this.setViewBox.apply(this, this._viewBox);
        return this;
    };
    (0, _raphaelCoreJs.R)._engine.create = function() {
        const con = (0, _raphaelCoreJs.R)._getContainer.apply(0, arguments);
        let container = con && con.container;
        let { x, y, width, height } = con;
        if (!container) throw new Error("SVG container not found.");
        const cnvs = $("svg");
        const css = "overflow:hidden;";
        let isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height,
            width,
            xmlns: "http://www.w3.org/2000/svg"
        });
        if (container == 1) {
            cnvs.style.cssText = `${css}position:absolute;left:${x}px;top:${y}px`;
            (0, _raphaelCoreJs.R)._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = `${css}position:relative`;
            if (container.firstChild) container.insertBefore(cnvs, container.firstChild);
            else container.appendChild(cnvs);
        }
        container = new (0, _raphaelCoreJs.R)._Paper();
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function() {});
        container.renderfix();
        return container;
    };
    (0, _raphaelCoreJs.R)._engine.setViewBox = function(x, y, w, h, fit) {
        (0, _eveJs.eve)("raphael.setViewBox", this, this._viewBox, [
            x,
            y,
            w,
            h,
            fit
        ]);
        const paperSize = this.getSize();
        let size = mmax(w / paperSize.width, h / paperSize.height);
        let { top } = this;
        const aspectRatio = fit ? "xMidYMid meet" : "xMinYMin";
        let vb;
        let sw;
        if (x == null) {
            if (this._vbSize) size = 1;
            delete this._vbSize;
            vb = `0 0 ${this.width}${S}${this.height}`;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while(size && top){
            sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
            top.attr({
                "stroke-width": sw
            });
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [
            x,
            y,
            w,
            h,
            !!fit
        ];
        return this;
    };
    /* \
   * Paper.renderfix
   [ method ]
   **
   * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent
   * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
   * This method fixes the issue.
   **
     Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
  \ */ (0, _raphaelCoreJs.R).prototype.renderfix = function() {
        const cnvs = this.canvas;
        const s = cnvs.style;
        let pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        const left = -pos.e % 1;
        const top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = `${this._left}px`;
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = `${this._top}px`;
            }
        }
    };
    /* \
   * Paper.clear
   [ method ]
   **
   * Clears the paper, i.e. removes all the elements.
  \ */ (0, _raphaelCoreJs.R).prototype.clear = function() {
        (0, _raphaelCoreJs.R).eve("raphael.clear", this);
        const c = this.canvas;
        while(c.firstChild)c.removeChild(c.firstChild);
        this.bottom = this.top = null;
        c.appendChild(this.defs = $("defs"));
    };
    /* \
   * Paper.remove
   [ method ]
   **
   * Removes the paper from the DOM.
  \ */ (0, _raphaelCoreJs.R).prototype.remove = function() {
        (0, _eveJs.eve)("raphael.remove", this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for(const i in this)this[i] = typeof this[i] === "function" ? (0, _raphaelCoreJs.R)._removedFactory(i) : null;
    };
    const setproto = (0, _raphaelCoreJs.R).st;
    for(const method in elproto)if (elproto[has](method) && !setproto[has](method)) setproto[method] = function(methodname) {
        return function() {
            const arg = arguments;
            return this.forEach((el)=>{
                el[methodname].apply(el, arg);
            });
        };
    }(method);
    return 0, _raphaelCoreJs.R;
}();

},{"../eve.js":"9FQ0M","./raphael.core.js":"5SUq7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9FQ0M":[function(require,module,exports) {
// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//  \\
//  Eve 0.5.4 - JavaScript Events Library                       \\
//  \\
//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\
//  \\
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eve", ()=>eve);
const eve = function() {
    var version = "0.5.4", has = "hasOwnProperty", separator = /[\.\/]/, comaseparator = /\s*,\s*/, wildcard = "*", numsort = function(a, b) {
        return a - b;
    }, current_event, stop, events = {
        n: {}
    }, firstDefined = function() {
        for(var i = 0, ii = this.length; i < ii; i++){
            if (typeof this[i] != "undefined") return this[i];
        }
    }, lastDefined = function() {
        var i = this.length;
        while(--i){
            if (typeof this[i] != "undefined") return this[i];
        }
    }, objtos = Object.prototype.toString, Str = String, isArray = Array.isArray || function(ar) {
        return ar instanceof Array || objtos.call(ar) == "[object Array]";
    }, /*\
   * eve
   [ method ]

   * Fires event with given `name`, given scope and other parameters.

   - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
   - scope (object) context for the event handlers
   - varargs (...) the rest of arguments will be sent to event handlers

   = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
  \*/ eve = function(name, scope) {
        var oldstop = stop, args = Array.prototype.slice.call(arguments, 2), listeners = eve.listeners(name), z = 0, l, indexed = [], queue = {}, out = [], ce = current_event;
        out.firstDefined = firstDefined;
        out.lastDefined = lastDefined;
        current_event = name;
        stop = 0;
        for(var i = 0, ii = listeners.length; i < ii; i++)if ("zIndex" in listeners[i]) {
            indexed.push(listeners[i].zIndex);
            if (listeners[i].zIndex < 0) queue[listeners[i].zIndex] = listeners[i];
        }
        indexed.sort(numsort);
        while(indexed[z] < 0){
            l = queue[indexed[z++]];
            out.push(l.apply(scope, args));
            if (stop) {
                stop = oldstop;
                return out;
            }
        }
        for(i = 0; i < ii; i++){
            l = listeners[i];
            if ("zIndex" in l) {
                if (l.zIndex == indexed[z]) {
                    out.push(l.apply(scope, args));
                    if (stop) break;
                    do {
                        z++;
                        l = queue[indexed[z]];
                        l && out.push(l.apply(scope, args));
                        if (stop) break;
                    }while (l);
                } else queue[l.zIndex] = l;
            } else {
                out.push(l.apply(scope, args));
                if (stop) break;
            }
        }
        stop = oldstop;
        current_event = ce;
        return out;
    };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
   * eve.listeners
   [ method ]

   * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

   - name (string) name of the event, dot (`.`) or slash (`/`) separated

   = (array) array of event handlers
  \*/ eve.listeners = function(name) {
        var names = isArray(name) ? name : name.split(separator), e = events, item, items, k, i, ii, j, jj, nes, es = [
            e
        ], out = [];
        for(i = 0, ii = names.length; i < ii; i++){
            nes = [];
            for(j = 0, jj = es.length; j < jj; j++){
                e = es[j].n;
                items = [
                    e[names[i]],
                    e[wildcard]
                ];
                k = 2;
                while(k--){
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
   * eve.separator
   [ method ]

   * If for some reasons you dont like default separators (`.` or `/`) you can specify yours
   * here. Be aware that if you pass a string longer than one character it will be treated as
   * a list of characters.

   - separator (string) new separator. Empty string resets to default: `.` or `/`.
  \*/ eve.separator = function(sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else separator = /[\.\/]/;
    };
    /*\
   * eve.on
   [ method ]
   **
   * Binds given event handler with a given name. You can use wildcards `*` for the names:
   | eve.on("*.under.*", f);
   | eve("mouse.under.floor"); // triggers f
   * Use @eve to trigger the listener.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
   **
   - name (array) if you dont want to use separators, you can use array of strings
   - f (function) event handler function
   **
   = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
   > Example:
   | eve.on("mouse", eatIt)(2);
   | eve.on("mouse", scream);
   | eve.on("mouse", catchIt)(1);
   * This will ensure that `catchIt` function will be called before `eatIt`.
   *
   * If you want to put your handler before non-indexed handlers, specify a negative value.
   * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.
  \*/ eve.on = function(name, f) {
        if (typeof f != "function") return function() {};
        var names = isArray(name) ? isArray(name[0]) ? name : [
            name
        ] : Str(name).split(comaseparator);
        for(var i = 0, ii = names.length; i < ii; i++)(function(name) {
            var names = isArray(name) ? name : Str(name).split(separator), e = events, exist;
            for(var i = 0, ii = names.length; i < ii; i++){
                e = e.n;
                e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {
                    n: {}
                });
            }
            e.f = e.f || [];
            for(i = 0, ii = e.f.length; i < ii; i++)if (e.f[i] == f) {
                exist = true;
                break;
            }
            !exist && e.f.push(f);
        })(names[i]);
        return function(zIndex) {
            if (+zIndex == +zIndex) f.zIndex = +zIndex;
        };
    };
    /*\
   * eve.f
   [ method ]
   **
   * Returns function that will fire given event with optional arguments.
   * Arguments that will be passed to the result function will be also
   * concated to the list of final arguments.
   | el.onclick = eve.f("click", 1, 2);
   | eve.on("click", function (a, b, c) {
   |     console.log(a, b, c); // 1, 2, [event object]
   | });
   - event (string) event name
   - varargs () and any other arguments
   = (function) possible event handler function
  \*/ eve.f = function(event) {
        var attrs = [].slice.call(arguments, 1);
        return function() {
            eve.apply(null, [
                event,
                null
            ].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
   * eve.stop
   [ method ]
   **
   * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
  \*/ eve.stop = function() {
        stop = 1;
    };
    /*\
   * eve.nt
   [ method ]
   **
   * Could be used inside event handler to figure out actual name of the event.
   **
   - subname (string) #optional subname of the event
   **
   = (string) name of the event, if `subname` is not specified
   * or
   = (boolean) `true`, if current events name contains `subname`
  \*/ eve.nt = function(subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        return cur;
    };
    /*\
   * eve.nts
   [ method ]
   **
   * Could be used inside event handler to figure out actual name of the event.
   **
   **
   = (array) names of the event
  \*/ eve.nts = function() {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
   * eve.off
   [ method ]
   **
   * Removes given function from the list of event listeners assigned to given name.
   * If no arguments specified all the events will be cleared.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
  \*/ /*\
   * eve.unbind
   [ method ]
   **
   * See @eve.off
  \*/ eve.off = eve.unbind = function(name, f) {
        if (!name) {
            eve._events = events = {
                n: {}
            };
            return;
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [
            name
        ] : Str(name).split(comaseparator);
        if (names.length > 1) {
            for(var i = 0, ii = names.length; i < ii; i++)eve.off(names[i], f);
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e, key, splice, i, ii, j, jj, cur = [
            events
        ], inodes = [];
        for(i = 0, ii = names.length; i < ii; i++)for(j = 0; j < cur.length; j += splice.length - 2){
            splice = [
                j,
                1
            ];
            e = cur[j].n;
            if (names[i] != wildcard) {
                if (e[names[i]]) {
                    splice.push(e[names[i]]);
                    inodes.unshift({
                        n: e,
                        name: names[i]
                    });
                }
            } else {
                for(key in e)if (e[has](key)) {
                    splice.push(e[key]);
                    inodes.unshift({
                        n: e,
                        name: key
                    });
                }
            }
            cur.splice.apply(cur, splice);
        }
        for(i = 0, ii = cur.length; i < ii; i++){
            e = cur[i];
            while(e.n){
                if (f) {
                    if (e.f) {
                        for(j = 0, jj = e.f.length; j < jj; j++)if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for(key in e.n)if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for(j = 0, jj = funcs.length; j < jj; j++)if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for(key in e.n)if (e.n[has](key) && e.n[key].f) delete e.n[key].f;
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for(i = 0, ii = inodes.length; i < ii; i++){
            e = inodes[i];
            for(key in e.n[e.name].f)continue prune;
            for(key in e.n[e.name].n)continue prune;
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
   * eve.once
   [ method ]
   **
   * Binds given event handler with a given name to only run once then unbind itself.
   | eve.once("login", f);
   | eve("login"); // triggers f
   | eve("login"); // no listeners
   * Use @eve to trigger the listener.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
   **
   = (function) same return function as @eve.on
  \*/ eve.once = function(name, f) {
        var f2 = function() {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
   * eve.version
   [ property (string) ]
   **
   * Current version of the library.
  \*/ eve.version = version;
    eve.toString = function() {
        return "You are running Eve " + version;
    };
    return eve;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"5SUq7":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "R", ()=>R);
var _eveJs = require("../eve.js");
const R = function() {
    /* \
   * Raphael
   [ method ]
   **
   * Creates a canvas object on which to draw.
   * You must do this first, as all future calls to drawing methods
   * from this instance will be bound to this canvas.
   > Parameters
   **
   - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
   - width (number)
   - height (number)
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - x (number)
   - y (number)
   - width (number)
   - height (number)
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.
   = (object) @Paper
   > Usage
   | // Each of the following examples create a canvas
   | // that is 320px wide by 200px high.
   | // Canvas is created at the viewports 10,50 coordinate.
   | var paper = Raphael(10, 50, 320, 200);
   | // Canvas is created at the top left corner of the #notepad element
   | // (or its top right corner in dir="rtl" elements)
   | var paper = Raphael(document.getElementById("notepad"), 320, 200);
   | // Same as above
   | var paper = Raphael("notepad", 320, 200);
   | // Image dump
   | var set = Raphael(["notepad", 320, 200, {
   |     type: "rect",
   |     x: 10,
   |     y: 10,
   |     width: 25,
   |     height: 25,
   |     stroke: "#f00"
   | }, {
   |     type: "text",
   |     x: 30,
   |     y: 40,
   |     text: "Dump"
   | }]);
  \ */ function R(first) {
        if (R.is(first, "function")) return loaded ? first() : (0, _eveJs.eve).on("raphael.DOMload", first);
        if (R.is(first, array)) return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        const args = Array.prototype.slice.call(arguments, 0);
        if (R.is(args[args.length - 1], "function")) {
            const f = args.pop();
            return loaded ? f.call(R._engine.create[apply](R, args)) : (0, _eveJs.eve).on("raphael.DOMload", ()=>{
                f.call(R._engine.create[apply](R, args));
            });
        }
        return R._engine.create[apply](R, arguments);
    }
    R.version = "2.2.0";
    R.eve = (0, _eveJs.eve);
    let loaded;
    const separator = /[, ]+/;
    const elements = {
        circle: 1,
        rect: 1,
        path: 1,
        ellipse: 1,
        text: 1,
        image: 1
    };
    const formatrg = /\{(\d+)\}/g;
    const proto = "prototype";
    const has = "hasOwnProperty";
    const g = {
        doc: document,
        win: window
    };
    const oldRaphael = {
        was: Object.prototype[has].call(g.win, "Raphael"),
        is: g.win.Raphael
    };
    const Paper = function() {
        /* \
       * Paper.ca
       [ property (object) ]
       **
       * Shortcut for @Paper.customAttributes
      \ */ /* \
       * Paper.customAttributes
       [ property (object) ]
       **
       * If you have a set of attributes that you would like to represent
       * as a function of some number you can do it easily with custom attributes:
       > Usage
       | paper.customAttributes.hue = function (num) {
       |     num = num % 1;
       |     return {fill: "hsb(" + num + ", 0.75, 1)"};
       | };
       | // Custom attribute hue will change fill
       | // to be given hue with fixed saturation and brightness.
       | // Now you can use it like this:
       | var c = paper.circle(10, 10, 10).attr({hue: .45});
       | // or even like this:
       | c.animate({hue: 1}, 1e3);
       |
       | // You could also create custom attribute
       | // with multiple parameters:
       | paper.customAttributes.hsb = function (h, s, b) {
       |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
       | };
       | c.attr({hsb: "0.5 .8 1"});
       | c.animate({hsb: [1, 0, 0.5]}, 1e3);
      \ */ this.ca = this.customAttributes = {};
    };
    let paperproto;
    const appendChild = "appendChild";
    var apply = "apply";
    const concat = "concat";
    const supportsTouch = "ontouchstart" in g.win || g.win.DocumentTouch && g.doc instanceof DocumentTouch // taken from Modernizr touch test
    ;
    const E = "";
    const S = " ";
    const Str = String;
    const split = "split";
    const events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S);
    const touchMap = {
        mousedown: "touchstart",
        mousemove: "touchmove",
        mouseup: "touchend"
    };
    const lowerCase = Str.prototype.toLowerCase;
    const math = Math;
    const mmax = math.max;
    const mmin = math.min;
    const { abs } = math;
    const { pow } = math;
    const { PI } = math;
    var nu = "number";
    const string = "string";
    var array = "array";
    const toString = "toString";
    const fillString = "fill";
    const objectToString = Object.prototype.toString;
    const paper = {};
    const push = "push";
    const ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i;
    const colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;
    const isnan = {
        NaN: 1,
        Infinity: 1,
        "-Infinity": 1
    };
    const bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/;
    const { round } = math;
    const setAttribute = "setAttribute";
    const toFloat = parseFloat;
    const toInt = parseInt;
    const upperCase = Str.prototype.toUpperCase;
    const availableAttrs = R._availableAttrs = {
        "arrow-end": "none",
        "arrow-start": "none",
        blur: 0,
        "clip-rect": "0 0 1e9 1e9",
        cursor: "default",
        cx: 0,
        cy: 0,
        fill: "#fff",
        "fill-opacity": 1,
        font: '10px "Arial"',
        "font-family": '"Arial"',
        "font-size": "10",
        "font-style": "normal",
        "font-weight": 400,
        gradient: 0,
        height: 0,
        href: "http://raphaeljs.com/",
        "letter-spacing": 0,
        opacity: 1,
        path: "M0,0",
        r: 0,
        rx: 0,
        ry: 0,
        src: "",
        stroke: "#000",
        "stroke-dasharray": "",
        "stroke-linecap": "butt",
        "stroke-linejoin": "butt",
        "stroke-miterlimit": 0,
        "stroke-opacity": 1,
        "stroke-width": 1,
        target: "_blank",
        "text-anchor": "middle",
        title: "Raphael",
        transform: "",
        width: 0,
        x: 0,
        y: 0,
        class: "",
        filter: ""
    };
    const availableAnimAttrs = R._availableAnimAttrs = {
        blur: nu,
        "clip-rect": "csv",
        cx: nu,
        cy: nu,
        fill: "colour",
        "fill-opacity": nu,
        "font-size": nu,
        height: nu,
        opacity: nu,
        path: "path",
        r: nu,
        rx: nu,
        ry: nu,
        stroke: "colour",
        "stroke-opacity": nu,
        "stroke-width": nu,
        transform: "transform",
        width: nu,
        x: nu,
        y: nu
    };
    const whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g;
    const commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/;
    const hsrg = {
        hs: 1,
        rg: 1
    };
    const p2s = /,?([achlmqrstvxz]),?/gi;
    const pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi;
    const tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi;
    const pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi;
    const radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/;
    const eldata = {};
    const sortByKey = function(a, b) {
        return a.key - b.key;
    };
    const sortByNumber = function(a, b) {
        return toFloat(a) - toFloat(b);
    };
    const fun = function() {};
    const pipe = function(x) {
        return x;
    };
    const rectPath = R._rectPath = function(x, y, w, h, r) {
        if (r) return [
            [
                "M",
                x + r,
                y
            ],
            [
                "l",
                w - r * 2,
                0
            ],
            [
                "a",
                r,
                r,
                0,
                0,
                1,
                r,
                r
            ],
            [
                "l",
                0,
                h - r * 2
            ],
            [
                "a",
                r,
                r,
                0,
                0,
                1,
                -r,
                r
            ],
            [
                "l",
                r * 2 - w,
                0
            ],
            [
                "a",
                r,
                r,
                0,
                0,
                1,
                -r,
                -r
            ],
            [
                "l",
                0,
                r * 2 - h
            ],
            [
                "a",
                r,
                r,
                0,
                0,
                1,
                r,
                -r
            ],
            [
                "z"
            ]
        ];
        return [
            [
                "M",
                x,
                y
            ],
            [
                "l",
                w,
                0
            ],
            [
                "l",
                0,
                h
            ],
            [
                "l",
                -w,
                0
            ],
            [
                "z"
            ]
        ];
    };
    const ellipsePath = function(x, y, rx, ry) {
        if (ry == null) ry = rx;
        return [
            [
                "M",
                x,
                y
            ],
            [
                "m",
                0,
                -ry
            ],
            [
                "a",
                rx,
                ry,
                0,
                1,
                1,
                0,
                2 * ry
            ],
            [
                "a",
                rx,
                ry,
                0,
                1,
                1,
                0,
                -2 * ry
            ],
            [
                "z"
            ]
        ];
    };
    const getPath = R._getPath = {
        path (el) {
            return el.attr("path");
        },
        circle (el) {
            const a = el.attrs;
            return ellipsePath(a.cx, a.cy, a.r);
        },
        ellipse (el) {
            const a = el.attrs;
            return ellipsePath(a.cx, a.cy, a.rx, a.ry);
        },
        rect (el) {
            const a = el.attrs;
            return rectPath(a.x, a.y, a.width, a.height, a.r);
        },
        image (el) {
            const a = el.attrs;
            return rectPath(a.x, a.y, a.width, a.height);
        },
        text (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        set (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        g (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    /* \
     * Raphael.mapPath
     [ method ]
     **
     * Transform the path string with given matrix.
     > Parameters
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \ */ const mapPath = R.mapPath = function(path, matrix) {
        if (!matrix) return path;
        let x;
        let y;
        let i;
        let j;
        let ii;
        let jj;
        let pathi;
        path = path2curve(path);
        for(i = 0, ii = path.length; i < ii; i++){
            pathi = path[i];
            for(j = 1, jj = pathi.length; j < jj; j += 2){
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    };
    R._g = g;
    R.type = "SVG";
    R.svg = true;
    R._Paper = Paper;
    /* \
   * Raphael.fn
   [ property (object) ]
   **
   * You can add your own method to the canvas. For example if you want to draw a pie chart,
   * you can create your own pie chart function and ship it as a Raphal plugin. To do this
   * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
   * Raphal instance is created, otherwise it will take no effect. Please note that the
   * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
   * ensure any namespacing ensures proper context.
   > Usage
   | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
   |     return this.path( ... );
   | };
   | // or create namespace
   | Raphael.fn.mystuff = {
   |     arrow: function () {},
   |     star: function () {},
   |     // etc
   | };
   | var paper = Raphael(10, 10, 630, 480);
   | // then use it
   | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
   | paper.mystuff.arrow();
   | paper.mystuff.star();
  \ */ R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    /* \
   * Raphael.is
   [ method ]
   **
   * Handful of replacements for `typeof` operator.
   > Parameters
   - o () any object or primitive
   - type (string) name of the type, i.e. string, function, number, etc.
   = (boolean) is given value is of given type
  \ */ R.is = function(o, type) {
        type = lowerCase.call(type);
        if (type == "finite") return !isnan[has](+o);
        if (type == "array") return o instanceof Array;
        return type == "null" && o === null || type === typeof o && o !== null || type == "object" && o === Object(o) || type == "array" && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };
    function clone(obj) {
        if (typeof obj === "function" || Object(obj) !== obj) return obj;
        const res = new obj.constructor();
        for(const key in obj)if (obj[has](key)) res[key] = clone(obj[key]);
        return res;
    }
    /* \
   * Raphael.angle
   [ method ]
   **
   * Returns angle between two or three points
   > Parameters
   - x1 (number) x coord of first point
   - y1 (number) y coord of first point
   - x2 (number) x coord of second point
   - y2 (number) y coord of second point
   - x3 (number) #optional x coord of third point
   - y3 (number) #optional y coord of third point
   = (number) angle in degrees.
  \ */ R.angle = function(x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            const x = x1 - x2;
            const y = y1 - y2;
            if (!x && !y) return 0;
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        }
        return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
    };
    /* \
   * Raphael.rad
   [ method ]
   **
   * Transform angle to radians
   > Parameters
   - deg (number) angle in degrees
   = (number) angle in radians.
  \ */ R.rad = function(deg) {
        return deg % 360 * PI / 180;
    };
    /* \
   * Raphael.deg
   [ method ]
   **
   * Transform angle to degrees
   > Parameters
   - rad (number) angle in radians
   = (number) angle in degrees.
  \ */ R.deg = function(rad) {
        return Math.round(rad * 180 / PI % 360 * 1000) / 1000;
    };
    /* \
   * Raphael.snapTo
   [ method ]
   **
   * Snaps given value to given grid.
   > Parameters
   - values (array|number) given array of values or step of the grid
   - value (number) value to adjust
   - tolerance (number) #optional tolerance for snapping. Default is `10`.
   = (number) adjusted value.
  \ */ R.snapTo = function(values, value, tolerance) {
        tolerance = R.is(tolerance, "finite") ? tolerance : 10;
        if (R.is(values, array)) {
            let i = values.length;
            while(i--)if (abs(values[i] - value) <= tolerance) return values[i];
        } else {
            values = +values;
            const rem = value % values;
            if (rem < tolerance) return value - rem;
            if (rem > values - tolerance) return value - rem + values;
        }
        return value;
    };
    /* \
   * Raphael.createUUID
   [ method ]
   **
   * Returns RFC4122, version 4 ID
  \ */ const createUUID = R.createUUID = function(uuidRegEx, uuidReplacer) {
        return function() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    }(/[xy]/g, (c)=>{
        const r = math.random() * 16 | 0;
        const v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
    });
    /* \
   * Raphael.setWindow
   [ method ]
   **
   * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
   > Parameters
   - newwin (window) new window object
  \ */ R.setWindow = function(newwin) {
        (0, _eveJs.eve)("raphael.setWindow", R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) R._engine.initWin(g.win);
    };
    var toHex = function(color) {
        const i = g.doc.createElement("i");
        i.title = "Rapha\xebl Colour Picker";
        i.style.display = "none";
        g.doc.body.appendChild(i);
        toHex = cacher("toHex", (color)=>{
            i.style.color = color;
            return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
        });
        return toHex(color);
    };
    const hsbtoString = function() {
        return `hsb(${[
            this.h,
            this.s,
            this.b
        ]})`;
    };
    const hsltoString = function() {
        return `hsl(${[
            this.h,
            this.s,
            this.l
        ]})`;
    };
    const rgbtoString = function() {
        return this.hex;
    };
    const prepareRGB = function(r, g, b) {
        if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null && R.is(r, string)) {
            const clr = R.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r > 1 || g > 1 || b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }
        return [
            r,
            g,
            b
        ];
    };
    const packageRGB = function(r, g, b, o) {
        r *= 255;
        g *= 255;
        b *= 255;
        const rgb = {
            r,
            g,
            b,
            hex: R.rgb(r, g, b),
            toString: rgbtoString
        };
        R.is(o, "finite") && (rgb.opacity = o);
        return rgb;
    };
    /* \
   * Raphael.color
   [ method ]
   **
   * Parses the color string and returns object with all values for the given color.
   > Parameters
   - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
   = (object) Combined RGB & HSB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #,
   o     error (boolean) `true` if string cant be parsed,
   o     h (number) hue,
   o     s (number) saturation,
   o     v (number) value (brightness),
   o     l (number) lightness
   o }
  \ */ R.color = function(clr) {
        let rgb;
        if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, "string")) clr = R.getRGB(clr);
            if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {
                    hex: "none"
                };
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /* \
   * Raphael.hsb2rgb
   [ method ]
   **
   * Converts HSB values to RGB object.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - v (number) value or brightness
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #
   o }
  \ */ R.hsb2rgb = function(h, s, v, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
            v = h.b;
            s = h.s;
            o = h.o;
            h = h.h;
        }
        h *= 360;
        let R;
        let G;
        let B;
        let X;
        let C;
        h = h % 360 / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;
        h = ~~h;
        R += [
            C,
            X,
            0,
            0,
            X,
            C
        ][h];
        G += [
            X,
            C,
            C,
            X,
            0,
            0
        ][h];
        B += [
            0,
            0,
            X,
            C,
            C,
            X
        ][h];
        return packageRGB(R, G, B, o);
    };
    /* \
   * Raphael.hsl2rgb
   [ method ]
   **
   * Converts HSL values to RGB object.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - l (number) luminosity
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #
   o }
  \ */ R.hsl2rgb = function(h, s, l, o) {
        if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        let R;
        let G;
        let B;
        let X;
        let C;
        h = h % 360 / 60;
        C = 2 * s * (l < 0.5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;
        h = ~~h;
        R += [
            C,
            X,
            0,
            0,
            X,
            C
        ][h];
        G += [
            X,
            C,
            C,
            X,
            0,
            0
        ][h];
        B += [
            0,
            0,
            X,
            C,
            C,
            X
        ][h];
        return packageRGB(R, G, B, o);
    };
    /* \
   * Raphael.rgb2hsb
   [ method ]
   **
   * Converts RGB values to HSB object.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (object) HSB object in format:
   o {
   o     h (number) hue
   o     s (number) saturation
   o     b (number) brightness
   o }
  \ */ R.rgb2hsb = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];
        let H;
        let S;
        let V;
        let C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {
            h: H,
            s: S,
            b: V,
            toString: hsbtoString
        };
    };
    /* \
   * Raphael.rgb2hsl
   [ method ]
   **
   * Converts RGB values to HSL object.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (object) HSL object in format:
   o {
   o     h (number) hue
   o     s (number) saturation
   o     l (number) luminosity
   o }
  \ */ R.rgb2hsl = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];
        let H;
        let S;
        let L;
        let M;
        let m;
        let C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        L = (M + m) / 2;
        S = C == 0 ? 0 : L < 0.5 ? C / (2 * L) : C / (2 - 2 * L);
        return {
            h: H,
            s: S,
            l: L,
            toString: hsltoString
        };
    };
    R._path2string = function() {
        // 2 decimal precision always...
        return this.map((t)=>[
                t[0],
                ...t.slice(1).map((t)=>Math.round(t * 1e2) / 1e2)
            ]).join(",").replace(p2s, "$1");
    };
    function repush(array, item) {
        for(let i = 0, ii = array.length; i < ii; i++)if (array[i] === item) return array.push(array.splice(i, 1)[0]);
    }
    const CACHE = R.CACHE = {};
    function cacher(name, f, scope, postprocessor) {
        function newf() {
            const arg = Array.prototype.slice.call(arguments, 0);
            const args = arg.join("\u2400");
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            const cached = cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cached) : cached;
        }
        var cache = newf.cache = {};
        var count = newf.count = [];
        newf.clear = function() {
            cache = newf.cache = {};
            count = newf.count = [];
        };
        CACHE[name] = newf;
        return newf;
    }
    R.clearCaches = function() {
        for(const key in CACHE){
            if (!CACHE.hasOwnProperty(key)) continue;
            CACHE[key].clear();
        }
    };
    const preload = R._preload = function(src, f) {
        const img = g.doc.createElement("img");
        img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
        img.onload = function() {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function() {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };
    function clrToString() {
        return this.hex;
    }
    /* \
   * Raphael.getRGB
   [ method ]
   **
   * Parses colour string as RGB object
   > Parameters
   - colour (string) colour string in one of formats:
   # <ul>
   #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
   #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
   #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
   #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
   #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
   #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
   #     <li>hsb(%, %, %)  same as above, but in %</li>
   #     <li>hsl(, , )  same as hsb</li>
   #     <li>hsl(%, %, %)  same as hsb</li>
   # </ul>
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue
   o     hex (string) color in HTML/CSS format: #,
   o     error (boolean) true if string cant be parsed
   o }
  \ */ R.getRGB = cacher("getRGB", (colour)=>{
        if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) return {
            r: -1,
            g: -1,
            b: -1,
            hex: "none",
            error: 1,
            toString: clrToString
        };
        if (colour == "none") return {
            r: -1,
            g: -1,
            b: -1,
            hex: "none",
            toString: clrToString
        };
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
        let res;
        let red;
        let green;
        let blue;
        let opacity;
        let t;
        let values;
        let rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == "%" && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == "%" && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == "%" && (blue *= 2.55);
                (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {
                r: red,
                g: green,
                b: blue,
                toString: clrToString
            };
            rgb.hex = `#${(16777216 | blue | green << 8 | red << 16).toString(16).slice(1)}`;
            R.is(opacity, "finite") && (rgb.opacity = opacity);
            return rgb;
        }
        return {
            r: -1,
            g: -1,
            b: -1,
            hex: "none",
            error: 1,
            toString: clrToString
        };
    }, R);
    /* \
   * Raphael.hsb
   [ method ]
   **
   * Converts HSB values to hex representation of the colour.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - b (number) value or brightness
   = (string) hex representation of the colour.
  \ */ R.hsb = cacher("hsb", (h, s, b)=>R.hsb2rgb(h, s, b).hex);
    /* \
   * Raphael.hsl
   [ method ]
   **
   * Converts HSL values to hex representation of the colour.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - l (number) luminosity
   = (string) hex representation of the colour.
  \ */ R.hsl = cacher("hsl", (h, s, l)=>R.hsl2rgb(h, s, l).hex);
    /* \
   * Raphael.rgb
   [ method ]
   **
   * Converts RGB values to hex representation of the colour.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (string) hex representation of the colour.
  \ */ R.rgb = cacher("rgb", (r, g, b)=>{
        function round(x) {
            return x + 0.5 | 0;
        }
        return `#${(16777216 | round(b) | round(g) << 8 | round(r) << 16).toString(16).slice(1)}`;
    });
    /* \
   * Raphael.getColor
   [ method ]
   **
   * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
   > Parameters
   - value (number) #optional brightness, default is `0.75`
   = (string) hex representation of the colour.
  \ */ R.getColor = function(value) {
        const start = this.getColor.start = this.getColor.start || {
            h: 0,
            s: 1,
            b: value || 0.75
        };
        const rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += 0.075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= 0.2;
            start.s <= 0 && (this.getColor.start = {
                h: 0,
                s: 1,
                b: start.b
            });
        }
        return rgb.hex;
    };
    /* \
   * Raphael.getColor.reset
   [ method ]
   **
   * Resets spectrum position for @Raphael.getColor back to red.
  \ */ R.getColor.reset = function() {
        delete this.start;
    };
    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        const d = [];
        for(let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2){
            const p = [
                {
                    x: +crp[i - 2],
                    y: +crp[i - 1]
                },
                {
                    x: +crp[i],
                    y: +crp[i + 1]
                },
                {
                    x: +crp[i + 2],
                    y: +crp[i + 3]
                },
                {
                    x: +crp[i + 4],
                    y: +crp[i + 5]
                }
            ];
            if (z) {
                if (!i) p[0] = {
                    x: +crp[iLen - 2],
                    y: +crp[iLen - 1]
                };
                else if (iLen - 4 == i) p[3] = {
                    x: +crp[0],
                    y: +crp[1]
                };
                else if (iLen - 2 == i) {
                    p[2] = {
                        x: +crp[0],
                        y: +crp[1]
                    };
                    p[3] = {
                        x: +crp[2],
                        y: +crp[3]
                    };
                }
            } else if (iLen - 4 == i) p[3] = p[2];
            else if (!i) p[0] = {
                x: +crp[i],
                y: +crp[i + 1]
            };
            d.push([
                "C",
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6 * p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }
        return d;
    }
    /* \
   * Raphael.parsePathString
   [ method ]
   **
   * Utility method
   **
   * Parses given path string into an array of arrays of path segments.
   > Parameters
   - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
   = (array) array of segments.
  \ */ R.parsePathString = function(pathString) {
        if (!pathString) return null;
        const pth = paths(pathString);
        if (pth.arr) return pathClone(pth.arr);
        const paramCounts = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            r: 4,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        };
        let data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) // rough assumption
        data = pathClone(pathString);
        if (!data.length) Str(pathString).replace(pathCommand, (a, b, c)=>{
            const params = [];
            let name = b.toLowerCase();
            c.replace(pathValues, (a, b)=>{
                b && params.push(+b);
            });
            if (name == "m" && params.length > 2) {
                data.push([
                    b
                ][concat](params.splice(0, 2)));
                name = "l";
                b = b == "m" ? "l" : "L";
            }
            if (name == "r") data.push([
                b
            ][concat](params));
            else while(params.length >= paramCounts[name]){
                data.push([
                    b
                ][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) break;
            }
        });
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /* \
   * Raphael.parseTransformString
   [ method ]
   **
   * Utility method
   **
   * Parses given path string into an array of transformations.
   > Parameters
   - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
   = (array) array of transformations.
  \ */ R.parseTransformString = cacher("parseTransformString", (TString)=>{
        if (!TString) return null;
        const paramCounts = {
            r: 3,
            s: 4,
            t: 2,
            m: 6
        };
        let data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) // rough assumption
        data = pathClone(TString);
        if (!data.length) Str(TString).replace(tCommand, (a, b, c)=>{
            const params = [];
            const name = lowerCase.call(b);
            c.replace(pathValues, (a, b)=>{
                b && params.push(+b);
            });
            data.push([
                b
            ][concat](params));
        });
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function(ps) {
        const p = paths.ps = paths.ps || {};
        if (p[ps]) p[ps].sleep = 100;
        else p[ps] = {
            sleep: 100
        };
        setTimeout(()=>{
            for(const key in p)if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    /* \
   * Raphael.findDotsAtSegment
   [ method ]
   **
   * Utility method
   **
   * Find dot coordinates on the given cubic bezier curve at the given t.
   > Parameters
   - p1x (number) x of the first point of the curve
   - p1y (number) y of the first point of the curve
   - c1x (number) x of the first anchor of the curve
   - c1y (number) y of the first anchor of the curve
   - c2x (number) x of the second anchor of the curve
   - c2y (number) y of the second anchor of the curve
   - p2x (number) x of the second point of the curve
   - p2y (number) y of the second point of the curve
   - t (number) position on the curve (0..1)
   = (object) point information in format:
   o {
   o     x: (number) x coordinate of the point
   o     y: (number) y coordinate of the point
   o     m: {
   o         x: (number) x coordinate of the left anchor
   o         y: (number) y coordinate of the left anchor
   o     }
   o     n: {
   o         x: (number) x coordinate of the right anchor
   o         y: (number) y coordinate of the right anchor
   o     }
   o     start: {
   o         x: (number) x coordinate of the start of the curve
   o         y: (number) y coordinate of the start of the curve
   o     }
   o     end: {
   o         x: (number) x coordinate of the end of the curve
   o         y: (number) y coordinate of the end of the curve
   o     }
   o     alpha: (number) angle of the curve derivative at the point
   o }
  \ */ R.findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        const t1 = 1 - t;
        const t13 = t1 ** 3;
        const t12 = t1 ** 2;
        const t2 = t * t;
        const t3 = t2 * t;
        const x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
        const y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
        const mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
        const my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
        const nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
        const ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
        const ax = t1 * p1x + t * c1x;
        const ay = t1 * p1y + t * c1y;
        const cx = t1 * c2x + t * p2x;
        const cy = t1 * c2y + t * p2y;
        let alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x,
            y,
            m: {
                x: mx,
                y: my
            },
            n: {
                x: nx,
                y: ny
            },
            start: {
                x: ax,
                y: ay
            },
            end: {
                x: cx,
                y: cy
            },
            alpha
        };
    };
    /* \
   * Raphael.bezierBBox
   [ method ]
   **
   * Utility method
   **
   * Return bounding box of a given cubic bezier curve
   > Parameters
   - p1x (number) x of the first point of the curve
   - p1y (number) y of the first point of the curve
   - c1x (number) x of the first anchor of the curve
   - c1y (number) y of the first anchor of the curve
   - c2x (number) x of the second anchor of the curve
   - c2y (number) y of the second anchor of the curve
   - p2x (number) x of the second point of the curve
   - p2y (number) y of the second point of the curve
   * or
   - bez (array) array of six points for bezier curve
   = (object) point information in format:
   o {
   o     min: {
   o         x: (number) x coordinate of the left point
   o         y: (number) y coordinate of the top point
   o     }
   o     max: {
   o         x: (number) x coordinate of the right point
   o         y: (number) y coordinate of the bottom point
   o     }
   o }
  \ */ R.bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, "array")) p1x = [
            p1x,
            p1y,
            c1x,
            c1y,
            c2x,
            c2y,
            p2x,
            p2y
        ];
        const bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /* \
   * Raphael.isPointInsideBBox
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if given point is inside bounding boxes.
   > Parameters
   - bbox (string) bounding box
   - x (string) x coordinate of the point
   - y (string) y coordinate of the point
   = (boolean) `true` if point inside
  \ */ R.isPointInsideBBox = function(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /* \
   * Raphael.isBBoxIntersect
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if two bounding boxes intersect
   > Parameters
   - bbox1 (string) first bounding box
   - bbox2 (string) second bounding box
   = (boolean) `true` if they intersect
  \ */ R.isBBoxIntersect = function(bbox1, bbox2) {
        const i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y) || i(bbox2, bbox1.x2, bbox1.y) || i(bbox2, bbox1.x, bbox1.y2) || i(bbox2, bbox1.x2, bbox1.y2) || i(bbox1, bbox2.x, bbox2.y) || i(bbox1, bbox2.x2, bbox2.y) || i(bbox1, bbox2.x, bbox2.y2) || i(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        const t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
        const t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) z = 1;
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        const z2 = z / 2;
        const n = 12;
        const Tvalues = [
            -0.1252,
            0.1252,
            -0.3678,
            0.3678,
            -0.5873,
            0.5873,
            -0.7699,
            0.7699,
            -0.9041,
            0.9041,
            -0.9816,
            0.9816
        ];
        const Cvalues = [
            0.2491,
            0.2491,
            0.2335,
            0.2335,
            0.2032,
            0.2032,
            0.1601,
            0.1601,
            0.1069,
            0.1069,
            0.0472,
            0.0472
        ];
        let sum = 0;
        for(let i = 0; i < n; i++){
            const ct = z2 * Tvalues[i] + z2;
            const xbase = base3(ct, x1, x2, x3, x4);
            const ybase = base3(ct, y1, y2, y3, y4);
            const comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) return;
        const t = 1;
        let step = t / 2;
        let t2 = t - step;
        let l;
        const e = 0.01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while(abs(l - ll) > e){
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) return;
        const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
        const ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
        const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (!denominator) return;
        const px = nx / denominator;
        const py = ny / denominator;
        const px2 = +px.toFixed(2);
        const py2 = +py.toFixed(2);
        if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) return;
        return {
            x: px,
            y: py
        };
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        const bbox1 = R.bezierBBox(bez1);
        const bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) return justCount ? 0 : [];
        const l1 = bezlen.apply(0, bez1);
        const l2 = bezlen.apply(0, bez2);
        const n1 = mmax(~~(l1 / 5), 1);
        const n2 = mmax(~~(l2 / 5), 1);
        const dots1 = [];
        const dots2 = [];
        const xy = {};
        let res = justCount ? 0 : [];
        for(var i = 0; i < n1 + 1; i++){
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({
                x: p.x,
                y: p.y,
                t: i / n1
            });
        }
        for(i = 0; i < n2 + 1; i++){
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({
                x: p.x,
                y: p.y,
                t: i / n2
            });
        }
        for(i = 0; i < n1; i++)for(let j = 0; j < n2; j++){
            const di = dots1[i];
            const di1 = dots1[i + 1];
            const dj = dots2[j];
            const dj1 = dots2[j + 1];
            const ci = abs(di1.x - di.x) < 0.001 ? "y" : "x";
            const cj = abs(dj1.x - dj.x) < 0.001 ? "y" : "x";
            const is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
            if (is) {
                if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) continue;
                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                const t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
                const t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                    if (justCount) res++;
                    else res.push({
                        x: is.x,
                        y: is.y,
                        t1: mmin(t1, 1),
                        t2: mmin(t2, 1)
                    });
                }
            }
        }
        return res;
    }
    /* \
   * Raphael.pathIntersection
   [ method ]
   **
   * Utility method
   **
   * Finds intersections of two paths
   > Parameters
   - path1 (string) path string
   - path2 (string) path string
   = (array) dots of intersection
   o [
   o     {
   o         x: (number) x coordinate of the point
   o         y: (number) y coordinate of the point
   o         t1: (number) t value for segment of path1
   o         t2: (number) t value for segment of path2
   o         segment1: (number) order number for segment of path1
   o         segment2: (number) order number for segment of path2
   o         bez1: (array) eight coordinates representing bezir curve for the segment of path1
   o         bez2: (array) eight coordinates representing bezir curve for the segment of path2
   o     }
   o ]
  \ */ R.pathIntersection = function(path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function(path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        let x1;
        let y1;
        let x2;
        let y2;
        let x1m;
        let y1m;
        let x2m;
        let y2m;
        let bez1;
        let bez2;
        let res = justCount ? 0 : [];
        for(let i = 0, ii = path1.length; i < ii; i++){
            const pi = path1[i];
            if (pi[0] == "M") {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == "C") {
                    bez1 = [
                        x1,
                        y1
                    ].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [
                        x1,
                        y1,
                        x1,
                        y1,
                        x1m,
                        y1m,
                        x1m,
                        y1m
                    ];
                    x1 = x1m;
                    y1 = y1m;
                }
                for(let j = 0, jj = path2.length; j < jj; j++){
                    const pj = path2[j];
                    if (pj[0] == "M") {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == "C") {
                            bez2 = [
                                x2,
                                y2
                            ].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [
                                x2,
                                y2,
                                x2,
                                y2,
                                x2m,
                                y2m,
                                x2m,
                                y2m
                            ];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        const intr = interHelper(bez1, bez2, justCount);
                        if (justCount) res += intr;
                        else {
                            for(let k = 0, kk = intr.length; k < kk; k++){
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /* \
   * Raphael.isPointInsidePath
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if given point is inside a given closed path.
   > Parameters
   - path (string) path string
   - x (number) x of the point
   - y (number) y of the point
   = (boolean) true, if point is inside the path
  \ */ R.isPointInsidePath = function(path, x, y) {
        const bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) && interPathHelper(path, [
            [
                "M",
                x,
                y
            ],
            [
                "H",
                bbox.x2 + 10
            ]
        ], 1) % 2 == 1;
    };
    R._removedFactory = function(methodname) {
        return function() {
            (0, _eveJs.eve)("raphael.log", null, `Rapha\xebl: you are calling to method \u201c${methodname}\u201d of removed object`, methodname);
        };
    };
    /* \
   * Raphael.pathBBox
   [ method ]
   **
   * Utility method
   **
   * Return bounding box of a given path
   > Parameters
   - path (string) path string
   = (object) bounding box
   o {
   o     x: (number) x coordinate of the left top point of the box
   o     y: (number) y coordinate of the left top point of the box
   o     x2: (number) x coordinate of the right bottom point of the box
   o     y2: (number) y coordinate of the right bottom point of the box
   o     width: (number) width of the box
   o     height: (number) height of the box
   o     cx: (number) x coordinate of the center of the box
   o     cy: (number) y coordinate of the center of the box
   o }
  \ */ const pathDimensions = R.pathBBox = function(path) {
        const pth = paths(path);
        if (pth.bbox) return clone(pth.bbox);
        if (!path) return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            x2: 0,
            y2: 0
        };
        path = path2curve(path);
        let x = 0;
        let y = 0;
        let X = [];
        let Y = [];
        let p;
        for(let i = 0, ii = path.length; i < ii; i++){
            p = path[i];
            if (p[0] == "M") {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                const dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        const xmin = mmin[apply](0, X);
        const ymin = mmin[apply](0, Y);
        const xmax = mmax[apply](0, X);
        const ymax = mmax[apply](0, Y);
        const width = xmax - xmin;
        const height = ymax - ymin;
        const bb = {
            x: xmin,
            y: ymin,
            x2: xmax,
            y2: ymax,
            width,
            height,
            cx: xmin + width / 2,
            cy: ymin + height / 2
        };
        pth.bbox = clone(bb);
        return bb;
    };
    var pathClone = function(pathArray) {
        // var res = clone(pathArray);
        // Array.slice() is faster then clone(pathArray).
        const res = pathArray.slice(0);
        for(let i = 0, ii = pathArray.length; i < ii; ++i)res[i] = pathArray[i].slice(0);
        res.toString = R._path2string;
        return res;
    };
    const pathToRelative = R._pathToRelative = function(pathArray) {
        const pth = paths(pathArray);
        if (pth.rel) return pathClone(pth.rel);
        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) // rough assumption
        pathArray = R.parsePathString(pathArray);
        const res = [];
        let x = 0;
        let y = 0;
        let mx = 0;
        let my = 0;
        let start = 0;
        if (pathArray[0][0] == "M") {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push([
                "M",
                x,
                y
            ]);
        }
        for(let i = start, ii = pathArray.length; i < ii; i++){
            let r = res[i] = [];
            const pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch(r[0]){
                    case "a":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case "v":
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case "m":
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for(let j = 1, jj = pa.length; j < jj; j++)r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                }
            } else {
                r = res[i] = [];
                if (pa[0] == "m") {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for(let k = 0, kk = pa.length; k < kk; k++)res[i][k] = pa[k];
            }
            const len = res[i].length;
            switch(res[i][0]){
                case "z":
                    x = mx;
                    y = my;
                    break;
                case "h":
                    x += +res[i][len - 1];
                    break;
                case "v":
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = R._path2string;
        pth.rel = pathClone(res);
        return res;
    };
    const pathToAbsolute = R._pathToAbsolute = function(pathArray) {
        // return pathArray;
        const pth = paths(pathArray);
        if (pth.abs) return pathClone(pth.abs);
        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) // rough assumption
        pathArray = R.parsePathString(pathArray);
        if (!pathArray || !pathArray.length) return [
            [
                "M",
                0,
                0
            ]
        ];
        let res = [];
        let x = 0;
        let y = 0;
        let mx = 0;
        let my = 0;
        let start = 0;
        if (pathArray[0][0] == "M") {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = [
                "M",
                x,
                y
            ];
        }
        const crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
        for(var r, pa, i = start, ii = pathArray.length; i < ii; i++){
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch(r[0]){
                    case "A":
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case "V":
                        r[1] = +pa[1] + y;
                        break;
                    case "H":
                        r[1] = +pa[1] + x;
                        break;
                    case "R":
                        var dots = [
                            x,
                            y
                        ][concat](pa.slice(1));
                        for(var j = 2, jj = dots.length; j < jj; j++){
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case "M":
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for(j = 1, jj = pa.length; j < jj; j++)r[j] = +pa[j] + (j % 2 ? x : y);
                }
            } else if (pa[0] == "R") {
                dots = [
                    x,
                    y
                ][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = [
                    "R"
                ][concat](pa.slice(-2));
            } else for(let k = 0, kk = pa.length; k < kk; k++)r[k] = pa[k];
            switch(r[0]){
                case "Z":
                    x = mx;
                    y = my;
                    break;
                case "H":
                    x = r[1];
                    break;
                case "V":
                    y = r[1];
                    break;
                case "M":
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = R._path2string;
        pth.abs = pathClone(res);
        return res;
    };
    const l2c = function(x1, y1, x2, y2) {
        return [
            x1,
            y1,
            x2,
            y2,
            x2,
            y2
        ];
    };
    const q2c = function(x1, y1, ax, ay, x2, y2) {
        const _13 = 1 / 3;
        const _23 = 2 / 3;
        return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2
        ];
    };
    var a2c = function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        const _120 = PI * 120 / 180;
        const rad = PI / 180 * (+angle || 0);
        let res = [];
        let xy;
        const rotate = cacher("a2c.rotate", (x, y, rad)=>{
            const X = x * math.cos(rad) - y * math.sin(rad);
            const Y = x * math.sin(rad) + y * math.cos(rad);
            return {
                x: X,
                y: Y
            };
        });
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            const cos = math.cos(PI / 180 * angle);
            const sin = math.sin(PI / 180 * angle);
            const x = (x1 - x2) / 2;
            const y = (y1 - y2) / 2;
            let h = x * x / (rx * rx) + y * y / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            const rx2 = rx * rx;
            const ry2 = ry * ry;
            const k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
            var cx = k * rx * y / ry + (x1 + x2) / 2;
            var cy = k * -ry * x / rx + (y1 + y2) / 2;
            var f1 = math.asin(((y1 - cy) / ry).toFixed(9));
            var f2 = math.asin(((y2 - cy) / ry).toFixed(9));
            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) f1 -= PI * 2;
            if (!sweep_flag && f2 > f1) f2 -= PI * 2;
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        let df = f2 - f1;
        if (abs(df) > _120) {
            const f2old = f2;
            const x2old = x2;
            const y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
                f2,
                f2old,
                cx,
                cy
            ]);
        }
        df = f2 - f1;
        const c1 = math.cos(f1);
        const s1 = math.sin(f1);
        const c2 = math.cos(f2);
        const s2 = math.sin(f2);
        const t = math.tan(df / 4);
        const hx = 4 / 3 * rx * t;
        const hy = 4 / 3 * ry * t;
        const m1 = [
            x1,
            y1
        ];
        const m2 = [
            x1 + hx * s1,
            y1 - hy * c1
        ];
        const m3 = [
            x2 + hx * s2,
            y2 - hy * c2
        ];
        const m4 = [
            x2,
            y2
        ];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) return [
            m2,
            m3,
            m4
        ][concat](res);
        res = [
            m2,
            m3,
            m4
        ][concat](res).join()[split](",");
        const newres = [];
        for(let i = 0, ii = res.length; i < ii; i++)newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        return newres;
    };
    const findDotAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        const t1 = 1 - t;
        return {
            x: t1 ** 3 * p1x + t1 ** 2 * 3 * t * c1x + t1 * 3 * t * t * c2x + t ** 3 * p2x,
            y: t1 ** 3 * p1y + t1 ** 2 * 3 * t * c1y + t1 * 3 * t * t * c2y + t ** 3 * p2y
        };
    };
    var curveDim = cacher("curveDim", (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y)=>{
        let a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x);
        let b = 2 * (c1x - p1x) - 2 * (c2x - c1x);
        let c = p1x - c1x;
        let t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
        let t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
        const y = [
            p1y,
            p2y
        ];
        const x = [
            p1x,
            p2x
        ];
        let dot;
        abs(t1) > "1e12" && (t1 = 0.5);
        abs(t2) > "1e12" && (t2 = 0.5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
        c = p1y - c1y;
        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
        abs(t1) > "1e12" && (t1 = 0.5);
        abs(t2) > "1e12" && (t2 = 0.5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        return {
            min: {
                x: mmin[apply](0, x),
                y: mmin[apply](0, y)
            },
            max: {
                x: mmax[apply](0, x),
                y: mmax[apply](0, y)
            }
        };
    });
    var path2curve = R._path2curve = cacher("path2curve", (path, path2)=>{
        const pth = !path2 && paths(path);
        if (!path2 && pth.curve) return pathClone(pth.curve);
        const p = pathToAbsolute(path);
        const p2 = path2 && pathToAbsolute(path2);
        const attrs = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        };
        const attrs2 = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        };
        const processPath = function(path, d, pcom) {
            let nx;
            let ny;
            const tq = {
                T: 1,
                Q: 1
            };
            if (!path) return [
                "C",
                d.x,
                d.y,
                d.x,
                d.y,
                d.x,
                d.y
            ];
            !(path[0] in tq) && (d.qx = d.qy = null);
            switch(path[0]){
                case "M":
                    d.X = path[1];
                    d.Y = path[2];
                    break;
                case "A":
                    path = [
                        "C"
                    ][concat](a2c[apply](0, [
                        d.x,
                        d.y
                    ][concat](path.slice(1))));
                    break;
                case "S":
                    if (pcom == "C" || pcom == "S") {
                        // In "S" case we have to take into account, if the previous command is C/S.
                        nx = d.x * 2 - d.bx // And reflect the previous
                        ;
                        ny = d.y * 2 - d.by // command's control point relative to the current point.
                        ;
                    } else {
                        // or some else or nothing
                        nx = d.x;
                        ny = d.y;
                    }
                    path = [
                        "C",
                        nx,
                        ny
                    ][concat](path.slice(1));
                    break;
                case "T":
                    if (pcom == "Q" || pcom == "T") {
                        // In "T" case we have to take into account, if the previous command is Q/T.
                        d.qx = d.x * 2 - d.qx // And make a reflection similar
                        ;
                        d.qy = d.y * 2 - d.qy // to case "S".
                        ;
                    } else {
                        // or something else or nothing
                        d.qx = d.x;
                        d.qy = d.y;
                    }
                    path = [
                        "C"
                    ][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                    break;
                case "Q":
                    d.qx = path[1];
                    d.qy = path[2];
                    path = [
                        "C"
                    ][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                    break;
                case "L":
                    path = [
                        "C"
                    ][concat](l2c(d.x, d.y, path[1], path[2]));
                    break;
                case "H":
                    path = [
                        "C"
                    ][concat](l2c(d.x, d.y, path[1], d.y));
                    break;
                case "V":
                    path = [
                        "C"
                    ][concat](l2c(d.x, d.y, d.x, path[1]));
                    break;
                case "Z":
                    path = [
                        "C"
                    ][concat](l2c(d.x, d.y, d.X, d.Y));
                    break;
            }
            return path;
        };
        const fixArc = function(pp, i) {
            if (pp[i].length > 7) {
                pp[i].shift();
                const pi = pp[i];
                while(pi.length){
                    pcoms1[i] = "A" // if created multiple C:s, their original seg is saved
                    ;
                    p2 && (pcoms2[i] = "A" // the same as above
                    );
                    pp.splice(i++, 0, [
                        "C"
                    ][concat](pi.splice(0, 6)));
                }
                pp.splice(i, 1);
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        const fixM = function(path1, path2, a1, a2, i) {
            if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                path2.splice(i, 0, [
                    "M",
                    a2.x,
                    a2.y
                ]);
                a1.bx = 0;
                a1.by = 0;
                a1.x = path1[i][1];
                a1.y = path1[i][2];
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        var pcoms1 = [] // path commands of original path p
        ;
        var pcoms2 = [] // path commands of original path p2
        ;
        let pfirst = "" // temporary holder for original path command
        ;
        let pcom = "" // holder for previous path command of original path
        ;
        for(var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++){
            p[i] && (pfirst = p[i][0] // save current path command
            );
            if (pfirst != "C") {
                // C is not saved yet, because it may be result of conversion
                pcoms1[i] = pfirst // Save current path command
                ;
                i && (pcom = pcoms1[i - 1] // Get previous path command pcom
                );
            }
            p[i] = processPath(p[i], attrs, pcom) // Previous path command is inputted to processPath
            ;
            if (pcoms1[i] != "A" && pfirst == "C") pcoms1[i] = "C" // A is the only command
            ;
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path
            fixArc(p, i) // fixArc adds also the right amount of A:s to pcoms1
            ;
            if (p2) {
                // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != "C") {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i - 1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);
                if (pcoms2[i] != "A" && pfirst == "C") pcoms2[i] = "C";
                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            const seg = p[i];
            const seg2 = p2 && p2[i];
            const seglen = seg.length;
            const seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) pth.curve = pathClone(p);
        return p2 ? [
            p,
            p2
        ] : p;
    }, null, pathClone);
    const parseDots = R._parseDots = cacher("parseDots", (gradient)=>{
        const dots = [];
        for(var i = 0, ii = gradient.length; i < ii; i++){
            const dot = {};
            const par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
            dot.color = R.getRGB(par[1]);
            if (dot.color.error) return null;
            dot.opacity = dot.color.opacity;
            dot.color = dot.color.hex;
            par[2] && (dot.offset = `${par[2]}%`);
            dots.push(dot);
        }
        for(i = 1, ii = dots.length - 1; i < ii; i++)if (!dots[i].offset) {
            let start = toFloat(dots[i - 1].offset || 0);
            let end = 0;
            for(var j = i + 1; j < ii; j++)if (dots[j].offset) {
                end = dots[j].offset;
                break;
            }
            if (!end) {
                end = 100;
                j = ii;
            }
            end = toFloat(end);
            const d = (end - start) / (j - i + 1);
            for(; i < j; i++){
                start += d;
                dots[i].offset = `${start}%`;
            }
        }
        return dots;
    });
    const tear = R._tear = function(el, paper) {
        el == paper.top && (paper.top = el.prev);
        el == paper.bottom && (paper.bottom = el.next);
        el.next && (el.next.prev = el.prev);
        el.prev && (el.prev.next = el.next);
    };
    const tofront = R._tofront = function(el, paper) {
        if (paper.top === el) return;
        tear(el, paper);
        el.next = null;
        el.prev = paper.top;
        paper.top.next = el;
        paper.top = el;
    };
    const toback = R._toback = function(el, paper) {
        if (paper.bottom === el) return;
        tear(el, paper);
        el.next = paper.bottom;
        el.prev = null;
        paper.bottom.prev = el;
        paper.bottom = el;
    };
    const insertafter = R._insertafter = function(el, el2, paper) {
        tear(el, paper);
        el2 == paper.top && (paper.top = el);
        el2.next && (el2.next.prev = el);
        el.next = el2.next;
        el.prev = el2;
        el2.next = el;
    };
    const insertbefore = R._insertbefore = function(el, el2, paper) {
        tear(el, paper);
        el2 == paper.bottom && (paper.bottom = el);
        el2.prev && (el2.prev.next = el);
        el.prev = el2.prev;
        el2.prev = el;
        el.next = el2;
    };
    /* \
     * Raphael.toMatrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix of transformations applied to a given path
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (object) @Matrix
    \ */ const toMatrix = R.toMatrix = function(path, transform) {
        const bb = pathDimensions(path);
        const el = {
            _: {
                transform: E
            },
            getBBox () {
                return bb;
            }
        };
        extractTransform(el, transform);
        return el.matrix;
    };
    /* \
     * Raphael.transformPath
     [ method ]
     **
     * Utility method
     **
     * Returns path transformed by a given transformation
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (string) path
    \ */ const transformPath = R.transformPath = function(path, transform) {
        return mapPath(path, toMatrix(path, transform));
    };
    var extractTransform = R._extractTransform = function(el, tstr) {
        if (tstr == null) return el._.transform;
        tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
        const tdata = R.parseTransformString(tstr);
        let deg = 0;
        let dx = 0;
        let dy = 0;
        let sx = 1;
        let sy = 1;
        const { _ } = el;
        const m = new Matrix();
        _.transform = tdata || [];
        if (tdata) for(let i = 0, ii = tdata.length; i < ii; i++){
            const t = tdata[i];
            const tlen = t.length;
            const command = Str(t[0]).toLowerCase();
            const absolute = t[0] != command;
            const inver = absolute ? m.invert() : 0;
            var x1;
            var y1;
            var x2;
            var y2;
            var bb;
            if (command == "t" && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else m.translate(t[1], t[2]);
            } else if (command == "r") {
                if (tlen == 2) {
                    bb = bb || el.getBBox(1);
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    deg += t[1];
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else m.rotate(t[1], t[2], t[3]);
                    deg += t[1];
                }
            } else if (command == "s") {
                if (tlen == 2 || tlen == 3) {
                    bb = bb || el.getBBox(1);
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    sx *= t[1];
                    sy *= t[tlen - 1];
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else m.scale(t[1], t[2], t[3], t[4]);
                    sx *= t[1];
                    sy *= t[2];
                }
            } else if (command == "m" && tlen == 7) m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            _.dirtyT = 1;
            el.matrix = m;
        }
        /* \
       * Element.matrix
       [ property (object) ]
       **
       * Keeps @Matrix object, which represents element transformation
      \ */ el.matrix = m;
        _.sx = sx;
        _.sy = sy;
        _.deg = deg;
        _.dx = dx = m.e;
        _.dy = dy = m.f;
        if (sx == 1 && sy == 1 && !deg && _.bbox) {
            _.bbox.x += +dx;
            _.bbox.y += +dy;
        } else _.dirtyT = 1;
    };
    const getEmpty = function(item) {
        const l = item[0];
        switch(l.toLowerCase()){
            case "t":
                return [
                    l,
                    0,
                    0
                ];
            case "m":
                return [
                    l,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0
                ];
            case "r":
                if (item.length == 4) return [
                    l,
                    0,
                    item[2],
                    item[3]
                ];
                return [
                    l,
                    0
                ];
            case "s":
                if (item.length == 5) return [
                    l,
                    1,
                    1,
                    item[3],
                    item[4]
                ];
                if (item.length == 3) return [
                    l,
                    1,
                    1
                ];
                return [
                    l,
                    1
                ];
        }
    };
    const equaliseTransform = R._equaliseTransform = function(t1, t2) {
        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
        t1 = R.parseTransformString(t1) || [];
        t2 = R.parseTransformString(t2) || [];
        const maxlength = mmax(t1.length, t2.length);
        const from = [];
        const to = [];
        let i = 0;
        let j;
        let jj;
        let tt1;
        let tt2;
        for(; i < maxlength; i++){
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) return;
            from[i] = [];
            to[i] = [];
            for(j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++){
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from,
            to
        };
    };
    R._getContainer = function(x, y, w, h) {
        let container;
        container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
        if (container == null) return;
        if (container.tagName) {
            if (y == null) return {
                container,
                width: container.style.pixelWidth || container.offsetWidth,
                height: container.style.pixelHeight || container.offsetHeight
            };
            return {
                container,
                width: y,
                height: w
            };
        }
        return {
            container: 1,
            x,
            y,
            width: w,
            height: h
        };
    };
    /* \
   * Raphael.pathToRelative
   [ method ]
   **
   * Utility method
   **
   * Converts path to relative form
   > Parameters
   - pathString (string|array) path string or array of segments
   = (array) array of segments.
  \ */ R.pathToRelative = pathToRelative;
    R._engine = {};
    /* \
   * Raphael.path2curve
   [ method ]
   **
   * Utility method
   **
   * Converts path to a new path where all segments are cubic bezier curves.
   > Parameters
   - pathString (string|array) path string or array of segments
   = (array) array of segments.
  \ */ R.path2curve = path2curve;
    /* \
   * Raphael.matrix
   [ method ]
   **
   * Utility method
   **
   * Returns matrix based on given parameters.
   > Parameters
   - a (number)
   - b (number)
   - c (number)
   - d (number)
   - e (number)
   - f (number)
   = (object) @Matrix
  \ */ R.matrix = function(a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function(matrixproto) {
        /* \
     * Matrix.add
     [ method ]
     **
     * Adds given matrix to existing one.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     or
     - matrix (object) @Matrix
    \ */ matrixproto.add = function(a, b, c, d, e, f) {
            const out = [
                [],
                [],
                []
            ];
            const m = [
                [
                    this.a,
                    this.c,
                    this.e
                ],
                [
                    this.b,
                    this.d,
                    this.f
                ],
                [
                    0,
                    0,
                    1
                ]
            ];
            let matrix = [
                [
                    a,
                    c,
                    e
                ],
                [
                    b,
                    d,
                    f
                ],
                [
                    0,
                    0,
                    1
                ]
            ];
            let x;
            let y;
            let z;
            let res;
            if (a && a instanceof Matrix) matrix = [
                [
                    a.a,
                    a.c,
                    a.e
                ],
                [
                    a.b,
                    a.d,
                    a.f
                ],
                [
                    0,
                    0,
                    1
                ]
            ];
            for(x = 0; x < 3; x++)for(y = 0; y < 3; y++){
                res = 0;
                for(z = 0; z < 3; z++)res += m[x][z] * matrix[z][y];
                out[x][y] = res;
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /* \
     * Matrix.invert
     [ method ]
     **
     * Returns inverted version of the matrix
     = (object) @Matrix
    \ */ matrixproto.invert = function() {
            const me = this;
            const x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /* \
     * Matrix.clone
     [ method ]
     **
     * Returns copy of the matrix
     = (object) @Matrix
    \ */ matrixproto.clone = function() {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /* \
     * Matrix.translate
     [ method ]
     **
     * Translate the matrix
     > Parameters
     - x (number)
     - y (number)
    \ */ matrixproto.translate = function(x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /* \
     * Matrix.scale
     [ method ]
     **
     * Scales the matrix
     > Parameters
     - x (number)
     - y (number) #optional
     - cx (number) #optional
     - cy (number) #optional
    \ */ matrixproto.scale = function(x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /* \
     * Matrix.rotate
     [ method ]
     **
     * Rotates the matrix
     > Parameters
     - a (number)
     - x (number)
     - y (number)
    \ */ matrixproto.rotate = function(a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            const cos = +math.cos(a).toFixed(9);
            const sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /* \
     * Matrix.x
     [ method ]
     **
     * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
     > Parameters
     - x (number)
     - y (number)
     = (number) x
    \ */ matrixproto.x = function(x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /* \
     * Matrix.y
     [ method ]
     **
     * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
     > Parameters
     - x (number)
     - y (number)
     = (number) y
    \ */ matrixproto.y = function(x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function(i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function() {
            return R.svg ? `matrix(${[
                this.get(0),
                this.get(1),
                this.get(2),
                this.get(3),
                this.get(4),
                this.get(5)
            ].join()})` : [
                this.get(0),
                this.get(2),
                this.get(1),
                this.get(3),
                0,
                0
            ].join();
        };
        matrixproto.toFilter = function() {
            return `progid:DXImageTransform.Microsoft.Matrix(M11=${this.get(0)}, M12=${this.get(2)}, M21=${this.get(1)}, M22=${this.get(3)}, Dx=${this.get(4)}, Dy=${this.get(5)}, sizingmethod='auto expand')`;
        };
        matrixproto.offset = function() {
            return [
                this.e.toFixed(4),
                this.f.toFixed(4)
            ];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            const mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /* \
     * Matrix.split
     [ method ]
     **
     * Splits matrix into primitive transformations
     = (object) in format:
     o dx (number) translation by x
     o dy (number) translation by y
     o scalex (number) scale by x
     o scaley (number) scale by y
     o shear (number) shear
     o rotate (number) rotation in deg
     o isSimple (boolean) could it be represented via simple transformations
    \ */ matrixproto.split = function() {
            const out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;
            // scale and shear
            const row = [
                [
                    this.a,
                    this.c
                ],
                [
                    this.b,
                    this.d
                ]
            ];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);
            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [
                row[1][0] - row[0][0] * out.shear,
                row[1][1] - row[0][1] * out.shear
            ];
            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;
            // rotation
            const sin = -row[0][1];
            const cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) out.rotate = 360 - out.rotate;
            } else out.rotate = R.deg(math.asin(sin));
            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /* \
     * Matrix.toTransformString
     [ method ]
     **
     * Return transform string that represents given matrix
     = (string) transform string
    \ */ matrixproto.toTransformString = function(shorter) {
            const s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return (s.dx || s.dy ? `t${[
                    s.dx,
                    s.dy
                ]}` : E) + (s.scalex != 1 || s.scaley != 1 ? `s${[
                    s.scalex,
                    s.scaley,
                    0,
                    0
                ]}` : E) + (s.rotate ? `r${[
                    s.rotate,
                    0,
                    0
                ]}` : E);
            }
            return `m${[
                this.get(0),
                this.get(1),
                this.get(2),
                this.get(3),
                this.get(4),
                this.get(5)
            ]}`;
        };
    })(Matrix.prototype);
    const preventDefault = function() {
        this.returnValue = false;
    };
    const preventTouch = function() {
        return this.originalEvent.preventDefault();
    };
    const stopPropagation = function() {
        this.cancelBubble = true;
    };
    const stopTouch = function() {
        return this.originalEvent.stopPropagation();
    };
    const getEventPosition = function(e) {
        const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
        const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
        return {
            x: e.clientX + scrollX,
            y: e.clientY + scrollY
        };
    };
    const addEvent = function() {
        if (g.doc.addEventListener) return function(obj, type, fn, element) {
            const f = function(e) {
                const pos = getEventPosition(e);
                return fn.call(element, e, pos.x, pos.y);
            };
            obj.addEventListener(type, f, false);
            if (supportsTouch && touchMap[type]) {
                var _f = function(e) {
                    const pos = getEventPosition(e);
                    const olde = e;
                    for(let i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++)if (e.targetTouches[i].target == obj) {
                        e = e.targetTouches[i];
                        e.originalEvent = olde;
                        e.preventDefault = preventTouch;
                        e.stopPropagation = stopTouch;
                        break;
                    }
                    return fn.call(element, e, pos.x, pos.y);
                };
                obj.addEventListener(touchMap[type], _f, false);
            }
            return function() {
                obj.removeEventListener(type, f, false);
                if (supportsTouch && touchMap[type]) obj.removeEventListener(touchMap[type], _f, false);
                return true;
            };
        };
        if (g.doc.attachEvent) return function(obj, type, fn, element) {
            const f = function(e) {
                e = e || g.win.event;
                const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
                const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                const x = e.clientX + scrollX;
                const y = e.clientY + scrollY;
                e.preventDefault = e.preventDefault || preventDefault;
                e.stopPropagation = e.stopPropagation || stopPropagation;
                return fn.call(element, e, x, y);
            };
            obj.attachEvent(`on${type}`, f);
            const detacher = function() {
                obj.detachEvent(`on${type}`, f);
                return true;
            };
            return detacher;
        };
    }();
    let drag = [];
    const dragMove = function(e) {
        let x = e.clientX;
        let y = e.clientY;
        const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
        const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
        let dragi;
        let j = drag.length;
        while(j--){
            dragi = drag[j];
            if (supportsTouch && e.touches) {
                let i = e.touches.length;
                var touch;
                while(i--){
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else e.preventDefault();
            const { node } = dragi.el;
            var o;
            const next = node.nextSibling;
            const parent = node.parentNode;
            const { display } = node.style;
            g.win.opera && parent.removeChild(node);
            node.style.display = "none";
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o && (0, _eveJs.eve)(`raphael.drag.over.${dragi.el.id}`, dragi.el, o);
            x += scrollX;
            y += scrollY;
            (0, _eveJs.eve)(`raphael.drag.move.${dragi.el.id}`, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    };
    var dragUp = function(e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        let i = drag.length;
        let dragi;
        while(i--){
            dragi = drag[i];
            dragi.el._drag = {};
            (0, _eveJs.eve)(`raphael.drag.end.${dragi.el.id}`, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    };
    /* \
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is useful when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldnt affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \ */ const elproto = R.el = {};
    /* \
   * Element.click
   [ method ]
   **
   * Adds event handler for click for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unclick
   [ method ]
   **
   * Removes event handler for click for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.dblclick
   [ method ]
   **
   * Adds event handler for double click for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.undblclick
   [ method ]
   **
   * Removes event handler for double click for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mousedown
   [ method ]
   **
   * Adds event handler for mousedown for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmousedown
   [ method ]
   **
   * Removes event handler for mousedown for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mousemove
   [ method ]
   **
   * Adds event handler for mousemove for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmousemove
   [ method ]
   **
   * Removes event handler for mousemove for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseout
   [ method ]
   **
   * Adds event handler for mouseout for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseout
   [ method ]
   **
   * Removes event handler for mouseout for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseover
   [ method ]
   **
   * Adds event handler for mouseover for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseover
   [ method ]
   **
   * Removes event handler for mouseover for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseup
   [ method ]
   **
   * Adds event handler for mouseup for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseup
   [ method ]
   **
   * Removes event handler for mouseup for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchstart
   [ method ]
   **
   * Adds event handler for touchstart for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchstart
   [ method ]
   **
   * Removes event handler for touchstart for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchmove
   [ method ]
   **
   * Adds event handler for touchmove for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchmove
   [ method ]
   **
   * Removes event handler for touchmove for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchend
   [ method ]
   **
   * Adds event handler for touchend for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchend
   [ method ]
   **
   * Removes event handler for touchend for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchcancel
   [ method ]
   **
   * Adds event handler for touchcancel for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchcancel
   [ method ]
   **
   * Removes event handler for touchcancel for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ for(let i = events.length; i--;)(function(eventName) {
        R[eventName] = elproto[eventName] = function(fn, scope) {
            if (R.is(fn, "function")) {
                this.events = this.events || [];
                this.events.push({
                    name: eventName,
                    f: fn,
                    unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                });
            }
            return this;
        };
        R[`un${eventName}`] = elproto[`un${eventName}`] = function(fn) {
            const events = this.events || [];
            let l = events.length;
            while(l--)if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                events[l].unbind();
                events.splice(l, 1);
                !events.length && delete this.events;
            }
            return this;
        };
    })(events[i]);
    /* \
   * Element.data
   [ method ]
   **
   * Adds or retrieves given value associated with given key.
   **
   * See also @Element.removeData
   > Parameters
   - key (string) key to store data
   - value (any) #optional value to store
   = (object) @Element
   * or, if value is not specified:
   = (any) value
   * or, if key and value are not specified:
   = (object) Key/value pairs for all the data associated with the element.
   > Usage
   | for (var i = 0, i < 5, i++) {
   |     paper.circle(10 + 15 * i, 10, 10)
   |          .attr({fill: "#000"})
   |          .data("i", i)
   |          .click(function () {
   |             alert(this.data("i"));
   |          });
   | }
  \ */ elproto.data = function(key, value) {
        const data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) return data;
        if (arguments.length == 1) {
            if (R.is(key, "object")) {
                for(const i in key)if (key[has](i)) this.data(i, key[i]);
                return this;
            }
            (0, _eveJs.eve)(`raphael.data.get.${this.id}`, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        (0, _eveJs.eve)(`raphael.data.set.${this.id}`, this, value, key);
        return this;
    };
    /* \
   * Element.removeData
   [ method ]
   **
   * Removes value associated with an element by given key.
   * If key is not provided, removes all the data of the element.
   > Parameters
   - key (string) #optional key
   = (object) @Element
  \ */ elproto.removeData = function(key) {
        if (key == null) eldata[this.id] = {};
        else eldata[this.id] && delete eldata[this.id][key];
        return this;
    };
    /* \
    * Element.getData
    [ method ]
    **
    * Retrieves the element data
    = (object) data
  \ */ elproto.getData = function() {
        return clone(eldata[this.id] || {});
    };
    /* \
   * Element.hover
   [ method ]
   **
   * Adds event handlers for hover for the element.
   > Parameters
   - f_in (function) handler for hover in
   - f_out (function) handler for hover out
   - icontext (object) #optional context for hover in handler
   - ocontext (object) #optional context for hover out handler
   = (object) @Element
  \ */ elproto.hover = function(f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /* \
   * Element.unhover
   [ method ]
   **
   * Removes event handlers for hover for the element.
   > Parameters
   - f_in (function) handler for hover in
   - f_out (function) handler for hover out
   = (object) @Element
  \ */ elproto.unhover = function(f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    const draggable = [];
    /* \
   * Element.drag
   [ method ]
   **
   * Adds event handlers for drag of the element.
   > Parameters
   - onmove (function) handler for moving
   - onstart (function) handler for drag start
   - onend (function) handler for drag end
   - mcontext (object) #optional context for moving handler
   - scontext (object) #optional context for drag start handler
   - econtext (object) #optional context for drag end handler
   * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,
   * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
   * `drag.over.<id>` will be fired as well.
   *
   * Start event and start handler will be called in specified context or in context of the element with following parameters:
   o x (number) x position of the mouse
   o y (number) y position of the mouse
   o event (object) DOM event object
   * Move event and move handler will be called in specified context or in context of the element with following parameters:
   o dx (number) shift by x from the start point
   o dy (number) shift by y from the start point
   o x (number) x position of the mouse
   o y (number) y position of the mouse
   o event (object) DOM event object
   * End event and end handler will be called in specified context or in context of the element with following parameters:
   o event (object) DOM event object
   = (object) @Element
  \ */ elproto.drag = function(onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            let x = e.clientX;
            let y = e.clientY;
            const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
            const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                let i = e.touches.length;
                let touch;
                while(i--){
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({
                el: this,
                move_scope,
                start_scope,
                end_scope
            });
            onstart && (0, _eveJs.eve).on(`raphael.drag.start.${this.id}`, onstart);
            onmove && (0, _eveJs.eve).on(`raphael.drag.move.${this.id}`, onmove);
            onend && (0, _eveJs.eve).on(`raphael.drag.end.${this.id}`, onend);
            (0, _eveJs.eve)(`raphael.drag.start.${this.id}`, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this.start = start // SLATEBOX - makes text draggable
        ;
        this._drag = {};
        draggable.push({
            el: this,
            start
        });
        this.mousedown(start);
        return this;
    };
    /* \
   * Element.onDragOver
   [ method ]
   **
   * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
   > Parameters
   - f (function) handler for event, first argument would be the element you are dragging over
  \ */ elproto.onDragOver = function(f) {
        f ? (0, _eveJs.eve).on(`raphael.drag.over.${this.id}`, f) : (0, _eveJs.eve).unbind(`raphael.drag.over.${this.id}`);
    };
    /* \
   * Element.undrag
   [ method ]
   **
   * Removes all drag event handlers from given element.
  \ */ elproto.undrag = function() {
        let i = draggable.length;
        while(i--)if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            (0, _eveJs.eve).unbind(`raphael.drag.*.${this.id}`);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    /* \
   * Paper.circle
   [ method ]
   **
   * Draws a circle.
   **
   > Parameters
   **
   - x (number) x coordinate of the centre
   - y (number) y coordinate of the centre
   - r (number) radius
   = (object) Raphal element object with type circle
   **
   > Usage
   | var c = paper.circle(50, 50, 40);
  \ */ paperproto.circle = function(x, y, r) {
        const out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.rect
   [ method ]
   *
   * Draws a rectangle.
   **
   > Parameters
   **
   - x (number) x coordinate of the top left corner
   - y (number) y coordinate of the top left corner
   - width (number) width
   - height (number) height
   - r (number) #optional radius for rounded corners, default is 0
   = (object) Raphal element object with type rect
   **
   > Usage
   | // regular rectangle
   | var c = paper.rect(10, 10, 50, 50);
   | // rectangle with rounded corners
   | var c = paper.rect(40, 40, 50, 50, 10);
  \ */ paperproto.rect = function(x, y, w, h, r) {
        const out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
     * Paper.g
     [ method ]
     *
     * Draws a svg group (g) element.
     **
    \ */ paperproto.g = function() {
        const out = R._engine.g(this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
     * Paper.def
     [ method ]
     *
     * Adds a <def>
     **
    \ */ paperproto.def = function(def) {
        R._engine.def.call(this, def);
    };
    /* \
   * Paper.ellipse
   [ method ]
   **
   * Draws an ellipse.
   **
   > Parameters
   **
   - x (number) x coordinate of the centre
   - y (number) y coordinate of the centre
   - rx (number) horizontal radius
   - ry (number) vertical radius
   = (object) Raphal element object with type ellipse
   **
   > Usage
   | var c = paper.ellipse(50, 50, 40, 20);
  \ */ paperproto.ellipse = function(x, y, rx, ry) {
        const out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.path
   [ method ]
   **
   * Creates a path element by given path data string.
   > Parameters
   - pathString (string) #optional path string in SVG format.
   * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
   | "M10,20L30,40"
   * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.
   *
   # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
   # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
   # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
   # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
   # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
   # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
   # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
   # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
   # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
   # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>
   # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>
   # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
   # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
   * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.
   * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.
   > Usage
   | var c = paper.path("M10 10L90 90");
   | // draw a diagonal line:
   | // move to 10,10, line to 90,90
   * For example of path strings, check out these icons: http://raphaeljs.com/icons/
  \ */ paperproto.path = function(pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        const out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.image
   [ method ]
   **
   * Embeds an image into the surface.
   **
   > Parameters
   **
   - src (string) URI of the source image
   - x (number) x coordinate position
   - y (number) y coordinate position
   - width (number) width of the image
   - height (number) height of the image
   = (object) Raphal element object with type image
   **
   > Usage
   | var c = paper.image("apple.png", 10, 10, 80, 80);
  \ */ paperproto.image = function(src, x, y, w, h) {
        const out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.text
   [ method ]
   **
   * Draws a text string. If you need line breaks, put \n in the string.
   **
   > Parameters
   **
   - x (number) x coordinate position
   - y (number) y coordinate position
   - text (string) The text string to draw
   = (object) Raphal element object with type text
   **
   > Usage
   | var t = paper.text(50, 50, "Raphal\nkicks\nbutt!");
  \ */ paperproto.text = function(x, y, text) {
        const out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.set
   [ method ]
   **
   * Creates array-like object to keep and operate several elements at once.
   * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.
   * Sets act as pseudo elements  all methods available to an element can be used on a set.
   = (object) array-like object that represents set of elements
   **
   > Usage
   | var st = paper.set();
   | st.push(
   |     paper.circle(10, 10, 5),
   |     paper.circle(30, 10, 5)
   | );
   | st.attr({fill: "red"}); // changes the fill of both circles
  \ */ paperproto.set = function(itemsArray) {
        !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        const out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out.paper = this;
        out.type = "set";
        return out;
    };
    /* \
   * Paper.setStart
   [ method ]
   **
   * Creates @Paper.set. All elements that will be created after calling this method and before calling
   * @Paper.setFinish will be added to the set.
   **
   > Usage
   | paper.setStart();
   | paper.circle(10, 10, 5),
   | paper.circle(30, 10, 5)
   | var st = paper.setFinish();
   | st.attr({fill: "red"}); // changes the fill of both circles
  \ */ paperproto.setStart = function(set) {
        this.__set__ = set || this.set();
    };
    /* \
   * Paper.setFinish
   [ method ]
   **
   * See @Paper.setStart. This method finishes catching and returns resulting set.
   **
   = (object) set
  \ */ paperproto.setFinish = function(set) {
        const out = this.__set__;
        delete this.__set__;
        return out;
    };
    /* \
   * Paper.getSize
   [ method ]
   **
   * Obtains current paper actual size.
   **
   = (object)
   \ */ paperproto.getSize = function() {
        const container = this.canvas.parentNode;
        return {
            width: container.offsetWidth,
            height: container.offsetHeight
        };
    };
    /* \
   * Paper.setSize
   [ method ]
   **
   * If you need to change dimensions of the canvas call this method
   **
   > Parameters
   **
   - width (number) new width of the canvas
   - height (number) new height of the canvas
  \ */ paperproto.setSize = function(width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    /* \
   * Paper.setViewBox
   [ method ]
   **
   * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
   * specifying new boundaries.
   **
   > Parameters
   **
   - x (number) new x position, default is `0`
   - y (number) new y position, default is `0`
   - w (number) new width of the canvas
   - h (number) new height of the canvas
   - fit (boolean) `true` if you want graphics to fit into new boundary box
  \ */ paperproto.setViewBox = function(x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /* \
   * Paper.top
   [ property ]
   **
   * Points to the topmost element on the paper
  \ */ /* \
   * Paper.bottom
   [ property ]
   **
   * Points to the bottom element on the paper
  \ */ paperproto.top = paperproto.bottom = null;
    /* \
   * Paper.raphael
   [ property ]
   **
   * Points to the @Raphael object/function
  \ */ paperproto.raphael = R;
    const getOffset = function(elem) {
        const box = elem.getBoundingClientRect();
        const doc = elem.ownerDocument;
        const { body } = doc;
        const docElem = doc.documentElement;
        const clientTop = docElem.clientTop || body.clientTop || 0;
        const clientLeft = docElem.clientLeft || body.clientLeft || 0;
        const top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop;
        const left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /* \
   * Paper.getElementByPoint
   [ method ]
   **
   * Returns you topmost element under given point.
   **
   = (object) Raphal element object
   > Parameters
   **
   - x (number) x coordinate from the top left corner of the window
   - y (number) y coordinate from the top left corner of the window
   > Usage
   | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
  \ */ paperproto.getElementByPoint = function(x, y) {
        const paper = this;
        const svg = paper.canvas;
        let target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == "svg") {
            const so = getOffset(svg);
            const sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            const hits = svg.getIntersectionList(sr, null);
            if (hits.length) target = hits[hits.length - 1];
        }
        if (!target) return null;
        while(target.parentNode && target != svg.parentNode && !target.raphael)target = target.parentNode;
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };
    /* \
   * Paper.getElementsByBBox
   [ method ]
   **
   * Returns set of elements that have an intersecting bounding box
   **
   > Parameters
   **
   - bbox (object) bbox to check with
   = (object) @Set
   \ */ paperproto.getElementsByBBox = function(bbox) {
        const set = this.set();
        this.forEach((el)=>{
            if (R.isBBoxIntersect(el.getBBox(), bbox)) set.push(el);
        });
        return set;
    };
    /* \
   * Paper.getById
   [ method ]
   **
   * Returns you element by its internal ID.
   **
   > Parameters
   **
   - id (number) id
   = (object) Raphal element object
  \ */ paperproto.getById = function(id) {
        let bot = this.bottom;
        while(bot){
            if (bot.id == id) return bot;
            bot = bot.next;
        }
        return null;
    };
    /* \
   * Paper.forEach
   [ method ]
   **
   * Executes given function for each element on the paper
   *
   * If callback function returns `false` it will stop loop running.
   **
   > Parameters
   **
   - callback (function) function to run
   - thisArg (object) context object for the callback
   = (object) Paper object
   > Usage
   | paper.forEach(function (el) {
   |     el.attr({ stroke: "blue" });
   | });
  \ */ paperproto.forEach = function(callback, thisArg) {
        let bot = this.bottom;
        while(bot){
            if (callback.call(thisArg, bot) === false) return this;
            bot = bot.next;
        }
        return this;
    };
    /* \
   * Paper.getElementsByPoint
   [ method ]
   **
   * Returns set of elements that have common point inside
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (object) @Set
  \ */ paperproto.getElementsByPoint = function(x, y) {
        const set = this.set();
        this.forEach((el)=>{
            if (el.isPointInside(x, y)) set.push(el);
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return `${this.x + S + this.y + S + this.width} \xd7 ${this.height}`;
    }
    /* \
   * Element.isPointInside
   [ method ]
   **
   * Determine if given point is inside this elements shape
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (boolean) `true` if point inside the shape
  \ */ elproto.isPointInside = function(x, y) {
        let rp = this.realPath = getPath[this.type](this);
        if (this.attr("transform") && this.attr("transform").length) rp = R.transformPath(rp, this.attr("transform"));
        return R.isPointInsidePath(rp, x, y);
    };
    /* \
   * Element.getBBox
   [ method ]
   **
   * Return bounding box for a given element
   **
   > Parameters
   **
   - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
   = (object) Bounding box object:
   o {
   o     x: (number) top left corner x
   o     y: (number) top left corner y
   o     x2: (number) bottom right corner x
   o     y2: (number) bottom right corner y
   o     width: (number) width
   o     height: (number) height
   o }
  \ */ elproto.getBBox = function(isWithoutTransform) {
        if (this.removed) return {};
        const { _ } = this;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /* \
   * Element.clone
   [ method ]
   **
   = (object) clone of a given element
   **
  \ */ elproto.clone = function() {
        if (this.removed) return null;
        const out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Element.glow
   [ method ]
   **
   * Return set of elements that create glow-like effect around given element. See @Paper.set.
   *
   * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.
   **
   > Parameters
   **
   - glow (object) #optional parameters object with all properties optional:
   o {
   o     width (number) size of the glow, default is `10`
   o     fill (boolean) will it be filled, default is `false`
   o     opacity (number) opacity, default is `0.5`
   o     offsetx (number) horizontal offset, default is `0`
   o     offsety (number) vertical offset, default is `0`
   o     color (string) glow colour, default is `black`
   o }
   = (object) @Paper.set of elements that represents glow
  \ */ elproto.glow = function(glow) {
        if (this.type == "text") return null;
        glow = glow || {};
        const s = {
            width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
            fill: glow.fill || false,
            opacity: glow.opacity == null ? 0.5 : glow.opacity,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || "#000"
        };
        const c = s.width / 2;
        const r = this.paper;
        const out = r.set();
        let path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for(let i = 1; i < c + 1; i++)out.push(r.path(path).attr({
            stroke: s.color,
            fill: s.fill ? s.color : "none",
            "stroke-linejoin": "round",
            "stroke-linecap": "round",
            "stroke-width": +(s.width / c * i).toFixed(3),
            opacity: +(s.opacity / c).toFixed(3)
        }));
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    const curveslengths = {};
    const getPointAtSegmentLength = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
    };
    const getLengthFactory = function(istotal, subpath) {
        return function(path, length, onlystart) {
            path = path2curve(path);
            let x;
            let y;
            let p;
            let l;
            let sp = "";
            const subpaths = {};
            let point;
            let len = 0;
            for(let i = 0, ii = path.length; i < ii; i++){
                p = path[i];
                if (p[0] == "M") {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += [
                                `C${point.start.x}`,
                                point.start.y,
                                point.m.x,
                                point.m.y,
                                point.x,
                                point.y
                            ];
                            if (onlystart) return sp;
                            subpaths.start = sp;
                            sp = [
                                `M${point.x}`,
                                `${point.y}C${point.n.x}`,
                                point.n.y,
                                point.end.x,
                                point.end.y,
                                p[5],
                                p[6]
                            ].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {
                                x: point.x,
                                y: point.y,
                                alpha: point.alpha
                            };
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {
                x: point.x,
                y: point.y,
                alpha: point.alpha
            });
            return point;
        };
    };
    const getTotalLength = getLengthFactory(1);
    const getPointAtLength = getLengthFactory();
    const getSubpathsAtLength = getLengthFactory(0, 1);
    /* \
   * Raphael.getTotalLength
   [ method ]
   **
   * Returns length of the given path in pixels.
   **
   > Parameters
   **
   - path (string) SVG path string.
   **
   = (number) length.
  \ */ R.getTotalLength = getTotalLength;
    /* \
   * Raphael.getPointAtLength
   [ method ]
   **
   * Return coordinates of the point located at the given length on the given path.
   **
   > Parameters
   **
   - path (string) SVG path string
   - length (number)
   **
   = (object) representation of the point:
   o {
   o     x: (number) x coordinate
   o     y: (number) y coordinate
   o     alpha: (number) angle of derivative
   o }
  \ */ R.getPointAtLength = getPointAtLength;
    /* \
   * Raphael.getSubpath
   [ method ]
   **
   * Return subpath of a given path from given length to given length.
   **
   > Parameters
   **
   - path (string) SVG path string
   - from (number) position of the start of the segment
   - to (number) position of the end of the segment
   **
   = (string) pathstring for the segment
  \ */ R.getSubpath = function(path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) return getSubpathsAtLength(path, from).end;
        const a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /* \
   * Element.getTotalLength
   [ method ]
   **
   * Returns length of the path in pixels. Only works for element of path type.
   = (number) length.
  \ */ elproto.getTotalLength = function() {
        const path = this.getPath();
        if (!path) return;
        if (this.node.getTotalLength) return this.node.getTotalLength();
        return getTotalLength(path);
    };
    /* \
   * Element.getPointAtLength
   [ method ]
   **
   * Return coordinates of the point located at the given length on the given path. Only works for element of path type.
   **
   > Parameters
   **
   - length (number)
   **
   = (object) representation of the point:
   o {
   o     x: (number) x coordinate
   o     y: (number) y coordinate
   o     alpha: (number) angle of derivative
   o }
  \ */ elproto.getPointAtLength = function(length) {
        const path = this.getPath();
        if (!path) return;
        return getPointAtLength(path, length);
    };
    /* \
   * Element.getPath
   [ method ]
   **
   * Returns path of the element. Only works for elements of path type and simple elements like circle.
   = (object) path
   **
  \ */ elproto.getPath = function() {
        let path;
        const getPath = R._getPath[this.type];
        if (this.type == "text" || this.type == "set") return;
        if (getPath) path = getPath(this);
        return path;
    };
    /* \
   * Element.getSubpath
   [ method ]
   **
   * Return subpath of a given element from given length to given length. Only works for element of path type.
   **
   > Parameters
   **
   - from (number) position of the start of the segment
   - to (number) position of the end of the segment
   **
   = (string) pathstring for the segment
  \ */ elproto.getSubpath = function(from, to) {
        const path = this.getPath();
        if (!path) return;
        return R.getSubpath(path, from, to);
    };
    /* \
   * Raphael.easing_formulas
   [ property ]
   **
   * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
   # <ul>
   #     <li>linear</li>
   #     <li>&lt; or easeIn or ease-in</li>
   #     <li>> or easeOut or ease-out</li>
   #     <li>&lt;> or easeInOut or ease-in-out</li>
   #     <li>backIn or back-in</li>
   #     <li>backOut or back-out</li>
   #     <li>elastic</li>
   #     <li>bounce</li>
   # </ul>
   # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
  \ */ const ef = R.easing_formulas = {
        linear (n) {
            return n;
        },
        "<": function(n) {
            return n ** 1.7;
        },
        ">": function(n) {
            return n ** 0.48;
        },
        "<>": function(n) {
            const q = 0.48 - n / 1.04;
            const Q = math.sqrt(0.1734 + q * q);
            const x = Q - q;
            const X = abs(x) ** (1 / 3) * (x < 0 ? -1 : 1);
            const y = -Q - q;
            const Y = abs(y) ** (1 / 3) * (y < 0 ? -1 : 1);
            const t = X + Y + 0.5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn (n) {
            const s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut (n) {
            n -= 1;
            const s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic (n) {
            if (n == !!n) return n;
            return 2 ** (-10 * n) * math.sin((n - 0.075) * (2 * PI) / 0.3) + 1;
        },
        bounce (n) {
            const s = 7.5625;
            const p = 2.75;
            let l;
            if (n < 1 / p) l = s * n * n;
            else if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + 0.75;
            } else if (n < 2.5 / p) {
                n -= 2.25 / p;
                l = s * n * n + 0.9375;
            } else {
                n -= 2.625 / p;
                l = s * n * n + 0.984375;
            }
            return l;
        }
    };
    ef.easeIn = ef["ease-in"] = ef["<"];
    ef.easeOut = ef["ease-out"] = ef[">"];
    ef.easeInOut = ef["ease-in-out"] = ef["<>"];
    ef["back-in"] = ef.backIn;
    ef["back-out"] = ef.backOut;
    const animationElements = [];
    const requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        setTimeout(callback, 16);
    };
    var animation = function() {
        const Now = +new Date();
        let l = 0;
        for(; l < animationElements.length; l++){
            const e = animationElements[l];
            if (e.el.removed || e.paused) continue;
            let time = Now - e.start;
            var { ms } = e;
            const { easing } = e;
            var { from } = e;
            var { diff } = e;
            const { to } = e;
            const { t } = e;
            const that = e.el;
            const set = {};
            var now;
            const init = {};
            var key;
            if (e.initstatus) {
                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                e.status = e.initstatus;
                delete e.initstatus;
                e.stop && animationElements.splice(l--, 1);
            } else e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
            if (time < 0) continue;
            if (time < ms) {
                var pos = easing(time / ms);
                for(var attr in from)if (from[has](attr)) {
                    switch(availableAnimAttrs[attr]){
                        case nu:
                            now = +from[attr] + pos * ms * diff[attr];
                            break;
                        case "colour":
                            now = `rgb(${[
                                upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                upto255(round(from[attr].b + pos * ms * diff[attr].b))
                            ].join(",")})`;
                            break;
                        case "path":
                            now = [];
                            for(var i = 0, ii = from[attr].length; i < ii; i++){
                                now[i] = [
                                    from[attr][i][0]
                                ];
                                for(var j = 1, jj = from[attr][i].length; j < jj; j++)now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                now[i] = now[i].join(S);
                            }
                            now = now.join(S);
                            break;
                        case "transform":
                            if (diff[attr].real) {
                                now = [];
                                for(i = 0, ii = from[attr].length; i < ii; i++){
                                    now[i] = [
                                        from[attr][i][0]
                                    ];
                                    for(j = 1, jj = from[attr][i].length; j < jj; j++)now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                }
                            } else {
                                const get = function(i) {
                                    return +from[attr][i] + pos * ms * diff[attr][i];
                                };
                                // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                now = [
                                    [
                                        "m",
                                        get(0),
                                        get(1),
                                        get(2),
                                        get(3),
                                        get(4),
                                        get(5)
                                    ]
                                ];
                            }
                            break;
                        case "csv":
                            if (attr == "clip-rect") {
                                now = [];
                                i = 4;
                                while(i--)now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                            }
                            break;
                        default:
                            var from2 = [][concat](from[attr]);
                            now = [];
                            i = that.paper.customAttributes[attr].length;
                            while(i--)now[i] = +from2[i] + pos * ms * diff[attr][i];
                            break;
                    }
                    set[attr] = now;
                }
                that.attr(set);
                (function(id, that, anim) {
                    setTimeout(()=>{
                        (0, _eveJs.eve)(`raphael.anim.frame.${id}`, that, anim);
                    });
                })(that.id, that, e.anim);
            } else {
                (function(f, el, a) {
                    setTimeout(()=>{
                        (0, _eveJs.eve)(`raphael.anim.frame.${el.id}`, el, a);
                        (0, _eveJs.eve)(`raphael.anim.finish.${el.id}`, el, a);
                        R.is(f, "function") && f.call(el);
                    });
                })(e.callback, that, e.anim);
                that.attr(to);
                animationElements.splice(l--, 1);
                if (e.repeat > 1 && !e.next) {
                    for(key in to)if (to[has](key)) init[key] = e.totalOrigin[key];
                    e.el.attr(init);
                    runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                }
                if (e.next && !e.stop) runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
            }
        }
        animationElements.length && requestAnimFrame(animation);
    };
    var upto255 = function(color) {
        return color > 255 ? 255 : color < 0 ? 0 : color;
    };
    /* \
   * Element.animateWith
   [ method ]
   **
   * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
   **
   > Parameters
   **
   - el (object) element to sync with
   - anim (object) animation to sync with
   - params (object) #optional final attributes for the element, see also @Element.attr
   - ms (number) #optional number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   * or
   - element (object) element to sync with
   - anim (object) animation to sync with
   - animation (object) #optional animation object, see @Raphael.animation
   **
   = (object) original element
  \ */ elproto.animateWith = function(el, anim, params, ms, easing, callback) {
        const element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        const a = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        let x;
        let y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for(let i = 0, ii = animationElements.length; i < ii; i++)if (animationElements[i].anim == anim && animationElements[i].el == el) {
            animationElements[ii - 1].start = animationElements[i].start;
            break;
        }
        return element;
    //
    //
    // var a = params ? R.animation(params, ms, easing, callback) : anim,
    //     status = element.status(anim);
    // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        const cx = 3 * p1x;
        const bx = 3 * (p2x - p1x) - cx;
        const ax = 1 - cx - bx;
        const cy = 3 * p1y;
        const by = 3 * (p2y - p1y) - cy;
        const ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            const t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            let t0;
            let t1;
            let t2;
            let x2;
            let d2;
            let i;
            for(t2 = x, i = 0; i < 8; i++){
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) return t2;
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) break;
                t2 -= x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) return t0;
            if (t2 > t1) return t1;
            while(t0 < t1){
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) return t2;
                if (x > x2) t0 = t2;
                else t1 = t2;
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function(f) {
        f ? (0, _eveJs.eve).on(`raphael.anim.frame.${this.id}`, f) : (0, _eveJs.eve).unbind(`raphael.anim.frame.${this.id}`);
        return this;
    };
    function Animation(anim, ms) {
        const percents = [];
        const newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for(const attr in anim)if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /* \
   * Animation.delay
   [ method ]
   **
   * Creates a copy of existing animation object with given delay.
   **
   > Parameters
   **
   - delay (number) number of ms to pass between animation start and actual animation
   **
   = (object) new altered Animation object
   | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
   | circle1.animate(anim); // run the given animation immediately
   | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
  \ */ Animation.prototype.delay = function(delay) {
        const a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /* \
   * Animation.repeat
   [ method ]
   **
   * Creates a copy of existing animation object with given repetition.
   **
   > Parameters
   **
   - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
   **
   = (object) new altered Animation object
  \ */ Animation.prototype.repeat = function(times) {
        const a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        let params;
        let isInAnim;
        let isInAnimSet;
        const percents = [];
        let next;
        let prev;
        let timestamp;
        let { ms } = anim;
        const from = {};
        const to = {};
        const diff = {};
        if (status) for(i = 0, ii = animationElements.length; i < ii; i++){
            var e = animationElements[i];
            if (e.el.id == element.id && e.anim == anim) {
                if (e.percent != percent) {
                    animationElements.splice(i, 1);
                    isInAnimSet = 1;
                } else isInAnim = e;
                element.attr(e.totalOrigin);
                break;
            }
        }
        else status = +to // NaN
        ;
        for(var i = 0, ii = anim.percents.length; i < ii; i++){
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) element.attr(anim.anim[anim.percents[i]]);
        }
        if (!params) return;
        if (!isInAnim) {
            for(const attr in params)if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    from[attr] == null && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch(availableAnimAttrs[attr]){
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case "colour":
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case "path":
                            var pathes = path2curve(from[attr], to[attr]);
                            var toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for(i = 0, ii = from[attr].length; i < ii; i++){
                                diff[attr][i] = [
                                    0
                                ];
                                for(var j = 1, jj = from[attr][i].length; j < jj; j++)diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                            }
                            break;
                        case "transform":
                            var { _ } = element;
                            var eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for(i = 0, ii = from[attr].length; i < ii; i++){
                                    diff[attr][i] = [
                                        from[attr][i][0]
                                    ];
                                    for(j = 1, jj = from[attr][i].length; j < jj; j++)diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                }
                            } else {
                                const m = element.matrix || new Matrix();
                                const to2 = {
                                    _: {
                                        transform: _.transform
                                    },
                                    getBBox () {
                                        return element.getBBox(1);
                                    }
                                };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                            // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                            // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                            // extractTransform(to2, to[attr]);
                            // diff[attr] = [
                            //     (to2._.sx - _.sx) / ms,
                            //     (to2._.sy - _.sy) / ms,
                            //     (to2._.deg - _.deg) / ms,
                            //     (to2._.dx - _.dx) / ms,
                            //     (to2._.dy - _.dy) / ms
                            // ];
                            }
                            break;
                        case "csv":
                            var values = Str(params[attr])[split](separator);
                            var from2 = Str(from[attr])[split](separator);
                            if (attr == "clip-rect") {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while(i--)diff[attr][i] = (values[i] - from[attr][i]) / ms;
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while(i--)diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            break;
                    }
                }
            }
            const { easing } = params;
            let easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    const curve = easyeasy;
                    easyeasy = function(t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else easyeasy = pipe;
            }
            timestamp = params.start || anim.start || +new Date();
            e = {
                anim,
                percent,
                timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms,
                easing: easyeasy,
                from,
                diff,
                to,
                el: element,
                callback: params.callback,
                prev,
                next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date() - ms * status;
                if (animationElements.length == 1) return animation();
            }
            if (isInAnimSet) e.start = new Date() - e.ms * status;
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date() - isInAnim.ms * status;
        }
        (0, _eveJs.eve)(`raphael.anim.start.${element.id}`, element, anim);
    }
    /* \
   * Raphael.animation
   [ method ]
   **
   * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
   * See also @Animation.delay and @Animation.repeat methods.
   **
   > Parameters
   **
   - params (object) final attributes for the element, see also @Element.attr
   - ms (number) number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   **
   = (object) @Animation
  \ */ R.animation = function(params, ms, easing, callback) {
        if (params instanceof Animation) return params;
        if (R.is(easing, "function") || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        const p = {};
        let json;
        let attr;
        for(attr in params)if (params[has](attr) && toFloat(attr) != attr && `${toFloat(attr)}%` != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            // if percent-like syntax is used and end-of-all animation callback used
            if (callback) {
                // find the last one
                let lastKey = 0;
                for(const i in params){
                    const percent = toInt(i);
                    if (params[has](i) && percent > lastKey) lastKey = percent;
                }
                lastKey += "%";
                // if already defined callback in the last keyframe, skip
                !params[lastKey].callback && (params[lastKey].callback = callback);
            }
            return new Animation(params, ms);
        }
        easing && (p.easing = easing);
        callback && (p.callback = callback);
        return new Animation({
            100: p
        }, ms);
    };
    /* \
   * Element.animate
   [ method ]
   **
   * Creates and starts animation for given element.
   **
   > Parameters
   **
   - params (object) final attributes for the element, see also @Element.attr
   - ms (number) number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   * or
   - animation (object) animation object, see @Raphael.animation
   **
   = (object) original element
  \ */ elproto.animate = function(params, ms, easing, callback) {
        const element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        const anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /* \
   * Element.setTime
   [ method ]
   **
   * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
   **
   > Parameters
   **
   - anim (object) animation object
   - value (number) number of milliseconds from the beginning of the animation
   **
   = (object) original element if `value` is specified
   * Note, that during animation following events are triggered:
   *
   * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
  \ */ elproto.setTime = function(anim, value) {
        if (anim && value != null) this.status(anim, mmin(value, anim.ms) / anim.ms);
        return this;
    };
    /* \
   * Element.status
   [ method ]
   **
   * Gets or sets the status of animation of the element.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
   **
   = (number) status
   * or
   = (array) status if `anim` is not specified. Array of objects in format:
   o {
   o     anim: (object) animation object
   o     status: (number) status
   o }
   * or
   = (object) original element if `value` is specified
  \ */ elproto.status = function(anim, value) {
        const out = [];
        let i = 0;
        let len;
        let e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        }
        len = animationElements.length;
        for(; i < len; i++){
            e = animationElements[i];
            if (e.el.id == this.id && (!anim || e.anim == anim)) {
                if (anim) return e.status;
                out.push({
                    anim: e.anim,
                    status: e.status
                });
            }
        }
        if (anim) return 0;
        return out;
    };
    /* \
   * Element.pause
   [ method ]
   **
   * Stops animation of the element with ability to resume it later on.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.pause = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if ((0, _eveJs.eve)(`raphael.anim.pause.${this.id}`, this, animationElements[i].anim) !== false) animationElements[i].paused = true;
        }
        return this;
    };
    /* \
   * Element.resume
   [ method ]
   **
   * Resumes animation if it was paused with @Element.pause method.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.resume = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            const e = animationElements[i];
            if ((0, _eveJs.eve)(`raphael.anim.resume.${this.id}`, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /* \
   * Element.stop
   [ method ]
   **
   * Stops animation of the element.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.stop = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if ((0, _eveJs.eve)(`raphael.anim.stop.${this.id}`, this, animationElements[i].anim) !== false) animationElements.splice(i--, 1);
        }
        return this;
    };
    function stopAnimation(paper) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.paper == paper) animationElements.splice(i--, 1);
    }
    (0, _eveJs.eve).on("raphael.remove", stopAnimation);
    (0, _eveJs.eve).on("raphael.clear", stopAnimation);
    elproto.toString = function() {
        return "Rapha\xebl\u2019s object";
    };
    // Set
    var Set = function(items) {
        this.items = [];
        this.length = 0;
        this.type = "set";
        if (items) {
            for(let i = 0, ii = items.length; i < ii; i++)if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                this[this.items.length] = this.items[this.items.length] = items[i];
                this.length++;
            }
        }
    };
    const setproto = Set.prototype;
    /* \
   * Set.push
   [ method ]
   **
   * Adds each argument to the current set.
   = (object) original element
  \ */ setproto.push = function() {
        let item;
        let len;
        for(let i = 0, ii = arguments.length; i < ii; i++){
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /* \
   * Set.pop
   [ method ]
   **
   * Removes last element and returns it.
   = (object) element
  \ */ setproto.pop = function() {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /* \
   * Set.forEach
   [ method ]
   **
   * Executes given function for each element in the set.
   *
   * If function returns `false` it will stop loop running.
   **
   > Parameters
   **
   - callback (function) function to run
   - thisArg (object) context object for the callback
   = (object) Set object
  \ */ setproto.forEach = function(callback, thisArg) {
        for(let i = 0, ii = this.items.length; i < ii; i++){
            if (callback.call(thisArg, this.items[i], i) === false) return this;
        }
        return this;
    };
    for(const method in elproto)if (elproto[has](method)) setproto[method] = function(methodname) {
        return function() {
            const arg = arguments;
            return this.forEach((el)=>{
                el[methodname][apply](el, arg);
            });
        };
    }(method);
    setproto.attr = function(name, value) {
        if (name && R.is(name, array) && R.is(name[0], "object")) for(let j = 0, jj = name.length; j < jj; j++)this.items[j].attr(name[j]);
        else for(let i = 0, ii = this.items.length; i < ii; i++)this.items[i].attr(name, value);
        return this;
    };
    /* \
   * Set.clear
   [ method ]
   **
   * Removes all elements from the set
  \ */ setproto.clear = function() {
        while(this.length)this.pop();
    };
    /* \
   * Set.splice
   [ method ]
   **
   * Removes given element from the set
   **
   > Parameters
   **
   - index (number) position of the deletion
   - count (number) number of element to remove
   - insertion (object) #optional elements to insert
   = (object) set elements that were deleted
  \ */ setproto.splice = function(index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        const tail = [];
        const todel = [];
        const args = [];
        let i;
        for(i = 2; i < arguments.length; i++)args.push(arguments[i]);
        for(i = 0; i < count; i++)todel.push(this[index + i]);
        for(; i < this.length - index; i++)tail.push(this[index + i]);
        const arglen = args.length;
        for(i = 0; i < arglen + tail.length; i++)this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        i = this.items.length = this.length -= count - arglen;
        while(this[i])delete this[i++];
        return new Set(todel);
    };
    /* \
   * Set.exclude
   [ method ]
   **
   * Removes given element from the set
   **
   > Parameters
   **
   - element (object) element to remove
   = (boolean) `true` if object was found & removed from the set
  \ */ setproto.exclude = function(el) {
        for(let i = 0, ii = this.length; i < ii; i++)if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function(params, ms, easing, callback) {
        (R.is(easing, "function") || !easing) && (callback = easing || null);
        let len = this.items.length;
        let i = len;
        let item;
        const set = this;
        let collector;
        if (!len) return this;
        callback && (collector = function() {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        const anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while(i--){
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            this.items[i] && !this.items[i].removed || len--;
        }
        return this;
    };
    setproto.insertAfter = function(el) {
        let i = this.items.length;
        while(i--)this.items[i].insertAfter(el);
        return this;
    };
    setproto.getBBox = function() {
        let x = [];
        let y = [];
        let x2 = [];
        let y2 = [];
        for(let i = this.items.length; i--;)if (!this.items[i].removed) {
            const box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x,
            y,
            x2,
            y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function(s) {
        s = this.paper.set();
        for(let i = 0, ii = this.items.length; i < ii; i++)s.push(this.items[i].clone());
        return s;
    };
    setproto.toString = function() {
        return "Rapha\xebl\u2018s set";
    };
    setproto.glow = function(glowConfig) {
        const ret = this.paper.set();
        this.forEach((shape, index)=>{
            const g = shape.glow(glowConfig);
            if (g != null) g.forEach((shape2, index2)=>{
                ret.push(shape2);
            });
        });
        return ret;
    };
    /* \
   * Set.isPointInside
   [ method ]
   **
   * Determine if given point is inside this sets elements
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (boolean) `true` if point is inside any of the set's elements
   \ */ setproto.isPointInside = function(x, y) {
        let isPointInside = false;
        this.forEach((el)=>{
            if (el.isPointInside(x, y)) {
                isPointInside = true;
                return false // stop loop
                ;
            }
        });
        return isPointInside;
    };
    /* \
   * Raphael.registerFont
   [ method ]
   **
   * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.
   * Returns original parameter, so it could be used with chaining.
   # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
   **
   > Parameters
   **
   - font (object) the font to register
   = (object) the font you passed in
   > Usage
   | Cufon.registerFont(Raphael.registerFont({}));
  \ */ R.registerFont = function(font) {
        if (!font.face) return font;
        this.fonts = this.fonts || {};
        const fontcopy = {
            w: font.w,
            face: {},
            glyphs: {}
        };
        const family = font.face["font-family"];
        for(const prop in font.face)if (font.face[has](prop)) fontcopy.face[prop] = font.face[prop];
        if (this.fonts[family]) this.fonts[family].push(fontcopy);
        else this.fonts[family] = [
            fontcopy
        ];
        if (!font.svg) {
            fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
            for(const glyph in font.glyphs)if (font.glyphs[has](glyph)) {
                const path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && `M${path.d.replace(/[mlcxtrv]/g, (command)=>({
                            l: "L",
                            c: "C",
                            x: "z",
                            t: "m",
                            r: "l",
                            v: "c"
                        })[command] || "M")}z`
                };
                if (path.k) {
                    for(const k in path.k)if (path[has](k)) fontcopy.glyphs[glyph].k[k] = path.k[k];
                }
            }
        }
        return font;
    };
    /* \
   * Paper.getFont
   [ method ]
   **
   * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.
   **
   > Parameters
   **
   - family (string) font family name or any word from it
   - weight (string) #optional font weight
   - style (string) #optional font style
   - stretch (string) #optional font stretch
   = (object) the font object
   > Usage
   | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
  \ */ paperproto.getFont = function(family, weight, style, stretch) {
        stretch = stretch || "normal";
        style = style || "normal";
        weight = +weight || ({
            normal: 400,
            bold: 700,
            lighter: 300,
            bolder: 800
        })[weight] || 400;
        if (!R.fonts) return;
        let font = R.fonts[family];
        if (!font) {
            const name = new RegExp(`(^|\\s)${family.replace(/[^\w\d\s+!~.:_-]/g, E)}(\\s|$)`, "i");
            for(const fontName in R.fonts)if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        let thefont;
        if (font) for(let i = 0, ii = font.length; i < ii; i++){
            thefont = font[i];
            if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) break;
        }
        return thefont;
    };
    /* \
   * Paper.print
   [ method ]
   **
   * Creates path that represent given text written using given font at given position with given size.
   * Result of the method is path element that contains whole text as a separate path.
   **
   > Parameters
   **
   - x (number) x position of the text
   - y (number) y position of the text
   - string (string) text to print
   - font (object) font object, see @Paper.getFont
   - size (number) #optional size of the font, default is `16`
   - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
   - letter_spacing (number) #optional number in range `-1..1`, default is `0`
   - line_spacing (number) #optional number in range `1..3`, default is `1`
   = (object) resulting path element, which consist of all letters
   > Usage
   | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
  \ */ paperproto.print = function(x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || "middle" // baseline|middle
        ;
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        const letters = Str(string)[split](E);
        let shift = 0;
        let notfirst = 0;
        let path = E;
        let scale;
        R.is(font, "string") && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face["units-per-em"];
            const bb = font.face.bbox[split](separator);
            const top = +bb[0];
            const lineHeight = bb[3] - bb[1];
            let shifty = 0;
            const height = +bb[1] + (origin == "baseline" ? lineHeight + +font.face.descent : lineHeight / 2);
            for(let i = 0, ii = letters.length; i < ii; i++){
                if (letters[i] == "\n") {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    const prev = notfirst && font.glyphs[letters[i - 1]] || {};
                    var curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) path += R.transformPath(curr.d, [
                    "t",
                    shift * scale,
                    shifty * scale,
                    "s",
                    scale,
                    scale,
                    top,
                    height,
                    "t",
                    (x - top) / scale,
                    (y - height) / scale
                ]);
            }
        }
        return this.path(path).attr({
            fill: "#000",
            stroke: "none"
        });
    };
    /* \
   * Paper.add
   [ method ]
   **
   * Imports elements in JSON array in format `{type: type, <attributes>}`
   **
   > Parameters
   **
   - json (array)
   = (object) resulting set of imported elements
   > Usage
   | paper.add([
   |     {
   |         type: "circle",
   |         cx: 10,
   |         cy: 10,
   |         r: 5
   |     },
   |     {
   |         type: "rect",
   |         x: 10,
   |         y: 10,
   |         width: 10,
   |         height: 10,
   |         fill: "#fc0"
   |     }
   | ]);
  \ */ paperproto.add = function(json) {
        if (R.is(json, "array")) {
            var res = this.set();
            let i = 0;
            const ii = json.length;
            let j;
            for(; i < ii; i++){
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };
    /* \
   * Raphael.format
   [ method ]
   **
   * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.
   **
   > Parameters
   **
   - token (string) string to format
   -  (string) rest of arguments will be treated as parameters for replacement
   = (string) formated string
   > Usage
   | var x = 10,
   |     y = 20,
   |     width = 40,
   |     height = 50;
   | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
   | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
  \ */ R.format = function(token, params) {
        const args = R.is(params, array) ? [
            0
        ][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, (str, i)=>args[++i] == null ? E : args[i]));
        return token || E;
    };
    /* \
   * Raphael.fullfill
   [ method ]
   **
   * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.
   **
   > Parameters
   **
   - token (string) string to format
   - json (object) object which properties will be used as a replacement
   = (string) formated string
   > Usage
   | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
   | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
   |     x: 10,
   |     y: 20,
   |     dim: {
   |         width: 40,
   |         height: 50,
   |         "negative width": -40
   |     }
   | }));
  \ */ R.fullfill = function() {
        const tokenRegex = /\{([^\}]+)\}/g;
        const objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g // matches .xxxxx or ["xxxxx"] to run over object properties
        ;
        const replacer = function(all, key, obj) {
            let res = obj;
            key.replace(objNotationRegex, (all, name, quote, quotedName, isFunc)=>{
                name = name || quotedName;
                if (res) {
                    if (name in res) res = res[name];
                    typeof res === "function" && isFunc && (res = res());
                }
            });
            res = `${res == null || res == obj ? all : res}`;
            return res;
        };
        return function(str, obj) {
            return String(str).replace(tokenRegex, (all, key)=>replacer(all, key, obj));
        };
    }();
    /* \
   * Raphael.ninja
   [ method ]
   **
   * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
   * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
   **
   = (object) Raphael object
   > Usage
   | (function (local_raphael) {
   |     var paper = local_raphael(10, 10, 320, 200);
   |     
   | })(Raphael.ninja());
  \ */ R.ninja = function() {
        if (oldRaphael.was) g.win.Raphael = oldRaphael.is;
        else {
            // IE8 raises an error when deleting window property
            window.Raphael = undefined;
            try {
                delete window.Raphael;
            } catch (e) {}
        }
        return R;
    };
    /* \
   * Raphael.st
   [ property (object) ]
   **
   * You can add your own method to elements and sets. It is wise to add a set method for each element method
   * you added, so you will be able to call the same method on sets too.
   **
   * See also @Raphael.el.
   > Usage
   | Raphael.el.red = function () {
   |     this.attr({fill: "#f00"});
   | };
   | Raphael.st.red = function () {
   |     this.forEach(function (el) {
   |         el.red();
   |     });
   | };
   | // then use it
   | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
  \ */ R.st = setproto;
    (0, _eveJs.eve).on("raphael.DOMload", ()=>{
        loaded = true;
    });
    (function(doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener) {
            doc.addEventListener(loaded, f = function() {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = "complete";
            }, false);
            doc.readyState = "loading";
        }
        function isLoaded() {
            /in/.test(doc && doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
        }
        isLoaded();
    })(document, "DOMContentLoaded");
    return R;
}();

},{"../eve.js":"9FQ0M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6wubb":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getTransformedPath);
var _utils = require("./utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
function getTransformedPath(originalPath, transforms) {
    let transformsArray = transforms;
    let transformedPath = originalPath;
    if (!transforms.find && typeof transforms === "string") transformsArray = [
        transforms
    ];
    // NOTE: it's safer to apply transforms one by one because this transform string `T${_x * percent}, ${_y * percent}, s${_width/150 * percent}, ${_height/100 * percent}, ${_x}, ${_y}`
    //      would be applied incorrectly - element would be translated using the center of scaling ${_x}, ${_y} which seems to be a bug in raphael.js
    transformsArray.forEach((transform)=>{
        transformedPath = (0, _utilsDefault.default)._transformPath(transformedPath, transform).toString();
    });
    return transformedPath;
}

},{"./utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpLaV":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
var _raphaelFnShapes = require("../deps/raphael/raphael.fn.shapes");
var _raphaelElExtensions = require("../deps/raphael/raphael.el.extensions");
var _embedGoogleFonts = require("../helpers/embedGoogleFonts");
var _embedGoogleFontsDefault = parcelHelpers.interopDefault(_embedGoogleFonts);
var _emile = require("../deps/emile");
class canvas {
    constructor(slate){
        const self = this;
        self.slate = slate;
        let c = slate.options.container;
        if (typeof c === "string") c = (0, _utilsDefault.default).el(c);
        if (c === undefined || c === null) throw new Error("You must provide a container to initiate the canvas!");
        // customize raphael -- modifies global Raphael for all other imports
        (0, _raphaelFnShapes.shapes)((0, _raphaelSvg.Raphael));
        (0, _raphaelElExtensions.extensions)((0, _raphaelSvg.Raphael));
        self.isDragging = false;
        self.slate.paper = null;
        self.internal = null;
        self.status = null;
        self.imageFolder = null;
        self.dken = null;
        self.eve = {
            init: [
                "onmousedown",
                "ontouchstart"
            ],
            drag: [
                "onmousemove",
                "ontouchmove"
            ],
            up: [
                "onmouseup",
                "ontouchend",
                "onmouseout"
            ],
            gest: [
                "ongesturestart",
                "ongesturechange",
                "ongestureend"
            ]
        };
    }
    init() {
        const self = this;
        const imageFolder = self.slate.options.imageFolder || "/images/";
        const c = self.slate.options.container;
        const { slate } = self;
        self.Canvas = {
            objInitPos: {},
            objInitialMousePos: {
                x: 0,
                y: 0
            },
            initDrag (e) {
                if (slate.isCtrl) slate.multiSelection?.start();
                if (slate.options.allowDrag) {
                    self.isDragging = true;
                    slate.multiSelection?.end();
                    slate.nodes?.closeAllMenus();
                    const m = (0, _utilsDefault.default).mousePos(e);
                    self.Canvas.objInitPos = (0, _utilsDefault.default).positionedOffset(self.internal);
                    const offsets = (0, _utilsDefault.default).positionedOffset(slate.options.container);
                    self.Canvas.objInitialMousePos = {
                        x: m.x + offsets.left,
                        y: m.y + offsets.top
                    };
                    const xy = self.cp(e);
                    if (self.status) self.status.innerHTML = `${Math.abs(xy.x)}, ${Math.abs(xy.y)}`;
                    if (slate.options.showStatus) {
                        if (self.status) self.status.style.display = "block";
                        slate.multiSelection?.hide();
                    }
                    self.internal.style.cursor = `url(${imageFolder}closedhand.cur), default`;
                    if (m.allTouches) slate.options.lastTouches = m.allTouches;
                    if (slate.removeContextMenus) slate.removeContextMenus();
                    slate.draggingZoom = self.slate.options.viewPort.zoom;
                    // hide filters during dragging
                    slate.toggleFilters(true);
                    (0, _utilsDefault.default).stopEvent(e);
                } else if (slate.onSelectionStart) slate.onSelectionStart.apply(self, [
                    e
                ]);
                else (0, _utilsDefault.default).stopEvent(e);
            },
            setCursor () {
                if (self.isDragging) self.internal.style.cursor = `url(${imageFolder}closedhand.cur), default`;
                else self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
            },
            onDrag (e) {
                requestAnimationFrame(()=>{
                    // broadcast custom collab
                    const mp = (0, _utilsDefault.default).mousePos(e);
                    const curPos = (0, _utilsDefault.default).positionedOffset(self.internal);
                    mp.currentZoom = slate.options.viewPort.zoom.r;
                    mp.left = Math.abs(curPos.left);
                    mp.top = Math.abs(curPos.top);
                    slate.collab?.send({
                        type: "onMouseMoved",
                        data: mp
                    });
                    if (self.isDragging && slate.options.allowDrag) {
                        const xy = self.cp(e);
                        if (xy.allTouches && xy.allTouches.length > 1) slate.options.lastTouches = xy.allTouches;
                        if (self.status) self.status.innerHTML = `${Math.abs(xy.x)}, ${Math.abs(xy.y)}`;
                        self.internal.style.left = `${xy.x}px`;
                        self.internal.style.top = `${xy.y}px`;
                    }
                });
            },
            endDrag (e) {
                if (self.isDragging && slate.options.allowDrag) {
                    self.isDragging = false;
                    self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
                    if (self.status) self.status.style.display = "none";
                    slate.multiSelection?.show();
                    const xy = self.cp(e);
                    slate.draggingZoom = null;
                    self.endDrag(xy);
                    // show filters after dragging
                    slate.toggleFilters(false);
                }
            }
        };
        // wipe it clean
        if (!slate.options.preserve) c.innerHTML = "";
        if (self.slate.paper) self.slate.paper.clear();
        if (self.internal) c.removeChild(self.internal);
        // internal
        self.internal = document.createElement("div");
        self.internal.setAttribute("class", `slateboxInternal_${self.slate.options.id} sb_canvas`);
        // console.log("setting slate canvas", `slateboxInternal_${self.slate.options.id}`);
        const _w = slate.options.viewPort.width;
        const _h = slate.options.viewPort.height;
        const _l = slate.options.viewPort.left;
        const _t = slate.options.viewPort.top;
        self.internal.style.width = `${_w + 100000}px`;
        self.internal.style.height = `${_h + 100000}px`;
        self.internal.style.left = `${_l * -1}px`;
        self.internal.style.top = `${_t * -1}px`;
        self.internal.style.position = "absolute";
        self.internal.style["-webkit-transform"] = `translateZ(0)`;
        self.internal.style.transform = `translateZ(0)` // `translate3d(0,0,0)`; //helps with GPU based rendering
        ;
        c.appendChild(self.internal);
        self.internal.addEventListener("mousedown", ()=>{
            self.slate?.events?.onCanvasClicked?.apply();
        });
        // status
        if (self.slate.options.showStatus) {
            self.status = document.createElement("div");
            self.status.style.position = "absolute";
            self.status.style.height = "20px";
            self.status.style.left = "5px";
            self.status.style.color = "#000";
            self.status.style.fontSize = "10pt";
            self.status.style.fontFamily = "trebuchet ms";
            self.status.style.top = "0px";
            self.status.style.display = "none";
            self.status.style.padding = "5px";
            self.status.style.filter = "alpha(opacity=80)";
            self.status.style.opacity = ".80";
            self.status.style.backgroundColor = "#ffff99";
            self.status.style.fontWeight = "bold";
            c.appendChild(self.status);
        }
        // style container
        c.style.position = "relative";
        c.style.overflow = "hidden";
        // style internal
        self.internal.style.borderTop = `${slate.borderTop}px`;
        self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
        self.slate.paper = (0, _raphaelSvg.Raphael)(self.internal, _w, _h);
        self.refreshBackground();
        if (slate.options.allowDrag) self.wire();
        slate.options.viewPort.originalHeight = _h;
        slate.options.viewPort.originalWidth = _w;
        // set up initial zoom params
        self.resize(_w);
        // show zoom slider
        if (slate.options.showZoom && !slate.options.isEmbedded) {
            if (slate.zoomSlider) slate.zoomSlider.show(slate.options.viewPort.width);
        }
        // show undo redo
        if (slate.options.showUndoRedo && !slate.options.isEmbedded) {
            if (slate.undoRedo) slate.undoRedo.show();
        }
        // show birdsEye -- this is self referential on canvas in loadJSON inside slate, so this must be deferred until canvas constructor is done.
        if (slate.options.showbirdsEye && !slate.options.isEmbedded) {
            if (slate.birdsEye.enabled()) slate.birdsEye.reload(slate.exportJSON());
            else slate.birdsEye.show({
                size: slate.options.sizeOfbirdsEye || 200,
                onHandleMove () {}
            });
        }
        // set up the shareable/branding if need be
        if (!slate.options.isbirdsEye && (slate.options.isSharing || slate.options.isEmbedding)) {
            const _btnSize = 25;
            const _scaleSize = _btnSize - 3;
            const _iframe = document.getElementById("snap_slate");
            const _parent = document.createElement("div");
            _parent.className = "sb_parent_shareable";
            const _styles = (0, _utilsDefault.default).buildStyle({
                height: _iframe ? `${_scaleSize + 8}px` : `${_scaleSize}px`
            });
            _parent.setAttribute("style", _styles);
            if (slate.options.isEmbedding && !slate.options.nobrand) {
                const _brand = document.createElement("a");
                _brand.className = "sb_brand";
                _brand.setAttribute("href", "https://slatebox.com");
                _brand.innerHTML = "built with slatebox";
                _parent.appendChild(_brand);
            }
            if (!slate.options.isbirdsEye && slate.options.isSharing) {
                const _svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${_btnSize}" height="${_btnSize}"><path fill="#333" stroke="#000" d="{path}" stroke-dasharray="none" stroke-width="1" opacity="1" fill-opacity="1"></path></svg>`;
                [
                    "download",
                    "embed"
                ].forEach((e)=>{
                    const _btn = document.createElement("div");
                    _btn.className = "sb_share";
                    _btn.setAttribute("data-action", e);
                    const _bstyles = (0, _utilsDefault.default).buildStyle({
                        width: `${_btnSize}px`,
                        height: `${_btnSize}px`
                    });
                    _btn.setAttribute("style", _bstyles);
                    const _new = (0, _utilsDefault.default).centerAndScalePathToFitContainer({
                        containerSize: _btnSize,
                        scaleSize: _scaleSize,
                        path: (0, _sbIconsDefault.default).icons[e]
                    });
                    _btn.innerHTML = _svg.replace(/{path}/gi, _new.path);
                    _parent.appendChild(_btn);
                    (0, _utilsDefault.default).addEvent(_btn, "click", ()=>{
                        const _act = this.getAttribute("data-action");
                        switch(_act){
                            case "embed":
                                {
                                    const _et = document.createElement("textarea");
                                    document.body.appendChild(_et);
                                    let _val = "";
                                    if (_iframe) _val = `<iframe id='sb_embed_${slate.options.id}' src='${window.location.href}' width='${_iframe.clientWidth}' height='${_iframe.clientHeight}' frameborder='0' scrolling='no'></iframe>`;
                                    else {
                                        const _ele = slate.options.container.parentElement;
                                        const _raw = _ele.innerHTML;
                                        const _split = _raw.split('<div class="slateboxInternal"');
                                        const _orig = `${_split[0]}<script>${_split[1].split("<script>")[1]}`;
                                        _val = `<div id="sb_embed_${slate.options.id}">${_orig}</div>`;
                                    }
                                    _et.value = _val;
                                    _et.select();
                                    document.execCommand("copy");
                                    document.body.removeChild(_et);
                                    const _note = document.createElement("div");
                                    _note.innerHTML = "Copied!";
                                    _note.setAttribute("style", (0, _utilsDefault.default).buildStyle({
                                        "font-size": "11pt",
                                        "text-align": "center",
                                        padding: "4px",
                                        "margin-right": "-1px",
                                        width: "125px",
                                        height: "22px",
                                        position: "absolute",
                                        right: 0,
                                        bottom: 0,
                                        "background-color": "#333",
                                        color: "#fff"
                                    }));
                                    _parent.appendChild(_note);
                                    window.setTimeout(()=>{
                                        _parent.removeChild(_note);
                                    }, 1500);
                                    break;
                                }
                            case "download":
                                slate.png();
                                break;
                            default:
                                break;
                        }
                    });
                });
            }
            if (slate.options.isEmbedding && _parent.innerHTML !== "") c.appendChild(_parent);
        }
        self.windowSize = (0, _utilsDefault.default).windowSize();
        self.containerOffset = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        (0, _utilsDefault.default).addEvent(window, "resize", ()=>{
            self.windowSize = (0, _utilsDefault.default).windowSize();
            self.containerOffset = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
            if (self.dken !== null) {
                self.dken.style.width = `${self.ws.width}px`;
                self.dken.style.height = `${self.ws.height}px`;
            }
        });
        setTimeout(()=>{
            self.slate.birdsEye?.setBe();
            self.slate.birdsEye?.refresh();
        // set init
        // self.Canvas.objInitPos = utils.positionedOffset(self.internal)
        // console.log('init mouse', self.Canvas.objInitPos)
        }, 500);
        // self.cp()
        // self.initDragDefaults()
        self.completeInit = true;
    }
    cp(e) {
        const m = e ? (0, _utilsDefault.default).mousePos(e) : {
            x: 0,
            y: 0
        };
        let difX = this.Canvas.objInitPos.left + (m.x - this.Canvas.objInitialMousePos.x);
        let difY = this.Canvas.objInitPos.top + (m.y - this.Canvas.objInitialMousePos.y);
        return {
            x: difX,
            y: difY
        };
    }
    endDrag(coords) {
        this.slate.options.viewPort.left = Math.abs(coords.x);
        this.slate.options.viewPort.top = Math.abs(coords.y);
        this.internal.style.left = `${coords.x}px`;
        this.internal.style.top = `${coords.y}px`;
        const curPos = (0, _utilsDefault.default).positionedOffset(this.internal);
        const moved = {
            x: this.Canvas.objInitPos.left - curPos.left,
            y: this.Canvas.objInitPos.top - curPos.top
        };
        this.slate.birdsEye?.refresh(true);
        if (this.slate.options.allowCollaboration) this.broadcast(moved);
    }
    broadcast(moved) {
        this.slate.collab?.send({
            type: "onCanvasMove",
            data: {
                left: this.slate.options.viewPort.left,
                top: this.slate.options.viewPort.top,
                relative: moved,
                orient: this.slate.getOrientation()
            }
        });
    }
    zoom(_opts) {
        const self = this;
        const opts = {
            dur: 500,
            callbacks: {
                after: null,
                during: null
            },
            easing: "easeFromTo",
            zoomPercent: 100
        };
        Object.assign(opts, _opts);
        self.slate.nodes.closeAllConnectors();
        const _startZoom = self.slate.options.viewPort.zoom.w || 50000;
        const _targetZoom = self.slate.options.viewPort.originalWidth * (100 / parseInt(opts.zoomPercent, 10));
        const _zoomDif = Math.abs(_targetZoom - _startZoom);
        opts.dur = !opts.dur && opts.dur !== 0 ? 500 : opts.dur;
        // eslint-disable-next-line no-undef
        emile(self.internal, "padding:1px", {
            duration: opts.dur,
            before () {
                self.slate.options.allowDrag = false;
            },
            after () {
                self.slate.options.allowDrag = true;
                self.slate.zoomSlider.set(_targetZoom);
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.after?.apply(self.slate, [
                    _targetZoom
                ]);
            },
            during (pc) {
                const _val = _targetZoom > _startZoom ? _startZoom + _zoomDif * pc : _startZoom - _zoomDif * pc;
                self.slate.zoom(0, 0, _val, _val, false);
                self.slate.canvas.resize(_val);
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.during?.apply(pc);
            },
            easing: (0, _utilsDefault.default).easing[opts.easing]
        });
    }
    move(_opts) {
        const self = this;
        const opts = {
            x: 0,
            y: 0,
            dur: 500,
            callbacks: {
                after: null,
                during: null
            },
            isAbsolute: true,
            easing: "easeFromTo"
        };
        Object.assign(opts, _opts);
        let { x, y } = opts;
        if (opts.isAbsolute === false) {
            x = self.slate.options.viewPort.left + x;
            y = self.slate.options.viewPort.top + y;
        }
        self.slate.nodes.closeAllConnectors();
        if (opts.dur > 0) // eslint-disable-next-line no-undef
        emile(self.internal, `left:${x * -1}px;top:${y * -1}px`, {
            duration: opts.dur,
            before () {
                self.slate.options.allowDrag = false;
            },
            after () {
                self.slate.options.allowDrag = true;
                self.slate.options.viewPort.left = Math.abs(parseInt(self.internal.style.left.replace("px", ""), 10));
                self.slate.options.viewPort.top = Math.abs(parseInt(self.internal.style.top.replace("px", ""), 10));
                self.slate.birdsEye?.refresh(true);
                opts.callbacks.after?.apply(self.slate);
            },
            during (pc) {
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.during?.apply(pc);
            },
            easing: (0, _utilsDefault.default).easing[opts.easing]
        });
        else window.requestAnimationFrame(()=>{
            self.internal.style.left = `${x * -1}px`;
            self.internal.style.top = `${y * -1}px`;
            self.slate.options.viewPort.left = Math.abs(x);
            self.slate.options.viewPort.top = Math.abs(y);
            opts.callbacks?.after?.apply(self.slate);
        });
    }
    bbox() {
        const dimen = (0, _utilsDefault.default).getDimensions(this.slate.options.container);
        return {
            x: Math.abs(this.slate.options.viewPort.top),
            y: Math.abs(this.slate.options.viewPort.left),
            width: dimen.width,
            height: dimen.height
        };
    }
    resize(val) {
        const uval = parseInt(val, 10);
        const R = this.slate.options.viewPort.width / uval;
        const dimen = (0, _utilsDefault.default).getDimensions(this.slate.options.container);
        let _top = this.slate.options.viewPort.top * -1 * R;
        let _left = this.slate.options.viewPort.left * -1 * R;
        const _centerY = (dimen.height / 2 * R - dimen.height / 2) * -1;
        const _centerX = (dimen.width / 2 * R - dimen.width / 2) * -1;
        _top += _centerY;
        _left += _centerX;
        const threshold = this.slate.options.viewPort.originalWidth - 1000;
        if (-_top > threshold || -_left > threshold) return false;
        this.internal.style.top = `${_top}px`;
        this.internal.style.left = `${_left}px`;
        this.slate.options.viewPort.zoom = {
            w: uval,
            h: uval,
            l: parseFloat(_left * -1),
            t: parseFloat(_top * -1),
            r: this.slate.options.viewPort.originalWidth / uval
        };
        return true;
    }
    clear() {
        this.slate.options.container.innerHTML = "";
        return this.slate._;
    }
    wire() {
        const self = this;
        self.eve.init.forEach((ee)=>{
            self.internal[ee] = self.Canvas.initDrag;
        });
        self.eve.drag.forEach((ee)=>{
            self.internal[ee] = self.Canvas.onDrag;
        });
        self.eve.up.forEach((ee)=>{
            self.internal[ee] = self.Canvas.endDrag;
        });
    }
    unwire() {
        const self = this;
        self.eve.init.forEach((ee)=>{
            self.internal[ee] = null;
        });
        self.eve.drag.forEach((ee)=>{
            self.internal[ee] = null;
        });
        self.eve.up.forEach((ee)=>{
            self.internal[ee] = null;
        });
    }
    rawSVG(cb) {
        const self = this;
        function finalize(svg) {
            if (self.slate.events.onOptimizeSVG) self.slate.events.onOptimizeSVG(svg, (err, optimized)=>{
                if (err) console.error("Unable to optimize slate svg export", err);
                else cb(optimized);
            });
            else cb(svg);
        }
        function extractImages(__svg) {
            let ssvg = __svg;
            const images = (0, _lodashUniqDefault.default)(self.slate.nodes.allNodes.map((n)=>n.options.image).filter((f)=>!!f));
            if (images.length > 0) images.forEach((i, ind)=>{
                if (self.slate.events.onBase64ImageRequested) {
                    // server side gen
                    let imageType = "png";
                    if (i.indexOf("jpg")) imageType = "jpeg";
                    else if (i.indexOf("gif")) imageType = "gif";
                    self.slate.events.onBase64ImageRequested(i, imageType, (err, res)=>{
                        if (err) console.error("Unable to retrieve base64 from image", err);
                        else {
                            const ix = i.replace(/&/gi, "&amp;");
                            while(ssvg.indexOf(ix) > -1)ssvg = ssvg.replace(ix, res);
                        }
                        if (ind + 1 === images.length) finalize(ssvg);
                    });
                } else // client side only -- good luck with CORS - this method should be avoided
                (0, _utilsDefault.default).toDataUrl(i).then((dataUrl)=>{
                    ssvg = ssvg.replace(new RegExp(i, "gi"), dataUrl);
                }).catch((err)=>{
                    console.error("Unable to get image", err);
                }).finally(()=>{
                    if (ind + 1 === images.length) finalize(ssvg);
                });
            });
            else finalize(ssvg);
        }
        // always embed fonts and fix links -- a style node is always added in the init
        (0, _embedGoogleFontsDefault.default)({
            fonts: (0, _lodashUniqDefault.default)(self.slate.nodes.allNodes.map((n)=>n.options.fontFamily)),
            text: (0, _lodashUniqDefault.default)(self.slate.nodes.allNodes.flatMap((n)=>n.options.text.replace(/ /gi, "").split(""))).join("").trim(),
            styleNode: self.internal.querySelector("svg > defs > style")
        }).then(()=>{
            // need to swap out xlink:href with href for the blob to work w/ the pixelate (or other) filter
            let __svg = self.internal.innerHTML.replace(/xlink:href/gi, "href");
            const slateBg = self.slate.options.containerStyle.backgroundImage;
            if (slateBg) {
                // server side gen
                let bgImageType = "png";
                if (slateBg.indexOf("jpg")) bgImageType = "jpeg";
                else if (slateBg.indexOf("gif")) bgImageType = "gif";
                self.slate.events.onBase64ImageRequested(slateBg, bgImageType, (err, res)=>{
                    if (err) console.error("Unable to retrieve base64 from image", err);
                    else __svg = __svg.replace(slateBg, res);
                    extractImages(__svg);
                });
            } else extractImages(__svg);
        });
    }
    bgToBack() {
        this._bg?.toBack();
    }
    hideBg(t) {
        const self = this;
        const e = self.slate.options.containerStyle.backgroundEffect;
        self._bg?.remove();
        delete self._bg;
        if (e) {
            if (!self.slate.options.isbirdsEye) {
                clearTimeout(self.showBgTimeout);
                self.showBgTimeout = setTimeout(()=>{
                    if (!(0, _utilsDefault.default).isSafari()) {
                        const attrs = {
                            filter: `url(#${e})`
                        };
                        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile() && self.slate.filters.availableFilters[e]?.fill) attrs.fill = `url(#${self.slate.filters.availableFilters[e]?.fill})`;
                        self._bg = self.slate.paper.rect(0, 0, self.slate.options.viewPort.width, self.slate.options.viewPort.height).attr(attrs).toBack();
                    }
                }, t || 2500);
            }
        }
        self.refreshBackground();
    }
    refreshBackground() {
        const self = this;
        self.internal.style.backgroundColor = "";
        if (self.internal.parentElement) {
            self.internal.parentElement.style.backgroundImage = "";
            self.internal.parentElement.style.backgroundSize = "";
            self.internal.parentElement.style.background = "";
        }
        self.internal.style.backgroundSize = "";
        self.internal.style.backgroundPosition = "";
        if (self.slate.options.containerStyle.backgroundEffect) self.slate.options.containerStyle.backgroundColor = self.slate.filters.availableFilters[self.slate.options.containerStyle.backgroundEffect].backgroundColor;
        if (self.slate.options.containerStyle.backgroundImage) {
            self.slate.options.containerStyle.prevBackgroundColor = self.slate.options.containerStyle.backgroundColor;
            self.slate.options.containerStyle.backgroundColor = "transparent";
            if (self.internal.parentElement) {
                self.internal.parentElement.style.backgroundImage = `url('${self.slate.options.containerStyle.backgroundImage}')`;
                if (self.slate.options.containerStyle.backgroundSize) self.internal.parentElement.style.backgroundSize = self.slate.options.containerStyle.backgroundSize;
            }
        }
        // show only on first load
        if (!self.initBg && self.slate.options.containerStyle.backgroundEffect) {
            self.initBg = true;
            self.hideBg(1);
        }
        switch(self.slate.options.containerStyle.backgroundColor){
            case "transparent":
                if (!self.slate.options.isbirdsEye) {
                    if (self.slate.options.isEmbedding) self.internal.style.backgroundColor = "";
                    else if (!self.slate.options.containerStyle.backgroundImage) {
                        self.internal.style.backgroundImage = "linear-gradient(45deg,rgba(13,26,43,0.1) 25%,transparent 25%,transparent 75%,rgba(13,26,43,0.1) 75%),linear-gradient(45deg,rgba(13,26,43,0.1) 25%,transparent 25%,transparent 75%,rgba(13,26,43,0.1) 75%)";
                        self.internal.style.backgroundSize = "12px 12px";
                        self.internal.style.backgroundPosition = "0 0,6px 6px";
                    }
                }
                break;
            default:
                if (self.slate.options.containerStyle.backgroundColorAsGradient) {
                    self.internal.style.backgroundColor = "";
                    if (self.internal.parentElement) {
                        const bgStyle = `${self.slate.options.containerStyle.backgroundGradientType}-gradient(${self.slate.options.containerStyle.backgroundGradientColors.join(",")})`;
                        self.internal.parentElement.style.background = bgStyle;
                    }
                } else self.internal.style.backgroundColor = self.slate.options.containerStyle.backgroundColor || "#fff";
                break;
        }
        self.slate.grid?.setGrid();
    }
    get() {
        return this.internal;
    }
    draggable() {
        return this.internal;
    }
}
exports.default = canvas;

},{"lodash.uniq":"iDalh","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","../deps/raphael/raphael.svg":"jK21R","../deps/raphael/raphael.fn.shapes":"k1q4m","../deps/raphael/raphael.el.extensions":"7Msrc","../helpers/embedGoogleFonts":"jW8Fw","../deps/emile":"dd61Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5LoVV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class sbIcons {
    static icons = {
        handle: "M26.33,15.836l-3.893-1.545l3.136-7.9c0.28-0.705-0.064-1.505-0.771-1.785c-0.707-0.28-1.506,0.065-1.785,0.771l-3.136,7.9l-4.88-1.937l3.135-7.9c0.281-0.706-0.064-1.506-0.77-1.786c-0.706-0.279-1.506,0.065-1.785,0.771l-3.136,7.9L8.554,8.781l-1.614,4.066l2.15,0.854l-2.537,6.391c-0.61,1.54,0.143,3.283,1.683,3.895l1.626,0.646L8.985,26.84c-0.407,1.025,0.095,2.188,1.122,2.596l0.93,0.369c1.026,0.408,2.188-0.095,2.596-1.121l0.877-2.207l1.858,0.737c1.54,0.611,3.284-0.142,3.896-1.682l2.535-6.391l1.918,0.761L26.33,15.836z",
        editor: "M25.31,2.872l-3.384-2.127c-0.854-0.536-1.979-0.278-2.517,0.576l-1.334,2.123l6.474,4.066l1.335-2.122C26.42,4.533,26.164,3.407,25.31,2.872zM6.555,21.786l6.474,4.066L23.581,9.054l-6.477-4.067L6.555,21.786zM5.566,26.952l-0.143,3.819l3.379-1.787l3.14-1.658l-6.246-3.925L5.566,26.952z",
        deleter: "M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z",
        searcher: "M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z",
        up: "M1.67892,15.48059l23.55337,0l-11.37616,-13.92457l-12.17721,13.92457z",
        arrow: "M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM13.665,25.725l-3.536-3.539l6.187-6.187l-6.187-6.187l3.536-3.536l9.724,9.723L13.665,25.725z",
        settings: "M16.015,12.03c-2.156,0-3.903,1.747-3.903,3.903c0,2.155,1.747,3.903,3.903,3.903c0.494,0,0.962-0.102,1.397-0.27l0.836,1.285l1.359-0.885l-0.831-1.276c0.705-0.706,1.142-1.681,1.142-2.757C19.918,13.777,18.171,12.03,16.015,12.03zM16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM26.174,20.809c-0.241,0.504-0.513,0.99-0.826,1.45L22.19,21.58c-0.481,0.526-1.029,0.994-1.634,1.385l0.119,3.202c-0.507,0.23-1.028,0.421-1.569,0.57l-1.955-2.514c-0.372,0.051-0.75,0.086-1.136,0.086c-0.356,0-0.706-0.029-1.051-0.074l-1.945,2.5c-0.541-0.151-1.065-0.342-1.57-0.569l0.117-3.146c-0.634-0.398-1.208-0.88-1.712-1.427L6.78,22.251c-0.313-0.456-0.583-0.944-0.826-1.448l2.088-2.309c-0.226-0.703-0.354-1.451-0.385-2.223l-2.768-1.464c0.055-0.563,0.165-1.107,0.301-1.643l3.084-0.427c0.29-0.702,0.675-1.352,1.135-1.942L8.227,7.894c0.399-0.389,0.83-0.744,1.283-1.07l2.663,1.672c0.65-0.337,1.349-0.593,2.085-0.75l0.968-3.001c0.278-0.021,0.555-0.042,0.837-0.042c0.282,0,0.56,0.022,0.837,0.042l0.976,3.028c0.72,0.163,1.401,0.416,2.036,0.75l2.704-1.697c0.455,0.326,0.887,0.681,1.285,1.07l-1.216,2.986c0.428,0.564,0.793,1.181,1.068,1.845l3.185,0.441c0.135,0.535,0.247,1.081,0.302,1.643l-2.867,1.516c-0.034,0.726-0.15,1.43-0.355,2.1L26.174,20.809z",
        sliderHandle: "M16,3.5c-4.142,0-7.5,3.358-7.5,7.5c0,4.143,7.5,18.121,7.5,18.121S23.5,15.143,23.5,11C23.5,6.858,20.143,3.5,16,3.5z M16,14.584z",
        speechbubble: "M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z",
        link: "M15.667,4.601c-1.684,1.685-2.34,3.985-2.025,6.173l3.122-3.122c0.004-0.005,0.014-0.008,0.016-0.012c0.21-0.403,0.464-0.789,0.802-1.126c1.774-1.776,4.651-1.775,6.428,0c1.775,1.773,1.777,4.652,0.002,6.429c-0.34,0.34-0.727,0.593-1.131,0.804c-0.004,0.002-0.006,0.006-0.01,0.01l-3.123,3.123c2.188,0.316,4.492-0.34,6.176-2.023c2.832-2.832,2.83-7.423,0-10.255C23.09,1.77,18.499,1.77,15.667,4.601zM14.557,22.067c-0.209,0.405-0.462,0.791-0.801,1.131c-1.775,1.774-4.656,1.774-6.431,0c-1.775-1.774-1.775-4.653,0-6.43c0.339-0.338,0.725-0.591,1.128-0.8c0.004-0.006,0.005-0.012,0.011-0.016l3.121-3.123c-2.187-0.316-4.489,0.342-6.172,2.024c-2.831,2.831-2.83,7.423,0,10.255c2.833,2.831,7.424,2.831,10.257,0c1.684-1.684,2.342-3.986,2.023-6.175l-3.125,3.123C14.565,22.063,14.561,22.065,14.557,22.067zM9.441,18.885l2.197,2.197c0.537,0.537,1.417,0.537,1.953,0l8.302-8.302c0.539-0.536,0.539-1.417,0.002-1.952l-2.199-2.197c-0.536-0.539-1.416-0.539-1.952-0.002l-8.302,8.303C8.904,17.469,8.904,18.349,9.441,18.885z",
        copy: "M 20.48 7.28 H 9.92 c -0.968 0 -1.76 0.792 -1.76 1.76 v 12.32 h 1.76 V 9.04 h 10.56 V 7.28 z m 2.64 3.52 H 13.44 c -0.968 0 -1.76 0.792 -1.76 1.76 v 12.32 c 0 0.968 0.792 1.76 1.76 1.76 h 9.68 c 0.968 0 1.76 -0.792 1.76 -1.76 V 12.56 c 0 -0.968 -0.792 -1.76 -1.76 -1.76 z m 0 14.08 H 13.44 V 12.56 h 9.68 v 12.32 z",
        plus: "M25.979,12.896 19.312,12.896 19.312,6.229 12.647,6.229 12.647,12.896 5.979,12.896 5.979,19.562 12.647,19.562 12.647,26.229 19.312,26.229 19.312,19.562 25.979,19.562z",
        minus: "M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z",
        arrowHead: "M15.834,29.084 15.834,16.166 2.917,16.166 29.083,2.917z",
        undo: "M12.981,9.073V6.817l-12.106,6.99l12.106,6.99v-2.422c3.285-0.002,9.052,0.28,9.052,2.269c0,2.78-6.023,4.263-6.023,4.263v2.132c0,0,13.53,0.463,13.53-9.823C29.54,9.134,17.952,8.831,12.981,9.073z",
        lockClosed: "M24.875,15.334v-4.876c0-4.894-3.981-8.875-8.875-8.875s-8.875,3.981-8.875,8.875v4.876H5.042v15.083h21.916V15.334H24.875zM10.625,10.458c0-2.964,2.411-5.375,5.375-5.375s5.375,2.411,5.375,5.375v4.876h-10.75V10.458zM18.272,26.956h-4.545l1.222-3.667c-0.782-0.389-1.324-1.188-1.324-2.119c0-1.312,1.063-2.375,2.375-2.375s2.375,1.062,2.375,2.375c0,0.932-0.542,1.73-1.324,2.119L18.272,26.956z",
        lockOpen: "M24.875,15.334v-4.876c0-4.894-3.981-8.875-8.875-8.875s-8.875,3.981-8.875,8.875v0.375h3.5v-0.375c0-2.964,2.411-5.375,5.375-5.375s5.375,2.411,5.375,5.375v4.876H5.042v15.083h21.916V15.334H24.875zM18.272,26.956h-4.545l1.222-3.667c-0.782-0.389-1.324-1.188-1.324-2.119c0-1.312,1.063-2.375,2.375-2.375s2.375,1.062,2.375,2.375c0,0.932-0.542,1.73-1.324,2.119L18.272,26.956z",
        download: "M62.498910964222794,5C30.742627701282224,5,5,30.744805772836607,5,62.498910964222794C5,94.25519422716337,30.744805772836607,120,62.498910964222794,120C94.25519422716337,120,120,94.2551942271634,120,62.49891096422281C120,30.742627701282238,94.2551942271634,5.000000000000014,62.49891096422281,5.000000000000014C62.49891096422281,5.000000000000014,62.498910964222794,5,62.498910964222794,5M62.50108903577718,90.76374552548342C62.50108903577718,90.76374552548342,43.81105702759522,62.498910964222794,43.81105702759522,62.498910964222794C43.81105702759522,62.498910964222794,51.6085531922953,62.498910964222794,51.6085531922953,62.498910964222794C51.6085531922953,62.498910964222794,51.6085531922953,36.362052311596806,51.6085531922953,36.362052311596806C51.6085531922953,36.362052311596806,71.21119718176479,36.362052311596806,71.21119718176479,36.362052311596806C71.21119718176479,36.362052311596806,71.21119718176479,62.498910964222794,71.21119718176479,62.498910964222794C71.21119718176479,62.498910964222794,81.18676490085039,62.498910964222794,81.18676490085039,62.498910964222794C81.18676490085039,62.498910964222794,62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342C62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342",
        embed: "M62.49999999999999,5C30.759999999999998,5,5,30.759999999999998,5,62.49999999999999C5,94.23999999999998,30.759999999999998,120,62.49999999999999,120C94.23999999999998,120,120,94.23999999999998,120,62.49999999999999C120,30.760000000000005,94.23999999999998,5,62.49999999999999,5C62.49999999999999,5,62.49999999999999,5,62.49999999999999,5M46.285,74.57499999999999C47.894999999999996,76.41499999999999,47.665,79.28999999999999,45.824999999999996,80.9C43.98499999999999,82.51000000000002,41.10999999999999,82.28,39.5,80.44C39.5,80.44,26.505,65.375,26.505,65.375C25.009999999999998,63.65,25.009999999999998,61.23499999999999,26.505,59.50999999999999C26.505,59.50999999999999,39.385,44.44499999999999,39.385,44.44499999999999C40.19,43.41,41.455,42.834999999999994,42.834999999999994,42.834999999999994C43.86999999999999,42.834999999999994,44.904999999999994,43.17999999999999,45.709999999999994,43.86999999999999C46.62999999999999,44.675,47.20499999999999,45.709999999999994,47.20499999999999,46.974999999999994C47.31999999999999,48.125,46.85999999999999,49.275,46.169999999999995,50.19499999999999C46.169999999999995,50.19499999999999,35.81999999999999,62.49999999999999,35.81999999999999,62.49999999999999C35.81999999999999,62.49999999999999,46.285,74.57499999999999,46.285,74.57499999999999C46.285,74.57499999999999,46.285,74.57499999999999,46.285,74.57499999999999M73.08,49.275C73.08,49.275,60.199999999999996,79.28999999999999,60.199999999999996,79.28999999999999C59.28,81.475,56.519999999999996,82.625,54.334999999999994,81.59C53.184999999999995,81.13,52.37999999999999,80.20999999999998,51.919999999999995,79.17500000000001C51.459999999999994,78.025,51.459999999999994,76.875,51.919999999999995,75.725C51.919999999999995,75.725,64.8,45.709999999999994,64.8,45.709999999999994C65.49,44.099999999999994,67.1,42.949999999999996,68.94,42.949999999999996C69.515,42.949999999999996,70.09,43.065,70.66499999999999,43.294999999999995C71.815,43.754999999999995,72.62,44.675,73.08,45.709999999999994C73.53999999999999,46.974999999999994,73.53999999999999,48.125,73.08,49.275C73.08,49.275,73.08,49.275,73.08,49.275M98.495,65.375C98.495,65.375,85.61499999999998,80.44,85.61499999999998,80.44C84.005,82.28,81.13,82.50999999999999,79.28999999999999,80.9C77.44999999999999,79.29000000000002,77.22,76.41499999999999,78.82999999999998,74.57499999999999C78.82999999999998,74.57499999999999,89.17999999999998,62.49999999999999,89.17999999999998,62.49999999999999C89.17999999999998,62.49999999999999,78.715,50.425,78.715,50.425C77.91,49.505,77.565,48.355,77.68,47.205C77.79499999999999,46.055,78.37,44.905,79.17500000000001,44.099999999999994C79.98000000000002,43.41,81.01499999999999,43.065,82.05000000000001,43.065C83.315,43.065,84.58000000000001,43.64,85.5,44.675C85.5,44.675,98.495,59.739999999999995,98.495,59.739999999999995C99.98999999999998,61.23499999999999,99.98999999999998,63.765,98.495,65.375C98.495,65.375,98.495,65.375,98.495,65.375",
        trash: "M 13.56 8.28 h 5.28 v -1.54 c 0 -0.0581 -0.0229 -0.1144 -0.0642 -0.1558 c -0.0414 -0.0414 -0.0977 -0.0642 -0.1558 -0.0642 h -4.84 c -0.0581 0 -0.1144 0.0229 -0.1558 0.0642 c -0.0414 0.0414 -0.0642 0.0977 -0.0642 0.1558 v 1.54 z m 9.68 0.88 h -14.08 v 15.84 c 0 0.4858 0.3942 0.88 0.88 0.88 h 12.32 c 0.4858 0 0.88 -0.3942 0.88 -0.88 v -15.84 z m -8.8 3.08 c 0 -0.2429 -0.1971 -0.44 -0.44 -0.44 s -0.44 0.1971 -0.44 0.44 v 10.56 c 0 0.2429 0.1971 0.44 0.44 0.44 s 0.44 -0.1971 0.44 -0.44 v -10.56 z m 4.4 0 c 0 -0.2429 -0.1971 -0.44 -0.44 -0.44 s -0.44 0.1971 -0.44 0.44 v 10.56 c 0 0.2429 0.1971 0.44 0.44 0.44 s 0.44 -0.1971 0.44 -0.44 v -10.56 z m 7.04 -3.96 v 0.88 h -1.76 v 15.84 c 0 0.9724 -0.7876 1.76 -1.76 1.76 h -12.32 c -0.9724 0 -1.76 -0.7876 -1.76 -1.76 v -15.84 h -1.76 v -0.88 h 6.16 v -1.76 c 0 -0.4858 0.3942 -0.88 0.88 -0.88 h 5.28 c 0.4858 0 0.88 0.3942 0.88 0.88 v 1.76 h 6.16 z",
        resize: "M24 10.999v-10.999h-11l3.379 3.379-13.001 13-3.378-3.378v10.999h11l-3.379-3.379 13.001-13z"
    };
}
exports.default = sbIcons;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1q4m":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shapes", ()=>shapes);
var _sbIconsJs = require("../../helpers/sbIcons.js");
var _sbIconsJsDefault = parcelHelpers.interopDefault(_sbIconsJs);
const shapes = function(R) {
    const c = "M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466z";
    const { icons } = (0, _sbIconsJsDefault.default);
    R.fn.handle = function(x, y) {
        return this.path(icons.handle + c);
    };
    R.fn.editor = function(x, y) {
        return this.path(icons.editor + c);
    };
    R.fn.deleter = function(x, y) {
        return this.path(icons.deleter + c);
    };
    R.fn.trash = function() {
        return this.path(icons.trash + c).attr({
            fill: "#000"
        });
    };
    R.fn.searcher = function(x, y) {
        return this.path(icons.searcher + c);
    };
    R.fn.plus = function(x, y) {
        return this.path(icons.plus + c);
    };
    R.fn.merge = function(x, y) {
        return this.path(icons.plus + c);
    };
    R.fn.copy = function(x, y) {
        return this.path(icons.copy + c);
    };
    R.fn.minus = function(x, y) {
        return this.path(icons.minus + c);
    };
    R.fn.link = function(x, y) {
        return this.path(icons.link + c);
    };
    R.fn.up = function(x, y) {
        return this.path(icons.up);
    };
    R.fn.down = function(x, y) {
        return this.path(icons.up).transform("r180");
    };
    R.fn.setting = function(x, y) {
        return this.path(icons.settings + c).transform("s,.9,.9");
    };
    R.fn.arrow = function() {
        return this.path(icons.arrow + c);
    };
    R.fn.arrowHead = function() {
        return this.path(icons.arrowHead).attr({
            fill: "#648CB2"
        }).transform("s0.7");
    };
    R.fn.linkArrow = function() {
        return this.path(icons.arrow + c).attr({
            fill: "#648CB2"
        });
    };
    R.fn.lockClosed = function() {
        return this.path(icons.lockClosed);
    };
    R.fn.lockOpen = function() {
        return this.path(icons.lockOpen);
    };
    R.fn.speechbubble = function(x, y, txt) {
        const _bubble = this.set();
        _bubble.push(this.path(icons.speechbubble).transform([
            "t",
            x,
            ",",
            y
        ].join()).scale(6, 4).scale(-1, 1)).attr({
            fill: "#fff",
            stroke: "#000",
            "stroke-width": 3
        });
        _bubble.push(this.text(x + 10, y + 10, txt).attr({
            "font-size": 12
        }));
        return _bubble;
    };
    R.fn.undo = function(path) {
        return this.path(icons.undo);
    };
    R.fn.redo = function(path) {
        return this.path(icons.undo).transform("s-1,1");
    };
    R.fn.resize = function() {
        return this.path(`M24 10.999v-10.999h-11l3.379 3.379-13.001 13-3.378-3.378v10.999h11l-3.379-3.379 13.001-13z`);
    };
    R.fn.resizeLines = function() {
        return this.image("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAXCAYAAAAP6L+eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEBJREFUeNpiYKAuYAPijUD8n1aGVowaOmoo/QyNpYWh+UB8g1aGSowaOmroqKEEAE0MZaCVoQxEFH3e5BgKEGAAnnVBs4ro6nUAAAAASUVORK5CYII=", 0, 0, 22, 23);
    };
};

},{"../../helpers/sbIcons.js":"5LoVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Msrc":[function(require,module,exports) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extensions", ()=>extensions);
const extensions = function(R) {
    R.el.loop = function(_options) {
        const _self = this;
        const options = {
            pkg: [
                {
                    "stroke-width": 3
                },
                {
                    "stroke-width": 1
                }
            ],
            duration: 200,
            repeat: false
        };
        Object.assign(options, _options);
        function loop() {
            _self.animate(options.pkg[0], options.duration, ()=>{
                _self.animate(options.pkg[1], options.duration, ()=>{
                    if (options.repeat) loop();
                });
            });
        }
        loop();
        return _self;
    };
    R.el.tooltip = function(obj, w, h) {
        if (w === undefined) w = 80;
        if (h === undefined) h = 20;
        const _tt = this.paper.set();
        const pos = this.getBBox();
        if (obj.type === "text") {
            // text tooltip
            _tt.push(this.paper.rect(pos.x, pos.y + h * -1 - 10, w, h, 5).attr({
                fill: "#fff"
            }));
            _tt.push(this.paper.text(pos.x + 5, pos.y - 20, "").attr({
                "text-anchor": "start",
                stroke: "#fff",
                "font-size": 13,
                fill: "#fff"
            }));
        } else {
            // image tooltip
            const xpad = w * -1 - 5;
            _tt.push(this.paper.rect(pos.x + xpad, pos.y + h / 2 * -1, w, h, 15).attr({
                "stroke-width": 2,
                stroke: "#fff",
                "z-index": 9999
            }));
            _tt.push(this.paper.rect(pos.x + xpad, pos.y + (h / 2 - 45), w, 47, 15)).attr({
                "stroke-width": 2,
                fill: "90-#333-#000",
                "z-index": 9999
            });
            _tt.push(this.paper.text(pos.x + xpad + w / 2, pos.y + (h / 2 - 20), "").attr({
                "text-anchor": "middle",
                stroke: "#fff",
                "font-weight": "normal",
                "font-family": "Verdana",
                "font-size": 11,
                "z-index": 999
            }));
        }
        const s = this;
        if (!s.removed) {
            s.tt = _tt;
            if (obj.type === "text") s.tt[0].animate({
                stroke: "#000",
                fill: "#333"
            }, 200, ()=>{
                s.tt[1].attr({
                    text: obj.msg
                });
            });
            else s.tt[0].animate({
                stroke: "#000",
                fill: "#333"
            }, 200, ()=>{
                // s.tt[1].attr({  });
                s.tt[2].attr({
                    text: obj.msg
                });
            });
        }
        return s.tt;
    };
    R.el.untooltip = function() {
        this.tt && this.tt.remove();
        return this;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jW8Fw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const kCSSFontFacePattern = /(@font\-face {[\s\S]*?})/g;
const kCSSUrlPattern = /url\((https.+?)\)/;
function fontToDataURLViaBlob(fontUrl) {
    return fetch(fontUrl).then((fontResponse)=>fontResponse.blob()).then((fontBlob)=>new Promise((resolve)=>{
            const reader = new FileReader();
            reader.onload = ()=>{
                resolve(reader.result);
            };
            reader.readAsDataURL(fontBlob);
        }));
}
function fontToDataURLViaBuffer(fontUrl) {
    return fetch(fontUrl).then((fontResponse)=>Promise.all([
            Promise.resolve(fontResponse.headers.get("content-type")),
            fontResponse.buffer()
        ])).then((fontBuffer)=>{
        const b64 = fontBuffer[1].toString("base64");
        return `data:${fontBuffer[0]};base64,${b64}`;
    });
}
function embedFont(fontFace) {
    const fontUrlMatch = kCSSUrlPattern.exec(fontFace);
    let promise;
    if (typeof FileReader !== "undefined") promise = fontToDataURLViaBlob(fontUrlMatch[1]);
    else promise = fontToDataURLViaBuffer(fontUrlMatch[1]);
    return promise.then((dataURL)=>fontFace.replace(fontUrlMatch[1], dataURL));
}
function embedGoogleFonts({ fonts, text, styleNode }) {
    const snode = styleNode;
    const fontQuery = fonts.join("|").replace(/ /g, "+");
    const googleFontUrl = `https://fonts.googleapis.com/css?family=${fontQuery}&text=${text}`;
    if (fonts.length > 0) return fetch(googleFontUrl).then((cssResponse)=>cssResponse.text()).then((cssText)=>{
        let fontFaces = kCSSFontFacePattern.exec(cssText);
        const embedFontPromises = [];
        while(fontFaces != null){
            embedFontPromises.push(embedFont(fontFaces[1]));
            fontFaces = kCSSFontFacePattern.exec(cssText);
        }
        return Promise.all(embedFontPromises);
    }).then((results)=>{
        snode.innerHTML += results.join("\n");
        return true;
    });
    return Promise.resolve(true);
}
exports.default = embedGoogleFonts;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dd61Y":[function(require,module,exports) {
/* eslint-disable */ // emile.js (c) 2009 Thomas Fuchs
// Licensed under the terms of the MIT license.
(function(emile, container) {
    const parseEl = document.createElement("div");
    const props = "backgroundColor borderBottomColor borderBottomWidth borderLeftColor borderLeftWidth borderRightColor borderRightWidth borderSpacing borderTopColor borderTopWidth bottom color fontSize fontWeight height left letterSpacing lineHeight marginBottom marginLeft marginRight marginTop maxHeight maxWidth minHeight minWidth opacity outlineColor outlineOffset outlineWidth paddingBottom paddingLeft paddingRight paddingTop right textIndent top width wordSpacing zIndex".split(" ");
    function interpolate(source, target, pos) {
        return parseFloat(source + (target - source) * pos).toFixed(3);
    }
    function s(str, p, c) {
        return str.substr(p, c || 1);
    }
    function color(source, target, pos) {
        let i = 2;
        let j;
        let c;
        let tmp;
        const v = [];
        const r = [];
        while(j = 3, c = arguments[i - 1], i--)if (s(c, 0) == "r") {
            c = c.match(/\d+/g);
            while(j--)v.push(~~c[j]);
        } else {
            if (c.length == 4) c = `#${s(c, 1)}${s(c, 1)}${s(c, 2)}${s(c, 2)}${s(c, 3)}${s(c, 3)}`;
            while(j--)v.push(parseInt(s(c, 1 + j * 2, 2), 16));
        }
        while(j--){
            tmp = ~~(v[j + 3] + (v[j] - v[j + 3]) * pos);
            r.push(tmp < 0 ? 0 : tmp > 255 ? 255 : tmp);
        }
        return `rgb(${r.join(",")})`;
    }
    function parse(prop) {
        const p = parseFloat(prop);
        const q = prop.replace(/^[\-\d\.]+/, "");
        return Number.isNaN(p) ? {
            v: q,
            f: color,
            u: ""
        } : {
            v: p,
            f: interpolate,
            u: q
        };
    }
    function normalize(style) {
        let css;
        const rules = {};
        let i = props.length;
        let v;
        parseEl.innerHTML = `<div style="${style}"></div>`;
        css = parseEl.childNodes[0].style;
        while(i--)if (v = css[props[i]]) rules[props[i]] = parse(v);
        return rules;
    }
    container[emile] = function(el, style, opts) {
        el = typeof el === "string" ? document.getElementById(el) : el;
        opts = opts || {};
        const target = normalize(style);
        const comp = el.currentStyle ? el.currentStyle : getComputedStyle(el, null);
        let prop;
        const current = {};
        const start = +new Date();
        const dur = opts.duration || 200;
        const finish = start + dur;
        let interval;
        const easing = opts.easing || function(pos) {
            return -Math.cos(pos * Math.PI) / 2 + 0.5;
        };
        for(prop in target)current[prop] = parse(comp[prop]);
        interval = setInterval(function() {
            window.requestAnimationFrame(()=>{
                const time = +new Date();
                const pos = time > finish ? 1 : (time - start) / dur;
                for(prop in target){
                    const tv = opts.onMove ? opts.onMove(prop) : target[prop].f(current[prop].v, target[prop].v, easing(pos));
                    el.style[prop] = tv + target[prop].u;
                }
                if (time > finish) {
                    clearInterval(interval);
                    opts.after && opts.after();
                } else opts.during && opts.during.apply(this, [
                    (time - start) / dur
                ]);
            });
        }, 10);
    };
})("emile", window);

},{}],"eYgJm":[function(require,module,exports) {
/* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _yjs = require("yjs");
var _yWebsocket = require("y-websocket");
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class collab {
    constructor(slate){
        this.slate = slate;
        this.invoker = null;
        this.constants = {
            mapName: "collabPackages",
            lastMapDocName: "last",
            ommittableUserData: [
                "websocketUrl",
                "websocketParams"
            ],
            onCollaborationUserCustomDataChanged: "onCollaborationUserCustomDataChanged",
            onNodeAITextChanged: "onNodeAITextChanged"
        };
        if (!(0, _utilsDefault.default).localRecipients) (0, _utilsDefault.default).localRecipients = [];
        this.xyMap = {};
        this.wire();
    }
    exe(pkg) {
        const self = this;
        if (!Array.isArray(pkg)) pkg = [
            pkg
        ];
        pkg.forEach((p)=>{
            // for local...
            self.invoke(p);
            // for remote...
            self.send(p);
        });
    }
    wire() {
        const self = this;
        function resetMultiSelect() {
            self.slate.multiSelection?.end();
        }
        self.invoker = {
            onZoom (pkg) {
                if (self.slate.options.followMe) {
                    resetMultiSelect();
                    const zoomPercent = self.slate.options.viewPort.originalWidth / pkg.data.zoomLevel * 100;
                    self.slate.canvas.zoom({
                        dur: pkg.data.duration || 500,
                        zoomPercent,
                        callbacks: {
                            during () {
                            // additional calcs
                            },
                            after () {}
                        }
                    });
                }
            },
            onNodePositioned (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.position(pkg.data.location, ()=>{}, pkg.data.easing, pkg.data.duration || 500);
                self.closeNodeSpecifics(pkg);
            },
            onNodeLinkRemoved (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.links?.unset(false);
                self.closeNodeSpecifics(pkg);
            },
            onNodeLinkAdded (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.links?.set(pkg, false);
                self.closeNodeSpecifics(pkg);
            },
            onNodeUnlocked (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    cn.options.allowDrag = true;
                    cn.options.isLocked = false;
                    cn.hideLock();
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeLocked (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    cn.options.allowDrag = false;
                    cn.options.isLocked = true;
                    cn?.showLock();
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeBehaviorChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    pkg.data.behaviorChanges.forEach((b)=>{
                        if (typeof b.value === "object") {
                            cn.options[b.name] = b.value.val;
                            Object.keys(b.value).forEach((k)=>{
                                if (k !== "val") cn.options[k] = b.value[k];
                            });
                        } else cn.options[b.name] = b.value;
                    });
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeToBack (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.toBack();
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeToFront (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.toFront();
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeShapeChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.shapes.set(pkg.data);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeAdded (pkg) {
                resetMultiSelect();
                if (pkg.data?.multiSelectCopy) // this is a multiSelection copy
                self.slate.multiSelection.createCopiedNodes(pkg.data.nodeOptions, pkg.data.assocDetails);
                else if (pkg.data.id) {
                    const exists = self.slate.nodes.one(pkg.data.options.id);
                    if (!exists) {
                        // by design: the id is the parent of the node being created
                        const cn = self.slate.nodes.one(pkg.data.id);
                        cn?.connectors.createNode(pkg.data.skipCenter, pkg.data.options, pkg.data.targetXPos, pkg.data.targetYPos);
                    } else console.log("node id already existed, caught dup", pkg.data.options.id);
                } else {
                    // straight up node addition
                    let nodesToCreate = pkg.data.nodeOptions;
                    if (!Array.isArray(nodesToCreate)) nodesToCreate = [
                        nodesToCreate
                    ];
                    nodesToCreate.forEach((nOpts)=>{
                        // sanity check
                        const exists = self.slate.nodes.one(nOpts.id);
                        if (!exists) {
                            const n = new (0, _nodeDefault.default)(nOpts);
                            self.slate.nodes.add(n);
                        }
                    });
                }
            },
            onNodeImageChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.images.set(pkg.data.img, pkg.data.w, pkg.data.h);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeDeleted (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.del();
                self.slate.birdsEye?.nodeDeleted(pkg);
            },
            onNodeResized (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.hideOwnMenus();
                const opts = {
                    associations: pkg.data.associations,
                    animate: true
                };
                Object.assign(cn.options, (0, _lodashOmitDefault.default)(pkg.data, [
                    "associations",
                    "textPosition"
                ]));
                cn?.resize.animateSet(pkg.data, opts);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeRotated (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    // needs to be updated
                    cn.options.textOffset = pkg.data.textOffset;
                    cn?.hideOwnMenus();
                    const previousRotationAngle = cn.options.rotate.rotationAngle;
                    const opts = {
                        associations: pkg.data.associations,
                        animate: true
                    };
                    Object.assign(cn.options, (0, _lodashOmitDefault.default)(pkg.data, "associations"));
                    cn?.rotate.animateSet({
                        ...pkg.data,
                        rotationAngle: pkg.data.rotate.rotationAngle - previousRotationAngle
                    }, opts);
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeColorChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.colorPicker.set(pkg.data);
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeTextChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.editor.set(pkg.data.text, pkg.data.fontSize, pkg.data.fontFamily, pkg.data.fontColor, pkg.data.textOpacity, pkg.data.textXAlign, pkg.data.textYAlign);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.slate.loadAllFonts();
            },
            onNodeAITextChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) cn.options.ai = {
                    ...pkg.data.ai,
                    ...cn.options.ai
                };
            },
            addRelationship (pkg) {
                resetMultiSelect();
                self.slate.nodes.addRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
            },
            removeRelationship (pkg) {
                resetMultiSelect();
                self.slate.nodes.removeRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
            },
            onNodesMove (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                self.slate.nodes.moveNodes(pkg, {
                    animate: pkg.data.dur > 0
                });
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeEffectChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.applyFilters(pkg.data.filter);
            },
            onNodeBorderPropertiesChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.applyBorder(pkg.data);
            },
            onLinePropertiesChanged (pkg) {
                const upkg = pkg;
                self.slate.toggleFilters(true, null, true);
                if (!upkg.data.forEach) upkg.data = [
                    upkg.data
                ];
                upkg.data.forEach((p)=>{
                    const cn = self.slate.nodes.one(p.id);
                    Object.assign(cn?.options, p.options);
                    cn?.lineOptions.set(p);
                });
            },
            onFollowMeChanged (pkg) {
                self.slate.options.followMe = pkg.data?.followMe;
            },
            onCanvasMove (pkg) {
                if (self.slate.options.followMe) {
                    self.slate.toggleFilters(true, null, true);
                    const opts = {
                        x: pkg.data.left,
                        y: pkg.data.top,
                        dur: pkg.data.duration || 500,
                        callback: {
                            after () {
                                self.slate.birdsEye?.refresh(true);
                            }
                        },
                        isAbsolute: !pkg.isRelative
                    };
                    self.slate.canvas.move(opts);
                }
            },
            onSlateThemeChanged (pkg) {
                self.slate.options.themeId = pkg.data?.theme?._id;
                if (pkg.data?.theme) self.slate.applyTheme(pkg.data.theme, pkg.data.syncWithTheme);
            },
            onSlateLayoutTypeChanged (pkg) {
                if (pkg.data.layoutType != null) self.slate.options.layoutType = pkg.data.layoutType;
                if (pkg.data.disableAutoLayoutOfManuallyPositionedNodes != null) self.slate.options.disableAutoLayoutOfManuallyPositionedNodes = pkg.data.disableAutoLayoutOfManuallyPositionedNodes;
            },
            onSlateBackgroundEffectChanged (pkg) {
                self.slate.options.containerStyle.backgroundEffect = pkg.data.effect;
                self.slate.canvas.hideBg(1);
            // self.slate.png({ backgroundOnly: true, base64: true }, (base64) => {
            //   self.slate.canvas.internal.style.background = base64;
            //   self.slate.canvas._bg?.remove();
            // });
            },
            onSlateBackgroundImageChanged (pkg) {
                if (pkg.data.bg) {
                    self.slate.options.containerStyle.backgroundImage = pkg.data.bg.url;
                    self.slate.options.containerStyle.backgroundSize = pkg.data.bg.size;
                } else {
                    const c = self.slate.options.containerStyle.prevBackgroundColor || "#fff";
                    self.slate.options.containerStyle.backgroundColor = c;
                    self.slate.options.containerStyle.backgroundImage = null;
                    self.slate.options.containerStyle.backgroundEffect = null;
                }
                self.slate.canvas.hideBg(1);
            },
            onSlateBackgroundColorChanged (pkg) {
                self.slate.options.containerStyle.backgroundColor = pkg.data.color;
                self.slate.options.containerStyle.backgroundColorAsGradient = pkg.data.asGradient;
                self.slate.options.containerStyle.backgroundGradientType = pkg.data.gradientType;
                self.slate.options.containerStyle.backgroundGradientColors = pkg.data.gradientColors;
                self.slate.options.containerStyle.backgroundGradientStrategy = pkg.data.gradientStrategy;
                self.slate.options.containerStyle.backgroundImage = null;
                self.slate.options.containerStyle.backgroundEffect = null;
                self.slate.canvas.hideBg(1);
            },
            onLineColorChanged (pkg) {
                self.slate.options.defaultLineColor = pkg.data.color;
                self.slate.nodes.allNodes.forEach((n)=>{
                    n.options.lineColor = pkg.data.color;
                    n.relationships.associations.forEach((a)=>{
                        a.lineColor = pkg.data.color;
                    });
                    n.relationships.refreshOwnRelationships();
                });
            },
            onSlateAISet (pkg) {
                self.slate.options.ai = {
                    ...self.slate.options.ai || {},
                    ...pkg.data
                };
            },
            onSlateNameChanged (pkg) {
                self.slate.options.name = pkg.data.name;
            },
            onSlateDescriptionChanged (pkg) {
                self.slate.options.description = pkg.data.description;
            },
            onSlateShowGridChanged (pkg) {
                self.slate.options.viewPort.showGrid = pkg.data.showGrid;
                if (pkg.data.showGrid) self.slate.grid.show();
                else self.slate.grid.destroy();
            },
            onSlateMindMapModeChanged (pkg) {
                self.slate.options.mindMapMode = pkg.data.mindMapMode;
            },
            onSlateAutoResizeNodesBasedOnTextChanged (pkg) {
                self.slate.options.autoResizeNodesBasedOnText = pkg.data.autoResizeNodesBasedOnText;
            },
            onSlateTagsAndTemplateMarkdownChanged (pkg) {
                self.slate.options.tags = pkg.data.tags;
                self.slate.options.templateMarkdown = pkg.data.templateMarkdown;
                self.slate.options.templatePrompt = pkg.data.templatePrompt;
            },
            onSlateTemplateChanged (pkg) {
                self.slate.options.isTemplate = pkg.data.isTemplate;
            },
            onSlateSnapToObjectsChanged (pkg) {
                self.slate.options.viewPort.snapToObjects = pkg.data.snapToObjects;
            },
            onSlateFollowMeChanged (pkg) {
                self.slate.options.followMe = pkg.data.followMe;
            },
            onSlateHuddleChanged (pkg) {
                if (pkg.data.huddleType != null) self.slate.options.huddleType = pkg.data.huddleType;
                if (pkg.data.huddleEnabled != null) self.slate.options.huddleEnabled = pkg.data.huddleEnabled;
            }
        } // this invoker
        ;
    }
    _process(pkg) {
        const self = this;
        if ((0, _utilsDefault.default).localRecipients.length > 1) {
            let _time = 0;
            (0, _utilsDefault.default).localRecipients.forEach((s)=>{
                _time += 10;
                ((rec, t)=>{
                    setTimeout(()=>{
                        rec.collab.invoke(pkg);
                    }, t);
                })((0, _utilsDefault.default).localRecipients[s], _time);
            });
        } else if (self.invoker[pkg.type]) self.invoker[pkg.type](pkg);
    // else if (self.pc.onCollaboration) {
    //   self.pc.onCollaboration({ type: 'custom', slate: self.slate, pkg })
    // }
    }
    invoke(pkg) {
        const self = this;
        let packages = pkg;
        if (!Array.isArray(packages)) packages = [
            packages
        ];
        for (let pkg of packages)if (self.invoker[pkg.type]) self.invoker[pkg.type](pkg);
    }
    closeNodeSpecifics(pkg) {
        const self = this;
        const all = pkg.data.nodeOptions ? pkg.data.nodeOptions : [
            pkg.data
        ];
        all.forEach((n)=>{
            // close self node's marker if open
            const nx = self.slate.nodes.one(n.id);
            if (nx) {
                nx.menu?.hide();
                nx.connectors?.remove();
                nx.resize?.hide();
                nx.rotate?.hide();
                nx.relationships.associations.forEach((association)=>{
                    nx.lineOptions?.hide(association.id);
                });
            } else console.error("Unable to find node with id", n.id, "currentIds", self.slate.nodes.allNodes.map((nx)=>nx.options.id));
        });
        // remove any context menus
        self.slate.removeContextMenus();
        self.slate.untooltip();
    }
    async init() {
        const self = this;
        if (self.slate.options.isbirdsEye) // not allowed
        return;
        // go get the server url here
        if (self.collabPackage) {
            console.error("Unable to collaborate - collabPackage already created");
            return;
        }
        // ALL yjs depenencies are nested under the collabPackage
        const mainYDoc = new _yjs.Doc();
        self.collabPackage = {
            provider: null,
            users: [],
            /*
      return {
        websocketUrl: collaboratorDetails.wsUrl,
        websocketParams: collaboratorDetails.wsParams,
        color: collaboratorDetails.color,
        userName: getUserName(Meteor.userId()),
        x: 0,
        y: 0,
      }
      */ userBaseData: await self.slate.events.onInitCollaboration(mainYDoc.clientID),
            doc: mainYDoc,
            map: null
        };
        if (!self.collabPackage.userBaseData) console.error("Unable to collaborate - no self.collabPackage retrieved from the onInitCollaboration event");
        // attach clientID to the package for downstream reference
        self.collabPackage.userBaseData.clientID = self.collabPackage.doc.clientID;
        self.collabPackage.provider = new (0, _yWebsocket.WebsocketProvider)(self.collabPackage.userBaseData.websocketUrl, self.slate.options.id, self.collabPackage.doc, {
            connect: true,
            params: self.collabPackage.userBaseData.websocketParams
        });
        // a single map with a nodeId as the key and the last collab event as its value
        self.collabPackage.map = self.collabPackage.doc.getMap(self.constants.mapName);
        self.collabPackage.map.observe((e)=>{
            e.changes.keys.forEach((change, key)=>{
                if (change.action === "add" || change.action === "update") {
                    const p = self.collabPackage.map.get(key);
                    if (p.type === self.constants.onCollaborationUserCustomDataChanged) // for both local and remote - call this function so users are updated
                    self.slate.events.onCollaborationUsersChanged?.(self.collabPackage.users);
                    else {
                        // conflicts here are already resolved...
                        // but collab only have to fire if there
                        // is more than one user on the slate
                        if (// self.collabPackage.users.length > 1 &&
                        self.collabPackage.init && p.data.clientID !== self.collabPackage?.doc?.clientID) self.slate.collab.invoke(p);
                        // broadcast change so slate is saved
                        // not needed for ai events because only one can be the "host"
                        // and propogate the changes to the other slates -- so do not invoke the save command
                        // for other slates
                        if (p.data.clientID === self.collabPackage?.doc?.clientID) {
                            const isNodeAIType = [
                                self.constants.onNodeAITextChanged
                            ].includes(p.type);
                            if (!isNodeAIType || isNodeAIType && p.data.clientID === self.collabPackage?.doc?.clientID) self.slate.events?.onSlateChanged?.apply(self, [
                                p,
                                self.collabPackage.users
                            ]);
                        }
                        self.collabPackage.init = true;
                    }
                }
            });
        });
        self.collabPackage.provider.awareness.on("update", ({ added, updated, removed })=>{
            const awarenessStates = Array.from(self.collabPackage.provider.awareness.getStates().values());
            self.collabPackage.users = awarenessStates.filter((ux)=>!!ux.user).map((u)=>u.user);
            if (added.length > 0) {
                const users = self.collabPackage.users.filter((u)=>{
                    return added.includes(u.clientID);
                });
                self.slate.events.onCollaborationUsersAdded?.(users);
            }
            if (removed.length > 0) {
                const users = self.collabPackage.users.filter((u)=>{
                    return removed.includes(u.clientID);
                });
                self.slate.events.onCollaborationUsersRemoved?.(users);
                self.collabPackage.users = self.collabPackage.users.filter((u)=>{
                    return !removed.includes(u.clientID);
                });
            }
            if (added.length > 0 || removed.length > 0) self.slate.events.onCollaborationUsersChanged?.(self.collabPackage.users);
        });
        // monitors for cursor locations - the change event runs when the mouse moves, but the upate event
        // resolves when it settles (so no real-time view)
        self.collabPackage.provider.awareness.on("change", ({ added, updated, removed })=>{
            const awarenessStates = Array.from(self.collabPackage.provider.awareness.getStates().values());
            awarenessStates.forEach((u)=>{
                if (updated.includes(u.user?.clientID) && u.user?.clientID !== self.collabPackage?.doc?.clientID) self.slate.cursor(u.user);
            });
        });
        // this sends the cursor locations to the other clients
        if (!self.collabPackage.userBaseData.suppressCursor) self.collabPackage.provider.awareness.setLocalStateField("user", {
            ...(0, _lodashOmitDefault.default)(self.collabPackage.userBaseData, self.constants.ommittableUserData)
        });
        // for newly init clients, this will send the users immediately
        self.send({
            type: self.constants.onCollaborationUserCustomDataChanged,
            data: {}
        });
        // this auto destroys the connection so others immediately know the client is gone
        window.addEventListener("beforeunload", ()=>{
            self.destroy();
        });
    }
    destroy() {
        const self = this;
        self.collabPackage?.provider?.awareness?.destroy();
        self.collabPackage?.provider?.destroy();
    }
    currentCollaborators() {
        const self = this;
        return self.collabPackage?.users || [];
    }
    updateUserData(pkg) {
        const self = this;
        if (self.collabPackage) {
            // this will cause the onUsersChanged to fire
            // and also change the baseData so that this is not overridden
            // by any other setLocaLStateField calls
            self.collabPackage.userBaseData = {
                ...self.collabPackage.userBaseData,
                ...pkg
            };
            self.collabPackage.provider.awareness?.setLocalStateField("user", {
                ...(0, _lodashOmitDefault.default)(self.collabPackage.userBaseData, self.constants.ommittableUserData),
                ...pkg
            });
            // will broadcast that the users have changed
            self.send({
                type: self.constants.onCollaborationUserCustomDataChanged,
                data: {}
            });
        }
    }
    send(pkg) {
        const self = this;
        let packages = pkg;
        if (!Array.isArray(packages)) packages = [
            packages
        ];
        if (packages[0].type === "onMouseMoved") {
            if (self.collabPackage?.userBaseData && !self.collabPackage.userBaseData.suppressCursor) // broadcast the mouse cursors
            self.collabPackage?.provider.awareness?.setLocalStateField("user", {
                ...(0, _lodashOmitDefault.default)(self.collabPackage.userBaseData, self.constants.ommittableUserData),
                ...packages[0].data
            });
        } else {
            if (self.slate.undoRedo && self.slate.options.showUndoRedo) self.slate.undoRedo.snap();
            // these will only exist if allowCollaboration: true on the slate
            if (self.collabPackage?.doc && self.collabPackage?.map) packages.forEach((p)=>{
                p.data.clientID = self.collabPackage.doc.clientID;
                if (p.data?.nodeOptions) {
                    // to ensure each node is correctly CRDT-resolved
                    // with yJS independently, the moveNodes must be broken up so
                    // each node id is set directly on the YMap.
                    let asSingle = false;
                    if (!Array.isArray(p.data.nodeOptions)) {
                        asSingle = true;
                        p.data.nodeOptions = [
                            p.data.nodeOptions
                        ];
                    }
                    p.data.nodeOptions.forEach((nx, ind)=>{
                        const indivCollab = (0, _lodashClonedeepDefault.default)(p);
                        // in the onNodeAdded, the data.id !== nx.options.id (737... vs 22C...)
                        indivCollab.data.id = nx.id;
                        indivCollab.data.nodeOptions = asSingle ? nx : [
                            nx
                        ] // repackage it back the way it originally came in
                        ;
                        if (p.data?.textPositions) indivCollab.data.textPositions = [
                            p.data?.textPositions[ind]
                        ];
                        if (p.data?.associations) {
                            const indivAssocs = p.data?.associations.filter((a)=>a.childId === nx.id || a.parentId === nx.id);
                            indivCollab.data.associations = indivAssocs;
                        }
                        self.collabPackage.map.set(nx.id, indivCollab);
                    });
                } else // none nodeOptions based collaborations
                self.collabPackage.map.set(p.data.id || "slate", p);
            });
        }
    }
}
exports.default = collab;

},{"yjs":"gj9M9","y-websocket":"g8NHk","lodash.omit":"82TGT","lodash.clonedeep":"i3u1q","../helpers/utils":"8QI6M","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gj9M9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbsolutePosition", ()=>AbsolutePosition);
parcelHelpers.export(exports, "AbstractConnector", ()=>AbstractConnector);
parcelHelpers.export(exports, "AbstractStruct", ()=>AbstractStruct);
parcelHelpers.export(exports, "AbstractType", ()=>AbstractType);
parcelHelpers.export(exports, "Array", ()=>YArray);
parcelHelpers.export(exports, "ContentAny", ()=>ContentAny);
parcelHelpers.export(exports, "ContentBinary", ()=>ContentBinary);
parcelHelpers.export(exports, "ContentDeleted", ()=>ContentDeleted);
parcelHelpers.export(exports, "ContentDoc", ()=>ContentDoc);
parcelHelpers.export(exports, "ContentEmbed", ()=>ContentEmbed);
parcelHelpers.export(exports, "ContentFormat", ()=>ContentFormat);
parcelHelpers.export(exports, "ContentJSON", ()=>ContentJSON);
parcelHelpers.export(exports, "ContentString", ()=>ContentString);
parcelHelpers.export(exports, "ContentType", ()=>ContentType);
parcelHelpers.export(exports, "Doc", ()=>Doc);
parcelHelpers.export(exports, "GC", ()=>GC);
parcelHelpers.export(exports, "ID", ()=>ID);
parcelHelpers.export(exports, "Item", ()=>Item);
parcelHelpers.export(exports, "Map", ()=>YMap);
parcelHelpers.export(exports, "PermanentUserData", ()=>PermanentUserData);
parcelHelpers.export(exports, "RelativePosition", ()=>RelativePosition);
parcelHelpers.export(exports, "Skip", ()=>Skip);
parcelHelpers.export(exports, "Snapshot", ()=>Snapshot);
parcelHelpers.export(exports, "Text", ()=>YText);
parcelHelpers.export(exports, "Transaction", ()=>Transaction);
parcelHelpers.export(exports, "UndoManager", ()=>UndoManager);
parcelHelpers.export(exports, "UpdateDecoderV1", ()=>UpdateDecoderV1);
parcelHelpers.export(exports, "UpdateDecoderV2", ()=>UpdateDecoderV2);
parcelHelpers.export(exports, "UpdateEncoderV1", ()=>UpdateEncoderV1);
parcelHelpers.export(exports, "UpdateEncoderV2", ()=>UpdateEncoderV2);
parcelHelpers.export(exports, "XmlElement", ()=>YXmlElement);
parcelHelpers.export(exports, "XmlFragment", ()=>YXmlFragment);
parcelHelpers.export(exports, "XmlHook", ()=>YXmlHook);
parcelHelpers.export(exports, "XmlText", ()=>YXmlText);
parcelHelpers.export(exports, "YArrayEvent", ()=>YArrayEvent);
parcelHelpers.export(exports, "YEvent", ()=>YEvent);
parcelHelpers.export(exports, "YMapEvent", ()=>YMapEvent);
parcelHelpers.export(exports, "YTextEvent", ()=>YTextEvent);
parcelHelpers.export(exports, "YXmlEvent", ()=>YXmlEvent);
parcelHelpers.export(exports, "applyUpdate", ()=>applyUpdate);
parcelHelpers.export(exports, "applyUpdateV2", ()=>applyUpdateV2);
parcelHelpers.export(exports, "cleanupYTextFormatting", ()=>cleanupYTextFormatting);
parcelHelpers.export(exports, "compareIDs", ()=>compareIDs);
parcelHelpers.export(exports, "compareRelativePositions", ()=>compareRelativePositions);
parcelHelpers.export(exports, "convertUpdateFormatV1ToV2", ()=>convertUpdateFormatV1ToV2);
parcelHelpers.export(exports, "convertUpdateFormatV2ToV1", ()=>convertUpdateFormatV2ToV1);
parcelHelpers.export(exports, "createAbsolutePositionFromRelativePosition", ()=>createAbsolutePositionFromRelativePosition);
parcelHelpers.export(exports, "createDeleteSet", ()=>createDeleteSet);
parcelHelpers.export(exports, "createDeleteSetFromStructStore", ()=>createDeleteSetFromStructStore);
parcelHelpers.export(exports, "createDocFromSnapshot", ()=>createDocFromSnapshot);
parcelHelpers.export(exports, "createID", ()=>createID);
parcelHelpers.export(exports, "createRelativePositionFromJSON", ()=>createRelativePositionFromJSON);
parcelHelpers.export(exports, "createRelativePositionFromTypeIndex", ()=>createRelativePositionFromTypeIndex);
parcelHelpers.export(exports, "createSnapshot", ()=>createSnapshot);
parcelHelpers.export(exports, "decodeRelativePosition", ()=>decodeRelativePosition);
parcelHelpers.export(exports, "decodeSnapshot", ()=>decodeSnapshot);
parcelHelpers.export(exports, "decodeSnapshotV2", ()=>decodeSnapshotV2);
parcelHelpers.export(exports, "decodeStateVector", ()=>decodeStateVector);
parcelHelpers.export(exports, "decodeUpdate", ()=>decodeUpdate);
parcelHelpers.export(exports, "decodeUpdateV2", ()=>decodeUpdateV2);
parcelHelpers.export(exports, "diffUpdate", ()=>diffUpdate);
parcelHelpers.export(exports, "diffUpdateV2", ()=>diffUpdateV2);
parcelHelpers.export(exports, "emptySnapshot", ()=>emptySnapshot);
parcelHelpers.export(exports, "encodeRelativePosition", ()=>encodeRelativePosition);
parcelHelpers.export(exports, "encodeSnapshot", ()=>encodeSnapshot);
parcelHelpers.export(exports, "encodeSnapshotV2", ()=>encodeSnapshotV2);
parcelHelpers.export(exports, "encodeStateAsUpdate", ()=>encodeStateAsUpdate);
parcelHelpers.export(exports, "encodeStateAsUpdateV2", ()=>encodeStateAsUpdateV2);
parcelHelpers.export(exports, "encodeStateVector", ()=>encodeStateVector);
parcelHelpers.export(exports, "encodeStateVectorFromUpdate", ()=>encodeStateVectorFromUpdate);
parcelHelpers.export(exports, "encodeStateVectorFromUpdateV2", ()=>encodeStateVectorFromUpdateV2);
parcelHelpers.export(exports, "equalDeleteSets", ()=>equalDeleteSets);
parcelHelpers.export(exports, "equalSnapshots", ()=>equalSnapshots);
parcelHelpers.export(exports, "findIndexSS", ()=>findIndexSS);
parcelHelpers.export(exports, "findRootTypeKey", ()=>findRootTypeKey);
parcelHelpers.export(exports, "getItem", ()=>getItem);
parcelHelpers.export(exports, "getState", ()=>getState);
parcelHelpers.export(exports, "getTypeChildren", ()=>getTypeChildren);
parcelHelpers.export(exports, "isDeleted", ()=>isDeleted);
parcelHelpers.export(exports, "isParentOf", ()=>isParentOf);
parcelHelpers.export(exports, "iterateDeletedStructs", ()=>iterateDeletedStructs);
parcelHelpers.export(exports, "logType", ()=>logType);
parcelHelpers.export(exports, "logUpdate", ()=>logUpdate);
parcelHelpers.export(exports, "logUpdateV2", ()=>logUpdateV2);
parcelHelpers.export(exports, "mergeUpdates", ()=>mergeUpdates);
parcelHelpers.export(exports, "mergeUpdatesV2", ()=>mergeUpdatesV2);
parcelHelpers.export(exports, "obfuscateUpdate", ()=>obfuscateUpdate);
parcelHelpers.export(exports, "obfuscateUpdateV2", ()=>obfuscateUpdateV2);
parcelHelpers.export(exports, "parseUpdateMeta", ()=>parseUpdateMeta);
parcelHelpers.export(exports, "parseUpdateMetaV2", ()=>parseUpdateMetaV2);
parcelHelpers.export(exports, "readUpdate", ()=>readUpdate);
parcelHelpers.export(exports, "readUpdateV2", ()=>readUpdateV2);
parcelHelpers.export(exports, "relativePositionToJSON", ()=>relativePositionToJSON);
parcelHelpers.export(exports, "snapshot", ()=>snapshot);
parcelHelpers.export(exports, "snapshotContainsUpdate", ()=>snapshotContainsUpdate);
parcelHelpers.export(exports, "transact", ()=>transact);
parcelHelpers.export(exports, "tryGc", ()=>tryGc);
parcelHelpers.export(exports, "typeListToArraySnapshot", ()=>typeListToArraySnapshot);
parcelHelpers.export(exports, "typeMapGetAllSnapshot", ()=>typeMapGetAllSnapshot);
parcelHelpers.export(exports, "typeMapGetSnapshot", ()=>typeMapGetSnapshot);
var _observable = require("lib0/observable");
var _array = require("lib0/array");
var _math = require("lib0/math");
var _map = require("lib0/map");
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _random = require("lib0/random");
var _promise = require("lib0/promise");
var _buffer = require("lib0/buffer");
var _error = require("lib0/error");
var _binary = require("lib0/binary");
var _function = require("lib0/function");
var _set = require("lib0/set");
var _logging = require("lib0/logging");
var _time = require("lib0/time");
var _string = require("lib0/string");
var _iterator = require("lib0/iterator");
var _object = require("lib0/object");
var global = arguments[3];
/**
 * This is an abstract interface that all Connectors should implement to keep them interchangeable.
 *
 * @note This interface is experimental and it is not advised to actually inherit this class.
 *       It just serves as typing information.
 *
 * @extends {Observable<any>}
 */ class AbstractConnector extends (0, _observable.Observable) {
    /**
   * @param {Doc} ydoc
   * @param {any} awareness
   */ constructor(ydoc, awareness){
        super();
        this.doc = ydoc;
        this.awareness = awareness;
    }
}
class DeleteItem {
    /**
   * @param {number} clock
   * @param {number} len
   */ constructor(clock, len){
        /**
     * @type {number}
     */ this.clock = clock;
        /**
     * @type {number}
     */ this.len = len;
    }
}
/**
 * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.
 * - When created in a transaction, it must only be accessed after sorting, and merging
 *   - This DeleteSet is send to other clients
 * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore
 * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.
 */ class DeleteSet {
    constructor(){
        /**
     * @type {Map<number,Array<DeleteItem>>}
     */ this.clients = new Map();
    }
}
/**
 * Iterate over all structs that the DeleteSet gc's.
 *
 * @param {Transaction} transaction
 * @param {DeleteSet} ds
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateDeletedStructs = (transaction, ds, f)=>ds.clients.forEach((deletes, clientid)=>{
        const structs = /** @type {Array<GC|Item>} */ transaction.doc.store.clients.get(clientid);
        for(let i = 0; i < deletes.length; i++){
            const del = deletes[i];
            iterateStructs(transaction, structs, del.clock, del.len, f);
        }
    });
/**
 * @param {Array<DeleteItem>} dis
 * @param {number} clock
 * @return {number|null}
 *
 * @private
 * @function
 */ const findIndexDS = (dis, clock)=>{
    let left = 0;
    let right = dis.length - 1;
    while(left <= right){
        const midindex = _math.floor((left + right) / 2);
        const mid = dis[midindex];
        const midclock = mid.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.len) return midindex;
            left = midindex + 1;
        } else right = midindex - 1;
    }
    return null;
};
/**
 * @param {DeleteSet} ds
 * @param {ID} id
 * @return {boolean}
 *
 * @private
 * @function
 */ const isDeleted = (ds, id)=>{
    const dis = ds.clients.get(id.client);
    return dis !== undefined && findIndexDS(dis, id.clock) !== null;
};
/**
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const sortAndMergeDeleteSet = (ds)=>{
    ds.clients.forEach((dels)=>{
        dels.sort((a, b)=>a.clock - b.clock);
        // merge items without filtering or splicing the array
        // i is the current pointer
        // j refers to the current insert position for the pointed item
        // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
        let i, j;
        for(i = 1, j = 1; i < dels.length; i++){
            const left = dels[j - 1];
            const right = dels[i];
            if (left.clock + left.len >= right.clock) left.len = _math.max(left.len, right.clock + right.len - left.clock);
            else {
                if (j < i) dels[j] = right;
                j++;
            }
        }
        dels.length = j;
    });
};
/**
 * @param {Array<DeleteSet>} dss
 * @return {DeleteSet} A fresh DeleteSet
 */ const mergeDeleteSets = (dss)=>{
    const merged = new DeleteSet();
    for(let dssI = 0; dssI < dss.length; dssI++)dss[dssI].clients.forEach((delsLeft, client)=>{
        if (!merged.clients.has(client)) {
            // Write all missing keys from current ds and all following.
            // If merged already contains `client` current ds has already been added.
            /**
         * @type {Array<DeleteItem>}
         */ const dels = delsLeft.slice();
            for(let i = dssI + 1; i < dss.length; i++)_array.appendTo(dels, dss[i].clients.get(client) || []);
            merged.clients.set(client, dels);
        }
    });
    sortAndMergeDeleteSet(merged);
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {number} client
 * @param {number} clock
 * @param {number} length
 *
 * @private
 * @function
 */ const addToDeleteSet = (ds, client, clock, length)=>{
    _map.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []).push(new DeleteItem(clock, length));
};
const createDeleteSet = ()=>new DeleteSet();
/**
 * @param {StructStore} ss
 * @return {DeleteSet} Merged and sorted DeleteSet
 *
 * @private
 * @function
 */ const createDeleteSetFromStructStore = (ss)=>{
    const ds = createDeleteSet();
    ss.clients.forEach((structs, client)=>{
        /**
     * @type {Array<DeleteItem>}
     */ const dsitems = [];
        for(let i = 0; i < structs.length; i++){
            const struct = structs[i];
            if (struct.deleted) {
                const clock = struct.id.clock;
                let len = struct.length;
                if (i + 1 < structs.length) for(let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1])len += next.length;
                dsitems.push(new DeleteItem(clock, len));
            }
        }
        if (dsitems.length > 0) ds.clients.set(client, dsitems);
    });
    return ds;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const writeDeleteSet = (encoder, ds)=>{
    _encoding.writeVarUint(encoder.restEncoder, ds.clients.size);
    // Ensure that the delete set is written in a deterministic order
    _array.from(ds.clients.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, dsitems])=>{
        encoder.resetDsCurVal();
        _encoding.writeVarUint(encoder.restEncoder, client);
        const len = dsitems.length;
        _encoding.writeVarUint(encoder.restEncoder, len);
        for(let i = 0; i < len; i++){
            const item = dsitems[i];
            encoder.writeDsClock(item.clock);
            encoder.writeDsLen(item.len);
        }
    });
};
/**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {DeleteSet}
 *
 * @private
 * @function
 */ const readDeleteSet = (decoder)=>{
    const ds = new DeleteSet();
    const numClients = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = _decoding.readVarUint(decoder.restDecoder);
        const numberOfDeletes = _decoding.readVarUint(decoder.restDecoder);
        if (numberOfDeletes > 0) {
            const dsField = _map.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []);
            for(let i = 0; i < numberOfDeletes; i++)dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
        }
    }
    return ds;
};
/**
 * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..
 */ /**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.
 *
 * @private
 * @function
 */ const readAndApplyDeleteSet = (decoder, transaction, store)=>{
    const unappliedDS = new DeleteSet();
    const numClients = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = _decoding.readVarUint(decoder.restDecoder);
        const numberOfDeletes = _decoding.readVarUint(decoder.restDecoder);
        const structs = store.clients.get(client) || [];
        const state = getState(store, client);
        for(let i = 0; i < numberOfDeletes; i++){
            const clock = decoder.readDsClock();
            const clockEnd = clock + decoder.readDsLen();
            if (clock < state) {
                if (state < clockEnd) addToDeleteSet(unappliedDS, client, state, clockEnd - state);
                let index = findIndexSS(structs, clock);
                /**
         * We can ignore the case of GC and Delete structs, because we are going to skip them
         * @type {Item}
         */ // @ts-ignore
                let struct = structs[index];
                // split the first item if necessary
                if (!struct.deleted && struct.id.clock < clock) {
                    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
                    index++; // increase we now want to use the next struct
                }
                while(index < structs.length){
                    // @ts-ignore
                    struct = structs[index++];
                    if (struct.id.clock < clockEnd) {
                        if (!struct.deleted) {
                            if (clockEnd < struct.id.clock + struct.length) structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
                            struct.delete(transaction);
                        }
                    } else break;
                }
            } else addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
        }
    }
    if (unappliedDS.clients.size > 0) {
        const ds = new UpdateEncoderV2();
        _encoding.writeVarUint(ds.restEncoder, 0); // encode 0 structs
        writeDeleteSet(ds, unappliedDS);
        return ds.toUint8Array();
    }
    return null;
};
/**
 * @param {DeleteSet} ds1
 * @param {DeleteSet} ds2
 */ const equalDeleteSets = (ds1, ds2)=>{
    if (ds1.clients.size !== ds2.clients.size) return false;
    for (const [client, deleteItems1] of ds1.clients.entries()){
        const deleteItems2 = /** @type {Array<import('../internals.js').DeleteItem>} */ ds2.clients.get(client);
        if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false;
        for(let i = 0; i < deleteItems1.length; i++){
            const di1 = deleteItems1[i];
            const di2 = deleteItems2[i];
            if (di1.clock !== di2.clock || di1.len !== di2.len) return false;
        }
    }
    return true;
};
/**
 * @module Y
 */ const generateNewClientId = _random.uint32;
/**
 * @typedef {Object} DocOpts
 * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)
 * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.
 * @property {string} [DocOpts.guid] Define a globally unique identifier for this document
 * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.
 * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.
 * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.
 * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()
 */ /**
 * A Yjs instance handles the state of shared data.
 * @extends Observable<string>
 */ class Doc extends (0, _observable.Observable) {
    /**
   * @param {DocOpts} opts configuration
   */ constructor({ guid = _random.uuidv4(), collectionid = null, gc = true, gcFilter = ()=>true, meta = null, autoLoad = false, shouldLoad = true } = {}){
        super();
        this.gc = gc;
        this.gcFilter = gcFilter;
        this.clientID = generateNewClientId();
        this.guid = guid;
        this.collectionid = collectionid;
        /**
     * @type {Map<string, AbstractType<YEvent<any>>>}
     */ this.share = new Map();
        this.store = new StructStore();
        /**
     * @type {Transaction | null}
     */ this._transaction = null;
        /**
     * @type {Array<Transaction>}
     */ this._transactionCleanups = [];
        /**
     * @type {Set<Doc>}
     */ this.subdocs = new Set();
        /**
     * If this document is a subdocument - a document integrated into another document - then _item is defined.
     * @type {Item?}
     */ this._item = null;
        this.shouldLoad = shouldLoad;
        this.autoLoad = autoLoad;
        this.meta = meta;
        /**
     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
     *
     * @type {boolean}
     */ this.isLoaded = false;
        /**
     * This is set to true when the connection provider has successfully synced with a backend.
     * Note that when using peer-to-peer providers this event may not provide very useful.
     * Also note that not all providers implement this feature. Provider authors are encouraged to fire
     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
     * lost (with false as a parameter).
     */ this.isSynced = false;
        /**
     * Promise that resolves once the document has been loaded from a presistence provider.
     */ this.whenLoaded = _promise.create((resolve)=>{
            this.on("load", ()=>{
                this.isLoaded = true;
                resolve(this);
            });
        });
        const provideSyncedPromise = ()=>_promise.create((resolve)=>{
                /**
       * @param {boolean} isSynced
       */ const eventHandler = (isSynced)=>{
                    if (isSynced === undefined || isSynced === true) {
                        this.off("sync", eventHandler);
                        resolve();
                    }
                };
                this.on("sync", eventHandler);
            });
        this.on("sync", (isSynced)=>{
            if (isSynced === false && this.isSynced) this.whenSynced = provideSyncedPromise();
            this.isSynced = isSynced === undefined || isSynced === true;
            if (this.isSynced && !this.isLoaded) this.emit("load", []);
        });
        /**
     * Promise that resolves once the document has been synced with a backend.
     * This promise is recreated when the connection is lost.
     * Note the documentation about the `isSynced` property.
     */ this.whenSynced = provideSyncedPromise();
    }
    /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */ load() {
        const item = this._item;
        if (item !== null && !this.shouldLoad) transact(/** @type {any} */ item.parent.doc, (transaction)=>{
            transaction.subdocsLoaded.add(this);
        }, null, true);
        this.shouldLoad = true;
    }
    getSubdocs() {
        return this.subdocs;
    }
    getSubdocGuids() {
        return new Set(_array.from(this.subdocs).map((doc)=>doc.guid));
    }
    /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */ transact(f, origin = null) {
        return transact(this, f, origin);
    }
    /**
   * Define a shared data type.
   *
   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `y.define(name, Y.Array) === y.define(name, Y.Array)`
   *
   * After this method is called, the type is also available on `y.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Yjs instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @example
   *   const y = new Y(..)
   *   const appState = {
   *     document: y.getText('document')
   *     comments: y.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor
   *
   * @public
   */ get(name, TypeConstructor = AbstractType) {
        const type = _map.setIfUndefined(this.share, name, ()=>{
            // @ts-ignore
            const t = new TypeConstructor();
            t._integrate(this, null);
            return t;
        });
        const Constr = type.constructor;
        if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
            if (Constr === AbstractType) {
                // @ts-ignore
                const t = new TypeConstructor();
                t._map = type._map;
                type._map.forEach(/** @param {Item?} n */ (n)=>{
                    for(; n !== null; n = n.left)// @ts-ignore
                    n.parent = t;
                });
                t._start = type._start;
                for(let n = t._start; n !== null; n = n.right)n.parent = t;
                t._length = type._length;
                this.share.set(name, t);
                t._integrate(this, null);
                return t;
            } else throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
        }
        return type;
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */ getArray(name = "") {
        // @ts-ignore
        return this.get(name, YArray);
    }
    /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */ getText(name = "") {
        // @ts-ignore
        return this.get(name, YText);
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */ getMap(name = "") {
        // @ts-ignore
        return this.get(name, YMap);
    }
    /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */ getXmlFragment(name = "") {
        // @ts-ignore
        return this.get(name, YXmlFragment);
    }
    /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */ toJSON() {
        /**
     * @type {Object<string, any>}
     */ const doc = {};
        this.share.forEach((value, key)=>{
            doc[key] = value.toJSON();
        });
        return doc;
    }
    /**
   * Emit `destroy` event and unregister all event handlers.
   */ destroy() {
        _array.from(this.subdocs).forEach((subdoc)=>subdoc.destroy());
        const item = this._item;
        if (item !== null) {
            this._item = null;
            const content = /** @type {ContentDoc} */ item.content;
            content.doc = new Doc({
                guid: this.guid,
                ...content.opts,
                shouldLoad: false
            });
            content.doc._item = item;
            transact(/** @type {any} */ item.parent.doc, (transaction)=>{
                const doc = content.doc;
                if (!item.deleted) transaction.subdocsAdded.add(doc);
                transaction.subdocsRemoved.add(this);
            }, null, true);
        }
        this.emit("destroyed", [
            true
        ]);
        this.emit("destroy", [
            this
        ]);
        super.destroy();
    }
    /**
   * @param {string} eventName
   * @param {function(...any):any} f
   */ on(eventName, f) {
        super.on(eventName, f);
    }
    /**
   * @param {string} eventName
   * @param {function} f
   */ off(eventName, f) {
        super.off(eventName, f);
    }
}
class DSDecoderV1 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @return {number}
   */ readDsClock() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {number}
   */ readDsLen() {
        return _decoding.readVarUint(this.restDecoder);
    }
}
class UpdateDecoderV1 extends DSDecoderV1 {
    /**
   * @return {ID}
   */ readLeftID() {
        return createID(_decoding.readVarUint(this.restDecoder), _decoding.readVarUint(this.restDecoder));
    }
    /**
   * @return {ID}
   */ readRightID() {
        return createID(_decoding.readVarUint(this.restDecoder), _decoding.readVarUint(this.restDecoder));
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return _decoding.readUint8(this.restDecoder);
    }
    /**
   * @return {string}
   */ readString() {
        return _decoding.readVarString(this.restDecoder);
    }
    /**
   * @return {boolean} isKey
   */ readParentInfo() {
        return _decoding.readVarUint(this.restDecoder) === 1;
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readTypeRef() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */ readLen() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {any}
   */ readAny() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return _buffer.copyUint8Array(_decoding.readVarUint8Array(this.restDecoder));
    }
    /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */ readJSON() {
        return JSON.parse(_decoding.readVarString(this.restDecoder));
    }
    /**
   * @return {string}
   */ readKey() {
        return _decoding.readVarString(this.restDecoder);
    }
}
class DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        /**
     * @private
     */ this.dsCurrVal = 0;
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @return {number}
   */ readDsClock() {
        this.dsCurrVal += _decoding.readVarUint(this.restDecoder);
        return this.dsCurrVal;
    }
    /**
   * @return {number}
   */ readDsLen() {
        const diff = _decoding.readVarUint(this.restDecoder) + 1;
        this.dsCurrVal += diff;
        return diff;
    }
}
class UpdateDecoderV2 extends DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        super(decoder);
        /**
     * List of cached keys. If the keys[id] does not exist, we read a new key
     * from stringEncoder and push it to keys.
     *
     * @type {Array<string>}
     */ this.keys = [];
        _decoding.readVarUint(decoder); // read feature flag - currently unused
        this.keyClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.clientDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.leftClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.rightClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.infoDecoder = new _decoding.RleDecoder(_decoding.readVarUint8Array(decoder), _decoding.readUint8);
        this.stringDecoder = new _decoding.StringDecoder(_decoding.readVarUint8Array(decoder));
        this.parentInfoDecoder = new _decoding.RleDecoder(_decoding.readVarUint8Array(decoder), _decoding.readUint8);
        this.typeRefDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.lenDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
    }
    /**
   * @return {ID}
   */ readLeftID() {
        return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
    }
    /**
   * @return {ID}
   */ readRightID() {
        return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return this.clientDecoder.read();
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return /** @type {number} */ this.infoDecoder.read();
    }
    /**
   * @return {string}
   */ readString() {
        return this.stringDecoder.read();
    }
    /**
   * @return {boolean}
   */ readParentInfo() {
        return this.parentInfoDecoder.read() === 1;
    }
    /**
   * @return {number} An unsigned 8-bit integer
   */ readTypeRef() {
        return this.typeRefDecoder.read();
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */ readLen() {
        return this.lenDecoder.read();
    }
    /**
   * @return {any}
   */ readAny() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return _decoding.readVarUint8Array(this.restDecoder);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */ readJSON() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {string}
   */ readKey() {
        const keyClock = this.keyClockDecoder.read();
        if (keyClock < this.keys.length) return this.keys[keyClock];
        else {
            const key = this.stringDecoder.read();
            this.keys.push(key);
            return key;
        }
    }
}
class DSEncoderV1 {
    constructor(){
        this.restEncoder = _encoding.createEncoder();
    }
    toUint8Array() {
        return _encoding.toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        _encoding.writeVarUint(this.restEncoder, clock);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        _encoding.writeVarUint(this.restEncoder, len);
    }
}
class UpdateEncoderV1 extends DSEncoderV1 {
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        _encoding.writeVarUint(this.restEncoder, id.client);
        _encoding.writeVarUint(this.restEncoder, id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        _encoding.writeVarUint(this.restEncoder, id.client);
        _encoding.writeVarUint(this.restEncoder, id.clock);
    }
    /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */ writeClient(client) {
        _encoding.writeVarUint(this.restEncoder, client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        _encoding.writeUint8(this.restEncoder, info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        _encoding.writeVarString(this.restEncoder, s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        _encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        _encoding.writeVarUint(this.restEncoder, info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        _encoding.writeVarUint(this.restEncoder, len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        _encoding.writeAny(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        _encoding.writeVarUint8Array(this.restEncoder, buf);
    }
    /**
   * @param {any} embed
   */ writeJSON(embed) {
        _encoding.writeVarString(this.restEncoder, JSON.stringify(embed));
    }
    /**
   * @param {string} key
   */ writeKey(key) {
        _encoding.writeVarString(this.restEncoder, key);
    }
}
class DSEncoderV2 {
    constructor(){
        this.restEncoder = _encoding.createEncoder(); // encodes all the rest / non-optimized
        this.dsCurrVal = 0;
    }
    toUint8Array() {
        return _encoding.toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        const diff = clock - this.dsCurrVal;
        this.dsCurrVal = clock;
        _encoding.writeVarUint(this.restEncoder, diff);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        if (len === 0) _error.unexpectedCase();
        _encoding.writeVarUint(this.restEncoder, len - 1);
        this.dsCurrVal += len;
    }
}
class UpdateEncoderV2 extends DSEncoderV2 {
    constructor(){
        super();
        /**
     * @type {Map<string,number>}
     */ this.keyMap = new Map();
        /**
     * Refers to the next uniqe key-identifier to me used.
     * See writeKey method for more information.
     *
     * @type {number}
     */ this.keyClock = 0;
        this.keyClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.clientEncoder = new _encoding.UintOptRleEncoder();
        this.leftClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.rightClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.infoEncoder = new _encoding.RleEncoder(_encoding.writeUint8);
        this.stringEncoder = new _encoding.StringEncoder();
        this.parentInfoEncoder = new _encoding.RleEncoder(_encoding.writeUint8);
        this.typeRefEncoder = new _encoding.UintOptRleEncoder();
        this.lenEncoder = new _encoding.UintOptRleEncoder();
    }
    toUint8Array() {
        const encoder = _encoding.createEncoder();
        _encoding.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future
        _encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, _encoding.toUint8Array(this.infoEncoder));
        _encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, _encoding.toUint8Array(this.parentInfoEncoder));
        _encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
        // @note The rest encoder is appended! (note the missing var)
        _encoding.writeUint8Array(encoder, _encoding.toUint8Array(this.restEncoder));
        return _encoding.toUint8Array(encoder);
    }
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        this.clientEncoder.write(id.client);
        this.leftClockEncoder.write(id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        this.clientEncoder.write(id.client);
        this.rightClockEncoder.write(id.clock);
    }
    /**
   * @param {number} client
   */ writeClient(client) {
        this.clientEncoder.write(client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        this.infoEncoder.write(info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        this.stringEncoder.write(s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        this.parentInfoEncoder.write(isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        this.typeRefEncoder.write(info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        this.lenEncoder.write(len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        _encoding.writeAny(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        _encoding.writeVarUint8Array(this.restEncoder, buf);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */ writeJSON(embed) {
        _encoding.writeAny(this.restEncoder, embed);
    }
    /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */ writeKey(key) {
        const clock = this.keyMap.get(key);
        if (clock === undefined) {
            /**
       * @todo uncomment to introduce this feature finally
       *
       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.
       * Furthermore, I forgot to set the keyclock. So everything was working fine.
       *
       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).
       *
       * I don't know yet how to reintroduce this feature..
       *
       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.
       *
       */ // this.keyMap.set(key, this.keyClock)
            this.keyClockEncoder.write(this.keyClock++);
            this.stringEncoder.write(key);
        } else this.keyClockEncoder.write(clock);
    }
}
/**
 * @module encoding
 */ /**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Array<GC|Item>} structs All structs by `client`
 * @param {number} client
 * @param {number} clock write structs starting with `ID(client,clock)`
 *
 * @function
 */ const writeStructs = (encoder, structs, client, clock)=>{
    // write first id
    clock = _math.max(clock, structs[0].id.clock); // make sure the first id exists
    const startNewStructs = findIndexSS(structs, clock);
    // write # encoded structs
    _encoding.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
    encoder.writeClient(client);
    _encoding.writeVarUint(encoder.restEncoder, clock);
    const firstStruct = structs[startNewStructs];
    // write first struct with an offset
    firstStruct.write(encoder, clock - firstStruct.id.clock);
    for(let i = startNewStructs + 1; i < structs.length; i++)structs[i].write(encoder, 0);
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {StructStore} store
 * @param {Map<number,number>} _sm
 *
 * @private
 * @function
 */ const writeClientsStructs = (encoder, store, _sm)=>{
    // we filter all valid _sm entries into sm
    const sm = new Map();
    _sm.forEach((clock, client)=>{
        // only write if new structs are available
        if (getState(store, client) > clock) sm.set(client, clock);
    });
    getStateVector(store).forEach((_clock, client)=>{
        if (!_sm.has(client)) sm.set(client, 0);
    });
    // write # states that were updated
    _encoding.writeVarUint(encoder.restEncoder, sm.size);
    // Write items with higher client ids first
    // This heavily improves the conflict algorithm.
    _array.from(sm.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        writeStructs(encoder, /** @type {Array<GC|Item>} */ store.clients.get(client), client, clock);
    });
};
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.
 * @param {Doc} doc
 * @return {Map<number, { i: number, refs: Array<Item | GC> }>}
 *
 * @private
 * @function
 */ const readClientsStructRefs = (decoder, doc)=>{
    /**
   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}
   */ const clientRefs = _map.create();
    const numOfStateUpdates = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = _decoding.readVarUint(decoder.restDecoder);
        /**
     * @type {Array<GC|Item>}
     */ const refs = new Array(numberOfStructs);
        const client = decoder.readClient();
        let clock = _decoding.readVarUint(decoder.restDecoder);
        // const start = performance.now()
        clientRefs.set(client, {
            i: 0,
            refs
        });
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            switch(_binary.BITS5 & info){
                case 0:
                    {
                        const len = decoder.readLen();
                        refs[i] = new GC(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                case 10:
                    {
                        // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.
                        const len = _decoding.readVarUint(decoder.restDecoder);
                        refs[i] = new Skip(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                default:
                    {
                        /**
           * The optimized implementation doesn't use any variables because inlining variables is faster.
           * Below a non-optimized version is shown that implements the basic algorithm with
           * a few comments
           */ const cantCopyParentInfo = (info & (_binary.BIT7 | _binary.BIT8)) === 0;
                        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                        // and we read the next string as parentYKey.
                        // It indicates how we store/retrieve parent from `y.share`
                        // @type {string|null}
                        const struct = new Item(createID(client, clock), null, (info & _binary.BIT8) === _binary.BIT8 ? decoder.readLeftID() : null, null, (info & _binary.BIT7) === _binary.BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & _binary.BIT6) === _binary.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content
                        );
                        /* A non-optimized implementation of the above algorithm:

          // The item that was originally to the left of this item.
          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null
          // The item that was originally to the right of this item.
          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null
          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0
          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false
          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
          // and we read the next string as parentYKey.
          // It indicates how we store/retrieve parent from `y.share`
          // @type {string|null}
          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null

          const struct = new Item(
            createID(client, clock),
            null, // leftd
            origin, // origin
            null, // right
            rightOrigin, // right origin
            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent
            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub
            readItemContent(decoder, info) // item content
          )
          */ refs[i] = struct;
                        clock += struct.length;
                    }
            }
        }
    // console.log('time to read: ', performance.now() - start) // @todo remove
    }
    return clientRefs;
};
/**
 * Resume computing structs generated by struct readers.
 *
 * While there is something to do, we integrate structs in this order
 * 1. top element on stack, if stack is not empty
 * 2. next element from current struct reader (if empty, use next struct reader)
 *
 * If struct causally depends on another struct (ref.missing), we put next reader of
 * `ref.id.client` on top of stack.
 *
 * At some point we find a struct that has no causal dependencies,
 * then we start emptying the stack.
 *
 * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)
 * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.
 *
 * This method is implemented in a way so that we can resume computation if this update
 * causally depends on another update.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs
 * @return { null | { update: Uint8Array, missing: Map<number,number> } }
 *
 * @private
 * @function
 */ const integrateStructs = (transaction, store, clientsStructRefs)=>{
    /**
   * @type {Array<Item | GC>}
   */ const stack = [];
    // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.
    let clientsStructRefsIds = _array.from(clientsStructRefs.keys()).sort((a, b)=>a - b);
    if (clientsStructRefsIds.length === 0) return null;
    const getNextStructTarget = ()=>{
        if (clientsStructRefsIds.length === 0) return null;
        let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
        while(nextStructsTarget.refs.length === nextStructsTarget.i){
            clientsStructRefsIds.pop();
            if (clientsStructRefsIds.length > 0) nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
            else return null;
        }
        return nextStructsTarget;
    };
    let curStructsTarget = getNextStructTarget();
    if (curStructsTarget === null) return null;
    /**
   * @type {StructStore}
   */ const restStructs = new StructStore();
    const missingSV = new Map();
    /**
   * @param {number} client
   * @param {number} clock
   */ const updateMissingSv = (client, clock)=>{
        const mclock = missingSV.get(client);
        if (mclock == null || mclock > clock) missingSV.set(client, clock);
    };
    /**
   * @type {GC|Item}
   */ let stackHead = /** @type {any} */ curStructsTarget.refs[/** @type {any} */ curStructsTarget.i++];
    // caching the state because it is used very often
    const state = new Map();
    const addStackToRestSS = ()=>{
        for (const item of stack){
            const client = item.id.client;
            const unapplicableItems = clientsStructRefs.get(client);
            if (unapplicableItems) {
                // decrement because we weren't able to apply previous operation
                unapplicableItems.i--;
                restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
                clientsStructRefs.delete(client);
                unapplicableItems.i = 0;
                unapplicableItems.refs = [];
            } else // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue
            restStructs.clients.set(client, [
                item
            ]);
            // remove client from clientsStructRefsIds to prevent users from applying the same update again
            clientsStructRefsIds = clientsStructRefsIds.filter((c)=>c !== client);
        }
        stack.length = 0;
    };
    // iterate over all struct readers until we are done
    while(true){
        if (stackHead.constructor !== Skip) {
            const localClock = _map.setIfUndefined(state, stackHead.id.client, ()=>getState(store, stackHead.id.client));
            const offset = localClock - stackHead.id.clock;
            if (offset < 0) {
                // update from the same client is missing
                stack.push(stackHead);
                updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
                // hid a dead wall, add all items from stack to restSS
                addStackToRestSS();
            } else {
                const missing = stackHead.getMissing(transaction, store);
                if (missing !== null) {
                    stack.push(stackHead);
                    // get the struct reader that has the missing struct
                    /**
           * @type {{ refs: Array<GC|Item>, i: number }}
           */ const structRefs = clientsStructRefs.get(/** @type {number} */ missing) || {
                        refs: [],
                        i: 0
                    };
                    if (structRefs.refs.length === structRefs.i) {
                        // This update message causally depends on another update message that doesn't exist yet
                        updateMissingSv(/** @type {number} */ missing, getState(store, missing));
                        addStackToRestSS();
                    } else {
                        stackHead = structRefs.refs[structRefs.i++];
                        continue;
                    }
                } else if (offset === 0 || offset < stackHead.length) {
                    // all fine, apply the stackhead
                    stackHead.integrate(transaction, offset);
                    state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
                }
            }
        }
        // iterate to next stackHead
        if (stack.length > 0) stackHead = /** @type {GC|Item} */ stack.pop();
        else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];
        else {
            curStructsTarget = getNextStructTarget();
            if (curStructsTarget === null) break;
            else stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];
        }
    }
    if (restStructs.clients.size > 0) {
        const encoder = new UpdateEncoderV2();
        writeClientsStructs(encoder, restStructs, new Map());
        // write empty deleteset
        // writeDeleteSet(encoder, new DeleteSet())
        _encoding.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes
        return {
            missing: missingSV,
            update: encoder.toUint8Array()
        };
    }
    return null;
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 *
 * @private
 * @function
 */ const writeStructsFromTransaction = (encoder, transaction)=>writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts an decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]
 *
 * @function
 */ const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder))=>transact(ydoc, (transaction)=>{
        // force that transaction.local is set to non-local
        transaction.local = false;
        let retry = false;
        const doc = transaction.doc;
        const store = doc.store;
        // let start = performance.now()
        const ss = readClientsStructRefs(structDecoder, doc);
        // console.log('time to read structs: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to merge: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const restStructs = integrateStructs(transaction, store, ss);
        const pending = store.pendingStructs;
        if (pending) {
            // check if we can apply something
            for (const [client, clock] of pending.missing)if (clock < getState(store, client)) {
                retry = true;
                break;
            }
            if (restStructs) {
                // merge restStructs into store.pending
                for (const [client, clock] of restStructs.missing){
                    const mclock = pending.missing.get(client);
                    if (mclock == null || mclock > clock) pending.missing.set(client, clock);
                }
                pending.update = mergeUpdatesV2([
                    pending.update,
                    restStructs.update
                ]);
            }
        } else store.pendingStructs = restStructs;
        // console.log('time to integrate: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
        if (store.pendingDs) {
            // @todo we could make a lower-bound state-vector check as we do above
            const pendingDSUpdate = new UpdateDecoderV2(_decoding.createDecoder(store.pendingDs));
            _decoding.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate
            const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
            if (dsRest && dsRest2) // case 1: ds1 != null && ds2 != null
            store.pendingDs = mergeUpdatesV2([
                dsRest,
                dsRest2
            ]);
            else // case 2: ds1 != null
            // case 3: ds2 != null
            // case 4: ds1 == null && ds2 == null
            store.pendingDs = dsRest || dsRest2;
        } else // Either dsRest == null && pendingDs == null OR dsRest != null
        store.pendingDs = dsRest;
        // console.log('time to cleanup: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove
        // start = performance.now()
        if (retry) {
            const update = /** @type {{update: Uint8Array}} */ store.pendingStructs.update;
            store.pendingStructs = null;
            applyUpdateV2(transaction.doc, update);
        }
    }, transactionOrigin, false);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts an decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const readUpdate = (decoder, ydoc, transactionOrigin)=>readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 *
 * @function
 */ const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2)=>{
    const decoder = _decoding.createDecoder(update);
    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const applyUpdate = (ydoc, update, transactionOrigin)=>applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
/**
 * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will
 * only write the operations that are missing.
 *
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Doc} doc
 * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 *
 * @function
 */ const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map())=>{
    writeClientsStructs(encoder, doc.store, targetStateVector);
    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([
    0
]), encoder = new UpdateEncoderV2())=>{
    const targetStateVector = decodeStateVector(encodedTargetStateVector);
    writeStateAsUpdate(encoder, doc, targetStateVector);
    const updates = [
        encoder.toUint8Array()
    ];
    // also add the pending updates (if there are any)
    if (doc.store.pendingDs) updates.push(doc.store.pendingDs);
    if (doc.store.pendingStructs) updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));
    if (updates.length > 1) {
        if (encoder.constructor === UpdateEncoderV1) return mergeUpdates(updates.map((update, i)=>i === 0 ? update : convertUpdateFormatV2ToV1(update)));
        else if (encoder.constructor === UpdateEncoderV2) return mergeUpdatesV2(updates);
    }
    return updates[0];
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdate = (doc, encodedTargetStateVector)=>encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());
/**
 * Read state vector from Decoder and return as Map
 *
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const readStateVector = (decoder)=>{
    const ss = new Map();
    const ssLength = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < ssLength; i++){
        const client = _decoding.readVarUint(decoder.restDecoder);
        const clock = _decoding.readVarUint(decoder.restDecoder);
        ss.set(client, clock);
    }
    return ss;
};
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ // export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const decodeStateVector = (decodedState)=>readStateVector(new DSDecoderV1(_decoding.createDecoder(decodedState)));
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Map<number,number>} sv
 * @function
 */ const writeStateVector = (encoder, sv)=>{
    _encoding.writeVarUint(encoder.restEncoder, sv.size);
    _array.from(sv.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        _encoding.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping
        _encoding.writeVarUint(encoder.restEncoder, clock);
    });
    return encoder;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Doc} doc
 *
 * @function
 */ const writeDocumentStateVector = (encoder, doc)=>writeStateVector(encoder, getStateVector(doc.store));
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2())=>{
    if (doc instanceof Map) writeStateVector(encoder, doc);
    else writeDocumentStateVector(encoder, doc);
    return encoder.toUint8Array();
};
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVector = (doc)=>encodeStateVectorV2(doc, new DSEncoderV1());
/**
 * General event handler implementation.
 *
 * @template ARG0, ARG1
 *
 * @private
 */ class EventHandler {
    constructor(){
        /**
     * @type {Array<function(ARG0, ARG1):void>}
     */ this.l = [];
    }
}
/**
 * @template ARG0,ARG1
 * @returns {EventHandler<ARG0,ARG1>}
 *
 * @private
 * @function
 */ const createEventHandler = ()=>new EventHandler();
/**
 * Adds an event listener that is called when
 * {@link EventHandler#callEventListeners} is called.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler.
 *
 * @private
 * @function
 */ const addEventHandlerListener = (eventHandler, f)=>eventHandler.l.push(f);
/**
 * Removes an event listener.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler that was added with
 *                     {@link EventHandler#addEventListener}
 *
 * @private
 * @function
 */ const removeEventHandlerListener = (eventHandler, f)=>{
    const l = eventHandler.l;
    const len = l.length;
    eventHandler.l = l.filter((g)=>f !== g);
    if (len === eventHandler.l.length) console.error("[yjs] Tried to remove event handler that doesn't exist.");
};
/**
 * Call all event listeners that were added via
 * {@link EventHandler#addEventListener}.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {ARG0} arg0
 * @param {ARG1} arg1
 *
 * @private
 * @function
 */ const callEventHandlerListeners = (eventHandler, arg0, arg1)=>_function.callAll(eventHandler.l, [
        arg0,
        arg1
    ]);
class ID {
    /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */ constructor(client, clock){
        /**
     * Client id
     * @type {number}
     */ this.client = client;
        /**
     * unique per client id, continuous number
     * @type {number}
     */ this.clock = clock;
    }
}
/**
 * @param {ID | null} a
 * @param {ID | null} b
 * @return {boolean}
 *
 * @function
 */ const compareIDs = (a, b)=>a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
/**
 * @param {number} client
 * @param {number} clock
 *
 * @private
 * @function
 */ const createID = (client, clock)=>new ID(client, clock);
/**
 * @param {encoding.Encoder} encoder
 * @param {ID} id
 *
 * @private
 * @function
 */ const writeID = (encoder, id)=>{
    _encoding.writeVarUint(encoder, id.client);
    _encoding.writeVarUint(encoder, id.clock);
};
/**
 * Read ID.
 * * If first varUint read is 0xFFFFFF a RootID is returned.
 * * Otherwise an ID is returned
 *
 * @param {decoding.Decoder} decoder
 * @return {ID}
 *
 * @private
 * @function
 */ const readID = (decoder)=>createID(_decoding.readVarUint(decoder), _decoding.readVarUint(decoder));
/**
 * The top types are mapped from y.share.get(keyname) => type.
 * `type` does not store any information about the `keyname`.
 * This function finds the correct `keyname` for `type` and throws otherwise.
 *
 * @param {AbstractType<any>} type
 * @return {string}
 *
 * @private
 * @function
 */ const findRootTypeKey = (type)=>{
    // @ts-ignore _y must be defined, otherwise unexpected case
    for (const [key, value] of type.doc.share.entries()){
        if (value === type) return key;
    }
    throw _error.unexpectedCase();
};
/**
 * Check if `parent` is a parent of `child`.
 *
 * @param {AbstractType<any>} parent
 * @param {Item|null} child
 * @return {Boolean} Whether `parent` is a parent of `child`.
 *
 * @private
 * @function
 */ const isParentOf = (parent, child)=>{
    while(child !== null){
        if (child.parent === parent) return true;
        child = /** @type {AbstractType<any>} */ child.parent._item;
    }
    return false;
};
/**
 * Convenient helper to log type information.
 *
 * Do not use in productive systems as the output can be immense!
 *
 * @param {AbstractType<any>} type
 */ const logType = (type)=>{
    const res = [];
    let n = type._start;
    while(n){
        res.push(n);
        n = n.right;
    }
    console.log("Children: ", res);
    console.log("Children content: ", res.filter((m)=>!m.deleted).map((m)=>m.content));
};
class PermanentUserData {
    /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */ constructor(doc, storeType = doc.getMap("users")){
        /**
     * @type {Map<string,DeleteSet>}
     */ const dss = new Map();
        this.yusers = storeType;
        this.doc = doc;
        /**
     * Maps from clientid to userDescription
     *
     * @type {Map<number,string>}
     */ this.clients = new Map();
        this.dss = dss;
        /**
     * @param {YMap<any>} user
     * @param {string} userDescription
     */ const initUser = (user, userDescription)=>{
            /**
       * @type {YArray<Uint8Array>}
       */ const ds = user.get("ds");
            const ids = user.get("ids");
            const addClientId = /** @param {number} clientid */ (clientid)=>this.clients.set(clientid, userDescription);
            ds.observe(/** @param {YArrayEvent<any>} event */ (event)=>{
                event.changes.added.forEach((item)=>{
                    item.content.getContent().forEach((encodedDs)=>{
                        if (encodedDs instanceof Uint8Array) this.dss.set(userDescription, mergeDeleteSets([
                            this.dss.get(userDescription) || createDeleteSet(),
                            readDeleteSet(new DSDecoderV1(_decoding.createDecoder(encodedDs)))
                        ]));
                    });
                });
            });
            this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs)=>readDeleteSet(new DSDecoderV1(_decoding.createDecoder(encodedDs))))));
            ids.observe(/** @param {YArrayEvent<any>} event */ (event)=>event.changes.added.forEach((item)=>item.content.getContent().forEach(addClientId)));
            ids.forEach(addClientId);
        };
        // observe users
        storeType.observe((event)=>{
            event.keysChanged.forEach((userDescription)=>initUser(storeType.get(userDescription), userDescription));
        });
        // add intial data
        storeType.forEach(initUser);
    }
    /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */ setUserMapping(doc, clientid, userDescription, { filter = ()=>true } = {}) {
        const users = this.yusers;
        let user = users.get(userDescription);
        if (!user) {
            user = new YMap();
            user.set("ids", new YArray());
            user.set("ds", new YArray());
            users.set(userDescription, user);
        }
        user.get("ids").push([
            clientid
        ]);
        users.observe((_event)=>{
            setTimeout(()=>{
                const userOverwrite = users.get(userDescription);
                if (userOverwrite !== user) {
                    // user was overwritten, port all data over to the next user object
                    // @todo Experiment with Y.Sets here
                    user = userOverwrite;
                    // @todo iterate over old type
                    this.clients.forEach((_userDescription, clientid)=>{
                        if (userDescription === _userDescription) user.get("ids").push([
                            clientid
                        ]);
                    });
                    const encoder = new DSEncoderV1();
                    const ds = this.dss.get(userDescription);
                    if (ds) {
                        writeDeleteSet(encoder, ds);
                        user.get("ds").push([
                            encoder.toUint8Array()
                        ]);
                    }
                }
            }, 0);
        });
        doc.on("afterTransaction", /** @param {Transaction} transaction */ (transaction)=>{
            setTimeout(()=>{
                const yds = user.get("ds");
                const ds = transaction.deleteSet;
                if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {
                    const encoder = new DSEncoderV1();
                    writeDeleteSet(encoder, ds);
                    yds.push([
                        encoder.toUint8Array()
                    ]);
                }
            });
        });
    }
    /**
   * @param {number} clientid
   * @return {any}
   */ getUserByClientId(clientid) {
        return this.clients.get(clientid) || null;
    }
    /**
   * @param {ID} id
   * @return {string | null}
   */ getUserByDeletedId(id) {
        for (const [userDescription, ds] of this.dss.entries()){
            if (isDeleted(ds, id)) return userDescription;
        }
        return null;
    }
}
/**
 * A relative position is based on the Yjs model and is not affected by document changes.
 * E.g. If you place a relative position before a certain character, it will always point to this character.
 * If you place a relative position at the end of a type, it will always point to the end of the type.
 *
 * A numeric position is often unsuited for user selections, because it does not change when content is inserted
 * before or after.
 *
 * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.
 *
 * One of the properties must be defined.
 *
 * @example
 *   // Current cursor position is at position 10
 *   const relativePosition = createRelativePositionFromIndex(yText, 10)
 *   // modify yText
 *   yText.insert(0, 'abc')
 *   yText.delete(3, 10)
 *   // Compute the cursor position
 *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)
 *   absolutePosition.type === yText // => true
 *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3
 *
 */ class RelativePosition {
    /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */ constructor(type, tname, item, assoc = 0){
        /**
     * @type {ID|null}
     */ this.type = type;
        /**
     * @type {string|null}
     */ this.tname = tname;
        /**
     * @type {ID | null}
     */ this.item = item;
        /**
     * A relative position is associated to a specific character. By default
     * assoc >= 0, the relative position is associated to the character
     * after the meant position.
     * I.e. position 1 in 'ab' is associated to character 'b'.
     *
     * If assoc < 0, then the relative position is associated to the caharacter
     * before the meant position.
     *
     * @type {number}
     */ this.assoc = assoc;
    }
}
/**
 * @param {RelativePosition} rpos
 * @return {any}
 */ const relativePositionToJSON = (rpos)=>{
    const json = {};
    if (rpos.type) json.type = rpos.type;
    if (rpos.tname) json.tname = rpos.tname;
    if (rpos.item) json.item = rpos.item;
    if (rpos.assoc != null) json.assoc = rpos.assoc;
    return json;
};
/**
 * @param {any} json
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromJSON = (json)=>new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
class AbsolutePosition {
    /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */ constructor(type, index, assoc = 0){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
        /**
     * @type {number}
     */ this.index = index;
        this.assoc = assoc;
    }
}
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @param {number} [assoc]
 *
 * @function
 */ const createAbsolutePosition = (type, index, assoc = 0)=>new AbsolutePosition(type, index, assoc);
/**
 * @param {AbstractType<any>} type
 * @param {ID|null} item
 * @param {number} [assoc]
 *
 * @function
 */ const createRelativePosition = (type, item, assoc)=>{
    let typeid = null;
    let tname = null;
    if (type._item === null) tname = findRootTypeKey(type);
    else typeid = createID(type._item.id.client, type._item.id.clock);
    return new RelativePosition(typeid, tname, item, assoc);
};
/**
 * Create a relativePosition based on a absolute position.
 *
 * @param {AbstractType<any>} type The base type (e.g. YText or YArray).
 * @param {number} index The absolute position.
 * @param {number} [assoc]
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromTypeIndex = (type, index, assoc = 0)=>{
    let t = type._start;
    if (assoc < 0) {
        // associated to the left character or the beginning of a type, increment index if possible.
        if (index === 0) return createRelativePosition(type, null, assoc);
        index--;
    }
    while(t !== null){
        if (!t.deleted && t.countable) {
            if (t.length > index) // case 1: found position somewhere in the linked list
            return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);
            index -= t.length;
        }
        if (t.right === null && assoc < 0) // left-associated position, return last available id
        return createRelativePosition(type, t.lastId, assoc);
        t = t.right;
    }
    return createRelativePosition(type, null, assoc);
};
/**
 * @param {encoding.Encoder} encoder
 * @param {RelativePosition} rpos
 *
 * @function
 */ const writeRelativePosition = (encoder, rpos)=>{
    const { type, tname, item, assoc } = rpos;
    if (item !== null) {
        _encoding.writeVarUint(encoder, 0);
        writeID(encoder, item);
    } else if (tname !== null) {
        // case 2: found position at the end of the list and type is stored in y.share
        _encoding.writeUint8(encoder, 1);
        _encoding.writeVarString(encoder, tname);
    } else if (type !== null) {
        // case 3: found position at the end of the list and type is attached to an item
        _encoding.writeUint8(encoder, 2);
        writeID(encoder, type);
    } else throw _error.unexpectedCase();
    _encoding.writeVarInt(encoder, assoc);
    return encoder;
};
/**
 * @param {RelativePosition} rpos
 * @return {Uint8Array}
 */ const encodeRelativePosition = (rpos)=>{
    const encoder = _encoding.createEncoder();
    writeRelativePosition(encoder, rpos);
    return _encoding.toUint8Array(encoder);
};
/**
 * @param {decoding.Decoder} decoder
 * @return {RelativePosition}
 *
 * @function
 */ const readRelativePosition = (decoder)=>{
    let type = null;
    let tname = null;
    let itemID = null;
    switch(_decoding.readVarUint(decoder)){
        case 0:
            // case 1: found position somewhere in the linked list
            itemID = readID(decoder);
            break;
        case 1:
            // case 2: found position at the end of the list and type is stored in y.share
            tname = _decoding.readVarString(decoder);
            break;
        case 2:
            // case 3: found position at the end of the list and type is attached to an item
            type = readID(decoder);
    }
    const assoc = _decoding.hasContent(decoder) ? _decoding.readVarInt(decoder) : 0;
    return new RelativePosition(type, tname, itemID, assoc);
};
/**
 * @param {Uint8Array} uint8Array
 * @return {RelativePosition}
 */ const decodeRelativePosition = (uint8Array)=>readRelativePosition(_decoding.createDecoder(uint8Array));
/**
 * @param {RelativePosition} rpos
 * @param {Doc} doc
 * @return {AbsolutePosition|null}
 *
 * @function
 */ const createAbsolutePositionFromRelativePosition = (rpos, doc)=>{
    const store = doc.store;
    const rightID = rpos.item;
    const typeID = rpos.type;
    const tname = rpos.tname;
    const assoc = rpos.assoc;
    let type = null;
    let index = 0;
    if (rightID !== null) {
        if (getState(store, rightID.client) <= rightID.clock) return null;
        const res = followRedone(store, rightID);
        const right = res.item;
        if (!(right instanceof Item)) return null;
        type = /** @type {AbstractType<any>} */ right.parent;
        if (type._item === null || !type._item.deleted) {
            index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1); // adjust position based on left association if necessary
            let n = right.left;
            while(n !== null){
                if (!n.deleted && n.countable) index += n.length;
                n = n.left;
            }
        }
    } else {
        if (tname !== null) type = doc.get(tname);
        else if (typeID !== null) {
            if (getState(store, typeID.client) <= typeID.clock) // type does not exist yet
            return null;
            const { item } = followRedone(store, typeID);
            if (item instanceof Item && item.content instanceof ContentType) type = item.content.type;
            else // struct is garbage collected
            return null;
        } else throw _error.unexpectedCase();
        if (assoc >= 0) index = type._length;
        else index = 0;
    }
    return createAbsolutePosition(type, index, rpos.assoc);
};
/**
 * @param {RelativePosition|null} a
 * @param {RelativePosition|null} b
 * @return {boolean}
 *
 * @function
 */ const compareRelativePositions = (a, b)=>a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
class Snapshot {
    /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */ constructor(ds, sv){
        /**
     * @type {DeleteSet}
     */ this.ds = ds;
        /**
     * State Map
     * @type {Map<number,number>}
     */ this.sv = sv;
    }
}
/**
 * @param {Snapshot} snap1
 * @param {Snapshot} snap2
 * @return {boolean}
 */ const equalSnapshots = (snap1, snap2)=>{
    const ds1 = snap1.ds.clients;
    const ds2 = snap2.ds.clients;
    const sv1 = snap1.sv;
    const sv2 = snap2.sv;
    if (sv1.size !== sv2.size || ds1.size !== ds2.size) return false;
    for (const [key, value] of sv1.entries()){
        if (sv2.get(key) !== value) return false;
    }
    for (const [client, dsitems1] of ds1.entries()){
        const dsitems2 = ds2.get(client) || [];
        if (dsitems1.length !== dsitems2.length) return false;
        for(let i = 0; i < dsitems1.length; i++){
            const dsitem1 = dsitems1[i];
            const dsitem2 = dsitems2[i];
            if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) return false;
        }
    }
    return true;
};
/**
 * @param {Snapshot} snapshot
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 */ const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2())=>{
    writeDeleteSet(encoder, snapshot.ds);
    writeStateVector(encoder, snapshot.sv);
    return encoder.toUint8Array();
};
/**
 * @param {Snapshot} snapshot
 * @return {Uint8Array}
 */ const encodeSnapshot = (snapshot)=>encodeSnapshotV2(snapshot, new DSEncoderV1());
/**
 * @param {Uint8Array} buf
 * @param {DSDecoderV1 | DSDecoderV2} [decoder]
 * @return {Snapshot}
 */ const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(_decoding.createDecoder(buf)))=>{
    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));
};
/**
 * @param {Uint8Array} buf
 * @return {Snapshot}
 */ const decodeSnapshot = (buf)=>decodeSnapshotV2(buf, new DSDecoderV1(_decoding.createDecoder(buf)));
/**
 * @param {DeleteSet} ds
 * @param {Map<number,number>} sm
 * @return {Snapshot}
 */ const createSnapshot = (ds, sm)=>new Snapshot(ds, sm);
const emptySnapshot = createSnapshot(createDeleteSet(), new Map());
/**
 * @param {Doc} doc
 * @return {Snapshot}
 */ const snapshot = (doc)=>createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));
/**
 * @param {Item} item
 * @param {Snapshot|undefined} snapshot
 *
 * @protected
 * @function
 */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
/**
 * @param {Transaction} transaction
 * @param {Snapshot} snapshot
 */ const splitSnapshotAffectedStructs = (transaction, snapshot)=>{
    const meta = _map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, _set.create);
    const store = transaction.doc.store;
    // check if we already split for this snapshot
    if (!meta.has(snapshot)) {
        snapshot.sv.forEach((clock, client)=>{
            if (clock < getState(store, client)) getItemCleanStart(transaction, createID(client, clock));
        });
        iterateDeletedStructs(transaction, snapshot.ds, (_item)=>{});
        meta.add(snapshot);
    }
};
/**
 * @example
 *  const ydoc = new Y.Doc({ gc: false })
 *  ydoc.getText().insert(0, 'world!')
 *  const snapshot = Y.snapshot(ydoc)
 *  ydoc.getText().insert(0, 'hello ')
 *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)
 *  assert(restored.getText().toString() === 'world!')
 *
 * @param {Doc} originDoc
 * @param {Snapshot} snapshot
 * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc
 * @return {Doc}
 */ const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc())=>{
    if (originDoc.gc) // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted
    throw new Error("Garbage-collection must be disabled in `originDoc`!");
    const { sv, ds } = snapshot;
    const encoder = new UpdateEncoderV2();
    originDoc.transact((transaction)=>{
        let size = 0;
        sv.forEach((clock)=>{
            if (clock > 0) size++;
        });
        _encoding.writeVarUint(encoder.restEncoder, size);
        // splitting the structs before writing them to the encoder
        for (const [client, clock] of sv){
            if (clock === 0) continue;
            if (clock < getState(originDoc.store, client)) getItemCleanStart(transaction, createID(client, clock));
            const structs = originDoc.store.clients.get(client) || [];
            const lastStructIndex = findIndexSS(structs, clock - 1);
            // write # encoded structs
            _encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1);
            encoder.writeClient(client);
            // first clock written is 0
            _encoding.writeVarUint(encoder.restEncoder, 0);
            for(let i = 0; i <= lastStructIndex; i++)structs[i].write(encoder, 0);
        }
        writeDeleteSet(encoder, ds);
    });
    applyUpdateV2(newDoc, encoder.toUint8Array(), "snapshot");
    return newDoc;
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 */ const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2)=>{
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){
        if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) return false;
    }
    const mergedDS = mergeDeleteSets([
        snapshot.ds,
        readDeleteSet(updateDecoder)
    ]);
    return equalDeleteSets(snapshot.ds, mergedDS);
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 */ const snapshotContainsUpdate = (snapshot, update)=>snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);
class StructStore {
    constructor(){
        /**
     * @type {Map<number,Array<GC|Item>>}
     */ this.clients = new Map();
        /**
     * @type {null | { missing: Map<number, number>, update: Uint8Array }}
     */ this.pendingStructs = null;
        /**
     * @type {null | Uint8Array}
     */ this.pendingDs = null;
    }
}
/**
 * Return the states as a Map<client,clock>.
 * Note that clock refers to the next expected clock id.
 *
 * @param {StructStore} store
 * @return {Map<number,number>}
 *
 * @public
 * @function
 */ const getStateVector = (store)=>{
    const sm = new Map();
    store.clients.forEach((structs, client)=>{
        const struct = structs[structs.length - 1];
        sm.set(client, struct.id.clock + struct.length);
    });
    return sm;
};
/**
 * @param {StructStore} store
 * @param {number} client
 * @return {number}
 *
 * @public
 * @function
 */ const getState = (store, client)=>{
    const structs = store.clients.get(client);
    if (structs === undefined) return 0;
    const lastStruct = structs[structs.length - 1];
    return lastStruct.id.clock + lastStruct.length;
};
/**
 * @param {StructStore} store
 * @param {GC|Item} struct
 *
 * @private
 * @function
 */ const addStruct = (store, struct)=>{
    let structs = store.clients.get(struct.id.client);
    if (structs === undefined) {
        structs = [];
        store.clients.set(struct.id.client, structs);
    } else {
        const lastStruct = structs[structs.length - 1];
        if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) throw _error.unexpectedCase();
    }
    structs.push(struct);
};
/**
 * Perform a binary search on a sorted array
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 * @return {number}
 *
 * @private
 * @function
 */ const findIndexSS = (structs, clock)=>{
    let left = 0;
    let right = structs.length - 1;
    let mid = structs[right];
    let midclock = mid.id.clock;
    if (midclock === clock) return right;
    // @todo does it even make sense to pivot the search?
    // If a good split misses, it might actually increase the time to find the correct item.
    // Currently, the only advantage is that search with pivoting might find the item on the first try.
    let midindex = _math.floor(clock / (midclock + mid.length - 1) * right); // pivoting the search
    while(left <= right){
        mid = structs[midindex];
        midclock = mid.id.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.length) return midindex;
            left = midindex + 1;
        } else right = midindex - 1;
        midindex = _math.floor((left + right) / 2);
    }
    // Always check state before looking for a struct in StructStore
    // Therefore the case of not finding a struct is unexpected
    throw _error.unexpectedCase();
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {GC|Item}
 *
 * @private
 * @function
 */ const find = (store, id)=>{
    /**
   * @type {Array<GC|Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    return structs[findIndexSS(structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 * @private
 * @function
 */ const getItem = /** @type {function(StructStore,ID):Item} */ find;
/**
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 */ const findIndexCleanStart = (transaction, structs, clock)=>{
    const index = findIndexSS(structs, clock);
    const struct = structs[index];
    if (struct.id.clock < clock && struct instanceof Item) {
        structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
        return index + 1;
    }
    return index;
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanStart = (transaction, id)=>{
    const structs = /** @type {Array<Item>} */ transaction.doc.store.clients.get(id.client);
    return structs[findIndexCleanStart(transaction, structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanEnd = (transaction, store, id)=>{
    /**
   * @type {Array<Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    const index = findIndexSS(structs, id.clock);
    const struct = structs[index];
    if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
    return struct;
};
/**
 * Replace `item` with `newitem` in store
 * @param {StructStore} store
 * @param {GC|Item} struct
 * @param {GC|Item} newStruct
 *
 * @private
 * @function
 */ const replaceStruct = (store, struct, newStruct)=>{
    const structs = /** @type {Array<GC|Item>} */ store.clients.get(struct.id.client);
    structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
/**
 * Iterate over a range of structs
 *
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clockStart Inclusive start
 * @param {number} len
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateStructs = (transaction, structs, clockStart, len, f)=>{
    if (len === 0) return;
    const clockEnd = clockStart + len;
    let index = findIndexCleanStart(transaction, structs, clockStart);
    let struct;
    do {
        struct = structs[index++];
        if (clockEnd < struct.id.clock + struct.length) findIndexCleanStart(transaction, structs, clockEnd);
        f(struct);
    }while (index < structs.length && structs[index].id.clock < clockEnd);
};
/**
 * A transaction is created for every change on the Yjs model. It is possible
 * to bundle changes on the Yjs model in a single transaction to
 * minimize the number on messages sent and the number of observer calls.
 * If possible the user of this library should bundle as many changes as
 * possible. Here is an example to illustrate the advantages of bundling:
 *
 * @example
 * const map = y.define('map', YMap)
 * // Log content when change is triggered
 * map.observe(() => {
 *   console.log('change triggered')
 * })
 * // Each change on the map type triggers a log message:
 * map.set('a', 0) // => "change triggered"
 * map.set('b', 0) // => "change triggered"
 * // When put in a transaction, it will trigger the log after the transaction:
 * y.transact(() => {
 *   map.set('a', 1)
 *   map.set('b', 1)
 * }) // => "change triggered"
 *
 * @public
 */ class Transaction {
    /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */ constructor(doc, origin, local){
        /**
     * The Yjs instance.
     * @type {Doc}
     */ this.doc = doc;
        /**
     * Describes the set of deleted items by ids
     * @type {DeleteSet}
     */ this.deleteSet = new DeleteSet();
        /**
     * Holds the state before the transaction started.
     * @type {Map<Number,Number>}
     */ this.beforeState = getStateVector(doc.store);
        /**
     * Holds the state after the transaction.
     * @type {Map<Number,Number>}
     */ this.afterState = new Map();
        /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item.parentSub = null` for YArray)
     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}
     */ this.changed = new Map();
        /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}
     */ this.changedParentTypes = new Map();
        /**
     * @type {Array<AbstractStruct>}
     */ this._mergeStructs = [];
        /**
     * @type {any}
     */ this.origin = origin;
        /**
     * Stores meta information on the transaction
     * @type {Map<any,any>}
     */ this.meta = new Map();
        /**
     * Whether this change originates from this doc.
     * @type {boolean}
     */ this.local = local;
        /**
     * @type {Set<Doc>}
     */ this.subdocsAdded = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsRemoved = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsLoaded = new Set();
        /**
     * @type {boolean}
     */ this._needFormattingCleanup = false;
    }
}
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 * @return {boolean} Whether data was written.
 */ const writeUpdateMessageFromTransaction = (encoder, transaction)=>{
    if (transaction.deleteSet.clients.size === 0 && !_map.any(transaction.afterState, (clock, client)=>transaction.beforeState.get(client) !== clock)) return false;
    sortAndMergeDeleteSet(transaction.deleteSet);
    writeStructsFromTransaction(encoder, transaction);
    writeDeleteSet(encoder, transaction.deleteSet);
    return true;
};
/**
 * If `type.parent` was added in current transaction, `type` technically
 * did not change, it was just added and we should not fire events for `type`.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<YEvent<any>>} type
 * @param {string|null} parentSub
 */ const addChangedTypeToTransaction = (transaction, type, parentSub)=>{
    const item = type._item;
    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) _map.setIfUndefined(transaction.changed, type, _set.create).add(parentSub);
};
/**
 * @param {Array<AbstractStruct>} structs
 * @param {number} pos
 * @return {number} # of merged structs
 */ const tryToMergeWithLefts = (structs, pos)=>{
    let right = structs[pos];
    let left = structs[pos - 1];
    let i = pos;
    for(; i > 0; right = left, left = structs[--i - 1]){
        if (left.deleted === right.deleted && left.constructor === right.constructor) {
            if (left.mergeWith(right)) {
                if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ right.parent._map.get(right.parentSub) === right) /** @type {AbstractType<any>} */ right.parent._map.set(right.parentSub, /** @type {Item} */ left);
                continue;
            }
        }
        break;
    }
    const merged = pos - i;
    if (merged) // remove all merged structs from the array
    structs.splice(pos + 1 - merged, merged);
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGcDeleteSet = (ds, store, gcFilter)=>{
    for (const [client, deleteItems] of ds.clients.entries()){
        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            const endDeleteItemClock = deleteItem.clock + deleteItem.len;
            for(let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]){
                const struct = structs[si];
                if (deleteItem.clock + deleteItem.len <= struct.id.clock) break;
                if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) struct.gc(store, false);
            }
        }
    }
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 */ const tryMergeDeleteSet = (ds, store)=>{
    // try to merge deleted / gc'd items
    // merge from right to left for better efficiecy and so we don't miss any merge targets
    ds.clients.forEach((deleteItems, client)=>{
        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            // start with merging the item next to the last deleted item
            const mostRightIndexToCheck = _math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
            for(let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si])si -= 1 + tryToMergeWithLefts(structs, si);
        }
    });
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGc = (ds, store, gcFilter)=>{
    tryGcDeleteSet(ds, store, gcFilter);
    tryMergeDeleteSet(ds, store);
};
/**
 * @param {Array<Transaction>} transactionCleanups
 * @param {number} i
 */ const cleanupTransactions = (transactionCleanups, i)=>{
    if (i < transactionCleanups.length) {
        const transaction = transactionCleanups[i];
        const doc = transaction.doc;
        const store = doc.store;
        const ds = transaction.deleteSet;
        const mergeStructs = transaction._mergeStructs;
        try {
            sortAndMergeDeleteSet(ds);
            transaction.afterState = getStateVector(transaction.doc.store);
            doc.emit("beforeObserverCalls", [
                transaction,
                doc
            ]);
            /**
       * An array of event callbacks.
       *
       * Each callback is called even if the other ones throw errors.
       *
       * @type {Array<function():void>}
       */ const fs = [];
            // observe events on changed types
            transaction.changed.forEach((subs, itemtype)=>fs.push(()=>{
                    if (itemtype._item === null || !itemtype._item.deleted) itemtype._callObserver(transaction, subs);
                }));
            fs.push(()=>{
                // deep observe events
                transaction.changedParentTypes.forEach((events, type)=>{
                    // We need to think about the possibility that the user transforms the
                    // Y.Doc in the event.
                    if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
                        events = events.filter((event)=>event.target._item === null || !event.target._item.deleted);
                        events.forEach((event)=>{
                            event.currentTarget = type;
                            // path is relative to the current target
                            event._path = null;
                        });
                        // sort events by path length so that top-level events are fired first.
                        events.sort((event1, event2)=>event1.path.length - event2.path.length);
                        // We don't need to check for events.length
                        // because we know it has at least one element
                        callEventHandlerListeners(type._dEH, events, transaction);
                    }
                });
            });
            fs.push(()=>doc.emit("afterTransaction", [
                    transaction,
                    doc
                ]));
            (0, _function.callAll)(fs, []);
            if (transaction._needFormattingCleanup) cleanupYTextAfterTransaction(transaction);
        } finally{
            // Replace deleted items with ItemDeleted / GC.
            // This is where content is actually remove from the Yjs Doc.
            if (doc.gc) tryGcDeleteSet(ds, store, doc.gcFilter);
            tryMergeDeleteSet(ds, store);
            // on all affected store.clients props, try to merge
            transaction.afterState.forEach((clock, client)=>{
                const beforeClock = transaction.beforeState.get(client) || 0;
                if (beforeClock !== clock) {
                    const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
                    // we iterate from right to left so we can safely remove entries
                    const firstChangePos = _math.max(findIndexSS(structs, beforeClock), 1);
                    for(let i = structs.length - 1; i >= firstChangePos;)i -= 1 + tryToMergeWithLefts(structs, i);
                }
            });
            // try to merge mergeStructs
            // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left
            //        but at the moment DS does not handle duplicates
            for(let i = mergeStructs.length - 1; i >= 0; i--){
                const { client, clock } = mergeStructs[i].id;
                const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
                const replacedStructPos = findIndexSS(structs, clock);
                if (replacedStructPos + 1 < structs.length) {
                    if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) continue; // no need to perform next check, both are already merged
                }
                if (replacedStructPos > 0) tryToMergeWithLefts(structs, replacedStructPos);
            }
            if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {
                _logging.print(_logging.ORANGE, _logging.BOLD, "[yjs] ", _logging.UNBOLD, _logging.RED, "Changed the client-id because another client seems to be using it.");
                doc.clientID = generateNewClientId();
            }
            // @todo Merge all the transactions into one and provide send the data as a single update message
            doc.emit("afterTransactionCleanup", [
                transaction,
                doc
            ]);
            if (doc._observers.has("update")) {
                const encoder = new UpdateEncoderV1();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) doc.emit("update", [
                    encoder.toUint8Array(),
                    transaction.origin,
                    doc,
                    transaction
                ]);
            }
            if (doc._observers.has("updateV2")) {
                const encoder = new UpdateEncoderV2();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) doc.emit("updateV2", [
                    encoder.toUint8Array(),
                    transaction.origin,
                    doc,
                    transaction
                ]);
            }
            const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
            if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
                subdocsAdded.forEach((subdoc)=>{
                    subdoc.clientID = doc.clientID;
                    if (subdoc.collectionid == null) subdoc.collectionid = doc.collectionid;
                    doc.subdocs.add(subdoc);
                });
                subdocsRemoved.forEach((subdoc)=>doc.subdocs.delete(subdoc));
                doc.emit("subdocs", [
                    {
                        loaded: subdocsLoaded,
                        added: subdocsAdded,
                        removed: subdocsRemoved
                    },
                    doc,
                    transaction
                ]);
                subdocsRemoved.forEach((subdoc)=>subdoc.destroy());
            }
            if (transactionCleanups.length <= i + 1) {
                doc._transactionCleanups = [];
                doc.emit("afterAllTransactions", [
                    doc,
                    transactionCleanups
                ]);
            } else cleanupTransactions(transactionCleanups, i + 1);
        }
    }
};
/**
 * Implements the functionality of `y.transact(()=>{..})`
 *
 * @template T
 * @param {Doc} doc
 * @param {function(Transaction):T} f
 * @param {any} [origin=true]
 * @return {T}
 *
 * @function
 */ const transact = (doc, f, origin = null, local = true)=>{
    const transactionCleanups = doc._transactionCleanups;
    let initialCall = false;
    /**
   * @type {any}
   */ let result = null;
    if (doc._transaction === null) {
        initialCall = true;
        doc._transaction = new Transaction(doc, origin, local);
        transactionCleanups.push(doc._transaction);
        if (transactionCleanups.length === 1) doc.emit("beforeAllTransactions", [
            doc
        ]);
        doc.emit("beforeTransaction", [
            doc._transaction,
            doc
        ]);
    }
    try {
        result = f(doc._transaction);
    } finally{
        if (initialCall) {
            const finishCleanup = doc._transaction === transactionCleanups[0];
            doc._transaction = null;
            if (finishCleanup) // The first transaction ended, now process observer calls.
            // Observer call may create new transactions for which we need to call the observers and do cleanup.
            // We don't want to nest these calls, so we execute these calls one after
            // another.
            // Also we need to ensure that all cleanups are called, even if the
            // observes throw errors.
            // This file is full of hacky try {} finally {} blocks to ensure that an
            // event can throw errors and also that the cleanup is called.
            cleanupTransactions(transactionCleanups, 0);
        }
    }
    return result;
};
class StackItem {
    /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */ constructor(deletions, insertions){
        this.insertions = insertions;
        this.deletions = deletions;
        /**
     * Use this to save and restore metadata like selection range
     */ this.meta = new Map();
    }
}
/**
 * @param {Transaction} tr
 * @param {UndoManager} um
 * @param {StackItem} stackItem
 */ const clearUndoManagerStackItem = (tr, um, stackItem)=>{
    iterateDeletedStructs(tr, stackItem.deletions, (item)=>{
        if (item instanceof Item && um.scope.some((type)=>isParentOf(type, item))) keepItem(item, false);
    });
};
/**
 * @param {UndoManager} undoManager
 * @param {Array<StackItem>} stack
 * @param {string} eventType
 * @return {StackItem?}
 */ const popStackItem = (undoManager, stack, eventType)=>{
    /**
   * Whether a change happened
   * @type {StackItem?}
   */ let result = null;
    /**
   * Keep a reference to the transaction so we can fire the event with the changedParentTypes
   * @type {any}
   */ let _tr = null;
    const doc = undoManager.doc;
    const scope = undoManager.scope;
    transact(doc, (transaction)=>{
        while(stack.length > 0 && result === null){
            const store = doc.store;
            const stackItem = /** @type {StackItem} */ stack.pop();
            /**
       * @type {Set<Item>}
       */ const itemsToRedo = new Set();
            /**
       * @type {Array<Item>}
       */ const itemsToDelete = [];
            let performedChange = false;
            iterateDeletedStructs(transaction, stackItem.insertions, (struct)=>{
                if (struct instanceof Item) {
                    if (struct.redone !== null) {
                        let { item, diff } = followRedone(store, struct.id);
                        if (diff > 0) item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
                        struct = item;
                    }
                    if (!struct.deleted && scope.some((type)=>isParentOf(type, /** @type {Item} */ struct))) itemsToDelete.push(struct);
                }
            });
            iterateDeletedStructs(transaction, stackItem.deletions, (struct)=>{
                if (struct instanceof Item && scope.some((type)=>isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
                !isDeleted(stackItem.insertions, struct.id)) itemsToRedo.add(struct);
            });
            itemsToRedo.forEach((struct)=>{
                performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
            });
            // We want to delete in reverse order so that children are deleted before
            // parents, so we have more information available when items are filtered.
            for(let i = itemsToDelete.length - 1; i >= 0; i--){
                const item = itemsToDelete[i];
                if (undoManager.deleteFilter(item)) {
                    item.delete(transaction);
                    performedChange = true;
                }
            }
            result = performedChange ? stackItem : null;
        }
        transaction.changed.forEach((subProps, type)=>{
            // destroy search marker if necessary
            if (subProps.has(null) && type._searchMarker) type._searchMarker.length = 0;
        });
        _tr = transaction;
    }, undoManager);
    if (result != null) {
        const changedParentTypes = _tr.changedParentTypes;
        undoManager.emit("stack-item-popped", [
            {
                stackItem: result,
                type: eventType,
                changedParentTypes
            },
            undoManager
        ]);
    }
    return result;
};
/**
 * @typedef {Object} UndoManagerOptions
 * @property {number} [UndoManagerOptions.captureTimeout=500]
 * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.
 * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes
 * it is necessary to filter what an Undo/Redo operation can delete. If this
 * filter returns false, the type/item won't be deleted even it is in the
 * undo/redo scope.
 * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]
 * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).
 * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.
 */ /**
 * Fires 'stack-item-added' event when a stack item was added to either the undo- or
 * the redo-stack. You may store additional stack information via the
 * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).
 * Fires 'stack-item-popped' event when a stack item was popped from either the
 * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.
 *
 * @extends {Observable<'stack-item-added'|'stack-item-popped'|'stack-cleared'|'stack-item-updated'>}
 */ class UndoManager extends (0, _observable.Observable) {
    /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */ constructor(typeScope, { captureTimeout = 500, captureTransaction = (_tr)=>true, deleteFilter = ()=>true, trackedOrigins = new Set([
        null
    ]), ignoreRemoteMapChanges = false, doc = /** @type {Doc} */ _array.isArray(typeScope) ? typeScope[0].doc : typeScope.doc } = {}){
        super();
        /**
     * @type {Array<AbstractType<any>>}
     */ this.scope = [];
        this.doc = doc;
        this.addToScope(typeScope);
        this.deleteFilter = deleteFilter;
        trackedOrigins.add(this);
        this.trackedOrigins = trackedOrigins;
        this.captureTransaction = captureTransaction;
        /**
     * @type {Array<StackItem>}
     */ this.undoStack = [];
        /**
     * @type {Array<StackItem>}
     */ this.redoStack = [];
        /**
     * Whether the client is currently undoing (calling UndoManager.undo)
     *
     * @type {boolean}
     */ this.undoing = false;
        this.redoing = false;
        this.lastChange = 0;
        this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
        this.captureTimeout = captureTimeout;
        /**
     * @param {Transaction} transaction
     */ this.afterTransactionHandler = (transaction)=>{
            // Only track certain transactions
            if (!this.captureTransaction(transaction) || !this.scope.some((type)=>transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) return;
            const undoing = this.undoing;
            const redoing = this.redoing;
            const stack = undoing ? this.redoStack : this.undoStack;
            if (undoing) this.stopCapturing(); // next undo should not be appended to last stack item
            else if (!redoing) // neither undoing nor redoing: delete redoStack
            this.clear(false, true);
            const insertions = new DeleteSet();
            transaction.afterState.forEach((endClock, client)=>{
                const startClock = transaction.beforeState.get(client) || 0;
                const len = endClock - startClock;
                if (len > 0) addToDeleteSet(insertions, client, startClock, len);
            });
            const now = _time.getUnixTime();
            let didAdd = false;
            if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
                // append change to last stack op
                const lastOp = stack[stack.length - 1];
                lastOp.deletions = mergeDeleteSets([
                    lastOp.deletions,
                    transaction.deleteSet
                ]);
                lastOp.insertions = mergeDeleteSets([
                    lastOp.insertions,
                    insertions
                ]);
            } else {
                // create a new stack op
                stack.push(new StackItem(transaction.deleteSet, insertions));
                didAdd = true;
            }
            if (!undoing && !redoing) this.lastChange = now;
            // make sure that deleted structs are not gc'd
            iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ (item)=>{
                if (item instanceof Item && this.scope.some((type)=>isParentOf(type, item))) keepItem(item, true);
            });
            const changeEvent = [
                {
                    stackItem: stack[stack.length - 1],
                    origin: transaction.origin,
                    type: undoing ? "redo" : "undo",
                    changedParentTypes: transaction.changedParentTypes
                },
                this
            ];
            if (didAdd) this.emit("stack-item-added", changeEvent);
            else this.emit("stack-item-updated", changeEvent);
        };
        this.doc.on("afterTransaction", this.afterTransactionHandler);
        this.doc.on("destroy", ()=>{
            this.destroy();
        });
    }
    /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */ addToScope(ytypes) {
        ytypes = _array.isArray(ytypes) ? ytypes : [
            ytypes
        ];
        ytypes.forEach((ytype)=>{
            if (this.scope.every((yt)=>yt !== ytype)) {
                if (ytype.doc !== this.doc) _logging.warn("[yjs#509] Not same Y.Doc"); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509
                this.scope.push(ytype);
            }
        });
    }
    /**
   * @param {any} origin
   */ addTrackedOrigin(origin) {
        this.trackedOrigins.add(origin);
    }
    /**
   * @param {any} origin
   */ removeTrackedOrigin(origin) {
        this.trackedOrigins.delete(origin);
    }
    clear(clearUndoStack = true, clearRedoStack = true) {
        if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) this.doc.transact((tr)=>{
            if (clearUndoStack) {
                this.undoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                this.undoStack = [];
            }
            if (clearRedoStack) {
                this.redoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                this.redoStack = [];
            }
            this.emit("stack-cleared", [
                {
                    undoStackCleared: clearUndoStack,
                    redoStackCleared: clearRedoStack
                }
            ]);
        });
    }
    /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */ stopCapturing() {
        this.lastChange = 0;
    }
    /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ undo() {
        this.undoing = true;
        let res;
        try {
            res = popStackItem(this, this.undoStack, "undo");
        } finally{
            this.undoing = false;
        }
        return res;
    }
    /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ redo() {
        this.redoing = true;
        let res;
        try {
            res = popStackItem(this, this.redoStack, "redo");
        } finally{
            this.redoing = false;
        }
        return res;
    }
    /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */ canUndo() {
        return this.undoStack.length > 0;
    }
    /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */ canRedo() {
        return this.redoStack.length > 0;
    }
    destroy() {
        this.trackedOrigins.delete(this);
        this.doc.off("afterTransaction", this.afterTransactionHandler);
        super.destroy();
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 */ function* lazyStructReaderGenerator(decoder) {
    const numOfStateUpdates = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = _decoding.readVarUint(decoder.restDecoder);
        const client = decoder.readClient();
        let clock = _decoding.readVarUint(decoder.restDecoder);
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            // @todo use switch instead of ifs
            if (info === 10) {
                const len = _decoding.readVarUint(decoder.restDecoder);
                yield new Skip(createID(client, clock), len);
                clock += len;
            } else if ((_binary.BITS5 & info) !== 0) {
                const cantCopyParentInfo = (info & (_binary.BIT7 | _binary.BIT8)) === 0;
                // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                // and we read the next string as parentYKey.
                // It indicates how we store/retrieve parent from `y.share`
                // @type {string|null}
                const struct = new Item(createID(client, clock), null, (info & _binary.BIT8) === _binary.BIT8 ? decoder.readLeftID() : null, null, (info & _binary.BIT7) === _binary.BIT7 ? decoder.readRightID() : null, // @ts-ignore Force writing a string here.
                cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & _binary.BIT6) === _binary.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content
                );
                yield struct;
                clock += struct.length;
            } else {
                const len = decoder.readLen();
                yield new GC(createID(client, clock), len);
                clock += len;
            }
        }
    }
}
class LazyStructReader {
    /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */ constructor(decoder, filterSkips){
        this.gen = lazyStructReaderGenerator(decoder);
        /**
     * @type {null | Item | Skip | GC}
     */ this.curr = null;
        this.done = false;
        this.filterSkips = filterSkips;
        this.next();
    }
    /**
   * @return {Item | GC | Skip |null}
   */ next() {
        // ignore "Skip" structs
        do this.curr = this.gen.next().value || null;
        while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
        return this.curr;
    }
}
/**
 * @param {Uint8Array} update
 *
 */ const logUpdate = (update)=>logUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const logUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())structs.push(curr);
    _logging.print("Structs: ", structs);
    const ds = readDeleteSet(updateDecoder);
    _logging.print("DeleteSet: ", ds);
};
/**
 * @param {Uint8Array} update
 *
 */ const decodeUpdate = (update)=>decodeUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())structs.push(curr);
    return {
        structs,
        ds: readDeleteSet(updateDecoder)
    };
};
class LazyStructWriter {
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ constructor(encoder){
        this.currClient = 0;
        this.startClock = 0;
        this.written = 0;
        this.encoder = encoder;
        /**
     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.
     *
     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.
     *
     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.
     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.
     *
     * @type {Array<{ written: number, restEncoder: Uint8Array }>}
     */ this.clientStructs = [];
    }
}
/**
 * @param {Array<Uint8Array>} updates
 * @return {Uint8Array}
 */ const mergeUpdates = (updates)=>mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2)=>{
    const encoder = new YEncoder();
    const updateDecoder = new LazyStructReader(new YDecoder(_decoding.createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let size = 0;
        let currClient = curr.id.client;
        let stopCounting = curr.id.clock !== 0; // must start at 0
        let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                if (currClock !== 0) {
                    size++;
                    // We found a new client
                    // write what we have to the encoder
                    _encoding.writeVarUint(encoder.restEncoder, currClient);
                    _encoding.writeVarUint(encoder.restEncoder, currClock);
                }
                currClient = curr.id.client;
                currClock = 0;
                stopCounting = curr.id.clock !== 0;
            }
            // we ignore skips
            if (curr.constructor === Skip) stopCounting = true;
            if (!stopCounting) currClock = curr.id.clock + curr.length;
        }
        // write what we have
        if (currClock !== 0) {
            size++;
            _encoding.writeVarUint(encoder.restEncoder, currClient);
            _encoding.writeVarUint(encoder.restEncoder, currClock);
        }
        // prepend the size of the state vector
        const enc = _encoding.createEncoder();
        _encoding.writeVarUint(enc, size);
        _encoding.writeBinaryEncoder(enc, encoder.restEncoder);
        encoder.restEncoder = enc;
        return encoder.toUint8Array();
    } else {
        _encoding.writeVarUint(encoder.restEncoder, 0);
        return encoder.toUint8Array();
    }
};
/**
 * @param {Uint8Array} update
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdate = (update)=>encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2)=>{
    /**
   * @type {Map<number, number>}
   */ const from = new Map();
    /**
   * @type {Map<number, number>}
   */ const to = new Map();
    const updateDecoder = new LazyStructReader(new YDecoder(_decoding.createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let currClient = curr.id.client;
        let currClock = curr.id.clock;
        // write the beginning to `from`
        from.set(currClient, currClock);
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                // We found a new client
                // write the end to `to`
                to.set(currClient, currClock);
                // write the beginning to `from`
                from.set(curr.id.client, curr.id.clock);
                // update currClient
                currClient = curr.id.client;
            }
            currClock = curr.id.clock + curr.length;
        }
        // write the end to `to`
        to.set(currClient, currClock);
    }
    return {
        from,
        to
    };
};
/**
 * @param {Uint8Array} update
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMeta = (update)=>parseUpdateMetaV2(update, UpdateDecoderV1);
/**
 * This method is intended to slice any kind of struct and retrieve the right part.
 * It does not handle side-effects, so it should only be used by the lazy-encoder.
 *
 * @param {Item | GC | Skip} left
 * @param {number} diff
 * @return {Item | GC}
 */ const sliceStruct = (left, diff)=>{
    if (left.constructor === GC) {
        const { client, clock } = left.id;
        return new GC(createID(client, clock + diff), left.length - diff);
    } else if (left.constructor === Skip) {
        const { client, clock } = left.id;
        return new Skip(createID(client, clock + diff), left.length - diff);
    } else {
        const leftItem = /** @type {Item} */ left;
        const { client, clock } = leftItem.id;
        return new Item(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    }
};
/**
 *
 * This function works similarly to `readUpdateV2`.
 *
 * @param {Array<Uint8Array>} updates
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 * @return {Uint8Array}
 */ const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    if (updates.length === 1) return updates[0];
    const updateDecoders = updates.map((update)=>new YDecoder(_decoding.createDecoder(update)));
    let lazyStructDecoders = updateDecoders.map((decoder)=>new LazyStructReader(decoder, true));
    /**
   * @todo we don't need offset because we always slice before
   * @type {null | { struct: Item | GC | Skip, offset: number }}
   */ let currWrite = null;
    const updateEncoder = new YEncoder();
    // write structs lazily
    const lazyStructEncoder = new LazyStructWriter(updateEncoder);
    // Note: We need to ensure that all lazyStructDecoders are fully consumed
    // Note: Should merge document updates whenever possible - even from different updates
    // Note: Should handle that some operations cannot be applied yet ()
    while(true){
        // Write higher clients first  sort by clientID & clock and remove decoders without content
        lazyStructDecoders = lazyStructDecoders.filter((dec)=>dec.curr !== null);
        lazyStructDecoders.sort(/** @type {function(any,any):number} */ (dec1, dec2)=>{
            if (dec1.curr.id.client === dec2.curr.id.client) {
                const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
                if (clockDiff === 0) // @todo remove references to skip since the structDecoders must filter Skips.
                return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.
                ;
                else return clockDiff;
            } else return dec2.curr.id.client - dec1.curr.id.client;
        });
        if (lazyStructDecoders.length === 0) break;
        const currDecoder = lazyStructDecoders[0];
        // write from currDecoder until the next operation is from another client or if filler-struct
        // then we need to reorder the decoders and find the next operation to write
        const firstClient = /** @type {Item | GC} */ currDecoder.curr.id.client;
        if (currWrite !== null) {
            let curr = /** @type {Item | GC | null} */ currDecoder.curr;
            let iterated = false;
            // iterate until we find something that we haven't written already
            // remember: first the high client-ids are written
            while(curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client){
                curr = currDecoder.next();
                iterated = true;
            }
            if (curr === null || // current decoder is empty
            curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
            iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length // the above while loop was used and we are potentially missing updates
            ) continue;
            if (firstClient !== currWrite.struct.id.client) {
                writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                currWrite = {
                    struct: curr,
                    offset: 0
                };
                currDecoder.next();
            } else if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
                // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)
                if (currWrite.struct.constructor === Skip) // extend existing skip
                currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
                else {
                    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                    const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
                    /**
             * @type {Skip}
             */ const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
                    currWrite = {
                        struct,
                        offset: 0
                    };
                }
            } else {
                const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
                if (diff > 0) {
                    if (currWrite.struct.constructor === Skip) // prefer to slice Skip because the other struct might contain more information
                    currWrite.struct.length -= diff;
                    else curr = sliceStruct(curr, diff);
                }
                if (!currWrite.struct.mergeWith(/** @type {any} */ curr)) {
                    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                    currWrite = {
                        struct: curr,
                        offset: 0
                    };
                    currDecoder.next();
                }
            }
        } else {
            currWrite = {
                struct: /** @type {Item | GC} */ currDecoder.curr,
                offset: 0
            };
            currDecoder.next();
        }
        for(let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()){
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = {
                struct: next,
                offset: 0
            };
        }
    }
    if (currWrite !== null) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = null;
    }
    finishLazyStructWriting(lazyStructEncoder);
    const dss = updateDecoders.map((decoder)=>readDeleteSet(decoder));
    const ds = mergeDeleteSets(dss);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 */ const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    const state = decodeStateVector(sv);
    const encoder = new YEncoder();
    const lazyStructWriter = new LazyStructWriter(encoder);
    const decoder = new YDecoder(_decoding.createDecoder(update));
    const reader = new LazyStructReader(decoder, false);
    while(reader.curr){
        const curr = reader.curr;
        const currClient = curr.id.client;
        const svClock = state.get(currClient) || 0;
        if (reader.curr.constructor === Skip) {
            // the first written struct shouldn't be a skip
            reader.next();
            continue;
        }
        if (curr.id.clock + curr.length > svClock) {
            writeStructToLazyStructWriter(lazyStructWriter, curr, _math.max(svClock - curr.id.clock, 0));
            reader.next();
            while(reader.curr && reader.curr.id.client === currClient){
                writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
                reader.next();
            }
        } else // read until something new comes up
        while(reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock)reader.next();
    }
    finishLazyStructWriting(lazyStructWriter);
    // write ds
    const ds = readDeleteSet(decoder);
    writeDeleteSet(encoder, ds);
    return encoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 */ const diffUpdate = (update, sv)=>diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {LazyStructWriter} lazyWriter
 */ const flushLazyStructWriter = (lazyWriter)=>{
    if (lazyWriter.written > 0) {
        lazyWriter.clientStructs.push({
            written: lazyWriter.written,
            restEncoder: _encoding.toUint8Array(lazyWriter.encoder.restEncoder)
        });
        lazyWriter.encoder.restEncoder = _encoding.createEncoder();
        lazyWriter.written = 0;
    }
};
/**
 * @param {LazyStructWriter} lazyWriter
 * @param {Item | GC} struct
 * @param {number} offset
 */ const writeStructToLazyStructWriter = (lazyWriter, struct, offset)=>{
    // flush curr if we start another client
    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) flushLazyStructWriter(lazyWriter);
    if (lazyWriter.written === 0) {
        lazyWriter.currClient = struct.id.client;
        // write next client
        lazyWriter.encoder.writeClient(struct.id.client);
        // write startClock
        _encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
    }
    struct.write(lazyWriter.encoder, offset);
    lazyWriter.written++;
};
/**
 * Call this function when we collected all parts and want to
 * put all the parts together. After calling this method,
 * you can continue using the UpdateEncoder.
 *
 * @param {LazyStructWriter} lazyWriter
 */ const finishLazyStructWriting = (lazyWriter)=>{
    flushLazyStructWriter(lazyWriter);
    // this is a fresh encoder because we called flushCurr
    const restEncoder = lazyWriter.encoder.restEncoder;
    /**
   * Now we put all the fragments together.
   * This works similarly to `writeClientsStructs`
   */ // write # states that were updated - i.e. the clients
    _encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length);
    for(let i = 0; i < lazyWriter.clientStructs.length; i++){
        const partStructs = lazyWriter.clientStructs[i];
        /**
     * Works similarly to `writeStructs`
     */ // write # encoded structs
        _encoding.writeVarUint(restEncoder, partStructs.written);
        // write the rest of the fragment
        _encoding.writeUint8Array(restEncoder, partStructs.restEncoder);
    }
};
/**
 * @param {Uint8Array} update
 * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder
 * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder
 */ const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder)=>{
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    const updateEncoder = new YEncoder();
    const lazyWriter = new LazyStructWriter(updateEncoder);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
    finishLazyStructWriting(lazyWriter);
    const ds = readDeleteSet(updateDecoder);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @typedef {Object} ObfuscatorOptions
 * @property {boolean} [ObfuscatorOptions.formatting=true]
 * @property {boolean} [ObfuscatorOptions.subdocs=true]
 * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName
 */ /**
 * @param {ObfuscatorOptions} obfuscator
 */ const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {})=>{
    let i = 0;
    const mapKeyCache = _map.create();
    const nodeNameCache = _map.create();
    const formattingKeyCache = _map.create();
    const formattingValueCache = _map.create();
    formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range
    /**
   * @param {Item|GC|Skip} block
   * @return {Item|GC|Skip}
   */ return (block)=>{
        switch(block.constructor){
            case GC:
            case Skip:
                return block;
            case Item:
                {
                    const item = /** @type {Item} */ block;
                    const content = item.content;
                    switch(content.constructor){
                        case ContentDeleted:
                            break;
                        case ContentType:
                            if (yxml) {
                                const type = /** @type {ContentType} */ content.type;
                                if (type instanceof YXmlElement) type.nodeName = _map.setIfUndefined(nodeNameCache, type.nodeName, ()=>"node-" + i);
                                if (type instanceof YXmlHook) type.hookName = _map.setIfUndefined(nodeNameCache, type.hookName, ()=>"hook-" + i);
                            }
                            break;
                        case ContentAny:
                            {
                                const c = /** @type {ContentAny} */ content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentBinary:
                            {
                                const c = /** @type {ContentBinary} */ content;
                                c.content = new Uint8Array([
                                    i
                                ]);
                                break;
                            }
                        case ContentDoc:
                            {
                                const c = /** @type {ContentDoc} */ content;
                                if (subdocs) {
                                    c.opts = {};
                                    c.doc.guid = i + "";
                                }
                                break;
                            }
                        case ContentEmbed:
                            {
                                const c = /** @type {ContentEmbed} */ content;
                                c.embed = {};
                                break;
                            }
                        case ContentFormat:
                            {
                                const c = /** @type {ContentFormat} */ content;
                                if (formatting) {
                                    c.key = _map.setIfUndefined(formattingKeyCache, c.key, ()=>i + "");
                                    c.value = _map.setIfUndefined(formattingValueCache, c.value, ()=>({
                                            i
                                        }));
                                }
                                break;
                            }
                        case ContentJSON:
                            {
                                const c = /** @type {ContentJSON} */ content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentString:
                            {
                                const c = /** @type {ContentString} */ content;
                                c.str = _string.repeat(i % 10 + "", c.str.length);
                                break;
                            }
                        default:
                            // unknown content type
                            _error.unexpectedCase();
                    }
                    if (item.parentSub) item.parentSub = _map.setIfUndefined(mapKeyCache, item.parentSub, ()=>i + "");
                    i++;
                    return block;
                }
            default:
                // unknown block-type
                _error.unexpectedCase();
        }
    };
};
/**
 * This function obfuscates the content of a Yjs update. This is useful to share
 * buggy Yjs documents while significantly limiting the possibility that a
 * developer can on the user. Note that it might still be possible to deduce
 * some information by analyzing the "structure" of the document or by analyzing
 * the typing behavior using the CRDT-related metadata that is still kept fully
 * intact.
 *
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdate = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdateV2 = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV1ToV2 = (update)=>convertUpdateFormat(update, _function.id, UpdateDecoderV1, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV2ToV1 = (update)=>convertUpdateFormat(update, _function.id, UpdateDecoderV2, UpdateEncoderV1);
const errorComputeChanges = "You must not compute changes after the event-handler fired.";
/**
 * @template {AbstractType<any>} T
 * YEvent describes the changes on a YType.
 */ class YEvent {
    /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */ constructor(target, transaction){
        /**
     * The type on which this event was created on.
     * @type {T}
     */ this.target = target;
        /**
     * The current target on which the observe callback is called.
     * @type {AbstractType<any>}
     */ this.currentTarget = target;
        /**
     * The transaction that triggered this event.
     * @type {Transaction}
     */ this.transaction = transaction;
        /**
     * @type {Object|null}
     */ this._changes = null;
        /**
     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
     */ this._keys = null;
        /**
     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}
     */ this._delta = null;
        /**
     * @type {Array<string|number>|null}
     */ this._path = null;
    }
    /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */ get path() {
        return this._path || (this._path = getPathTo(this.currentTarget, this.target));
    }
    /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ deletes(struct) {
        return isDeleted(this.transaction.deleteSet, struct.id);
    }
    /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */ get keys() {
        if (this._keys === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) throw _error.create(errorComputeChanges);
            const keys = new Map();
            const target = this.target;
            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);
            changed.forEach((key)=>{
                if (key !== null) {
                    const item = /** @type {Item} */ target._map.get(key);
                    /**
           * @type {'delete' | 'add' | 'update'}
           */ let action;
                    let oldValue;
                    if (this.adds(item)) {
                        let prev = item.left;
                        while(prev !== null && this.adds(prev))prev = prev.left;
                        if (this.deletes(item)) {
                            if (prev !== null && this.deletes(prev)) {
                                action = "delete";
                                oldValue = _array.last(prev.content.getContent());
                            } else return;
                        } else if (prev !== null && this.deletes(prev)) {
                            action = "update";
                            oldValue = _array.last(prev.content.getContent());
                        } else {
                            action = "add";
                            oldValue = undefined;
                        }
                    } else {
                        if (this.deletes(item)) {
                            action = "delete";
                            oldValue = _array.last(/** @type {Item} */ item.content.getContent());
                        } else return; // nop
                    }
                    keys.set(key, {
                        action,
                        oldValue
                    });
                }
            });
            this._keys = keys;
        }
        return this._keys;
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */ get delta() {
        return this.changes.delta;
    }
    /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ adds(struct) {
        return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        let changes = this._changes;
        if (changes === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) throw _error.create(errorComputeChanges);
            const target = this.target;
            const added = _set.create();
            const deleted = _set.create();
            /**
       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}
       */ const delta = [];
            changes = {
                added,
                deleted,
                delta,
                keys: this.keys
            };
            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);
            if (changed.has(null)) {
                /**
         * @type {any}
         */ let lastOp = null;
                const packOp = ()=>{
                    if (lastOp) delta.push(lastOp);
                };
                for(let item = target._start; item !== null; item = item.right){
                    if (item.deleted) {
                        if (this.deletes(item) && !this.adds(item)) {
                            if (lastOp === null || lastOp.delete === undefined) {
                                packOp();
                                lastOp = {
                                    delete: 0
                                };
                            }
                            lastOp.delete += item.length;
                            deleted.add(item);
                        } // else nop
                    } else if (this.adds(item)) {
                        if (lastOp === null || lastOp.insert === undefined) {
                            packOp();
                            lastOp = {
                                insert: []
                            };
                        }
                        lastOp.insert = lastOp.insert.concat(item.content.getContent());
                        added.add(item);
                    } else {
                        if (lastOp === null || lastOp.retain === undefined) {
                            packOp();
                            lastOp = {
                                retain: 0
                            };
                        }
                        lastOp.retain += item.length;
                    }
                }
                if (lastOp !== null && lastOp.retain === undefined) packOp();
            }
            this._changes = changes;
        }
        return /** @type {any} */ changes;
    }
}
/**
 * Compute the path from this type to the specified target.
 *
 * @example
 *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`
 *   const path = type.getPathTo(child)
 *   // assuming `type instanceof YArray`
 *   console.log(path) // might look like => [2, 'key1']
 *   child === type.get(path[0]).get(path[1])
 *
 * @param {AbstractType<any>} parent
 * @param {AbstractType<any>} child target
 * @return {Array<string|number>} Path to the target
 *
 * @private
 * @function
 */ const getPathTo = (parent, child)=>{
    const path = [];
    while(child._item !== null && child !== parent){
        if (child._item.parentSub !== null) // parent is map-ish
        path.unshift(child._item.parentSub);
        else {
            // parent is array-ish
            let i = 0;
            let c = /** @type {AbstractType<any>} */ child._item.parent._start;
            while(c !== child._item && c !== null){
                if (!c.deleted) i++;
                c = c.right;
            }
            path.unshift(i);
        }
        child = /** @type {AbstractType<any>} */ child._item.parent;
    }
    return path;
};
const maxSearchMarker = 80;
/**
 * A unique timestamp that identifies each marker.
 *
 * Time is relative,.. this is more like an ever-increasing clock.
 *
 * @type {number}
 */ let globalSearchMarkerTimestamp = 0;
class ArraySearchMarker {
    /**
   * @param {Item} p
   * @param {number} index
   */ constructor(p, index){
        p.marker = true;
        this.p = p;
        this.index = index;
        this.timestamp = globalSearchMarkerTimestamp++;
    }
}
/**
 * @param {ArraySearchMarker} marker
 */ const refreshMarkerTimestamp = (marker)=>{
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * This is rather complex so this function is the only thing that should overwrite a marker
 *
 * @param {ArraySearchMarker} marker
 * @param {Item} p
 * @param {number} index
 */ const overwriteMarker = (marker, p, index)=>{
    marker.p.marker = false;
    marker.p = p;
    p.marker = true;
    marker.index = index;
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {Item} p
 * @param {number} index
 */ const markPosition = (searchMarker, p, index)=>{
    if (searchMarker.length >= maxSearchMarker) {
        // override oldest marker (we don't want to create more objects)
        const marker = searchMarker.reduce((a, b)=>a.timestamp < b.timestamp ? a : b);
        overwriteMarker(marker, p, index);
        return marker;
    } else {
        // create new marker
        const pm = new ArraySearchMarker(p, index);
        searchMarker.push(pm);
        return pm;
    }
};
/**
 * Search marker help us to find positions in the associative array faster.
 *
 * They speed up the process of finding a position without much bookkeeping.
 *
 * A maximum of `maxSearchMarker` objects are created.
 *
 * This function always returns a refreshed marker (updated timestamp)
 *
 * @param {AbstractType<any>} yarray
 * @param {number} index
 */ const findMarker = (yarray, index)=>{
    if (yarray._start === null || index === 0 || yarray._searchMarker === null) return null;
    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b)=>_math.abs(index - a.index) < _math.abs(index - b.index) ? a : b);
    let p = yarray._start;
    let pindex = 0;
    if (marker !== null) {
        p = marker.p;
        pindex = marker.index;
        refreshMarkerTimestamp(marker); // we used it, we might need to use it again
    }
    // iterate to right if possible
    while(p.right !== null && pindex < index){
        if (!p.deleted && p.countable) {
            if (index < pindex + p.length) break;
            pindex += p.length;
        }
        p = p.right;
    }
    // iterate to left if necessary (might be that pindex > index)
    while(p.left !== null && pindex > index){
        p = p.left;
        if (!p.deleted && p.countable) pindex -= p.length;
    }
    // we want to make sure that p can't be merged with left, because that would screw up everything
    // in that cas just return what we have (it is most likely the best marker anyway)
    // iterate to left until p can't be merged with left
    while(p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock){
        p = p.left;
        if (!p.deleted && p.countable) pindex -= p.length;
    }
    // @todo remove!
    // assure position
    // {
    //   let start = yarray._start
    //   let pos = 0
    //   while (start !== p) {
    //     if (!start.deleted && start.countable) {
    //       pos += start.length
    //     }
    //     start = /** @type {Item} */ (start.right)
    //   }
    //   if (pos !== pindex) {
    //     debugger
    //     throw new Error('Gotcha position fail!')
    //   }
    // }
    // if (marker) {
    //   if (window.lengthes == null) {
    //     window.lengthes = []
    //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)
    //   }
    //   window.lengthes.push(marker.index - pindex)
    //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)
    // }
    if (marker !== null && _math.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ p.parent.length / maxSearchMarker) {
        // adjust existing marker
        overwriteMarker(marker, p, pindex);
        return marker;
    } else // create new marker
    return markPosition(yarray._searchMarker, p, pindex);
};
/**
 * Update markers when a change happened.
 *
 * This should be called before doing a deletion!
 *
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {number} index
 * @param {number} len If insertion, len is positive. If deletion, len is negative.
 */ const updateMarkerChanges = (searchMarker, index, len)=>{
    for(let i = searchMarker.length - 1; i >= 0; i--){
        const m = searchMarker[i];
        if (len > 0) {
            /**
       * @type {Item|null}
       */ let p = m.p;
            p.marker = false;
            // Ideally we just want to do a simple position comparison, but this will only work if
            // search markers don't point to deleted items for formats.
            // Iterate marker to prev undeleted countable position so we know what to do when updating a position
            while(p && (p.deleted || !p.countable)){
                p = p.left;
                if (p && !p.deleted && p.countable) // adjust position. the loop should break now
                m.index -= p.length;
            }
            if (p === null || p.marker === true) {
                // remove search marker if updated position is null or if position is already marked
                searchMarker.splice(i, 1);
                continue;
            }
            m.p = p;
            p.marker = true;
        }
        if (index < m.index || len > 0 && index === m.index) m.index = _math.max(index, m.index + len);
    }
};
/**
 * Accumulate all (list) children of a type and return them as an Array.
 *
 * @param {AbstractType<any>} t
 * @return {Array<Item>}
 */ const getTypeChildren = (t)=>{
    let s = t._start;
    const arr = [];
    while(s){
        arr.push(s);
        s = s.right;
    }
    return arr;
};
/**
 * Call event listeners with an event. This will also add an event to all
 * parents (for `.observeDeep` handlers).
 *
 * @template EventType
 * @param {AbstractType<EventType>} type
 * @param {Transaction} transaction
 * @param {EventType} event
 */ const callTypeObservers = (type, transaction, event)=>{
    const changedType = type;
    const changedParentTypes = transaction.changedParentTypes;
    while(true){
        // @ts-ignore
        _map.setIfUndefined(changedParentTypes, type, ()=>[]).push(event);
        if (type._item === null) break;
        type = /** @type {AbstractType<any>} */ type._item.parent;
    }
    callEventHandlerListeners(changedType._eH, event, transaction);
};
/**
 * @template EventType
 * Abstract Yjs Type class
 */ class AbstractType {
    constructor(){
        /**
     * @type {Item|null}
     */ this._item = null;
        /**
     * @type {Map<string,Item>}
     */ this._map = new Map();
        /**
     * @type {Item|null}
     */ this._start = null;
        /**
     * @type {Doc|null}
     */ this.doc = null;
        this._length = 0;
        /**
     * Event handlers
     * @type {EventHandler<EventType,Transaction>}
     */ this._eH = createEventHandler();
        /**
     * Deep event handlers
     * @type {EventHandler<Array<YEvent<any>>,Transaction>}
     */ this._dEH = createEventHandler();
        /**
     * @type {null | Array<ArraySearchMarker>}
     */ this._searchMarker = null;
    }
    /**
   * @return {AbstractType<any>|null}
   */ get parent() {
        return this._item ? /** @type {AbstractType<any>} */ this._item.parent : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */ _integrate(y, item) {
        this.doc = y;
        this._item = item;
    }
    /**
   * @return {AbstractType<EventType>}
   */ _copy() {
        throw _error.methodUnimplemented();
    }
    /**
   * @return {AbstractType<EventType>}
   */ clone() {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */ _write(_encoder) {}
    /**
   * The first non-deleted item
   */ get _first() {
        let n = this._start;
        while(n !== null && n.deleted)n = n.right;
        return n;
    }
    /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, _parentSubs) {
        if (!transaction.local && this._searchMarker) this._searchMarker.length = 0;
    }
    /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */ observe(f) {
        addEventHandlerListener(this._eH, f);
    }
    /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ observeDeep(f) {
        addEventHandlerListener(this._dEH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */ unobserve(f) {
        removeEventHandlerListener(this._eH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ unobserveDeep(f) {
        removeEventHandlerListener(this._dEH, f);
    }
    /**
   * @abstract
   * @return {any}
   */ toJSON() {}
}
/**
 * @param {AbstractType<any>} type
 * @param {number} start
 * @param {number} end
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListSlice = (type, start, end)=>{
    if (start < 0) start = type._length + start;
    if (end < 0) end = type._length + end;
    let len = end - start;
    const cs = [];
    let n = type._start;
    while(n !== null && len > 0){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            if (c.length <= start) start -= c.length;
            else {
                for(let i = start; i < c.length && len > 0; i++){
                    cs.push(c[i]);
                    len--;
                }
                start = 0;
            }
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArray = (type)=>{
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)cs.push(c[i]);
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @param {Snapshot} snapshot
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArraySnapshot = (type, snapshot)=>{
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && isVisible(n, snapshot)) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)cs.push(c[i]);
        }
        n = n.right;
    }
    return cs;
};
/**
 * Executes a provided function on once on overy element of this YArray.
 *
 * @param {AbstractType<any>} type
 * @param {function(any,number,any):void} f A function to execute on every element of this YArray.
 *
 * @private
 * @function
 */ const typeListForEach = (type, f)=>{
    let index = 0;
    let n = type._start;
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)f(c[i], index++, type);
        }
        n = n.right;
    }
};
/**
 * @template C,R
 * @param {AbstractType<any>} type
 * @param {function(C,number,AbstractType<any>):R} f
 * @return {Array<R>}
 *
 * @private
 * @function
 */ const typeListMap = (type, f)=>{
    /**
   * @type {Array<any>}
   */ const result = [];
    typeListForEach(type, (c, i)=>{
        result.push(f(c, i, type));
    });
    return result;
};
/**
 * @param {AbstractType<any>} type
 * @return {IterableIterator<any>}
 *
 * @private
 * @function
 */ const typeListCreateIterator = (type)=>{
    let n = type._start;
    /**
   * @type {Array<any>|null}
   */ let currentContent = null;
    let currentContentIndex = 0;
    return {
        [Symbol.iterator] () {
            return this;
        },
        next: ()=>{
            // find some content
            if (currentContent === null) {
                while(n !== null && n.deleted)n = n.right;
                // check if we reached the end, no need to check currentContent, because it does not exist
                if (n === null) return {
                    done: true,
                    value: undefined
                };
                // we found n, so we can set currentContent
                currentContent = n.content.getContent();
                currentContentIndex = 0;
                n = n.right; // we used the content of n, now iterate to next
            }
            const value = currentContent[currentContentIndex++];
            // check if we need to empty currentContent
            if (currentContent.length <= currentContentIndex) currentContent = null;
            return {
                done: false,
                value
            };
        }
    };
};
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @return {any}
 *
 * @private
 * @function
 */ const typeListGet = (type, index)=>{
    const marker = findMarker(type, index);
    let n = type._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    for(; n !== null; n = n.right)if (!n.deleted && n.countable) {
        if (index < n.length) return n.content.getContent()[index];
        index -= n.length;
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Item?} referenceItem
 * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content)=>{
    let left = referenceItem;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const store = doc.store;
    const right = referenceItem === null ? parent._start : referenceItem.right;
    /**
   * @type {Array<Object|Array<any>|number|null>}
   */ let jsonContent = [];
    const packJsonContent = ()=>{
        if (jsonContent.length > 0) {
            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
            left.integrate(transaction, 0);
            jsonContent = [];
        }
    };
    content.forEach((c)=>{
        if (c === null) jsonContent.push(c);
        else switch(c.constructor){
            case Number:
            case Object:
            case Boolean:
            case Array:
            case String:
                jsonContent.push(c);
                break;
            default:
                packJsonContent();
                switch(c.constructor){
                    case Uint8Array:
                    case ArrayBuffer:
                        left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ c)));
                        left.integrate(transaction, 0);
                        break;
                    case Doc:
                        left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ c));
                        left.integrate(transaction, 0);
                        break;
                    default:
                        if (c instanceof AbstractType) {
                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                            left.integrate(transaction, 0);
                        } else throw new Error("Unexpected content type in insert operation");
                }
        }
    });
    packJsonContent();
};
const lengthExceeded = ()=>_error.create("Length exceeded!");
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenerics = (transaction, parent, index, content)=>{
    if (index > parent._length) throw lengthExceeded();
    if (index === 0) {
        if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, index, content.length);
        return typeListInsertGenericsAfter(transaction, parent, null, content);
    }
    const startIndex = index;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
        // we need to iterate one to the left so that the algorithm works
        if (index === 0) {
            // @todo refactor this as it actually doesn't consider formats
            n = n.prev; // important! get the left undeleted item so that we can actually decrease index
            index += n && n.countable && !n.deleted ? n.length : 0;
        }
    }
    for(; n !== null; n = n.right)if (!n.deleted && n.countable) {
        if (index <= n.length) {
            if (index < n.length) // insert in-between
            getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
            break;
        }
        index -= n.length;
    }
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, startIndex, content.length);
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * Pushing content is special as we generally want to push after the last item. So we don't have to update
 * the serach marker.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListPushGenerics = (transaction, parent, content)=>{
    // Use the marker with the highest index and iterate to the right.
    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker)=>currMarker.index > maxMarker.index ? currMarker : maxMarker, {
        index: 0,
        p: parent._start
    });
    let n = marker.p;
    if (n) while(n.right)n = n.right;
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {number} length
 *
 * @private
 * @function
 */ const typeListDelete = (transaction, parent, index, length)=>{
    if (length === 0) return;
    const startIndex = index;
    const startLength = length;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    // compute the first item to be deleted
    for(; n !== null && index > 0; n = n.right)if (!n.deleted && n.countable) {
        if (index < n.length) getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        index -= n.length;
    }
    // delete all items until done
    while(length > 0 && n !== null){
        if (!n.deleted) {
            if (length < n.length) getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));
            n.delete(transaction);
            length -= n.length;
        }
        n = n.right;
    }
    if (length > 0) throw lengthExceeded();
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */ );
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 *
 * @private
 * @function
 */ const typeMapDelete = (transaction, parent, key)=>{
    const c = parent._map.get(key);
    if (c !== undefined) c.delete(transaction);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value
 *
 * @private
 * @function
 */ const typeMapSet = (transaction, parent, key, value)=>{
    const left = parent._map.get(key) || null;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    let content;
    if (value == null) content = new ContentAny([
        value
    ]);
    else switch(value.constructor){
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
            content = new ContentAny([
                value
            ]);
            break;
        case Uint8Array:
            content = new ContentBinary(/** @type {Uint8Array} */ value);
            break;
        case Doc:
            content = new ContentDoc(/** @type {Doc} */ value);
            break;
        default:
            if (value instanceof AbstractType) content = new ContentType(value);
            else throw new Error("Unexpected content type");
    }
    new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGet = (parent, key)=>{
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;
};
/**
 * @param {AbstractType<any>} parent
 * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
 *
 * @private
 * @function
 */ const typeMapGetAll = (parent)=>{
    /**
   * @type {Object<string,any>}
   */ const res = {};
    parent._map.forEach((value, key)=>{
        if (!value.deleted) res[key] = value.content.getContent()[value.length - 1];
    });
    return res;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {boolean}
 *
 * @private
 * @function
 */ const typeMapHas = (parent, key)=>{
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Snapshot} snapshot
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGetSnapshot = (parent, key, snapshot)=>{
    let v = parent._map.get(key) || null;
    while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0)))v = v.left;
    return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined;
};
/**
 * @param {AbstractType<any>} parent
 * @param {Snapshot} snapshot
 * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
 *
 * @private
 * @function
 */ const typeMapGetAllSnapshot = (parent, snapshot)=>{
    /**
   * @type {Object<string,any>}
   */ const res = {};
    parent._map.forEach((value, key)=>{
        /**
     * @type {Item|null}
     */ let v = value;
        while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0)))v = v.left;
        if (v !== null && isVisible(v, snapshot)) res[key] = v.content.getContent()[v.length - 1];
    });
    return res;
};
/**
 * @param {Map<string,Item>} map
 * @return {IterableIterator<Array<any>>}
 *
 * @private
 * @function
 */ const createMapIterator = (map)=>_iterator.iteratorFilter(map.entries(), /** @param {any} entry */ (entry)=>!entry[1].deleted);
/**
 * @module YArray
 */ /**
 * Event that describes the changes on a YArray
 * @template T
 * @extends YEvent<YArray<T>>
 */ class YArrayEvent extends YEvent {
    /**
   * @param {YArray<T>} yarray The changed type
   * @param {Transaction} transaction The transaction object
   */ constructor(yarray, transaction){
        super(yarray, transaction);
        this._transaction = transaction;
    }
}
/**
 * A shared Array implementation.
 * @template T
 * @extends AbstractType<YArrayEvent<T>>
 * @implements {Iterable<T>}
 */ class YArray extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>?}
     * @private
     */ this._prelimContent = [];
        /**
     * @type {Array<ArraySearchMarker>}
     */ this._searchMarker = [];
    }
    /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */ static from(items) {
        /**
     * @type {YArray<T>}
     */ const a = new YArray();
        a.push(items);
        return a;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, /** @type {Array<any>} */ this._prelimContent);
        this._prelimContent = null;
    }
    /**
   * @return {YArray<T>}
   */ _copy() {
        return new YArray();
    }
    /**
   * @return {YArray<T>}
   */ clone() {
        /**
     * @type {YArray<T>}
     */ const arr = new YArray();
        arr.insert(0, this.toArray().map((el)=>el instanceof AbstractType ? /** @type {typeof el} */ el.clone() : el));
        return arr;
    }
    get length() {
        return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
    }
    /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListInsertGenerics(transaction, this, index, /** @type {any} */ content);
        });
        else /** @type {Array<any>} */ this._prelimContent.splice(index, 0, ...content);
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */ push(content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListPushGenerics(transaction, this, /** @type {any} */ content);
        });
        else /** @type {Array<any>} */ this._prelimContent.push(...content);
    }
    /**
   * Preppends content to this YArray.
   *
   * @param {Array<T>} content Array of content to preppend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListDelete(transaction, this, index, length);
        });
        else /** @type {Array<any>} */ this._prelimContent.splice(index, length);
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */ toJSON() {
        return this.map((c)=>c instanceof AbstractType ? c.toJSON() : c);
    }
    /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */ map(f) {
        return typeListMap(this, /** @type {any} */ f);
    }
    /**
   * Executes a provided function once on overy element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator]() {
        return typeListCreateIterator(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YArrayRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYArray = (_decoder)=>new YArray();
/**
 * @module YMap
 */ /**
 * @template T
 * @extends YEvent<YMap<T>>
 * Event that describes the changes on a YMap.
 */ class YMapEvent extends YEvent {
    /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */ constructor(ymap, transaction, subs){
        super(ymap, transaction);
        this.keysChanged = subs;
    }
}
/**
 * @template MapType
 * A shared Map implementation.
 *
 * @extends AbstractType<YMapEvent<MapType>>
 * @implements {Iterable<[string, MapType]>}
 */ class YMap extends AbstractType {
    /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */ constructor(entries){
        super();
        /**
     * @type {Map<string,any>?}
     * @private
     */ this._prelimContent = null;
        if (entries === undefined) this._prelimContent = new Map();
        else this._prelimContent = new Map(entries);
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item); /** @type {Map<string, any>} */ 
        this._prelimContent.forEach((value, key)=>{
            this.set(key, value);
        });
        this._prelimContent = null;
    }
    /**
   * @return {YMap<MapType>}
   */ _copy() {
        return new YMap();
    }
    /**
   * @return {YMap<MapType>}
   */ clone() {
        /**
     * @type {YMap<MapType>}
     */ const map = new YMap();
        this.forEach((value, key)=>{
            map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ value.clone() : value);
        });
        return map;
    }
    /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */ toJSON() {
        /**
     * @type {Object<string,MapType>}
     */ const map = {};
        this._map.forEach((item, key)=>{
            if (!item.deleted) {
                const v = item.content.getContent()[item.length - 1];
                map[key] = v instanceof AbstractType ? v.toJSON() : v;
            }
        });
        return map;
    }
    /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */ get size() {
        return [
            ...createMapIterator(this._map)
        ].length;
    }
    /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */ keys() {
        return _iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>v[0]);
    }
    /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */ values() {
        return _iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>v[1].content.getContent()[v[1].length - 1]);
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */ entries() {
        return _iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ (v)=>/** @type {any} */ [
                v[0],
                v[1].content.getContent()[v[1].length - 1]
            ]);
    }
    /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        this._map.forEach((item, key)=>{
            if (!item.deleted) f(item.content.getContent()[item.length - 1], key, this);
        });
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */ delete(key) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, key);
        });
        else /** @type {Map<string, any>} */ this._prelimContent.delete(key);
    }
    /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */ set(key, value) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, key, /** @type {any} */ value);
        });
        else /** @type {Map<string, any>} */ this._prelimContent.set(key, value);
        return value;
    }
    /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */ get(key) {
        return /** @type {any} */ typeMapGet(this, key);
    }
    /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */ has(key) {
        return typeMapHas(this, key);
    }
    /**
   * Removes all elements from this YMap.
   */ clear() {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            this.forEach(function(_value, key, map) {
                typeMapDelete(transaction, map, key);
            });
        });
        else /** @type {Map<string, any>} */ this._prelimContent.clear();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YMapRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYMap = (_decoder)=>new YMap();
/**
 * @module YText
 */ /**
 * @param {any} a
 * @param {any} b
 * @return {boolean}
 */ const equalAttrs = (a, b)=>a === b || typeof a === "object" && typeof b === "object" && a && b && _object.equalFlat(a, b);
class ItemTextListPosition {
    /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */ constructor(left, right, index, currentAttributes){
        this.left = left;
        this.right = right;
        this.index = index;
        this.currentAttributes = currentAttributes;
    }
    /**
   * Only call this if you know that this.right is defined
   */ forward() {
        if (this.right === null) _error.unexpectedCase();
        switch(this.right.content.constructor){
            case ContentFormat:
                if (!this.right.deleted) updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ this.right.content);
                break;
            default:
                if (!this.right.deleted) this.index += this.right.length;
                break;
        }
        this.left = this.right;
        this.right = this.right.right;
    }
}
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} pos
 * @param {number} count steps to move forward
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findNextPosition = (transaction, pos, count)=>{
    while(pos.right !== null && count > 0){
        switch(pos.right.content.constructor){
            case ContentFormat:
                if (!pos.right.deleted) updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ pos.right.content);
                break;
            default:
                if (!pos.right.deleted) {
                    if (count < pos.right.length) // split right
                    getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
                    pos.index += pos.right.length;
                    count -= pos.right.length;
                }
                break;
        }
        pos.left = pos.right;
        pos.right = pos.right.right;
    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above
    }
    return pos;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {boolean} useSearchMarker
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findPosition = (transaction, parent, index, useSearchMarker)=>{
    const currentAttributes = new Map();
    const marker = useSearchMarker ? findMarker(parent, index) : null;
    if (marker) {
        const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
        return findNextPosition(transaction, pos, index - marker.index);
    } else {
        const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
        return findNextPosition(transaction, pos, index);
    }
};
/**
 * Negate applied formats
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Map<string,any>} negatedAttributes
 *
 * @private
 * @function
 */ const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes)=>{
    // check if we really need to remove attributes
    while(currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ currPos.right.content.key), /** @type {ContentFormat} */ currPos.right.content.value))){
        if (!currPos.right.deleted) negatedAttributes.delete(/** @type {ContentFormat} */ currPos.right.content.key);
        currPos.forward();
    }
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    negatedAttributes.forEach((val, key)=>{
        const left = currPos.left;
        const right = currPos.right;
        const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
        nextFormat.integrate(transaction, 0);
        currPos.right = nextFormat;
        currPos.forward();
    });
};
/**
 * @param {Map<string,any>} currentAttributes
 * @param {ContentFormat} format
 *
 * @private
 * @function
 */ const updateCurrentAttributes = (currentAttributes, format)=>{
    const { key, value } = format;
    if (value === null) currentAttributes.delete(key);
    else currentAttributes.set(key, value);
};
/**
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const minimizeAttributeChanges = (currPos, attributes)=>{
    // go right while attributes[right.key] === right.value (or right is deleted)
    while(true){
        if (currPos.right === null) break;
        else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[/** @type {ContentFormat} */ currPos.right.content.key] || null, /** @type {ContentFormat} */ currPos.right.content.value)) ;
        else break;
        currPos.forward();
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 * @return {Map<string,any>}
 *
 * @private
 * @function
 **/ const insertAttributes = (transaction, parent, currPos, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const negatedAttributes = new Map();
    // insert format-start items
    for(const key in attributes){
        const val = attributes[key];
        const currentVal = currPos.currentAttributes.get(key) || null;
        if (!equalAttrs(currentVal, val)) {
            // save negated attribute (set null if currentVal undefined)
            negatedAttributes.set(key, currentVal);
            const { left, right } = currPos;
            currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
            currPos.right.integrate(transaction, 0);
            currPos.forward();
        }
    }
    return negatedAttributes;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {string|object|AbstractType<any>} text
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 **/ const insertText = (transaction, parent, currPos, text, attributes)=>{
    currPos.currentAttributes.forEach((_val, key)=>{
        if (attributes[key] === undefined) attributes[key] = null;
    });
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // insert content
    const content = text.constructor === String ? new ContentString(/** @type {string} */ text) : text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text);
    let { left, right, index } = currPos;
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
    right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
    right.integrate(transaction, 0);
    currPos.right = right;
    currPos.index = index;
    currPos.forward();
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const formatText = (transaction, parent, currPos, length, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // iterate until first non-format or null is found
    // delete all formats with attributes[format.key] != null
    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there
    // eslint-disable-next-line no-labels
    iterationLoop: while(currPos.right !== null && (length > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))){
        if (!currPos.right.deleted) switch(currPos.right.content.constructor){
            case ContentFormat:
                {
                    const { key, value } = /** @type {ContentFormat} */ currPos.right.content;
                    const attr = attributes[key];
                    if (attr !== undefined) {
                        if (equalAttrs(attr, value)) negatedAttributes.delete(key);
                        else {
                            if (length === 0) break iterationLoop;
                            negatedAttributes.set(key, value);
                        }
                        currPos.right.delete(transaction);
                    } else currPos.currentAttributes.set(key, value);
                    break;
                }
            default:
                if (length < currPos.right.length) getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                length -= currPos.right.length;
                break;
        }
        currPos.forward();
    }
    // Quill just assumes that the editor starts with a newline and that it always
    // ends with a newline. We only insert that newline when a new newline is
    // inserted - i.e when length is bigger than type.length
    if (length > 0) {
        let newlines = "";
        for(; length > 0; length--)newlines += "\n";
        currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
        currPos.right.integrate(transaction, 0);
        currPos.forward();
    }
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * Call this function after string content has been deleted in order to
 * clean up formatting Items.
 *
 * @param {Transaction} transaction
 * @param {Item} start
 * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item
 * @param {Map<string,any>} startAttributes
 * @param {Map<string,any>} currAttributes
 * @return {number} The amount of formatting Items deleted.
 *
 * @function
 */ const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes)=>{
    /**
   * @type {Item|null}
   */ let end = start;
    /**
   * @type {Map<string,ContentFormat>}
   */ const endFormats = _map.create();
    while(end && (!end.countable || end.deleted)){
        if (!end.deleted && end.content.constructor === ContentFormat) {
            const cf = /** @type {ContentFormat} */ end.content;
            endFormats.set(cf.key, cf);
        }
        end = end.right;
    }
    let cleanups = 0;
    let reachedCurr = false;
    while(start !== end){
        if (curr === start) reachedCurr = true;
        if (!start.deleted) {
            const content = start.content;
            switch(content.constructor){
                case ContentFormat:
                    {
                        const { key, value } = /** @type {ContentFormat} */ content;
                        const startAttrValue = startAttributes.get(key) || null;
                        if (endFormats.get(key) !== content || startAttrValue === value) {
                            // Either this format is overwritten or it is not necessary because the attribute already existed.
                            start.delete(transaction);
                            cleanups++;
                            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {
                                if (startAttrValue === null) currAttributes.delete(key);
                                else currAttributes.set(key, startAttrValue);
                            }
                        }
                        if (!reachedCurr && !start.deleted) updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ content);
                        break;
                    }
            }
        }
        start = /** @type {Item} */ start.right;
    }
    return cleanups;
};
/**
 * @param {Transaction} transaction
 * @param {Item | null} item
 */ const cleanupContextlessFormattingGap = (transaction, item)=>{
    // iterate until item.right is null or content
    while(item && item.right && (item.right.deleted || !item.right.countable))item = item.right;
    const attrs = new Set();
    // iterate back until a content item is found
    while(item && (item.deleted || !item.countable)){
        if (!item.deleted && item.content.constructor === ContentFormat) {
            const key = /** @type {ContentFormat} */ item.content.key;
            if (attrs.has(key)) item.delete(transaction);
            else attrs.add(key);
        }
        item = item.left;
    }
};
/**
 * This function is experimental and subject to change / be removed.
 *
 * Ideally, we don't need this function at all. Formatting attributes should be cleaned up
 * automatically after each change. This function iterates twice over the complete YText type
 * and removes unnecessary formatting attributes. This is also helpful for testing.
 *
 * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.
 *
 * @param {YText} type
 * @return {number} How many formatting attributes have been cleaned up.
 */ const cleanupYTextFormatting = (type)=>{
    let res = 0;
    transact(/** @type {Doc} */ type.doc, (transaction)=>{
        let start = /** @type {Item} */ type._start;
        let end = type._start;
        let startAttributes = _map.create();
        const currentAttributes = _map.copy(startAttributes);
        while(end){
            if (end.deleted === false) switch(end.content.constructor){
                case ContentFormat:
                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ end.content);
                    break;
                default:
                    res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
                    startAttributes = _map.copy(currentAttributes);
                    start = end;
                    break;
            }
            end = end.right;
        }
    });
    return res;
};
/**
 * This will be called by the transction once the event handlers are called to potentially cleanup
 * formatting attributes.
 *
 * @param {Transaction} transaction
 */ const cleanupYTextAfterTransaction = (transaction)=>{
    /**
   * @type {Set<YText>}
   */ const needFullCleanup = new Set();
    // check if another formatting item was inserted
    const doc = transaction.doc;
    for (const [client, afterClock] of transaction.afterState.entries()){
        const clock = transaction.beforeState.get(client) || 0;
        if (afterClock === clock) continue;
        iterateStructs(transaction, /** @type {Array<Item|GC>} */ doc.store.clients.get(client), clock, afterClock, (item)=>{
            if (!item.deleted && /** @type {Item} */ item.content.constructor === ContentFormat && item.constructor !== GC) needFullCleanup.add(/** @type {any} */ item.parent);
        });
    }
    // cleanup in a new transaction
    transact(doc, (t)=>{
        iterateDeletedStructs(transaction, transaction.deleteSet, (item)=>{
            if (item instanceof GC || !/** @type {YText} */ item.parent._hasFormatting || needFullCleanup.has(/** @type {YText} */ item.parent)) return;
            const parent = /** @type {YText} */ item.parent;
            if (item.content.constructor === ContentFormat) needFullCleanup.add(parent);
            else // If no formatting attribute was inserted or deleted, we can make due with contextless
            // formatting cleanups.
            // Contextless: it is not necessary to compute currentAttributes for the affected position.
            cleanupContextlessFormattingGap(t, item);
        });
        // If a formatting item was inserted, we simply clean the whole type.
        // We need to compute currentAttributes for the current position anyway.
        for (const yText of needFullCleanup)cleanupYTextFormatting(yText);
    });
};
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const deleteText = (transaction, currPos, length)=>{
    const startLength = length;
    const startAttrs = _map.copy(currPos.currentAttributes);
    const start = currPos.right;
    while(length > 0 && currPos.right !== null){
        if (currPos.right.deleted === false) switch(currPos.right.content.constructor){
            case ContentType:
            case ContentEmbed:
            case ContentString:
                if (length < currPos.right.length) getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                length -= currPos.right.length;
                currPos.right.delete(transaction);
                break;
        }
        currPos.forward();
    }
    if (start) cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
    const parent = /** @type {AbstractType<any>} */ /** @type {Item} */ (currPos.left || currPos.right).parent;
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);
    return currPos;
};
/**
 * The Quill Delta format represents changes on a text document with
 * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
 *
 * @example
 *   {
 *     ops: [
 *       { insert: 'Gandalf', attributes: { bold: true } },
 *       { insert: ' the ' },
 *       { insert: 'Grey', attributes: { color: '#cccccc' } }
 *     ]
 *   }
 *
 */ /**
  * Attributes that can be assigned to a selection of text.
  *
  * @example
  *   {
  *     bold: true,
  *     font-size: '40px'
  *   }
  *
  * @typedef {Object} TextAttributes
  */ /**
 * @extends YEvent<YText>
 * Event that describes the changes on a YText type.
 */ class YTextEvent extends YEvent {
    /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */ constructor(ytext, transaction, subs){
        super(ytext, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.keysChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) this.childListChanged = true;
            else this.keysChanged.add(sub);
        });
    }
    /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        if (this._changes === null) {
            /**
       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}
       */ const changes = {
                keys: this.keys,
                delta: this.delta,
                added: new Set(),
                deleted: new Set()
            };
            this._changes = changes;
        }
        return /** @type {any} */ this._changes;
    }
    /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */ get delta() {
        if (this._delta === null) {
            const y = /** @type {Doc} */ this.target.doc;
            /**
       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
       */ const delta = [];
            transact(y, (transaction)=>{
                const currentAttributes = new Map(); // saves all current attributes for insert
                const oldAttributes = new Map();
                let item = this.target._start;
                /**
         * @type {string?}
         */ let action = null;
                /**
         * @type {Object<string,any>}
         */ const attributes = {}; // counts added or removed new attributes for retain
                /**
         * @type {string|object}
         */ let insert = "";
                let retain = 0;
                let deleteLen = 0;
                const addOp = ()=>{
                    if (action !== null) {
                        /**
             * @type {any}
             */ let op = null;
                        switch(action){
                            case "delete":
                                if (deleteLen > 0) op = {
                                    delete: deleteLen
                                };
                                deleteLen = 0;
                                break;
                            case "insert":
                                if (typeof insert === "object" || insert.length > 0) {
                                    op = {
                                        insert
                                    };
                                    if (currentAttributes.size > 0) {
                                        op.attributes = {};
                                        currentAttributes.forEach((value, key)=>{
                                            if (value !== null) op.attributes[key] = value;
                                        });
                                    }
                                }
                                insert = "";
                                break;
                            case "retain":
                                if (retain > 0) {
                                    op = {
                                        retain
                                    };
                                    if (!_object.isEmpty(attributes)) op.attributes = _object.assign({}, attributes);
                                }
                                retain = 0;
                                break;
                        }
                        if (op) delta.push(op);
                        action = null;
                    }
                };
                while(item !== null){
                    switch(item.content.constructor){
                        case ContentType:
                        case ContentEmbed:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    addOp();
                                    action = "insert";
                                    insert = item.content.getContent()[0];
                                    addOp();
                                }
                            } else if (this.deletes(item)) {
                                if (action !== "delete") {
                                    addOp();
                                    action = "delete";
                                }
                                deleteLen += 1;
                            } else if (!item.deleted) {
                                if (action !== "retain") {
                                    addOp();
                                    action = "retain";
                                }
                                retain += 1;
                            }
                            break;
                        case ContentString:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    if (action !== "insert") {
                                        addOp();
                                        action = "insert";
                                    }
                                    insert += /** @type {ContentString} */ item.content.str;
                                }
                            } else if (this.deletes(item)) {
                                if (action !== "delete") {
                                    addOp();
                                    action = "delete";
                                }
                                deleteLen += item.length;
                            } else if (!item.deleted) {
                                if (action !== "retain") {
                                    addOp();
                                    action = "retain";
                                }
                                retain += item.length;
                            }
                            break;
                        case ContentFormat:
                            {
                                const { key, value } = /** @type {ContentFormat} */ item.content;
                                if (this.adds(item)) {
                                    if (!this.deletes(item)) {
                                        const curVal = currentAttributes.get(key) || null;
                                        if (!equalAttrs(curVal, value)) {
                                            if (action === "retain") addOp();
                                            if (equalAttrs(value, oldAttributes.get(key) || null)) delete attributes[key];
                                            else attributes[key] = value;
                                        } else if (value !== null) item.delete(transaction);
                                    }
                                } else if (this.deletes(item)) {
                                    oldAttributes.set(key, value);
                                    const curVal = currentAttributes.get(key) || null;
                                    if (!equalAttrs(curVal, value)) {
                                        if (action === "retain") addOp();
                                        attributes[key] = curVal;
                                    }
                                } else if (!item.deleted) {
                                    oldAttributes.set(key, value);
                                    const attr = attributes[key];
                                    if (attr !== undefined) {
                                        if (!equalAttrs(attr, value)) {
                                            if (action === "retain") addOp();
                                            if (value === null) delete attributes[key];
                                            else attributes[key] = value;
                                        } else if (attr !== null) item.delete(transaction);
                                    }
                                }
                                if (!item.deleted) {
                                    if (action === "insert") addOp();
                                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ item.content);
                                }
                                break;
                            }
                    }
                    item = item.right;
                }
                addOp();
                while(delta.length > 0){
                    const lastOp = delta[delta.length - 1];
                    if (lastOp.retain !== undefined && lastOp.attributes === undefined) // retain delta's if they don't assign attributes
                    delta.pop();
                    else break;
                }
            });
            this._delta = delta;
        }
        return /** @type {any} */ this._delta;
    }
}
/**
 * Type that represents text with formatting information.
 *
 * This type replaces y-richtext as this implementation is able to handle
 * block formats (format information on a paragraph), embeds (complex elements
 * like pictures and videos), and text formats (**bold**, *italic*).
 *
 * @extends AbstractType<YTextEvent>
 */ class YText extends AbstractType {
    /**
   * @param {String} [string] The initial value of the YText.
   */ constructor(string){
        super();
        /**
     * Array of pending operations on this type
     * @type {Array<function():void>?}
     */ this._pending = string !== undefined ? [
            ()=>this.insert(0, string)
        ] : [];
        /**
     * @type {Array<ArraySearchMarker>|null}
     */ this._searchMarker = [];
        /**
     * Whether this YText contains formatting attributes.
     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)
     */ this._hasFormatting = false;
    }
    /**
   * Number of characters of this text type.
   *
   * @type {number}
   */ get length() {
        return this._length;
    }
    /**
   * @param {Doc} y
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        try {
            /** @type {Array<function>} */ this._pending.forEach((f)=>f());
        } catch (e) {
            console.error(e);
        }
        this._pending = null;
    }
    _copy() {
        return new YText();
    }
    /**
   * @return {YText}
   */ clone() {
        const text = new YText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        const event = new YTextEvent(this, transaction, parentSubs);
        callTypeObservers(this, transaction, event);
        // If a remote change happened, we try to cleanup potential formatting duplicates.
        if (!transaction.local && this._hasFormatting) transaction._needFormattingCleanup = true;
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */ toString() {
        let str = "";
        /**
     * @type {Item|null}
     */ let n = this._start;
        while(n !== null){
            if (!n.deleted && n.countable && n.content.constructor === ContentString) str += /** @type {ContentString} */ n.content.str;
            n = n.right;
        }
        return str;
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */ toJSON() {
        return this.toString();
    }
    /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */ applyDelta(delta, { sanitize = true } = {}) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            const currPos = new ItemTextListPosition(null, this._start, 0, new Map());
            for(let i = 0; i < delta.length; i++){
                const op = delta[i];
                if (op.insert !== undefined) {
                    // Quill assumes that the content starts with an empty paragraph.
                    // Yjs/Y.Text assumes that it starts empty. We always hide that
                    // there is a newline at the end of the content.
                    // If we omit this step, clients will see a different number of
                    // paragraphs, but nothing bad will happen.
                    const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
                    if (typeof ins !== "string" || ins.length > 0) insertText(transaction, this, currPos, ins, op.attributes || {});
                } else if (op.retain !== undefined) formatText(transaction, this, currPos, op.retain, op.attributes || {});
                else if (op.delete !== undefined) deleteText(transaction, currPos, op.delete);
            }
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.applyDelta(delta));
    }
    /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */ toDelta(snapshot, prevSnapshot, computeYChange) {
        /**
     * @type{Array<any>}
     */ const ops = [];
        const currentAttributes = new Map();
        const doc = /** @type {Doc} */ this.doc;
        let str = "";
        let n = this._start;
        function packStr() {
            if (str.length > 0) {
                // pack str with attributes to ops
                /**
         * @type {Object<string,any>}
         */ const attributes = {};
                let addAttributes = false;
                currentAttributes.forEach((value, key)=>{
                    addAttributes = true;
                    attributes[key] = value;
                });
                /**
         * @type {Object<string,any>}
         */ const op = {
                    insert: str
                };
                if (addAttributes) op.attributes = attributes;
                ops.push(op);
                str = "";
            }
        }
        const computeDelta = ()=>{
            while(n !== null){
                if (isVisible(n, snapshot) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) switch(n.content.constructor){
                    case ContentString:
                        {
                            const cur = currentAttributes.get("ychange");
                            if (snapshot !== undefined && !isVisible(n, snapshot)) {
                                if (cur === undefined || cur.user !== n.id.client || cur.type !== "removed") {
                                    packStr();
                                    currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : {
                                        type: "removed"
                                    });
                                }
                            } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {
                                if (cur === undefined || cur.user !== n.id.client || cur.type !== "added") {
                                    packStr();
                                    currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : {
                                        type: "added"
                                    });
                                }
                            } else if (cur !== undefined) {
                                packStr();
                                currentAttributes.delete("ychange");
                            }
                            str += /** @type {ContentString} */ n.content.str;
                            break;
                        }
                    case ContentType:
                    case ContentEmbed:
                        {
                            packStr();
                            /**
               * @type {Object<string,any>}
               */ const op = {
                                insert: n.content.getContent()[0]
                            };
                            if (currentAttributes.size > 0) {
                                const attrs = /** @type {Object<string,any>} */ {};
                                op.attributes = attrs;
                                currentAttributes.forEach((value, key)=>{
                                    attrs[key] = value;
                                });
                            }
                            ops.push(op);
                            break;
                        }
                    case ContentFormat:
                        if (isVisible(n, snapshot)) {
                            packStr();
                            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ n.content);
                        }
                        break;
                }
                n = n.right;
            }
            packStr();
        };
        if (snapshot || prevSnapshot) // snapshots are merged again after the transaction, so we need to keep the
        // transaction alive until we are done
        transact(doc, (transaction)=>{
            if (snapshot) splitSnapshotAffectedStructs(transaction, snapshot);
            if (prevSnapshot) splitSnapshotAffectedStructs(transaction, prevSnapshot);
            computeDelta();
        }, "cleanup");
        else computeDelta();
        return ops;
    }
    /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */ insert(index, text, attributes) {
        if (text.length <= 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index, !attributes);
            if (!attributes) {
                attributes = {};
                // @ts-ignore
                pos.currentAttributes.forEach((v, k)=>{
                    attributes[k] = v;
                });
            }
            insertText(transaction, this, pos, text, attributes);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.insert(index, text, attributes));
    }
    /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */ insertEmbed(index, embed, attributes) {
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index, !attributes);
            insertText(transaction, this, pos, embed, attributes || {});
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.insertEmbed(index, embed, attributes || {}));
    }
    /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */ delete(index, length) {
        if (length === 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            deleteText(transaction, findPosition(transaction, this, index, true), length);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.delete(index, length));
    }
    /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */ format(index, length, attributes) {
        if (length === 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index, false);
            if (pos.right === null) return;
            formatText(transaction, this, pos, length, attributes);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.format(index, length, attributes));
    }
    /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, attributeName);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.removeAttribute(attributeName));
    }
    /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, attributeName, attributeValue);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.setAttribute(attributeName, attributeValue));
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return /** @type {any} */ typeMapGet(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes() {
        return typeMapGetAll(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YText}
 *
 * @private
 * @function
 */ const readYText = (_decoder)=>new YText();
/**
 * @module YXml
 */ /**
 * Define the elements to which a set of CSS queries apply.
 * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
 *
 * @example
 *   query = '.classSelector'
 *   query = 'nodeSelector'
 *   query = '#idSelector'
 *
 * @typedef {string} CSS_Selector
 */ /**
 * Dom filter function.
 *
 * @callback domFilter
 * @param {string} nodeName The nodeName of the element
 * @param {Map} attributes The map of attributes.
 * @return {boolean} Whether to include the Dom node in the YXmlElement.
 */ /**
 * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
 * position within them.
 *
 * Can be created with {@link YXmlFragment#createTreeWalker}
 *
 * @public
 * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}
 */ class YXmlTreeWalker {
    /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */ constructor(root, f = ()=>true){
        this._filter = f;
        this._root = root;
        /**
     * @type {Item}
     */ this._currentNode = /** @type {Item} */ root._start;
        this._firstCall = true;
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */ next() {
        /**
     * @type {Item|null}
     */ let n = this._currentNode;
        let type = n && n.content && /** @type {any} */ n.content.type;
        if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) do {
            type = /** @type {any} */ n.content.type;
            if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) // walk down in the tree
            n = type._start;
            else // walk right or up in the tree
            while(n !== null){
                if (n.right !== null) {
                    n = n.right;
                    break;
                } else if (n.parent === this._root) n = null;
                else n = /** @type {AbstractType<any>} */ n.parent._item;
            }
        }while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ n.content.type)));
        this._firstCall = false;
        if (n === null) // @ts-ignore
        return {
            value: undefined,
            done: true
        };
        this._currentNode = n;
        return {
            value: /** @type {any} */ n.content.type,
            done: false
        };
    }
}
/**
 * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
 * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
 * nodeName and it does not have attributes. Though it can be bound to a DOM
 * element - in this case the attributes and the nodeName are not shared.
 *
 * @public
 * @extends AbstractType<YXmlEvent>
 */ class YXmlFragment extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>|null}
     */ this._prelimContent = [];
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get firstChild() {
        const first = this._first;
        return first ? first.content.getContent()[0] : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, /** @type {Array<any>} */ this._prelimContent);
        this._prelimContent = null;
    }
    _copy() {
        return new YXmlFragment();
    }
    /**
   * @return {YXmlFragment}
   */ clone() {
        const el = new YXmlFragment();
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    get length() {
        return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */ createTreeWalker(filter) {
        return new YXmlTreeWalker(this, filter);
    }
    /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */ querySelector(query) {
        query = query.toUpperCase();
        // @ts-ignore
        const iterator = new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query);
        const next = iterator.next();
        if (next.done) return null;
        else return next.value;
    }
    /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */ querySelectorAll(query) {
        query = query.toUpperCase();
        // @ts-ignore
        return _array.from(new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query));
    }
    /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
    }
    /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */ toString() {
        return typeListMap(this, (xml)=>xml.toString()).join("");
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const fragment = _document.createDocumentFragment();
        if (binding !== undefined) binding._createAssociation(fragment, this);
        typeListForEach(this, (xmlType)=>{
            fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
        });
        return fragment;
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListInsertGenerics(transaction, this, index, content);
        });
        else // @ts-ignore _prelimContent is defined because this is not yet integrated
        this._prelimContent.splice(index, 0, ...content);
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insertAfter(ref, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
            typeListInsertGenericsAfter(transaction, this, refItem, content);
        });
        else {
            const pc = /** @type {Array<any>} */ this._prelimContent;
            const index = ref === null ? 0 : pc.findIndex((el)=>el === ref) + 1;
            if (index === 0 && ref !== null) throw _error.create("Reference item not found");
            pc.splice(index, 0, ...content);
        }
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListDelete(transaction, this, index, length);
        });
        else // @ts-ignore _prelimContent is defined because this is not yet integrated
        this._prelimContent.splice(index, length);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */ push(content) {
        this.insert(this.length, content);
    }
    /**
   * Preppends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Executes a provided function on once on overy child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlFragmentRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YXmlFragment}
 *
 * @private
 * @function
 */ const readYXmlFragment = (_decoder)=>new YXmlFragment();
/**
 * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes
 */ /**
 * An YXmlElement imitates the behavior of a
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.
 *
 * * An YXmlElement has attributes (key value pairs)
 * * An YXmlElement has childElements that must inherit from YXmlElement
 *
 * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]
 */ class YXmlElement extends YXmlFragment {
    constructor(nodeName = "UNDEFINED"){
        super();
        this.nodeName = nodeName;
        /**
     * @type {Map<string, any>|null}
     */ this._prelimAttrs = new Map();
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        /** @type {Map<string, any>} */ this._prelimAttrs.forEach((value, key)=>{
            this.setAttribute(key, value);
        });
        this._prelimAttrs = null;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */ _copy() {
        return new YXmlElement(this.nodeName);
    }
    /**
   * @return {YXmlElement<KV>}
   */ clone() {
        /**
     * @type {YXmlElement<KV>}
     */ const el = new YXmlElement(this.nodeName);
        const attrs = this.getAttributes();
        _object.forEach(attrs, (value, key)=>{
            if (typeof value === "string") el.setAttribute(key, value);
        });
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */ toString() {
        const attrs = this.getAttributes();
        const stringBuilder = [];
        const keys = [];
        for(const key in attrs)keys.push(key);
        keys.sort();
        const keysLen = keys.length;
        for(let i = 0; i < keysLen; i++){
            const key = keys[i];
            stringBuilder.push(key + '="' + attrs[key] + '"');
        }
        const nodeName = this.nodeName.toLocaleLowerCase();
        const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
        return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
    }
    /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, attributeName);
        });
        else /** @type {Map<string,any>} */ this._prelimAttrs.delete(attributeName);
    }
    /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, attributeName, attributeValue);
        });
        else /** @type {Map<string, any>} */ this._prelimAttrs.set(attributeName, attributeValue);
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return /** @type {any} */ typeMapGet(this, attributeName);
    }
    /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */ hasAttribute(attributeName) {
        return /** @type {any} */ typeMapHas(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes(snapshot) {
        return /** @type {any} */ snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this);
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const dom = _document.createElement(this.nodeName);
        const attrs = this.getAttributes();
        for(const key in attrs){
            const value = attrs[key];
            if (typeof value === "string") dom.setAttribute(key, value);
        }
        typeListForEach(this, (yxml)=>{
            dom.appendChild(yxml.toDOM(_document, hooks, binding));
        });
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlElementRefID);
        encoder.writeKey(this.nodeName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlElement}
 *
 * @function
 */ const readYXmlElement = (decoder)=>new YXmlElement(decoder.readKey());
/**
 * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>
 * An Event that describes changes on a YXml Element or Yxml Fragment
 */ class YXmlEvent extends YEvent {
    /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */ constructor(target, subs, transaction){
        super(target, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.attributesChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) this.childListChanged = true;
            else this.attributesChanged.add(sub);
        });
    }
}
/**
 * You can manage binding to a custom type with YXmlHook.
 *
 * @extends {YMap<any>}
 */ class YXmlHook extends YMap {
    /**
   * @param {string} hookName nodeName of the Dom Node.
   */ constructor(hookName){
        super();
        /**
     * @type {string}
     */ this.hookName = hookName;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   */ _copy() {
        return new YXmlHook(this.hookName);
    }
    /**
   * @return {YXmlHook}
   */ clone() {
        const el = new YXmlHook(this.hookName);
        this.forEach((value, key)=>{
            el.set(key, value);
        });
        return el;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const hook = hooks[this.hookName];
        let dom;
        if (hook !== undefined) dom = hook.createDom(this);
        else dom = document.createElement(this.hookName);
        dom.setAttribute("data-yjs-hook", this.hookName);
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlHookRefID);
        encoder.writeKey(this.hookName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlHook}
 *
 * @private
 * @function
 */ const readYXmlHook = (decoder)=>new YXmlHook(decoder.readKey());
/**
 * Represents text in a Dom Element. In the future this type will also handle
 * simple formatting information like bold and italic.
 */ class YXmlText extends YText {
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    _copy() {
        return new YXmlText();
    }
    /**
   * @return {YXmlText}
   */ clone() {
        const text = new YXmlText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks, binding) {
        const dom = _document.createTextNode(this.toString());
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    toString() {
        // @ts-ignore
        return this.toDelta().map((delta)=>{
            const nestedNodes = [];
            for(const nodeName in delta.attributes){
                const attrs = [];
                for(const key in delta.attributes[nodeName])attrs.push({
                    key,
                    value: delta.attributes[nodeName][key]
                });
                // sort attributes to get a unique order
                attrs.sort((a, b)=>a.key < b.key ? -1 : 1);
                nestedNodes.push({
                    nodeName,
                    attrs
                });
            }
            // sort node order to get a unique order
            nestedNodes.sort((a, b)=>a.nodeName < b.nodeName ? -1 : 1);
            // now convert to dom string
            let str = "";
            for(let i = 0; i < nestedNodes.length; i++){
                const node = nestedNodes[i];
                str += `<${node.nodeName}`;
                for(let j = 0; j < node.attrs.length; j++){
                    const attr = node.attrs[j];
                    str += ` ${attr.key}="${attr.value}"`;
                }
                str += ">";
            }
            str += delta.insert;
            for(let i = nestedNodes.length - 1; i >= 0; i--)str += `</${nestedNodes[i].nodeName}>`;
            return str;
        }).join("");
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlText}
 *
 * @private
 * @function
 */ const readYXmlText = (decoder)=>new YXmlText();
class AbstractStruct {
    /**
   * @param {ID} id
   * @param {number} length
   */ constructor(id, length){
        this.id = id;
        this.length = length;
    }
    /**
   * @type {boolean}
   */ get deleted() {
        throw _error.methodUnimplemented();
    }
    /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */ write(encoder, offset, encodingRef) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        throw _error.methodUnimplemented();
    }
}
const structGCRefNumber = 0;
/**
 * @private
 */ class GC extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {GC} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) return false;
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.length -= offset;
        }
        addStruct(transaction.doc.store, this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structGCRefNumber);
        encoder.writeLen(this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
class ContentBinary {
    /**
   * @param {Uint8Array} content
   */ constructor(content){
        this.content = content;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.content
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentBinary}
   */ copy() {
        return new ContentBinary(this.content);
    }
    /**
   * @param {number} offset
   * @return {ContentBinary}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentBinary} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeBuf(this.content);
    }
    /**
   * @return {number}
   */ getRef() {
        return 3;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentBinary}
 */ const readContentBinary = (decoder)=>new ContentBinary(decoder.readBuf());
class ContentDeleted {
    /**
   * @param {number} len
   */ constructor(len){
        this.len = len;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.len;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentDeleted}
   */ copy() {
        return new ContentDeleted(this.len);
    }
    /**
   * @param {number} offset
   * @return {ContentDeleted}
   */ splice(offset) {
        const right = new ContentDeleted(this.len - offset);
        this.len = offset;
        return right;
    }
    /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */ mergeWith(right) {
        this.len += right.len;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
        item.markDeleted();
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeLen(this.len - offset);
    }
    /**
   * @return {number}
   */ getRef() {
        return 1;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentDeleted}
 */ const readContentDeleted = (decoder)=>new ContentDeleted(decoder.readLen());
/**
 * @param {string} guid
 * @param {Object<string, any>} opts
 */ const createDocFromOpts = (guid, opts)=>new Doc({
        guid,
        ...opts,
        shouldLoad: opts.shouldLoad || opts.autoLoad || false
    });
/**
 * @private
 */ class ContentDoc {
    /**
   * @param {Doc} doc
   */ constructor(doc){
        if (doc._item) console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
        /**
     * @type {Doc}
     */ this.doc = doc;
        /**
     * @type {any}
     */ const opts = {};
        this.opts = opts;
        if (!doc.gc) opts.gc = false;
        if (doc.autoLoad) opts.autoLoad = true;
        if (doc.meta !== null) opts.meta = doc.meta;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.doc
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentDoc}
   */ copy() {
        return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
    }
    /**
   * @param {number} offset
   * @return {ContentDoc}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentDoc} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        // this needs to be reflected in doc.destroy as well
        this.doc._item = item;
        transaction.subdocsAdded.add(this.doc);
        if (this.doc.shouldLoad) transaction.subdocsLoaded.add(this.doc);
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (transaction.subdocsAdded.has(this.doc)) transaction.subdocsAdded.delete(this.doc);
        else transaction.subdocsRemoved.add(this.doc);
    }
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(this.doc.guid);
        encoder.writeAny(this.opts);
    }
    /**
   * @return {number}
   */ getRef() {
        return 9;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentDoc}
 */ const readContentDoc = (decoder)=>new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
/**
 * @private
 */ class ContentEmbed {
    /**
   * @param {Object} embed
   */ constructor(embed){
        this.embed = embed;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.embed
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentEmbed}
   */ copy() {
        return new ContentEmbed(this.embed);
    }
    /**
   * @param {number} offset
   * @return {ContentEmbed}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeJSON(this.embed);
    }
    /**
   * @return {number}
   */ getRef() {
        return 5;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentEmbed}
 */ const readContentEmbed = (decoder)=>new ContentEmbed(decoder.readJSON());
/**
 * @private
 */ class ContentFormat {
    /**
   * @param {string} key
   * @param {Object} value
   */ constructor(key, value){
        this.key = key;
        this.value = value;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentFormat}
   */ copy() {
        return new ContentFormat(this.key, this.value);
    }
    /**
   * @param {number} _offset
   * @return {ContentFormat}
   */ splice(_offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */ mergeWith(_right) {
        return false;
    }
    /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */ integrate(_transaction, item) {
        // @todo searchmarker are currently unsupported for rich text documents
        const p = /** @type {YText} */ item.parent;
        p._searchMarker = null;
        p._hasFormatting = true;
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeKey(this.key);
        encoder.writeJSON(this.value);
    }
    /**
   * @return {number}
   */ getRef() {
        return 6;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentFormat}
 */ const readContentFormat = (decoder)=>new ContentFormat(decoder.readKey(), decoder.readJSON());
/**
 * @private
 */ class ContentJSON {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentJSON}
   */ copy() {
        return new ContentJSON(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentJSON}
   */ splice(offset) {
        const right = new ContentJSON(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentJSON} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeString(c === undefined ? "undefined" : JSON.stringify(c));
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 2;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentJSON}
 */ const readContentJSON = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++){
        const c = decoder.readString();
        if (c === "undefined") cs.push(undefined);
        else cs.push(JSON.parse(c));
    }
    return new ContentJSON(cs);
};
class ContentAny {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentAny}
   */ copy() {
        return new ContentAny(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentAny}
   */ splice(offset) {
        const right = new ContentAny(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentAny} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeAny(c);
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 8;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentAny}
 */ const readContentAny = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++)cs.push(decoder.readAny());
    return new ContentAny(cs);
};
/**
 * @private
 */ class ContentString {
    /**
   * @param {string} str
   */ constructor(str){
        /**
     * @type {string}
     */ this.str = str;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.str.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.str.split("");
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentString}
   */ copy() {
        return new ContentString(this.str);
    }
    /**
   * @param {number} offset
   * @return {ContentString}
   */ splice(offset) {
        const right = new ContentString(this.str.slice(offset));
        this.str = this.str.slice(0, offset);
        // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248
        const firstCharCode = this.str.charCodeAt(offset - 1);
        if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {
            // Last character of the left split is the start of a surrogate utf16/ucs2 pair.
            // We don't support splitting of surrogate pairs because this may lead to invalid documents.
            // Replace the invalid character with a unicode replacement character ( / U+FFFD)
            this.str = this.str.slice(0, offset - 1) + "\uFFFD";
            // replace right as well
            right.str = "\uFFFD" + right.str.slice(1);
        }
        return right;
    }
    /**
   * @param {ContentString} right
   * @return {boolean}
   */ mergeWith(right) {
        this.str += right.str;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
    }
    /**
   * @return {number}
   */ getRef() {
        return 4;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentString}
 */ const readContentString = (decoder)=>new ContentString(decoder.readString());
/**
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}
 * @private
 */ const typeRefs = [
    readYArray,
    readYMap,
    readYText,
    readYXmlElement,
    readYXmlFragment,
    readYXmlHook,
    readYXmlText
];
const YArrayRefID = 0;
const YMapRefID = 1;
const YTextRefID = 2;
const YXmlElementRefID = 3;
const YXmlFragmentRefID = 4;
const YXmlHookRefID = 5;
const YXmlTextRefID = 6;
/**
 * @private
 */ class ContentType {
    /**
   * @param {AbstractType<any>} type
   */ constructor(type){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.type
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentType}
   */ copy() {
        return new ContentType(this.type._copy());
    }
    /**
   * @param {number} offset
   * @return {ContentType}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentType} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        this.type._integrate(transaction.doc, item);
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        let item = this.type._start;
        while(item !== null){
            if (!item.deleted) item.delete(transaction);
            else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) // This will be gc'd later and we want to merge it if possible
            // We try to merge all deleted items after each transaction,
            // but we have no knowledge about that this needs to be merged
            // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs
            transaction._mergeStructs.push(item);
            item = item.right;
        }
        this.type._map.forEach((item)=>{
            if (!item.deleted) item.delete(transaction);
            else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) // same as above
            transaction._mergeStructs.push(item);
        });
        transaction.changed.delete(this.type);
    }
    /**
   * @param {StructStore} store
   */ gc(store) {
        let item = this.type._start;
        while(item !== null){
            item.gc(store, true);
            item = item.right;
        }
        this.type._start = null;
        this.type._map.forEach(/** @param {Item | null} item */ (item)=>{
            while(item !== null){
                item.gc(store, true);
                item = item.left;
            }
        });
        this.type._map = new Map();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        this.type._write(encoder);
    }
    /**
   * @return {number}
   */ getRef() {
        return 7;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentType}
 */ const readContentType = (decoder)=>new ContentType(typeRefs[decoder.readTypeRef()](decoder));
/**
 * @todo This should return several items
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {{item:Item, diff:number}}
 */ const followRedone = (store, id)=>{
    /**
   * @type {ID|null}
   */ let nextID = id;
    let diff = 0;
    let item;
    do {
        if (diff > 0) nextID = createID(nextID.client, nextID.clock + diff);
        item = getItem(store, nextID);
        diff = nextID.clock - item.id.clock;
        nextID = item.redone;
    }while (nextID !== null && item instanceof Item);
    return {
        item,
        diff
    };
};
/**
 * Make sure that neither item nor any of its parents is ever deleted.
 *
 * This property does not persist when storing it into a database or when
 * sending it to other peers
 *
 * @param {Item|null} item
 * @param {boolean} keep
 */ const keepItem = (item, keep)=>{
    while(item !== null && item.keep !== keep){
        item.keep = keep;
        item = /** @type {AbstractType<any>} */ item.parent._item;
    }
};
/**
 * Split leftItem into two items
 * @param {Transaction} transaction
 * @param {Item} leftItem
 * @param {number} diff
 * @return {Item}
 *
 * @function
 * @private
 */ const splitItem = (transaction, leftItem, diff)=>{
    // create rightItem
    const { client, clock } = leftItem.id;
    const rightItem = new Item(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    if (leftItem.deleted) rightItem.markDeleted();
    if (leftItem.keep) rightItem.keep = true;
    if (leftItem.redone !== null) rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)
    leftItem.right = rightItem;
    // update right
    if (rightItem.right !== null) rightItem.right.left = rightItem;
    // right is more specific.
    transaction._mergeStructs.push(rightItem);
    // update parent._map
    if (rightItem.parentSub !== null && rightItem.right === null) /** @type {AbstractType<any>} */ rightItem.parent._map.set(rightItem.parentSub, rightItem);
    leftItem.length = diff;
    return rightItem;
};
/**
 * @param {Array<StackItem>} stack
 * @param {ID} id
 */ const isDeletedByUndoStack = (stack, id)=>_array.some(stack, /** @param {StackItem} s */ (s)=>isDeleted(s.deletions, id));
/**
 * Redoes the effect of this operation.
 *
 * @param {Transaction} transaction The Yjs instance.
 * @param {Item} item
 * @param {Set<Item>} redoitems
 * @param {DeleteSet} itemsToDelete
 * @param {boolean} ignoreRemoteMapChanges
 * @param {import('../utils/UndoManager.js').UndoManager} um
 *
 * @return {Item|null}
 *
 * @private
 */ const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um)=>{
    const doc = transaction.doc;
    const store = doc.store;
    const ownClientID = doc.clientID;
    const redone = item.redone;
    if (redone !== null) return getItemCleanStart(transaction, redone);
    let parentItem = /** @type {AbstractType<any>} */ item.parent._item;
    /**
   * @type {Item|null}
   */ let left = null;
    /**
   * @type {Item|null}
   */ let right;
    // make sure that parent is redone
    if (parentItem !== null && parentItem.deleted === true) {
        // try to undo parent if it will be undone anyway
        if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) return null;
        while(parentItem.redone !== null)parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
    const parentType = parentItem === null ? /** @type {AbstractType<any>} */ item.parent : /** @type {ContentType} */ parentItem.content.type;
    if (item.parentSub === null) {
        // Is an array item. Insert at the old position
        left = item.left;
        right = item;
        // find next cloned_redo items
        while(left !== null){
            /**
       * @type {Item|null}
       */ let leftTrace = left;
            // trace redone until parent matches
            while(leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item !== parentItem)leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
            if (leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item === parentItem) {
                left = leftTrace;
                break;
            }
            left = left.left;
        }
        while(right !== null){
            /**
       * @type {Item|null}
       */ let rightTrace = right;
            // trace redone until parent matches
            while(rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item !== parentItem)rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
            if (rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item === parentItem) {
                right = rightTrace;
                break;
            }
            right = right.right;
        }
    } else {
        right = null;
        if (item.right && !ignoreRemoteMapChanges) {
            left = item;
            // Iterate right while right is in itemsToDelete
            // If it is intended to delete right while item is redone, we can expect that item should replace right.
            while(left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))){
                left = left.right;
                // follow redone
                while(left.redone)left = getItemCleanStart(transaction, left.redone);
            }
            if (left && left.right !== null) // It is not possible to redo this item because it conflicts with a
            // change from another client
            return null;
        } else left = parentType._map.get(item.parentSub) || null;
    }
    const nextClock = getState(store, ownClientID);
    const nextId = createID(ownClientID, nextClock);
    const redoneItem = new Item(nextId, left, left && left.lastId, right, right && right.id, parentType, item.parentSub, item.content.copy());
    item.redone = nextId;
    keepItem(redoneItem, true);
    redoneItem.integrate(transaction, 0);
    return redoneItem;
};
/**
 * Abstract class that represents any content.
 */ class Item extends AbstractStruct {
    /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */ constructor(id, left, origin, right, rightOrigin, parent, parentSub, content){
        super(id, content.getLength());
        /**
     * The item that was originally to the left of this item.
     * @type {ID | null}
     */ this.origin = origin;
        /**
     * The item that is currently to the left of this item.
     * @type {Item | null}
     */ this.left = left;
        /**
     * The item that is currently to the right of this item.
     * @type {Item | null}
     */ this.right = right;
        /**
     * The item that was originally to the right of this item.
     * @type {ID | null}
     */ this.rightOrigin = rightOrigin;
        /**
     * @type {AbstractType<any>|ID|null}
     */ this.parent = parent;
        /**
     * If the parent refers to this item with some kind of key (e.g. YMap, the
     * key is specified here. The key is then used to refer to the list in which
     * to insert this item. If `parentSub = null` type._start is the list in
     * which to insert to. Otherwise it is `parent._map`.
     * @type {String | null}
     */ this.parentSub = parentSub;
        /**
     * If this type's effect is redone this type refers to the type that undid
     * this operation.
     * @type {ID | null}
     */ this.redone = null;
        /**
     * @type {AbstractContent}
     */ this.content = content;
        /**
     * bit1: keep
     * bit2: countable
     * bit3: deleted
     * bit4: mark - mark node as fast-search-marker
     * @type {number} byte
     */ this.info = this.content.isCountable() ? _binary.BIT2 : 0;
    }
    /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */ set marker(isMarked) {
        if ((this.info & _binary.BIT4) > 0 !== isMarked) this.info ^= _binary.BIT4;
    }
    get marker() {
        return (this.info & _binary.BIT4) > 0;
    }
    /**
   * If true, do not garbage collect this Item.
   */ get keep() {
        return (this.info & _binary.BIT1) > 0;
    }
    set keep(doKeep) {
        if (this.keep !== doKeep) this.info ^= _binary.BIT1;
    }
    get countable() {
        return (this.info & _binary.BIT2) > 0;
    }
    /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */ get deleted() {
        return (this.info & _binary.BIT3) > 0;
    }
    set deleted(doDelete) {
        if (this.deleted !== doDelete) this.info ^= _binary.BIT3;
    }
    markDeleted() {
        this.info |= _binary.BIT3;
    }
    /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) return this.origin.client;
        if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) return this.rightOrigin.client;
        if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) return this.parent.client;
        // We have all missing ids, now find the items
        if (this.origin) {
            this.left = getItemCleanEnd(transaction, store, this.origin);
            this.origin = this.left.lastId;
        }
        if (this.rightOrigin) {
            this.right = getItemCleanStart(transaction, this.rightOrigin);
            this.rightOrigin = this.right.id;
        }
        if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) this.parent = null;
        else if (!this.parent) {
            // only set parent if this shouldn't be garbage collected
            if (this.left && this.left.constructor === Item) {
                this.parent = this.left.parent;
                this.parentSub = this.left.parentSub;
            }
            if (this.right && this.right.constructor === Item) {
                this.parent = this.right.parent;
                this.parentSub = this.right.parentSub;
            }
        } else if (this.parent.constructor === ID) {
            const parentItem = getItem(store, this.parent);
            if (parentItem.constructor === GC) this.parent = null;
            else this.parent = /** @type {ContentType} */ parentItem.content.type;
        }
        return null;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
            this.origin = this.left.lastId;
            this.content = this.content.splice(offset);
            this.length -= offset;
        }
        if (this.parent) {
            if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
                /**
         * @type {Item|null}
         */ let left = this.left;
                /**
         * @type {Item|null}
         */ let o;
                // set o to the first conflicting item
                if (left !== null) o = left.right;
                else if (this.parentSub !== null) {
                    o = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(o !== null && o.left !== null)o = o.left;
                } else o = /** @type {AbstractType<any>} */ this.parent._start;
                // TODO: use something like DeleteSet here (a tree implementation would be best)
                // @todo use global set definitions
                /**
         * @type {Set<Item>}
         */ const conflictingItems = new Set();
                /**
         * @type {Set<Item>}
         */ const itemsBeforeOrigin = new Set();
                // Let c in conflictingItems, b in itemsBeforeOrigin
                // ***{origin}bbbb{this}{c,b}{c,b}{o}***
                // Note that conflictingItems is a subset of itemsBeforeOrigin
                while(o !== null && o !== this.right){
                    itemsBeforeOrigin.add(o);
                    conflictingItems.add(o);
                    if (compareIDs(this.origin, o.origin)) {
                        // case 1
                        if (o.id.client < this.id.client) {
                            left = o;
                            conflictingItems.clear();
                        } else if (compareIDs(this.rightOrigin, o.rightOrigin)) break;
                         // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations
                    } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) // case 2
                    {
                        if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
                            left = o;
                            conflictingItems.clear();
                        }
                    } else break;
                    o = o.right;
                }
                this.left = left;
            }
            // reconnect left/right + update parent map/start if necessary
            if (this.left !== null) {
                const right = this.left.right;
                this.right = right;
                this.left.right = this;
            } else {
                let r;
                if (this.parentSub !== null) {
                    r = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(r !== null && r.left !== null)r = r.left;
                } else {
                    r = /** @type {AbstractType<any>} */ this.parent._start; /** @type {AbstractType<any>} */ 
                    this.parent._start = this;
                }
                this.right = r;
            }
            if (this.right !== null) this.right.left = this;
            else if (this.parentSub !== null) {
                // set as current parent value if right === null and this is parentSub
                /** @type {AbstractType<any>} */ this.parent._map.set(this.parentSub, this);
                if (this.left !== null) // this is the current attribute value of parent. delete right
                this.left.delete(transaction);
            }
            // adjust length of parent
            if (this.parentSub === null && this.countable && !this.deleted) /** @type {AbstractType<any>} */ this.parent._length += this.length;
            addStruct(transaction.doc.store, this);
            this.content.integrate(transaction, this);
            // add parent to transaction.changed
            addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ this.parent, this.parentSub);
            if (/** @type {AbstractType<any>} */ this.parent._item !== null && /** @type {AbstractType<any>} */ this.parent._item.deleted || this.parentSub !== null && this.right !== null) // delete if parent is deleted or if this is not the current attribute value of parent
            this.delete(transaction);
        } else // parent is not defined. Integrate GC struct instead
        new GC(this.id, this.length).integrate(transaction, 0);
    }
    /**
   * Returns the next non-deleted item
   */ get next() {
        let n = this.right;
        while(n !== null && n.deleted)n = n.right;
        return n;
    }
    /**
   * Returns the previous non-deleted item
   */ get prev() {
        let n = this.left;
        while(n !== null && n.deleted)n = n.left;
        return n;
    }
    /**
   * Computes the last content address of this Item.
   */ get lastId() {
        // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible
        return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
    }
    /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
            const searchMarker = /** @type {AbstractType<any>} */ this.parent._searchMarker;
            if (searchMarker) searchMarker.forEach((marker)=>{
                if (marker.p === right) {
                    // right is going to be "forgotten" so we need to update the marker
                    marker.p = this;
                    // adjust marker index
                    if (!this.deleted && this.countable) marker.index -= this.length;
                }
            });
            if (right.keep) this.keep = true;
            this.right = right.right;
            if (this.right !== null) this.right.left = this;
            this.length += right.length;
            return true;
        }
        return false;
    }
    /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (!this.deleted) {
            const parent = /** @type {AbstractType<any>} */ this.parent;
            // adjust the length of parent
            if (this.countable && this.parentSub === null) parent._length -= this.length;
            this.markDeleted();
            addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
            addChangedTypeToTransaction(transaction, parent, this.parentSub);
            this.content.delete(transaction);
        }
    }
    /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */ gc(store, parentGCd) {
        if (!this.deleted) throw _error.unexpectedCase();
        this.content.gc(store);
        if (parentGCd) replaceStruct(store, this, new GC(this.id, this.length));
        else this.content = new ContentDeleted(this.length);
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */ write(encoder, offset) {
        const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
        const rightOrigin = this.rightOrigin;
        const parentSub = this.parentSub;
        const info = this.content.getRef() & _binary.BITS5 | (origin === null ? 0 : _binary.BIT8) | // origin is defined
        (rightOrigin === null ? 0 : _binary.BIT7) | // right origin is defined
        (parentSub === null ? 0 : _binary.BIT6); // parentSub is non-null
        encoder.writeInfo(info);
        if (origin !== null) encoder.writeLeftID(origin);
        if (rightOrigin !== null) encoder.writeRightID(rightOrigin);
        if (origin === null && rightOrigin === null) {
            const parent = /** @type {AbstractType<any>} */ this.parent;
            if (parent._item !== undefined) {
                const parentItem = parent._item;
                if (parentItem === null) {
                    // parent type on y._map
                    // find the correct key
                    const ykey = findRootTypeKey(parent);
                    encoder.writeParentInfo(true); // write parentYKey
                    encoder.writeString(ykey);
                } else {
                    encoder.writeParentInfo(false); // write parent id
                    encoder.writeLeftID(parentItem.id);
                }
            } else if (parent.constructor === String) {
                encoder.writeParentInfo(true); // write parentYKey
                encoder.writeString(parent);
            } else if (parent.constructor === ID) {
                encoder.writeParentInfo(false); // write parent id
                encoder.writeLeftID(parent);
            } else _error.unexpectedCase();
            if (parentSub !== null) encoder.writeString(parentSub);
        }
        this.content.write(encoder, offset);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @param {number} info
 */ const readItemContent = (decoder, info)=>contentRefs[info & _binary.BITS5](decoder);
/**
 * A lookup map for reading Item content.
 *
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}
 */ const contentRefs = [
    ()=>{
        _error.unexpectedCase();
    },
    readContentDeleted,
    readContentJSON,
    readContentBinary,
    readContentString,
    readContentEmbed,
    readContentFormat,
    readContentType,
    readContentAny,
    readContentDoc,
    ()=>{
        _error.unexpectedCase();
    } // 10 - Skip is not ItemContent
];
const structSkipRefNumber = 10;
/**
 * @private
 */ class Skip extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {Skip} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) return false;
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        // skip structs cannot be integrated
        _error.unexpectedCase();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structSkipRefNumber);
        // write as VarUint because Skips can't make use of predictable length-encoding
        _encoding.writeVarUint(encoder.restEncoder, this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
/** eslint-env browser */ const glo = /** @type {any} */ typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
const importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) /**
   * Dear reader of this message. Please take this seriously.
   *
   * If you see this message, make sure that you only import one version of Yjs. In many cases,
   * your package manager installs two versions of Yjs that are used by different packages within your project.
   * Another reason for this message is that some parts of your project use the commonjs version of Yjs
   * and others use the EcmaScript version of Yjs.
   *
   * This often leads to issues that are hard to debug. We often need to perform constructor checks,
   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to
   * do the constructor checks anymore - which might break the CRDT algorithm.
   *
   * https://github.com/yjs/yjs/issues/438
   */ console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
glo[importIdentifier] = true;

},{"lib0/observable":"20Rfd","lib0/array":"ef0AT","lib0/math":"jhXHz","lib0/map":"eE1vX","lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","lib0/random":"6PBGY","lib0/promise":"6ECaa","lib0/buffer":"3bzhu","lib0/error":"fYL2z","lib0/binary":"g6CPb","lib0/function":"1O0Qj","lib0/set":"iWXeP","lib0/logging":"klpvH","lib0/time":"gZsVK","lib0/string":"cA9Az","lib0/iterator":"aFgMm","lib0/object":"4uXcx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"20Rfd":[function(require,module,exports) {
/**
 * Observable class prototype.
 *
 * @module observable
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Handles named events.
 * @experimental
 *
 * This is basically a (better typed) duplicate of Observable, which will replace Observable in the
 * next release.
 *
 * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS
 */ parcelHelpers.export(exports, "ObservableV2", ()=>ObservableV2);
/* c8 ignore start */ /**
 * Handles named events.
 *
 * @deprecated
 * @template N
 */ parcelHelpers.export(exports, "Observable", ()=>Observable) /* c8 ignore end */ ;
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
var _arrayJs = require("./array.js");
class ObservableV2 {
    constructor(){
        /**
     * Some desc.
     * @type {Map<string, Set<any>>}
     */ this._observers = _mapJs.create();
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ on(name, f) {
        _mapJs.setIfUndefined(this._observers, /** @type {string} */ name, _setJs.create).add(f);
        return f;
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, /** @type {any} */ _f);
            f(...args);
        };
        this.on(name, /** @type {any} */ _f);
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) this._observers.delete(name);
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return _arrayJs.from((this._observers.get(name) || _mapJs.create()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = _mapJs.create();
    }
}
class Observable {
    constructor(){
        /**
     * Some desc.
     * @type {Map<N, any>}
     */ this._observers = _mapJs.create();
    }
    /**
   * @param {N} name
   * @param {function} f
   */ on(name, f) {
        _mapJs.setIfUndefined(this._observers, name, _setJs.create).add(f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, _f);
            f(...args);
        };
        this.on(name, _f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) this._observers.delete(name);
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return _arrayJs.from((this._observers.get(name) || _mapJs.create()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = _mapJs.create();
    }
}

},{"./map.js":"eE1vX","./set.js":"iWXeP","./array.js":"ef0AT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eE1vX":[function(require,module,exports) {
/**
 * Utility module to work with key-value stores.
 *
 * @module map
 */ /**
 * Creates a new Map instance.
 *
 * @function
 * @return {Map<any, any>}
 *
 * @function
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "copy", ()=>copy);
parcelHelpers.export(exports, "setIfUndefined", ()=>setIfUndefined);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "any", ()=>any);
parcelHelpers.export(exports, "all", ()=>all);
const create = ()=>new Map();
const copy = (m)=>{
    const r = create();
    m.forEach((v, k)=>{
        r.set(k, v);
    });
    return r;
};
const setIfUndefined = (map, key, createT)=>{
    let set = map.get(key);
    if (set === undefined) map.set(key, set = createT());
    return set;
};
const map = (m, f)=>{
    const res = [];
    for (const [key, value] of m)res.push(f(value, key));
    return res;
};
const any = (m, f)=>{
    for (const [key, value] of m){
        if (f(value, key)) return true;
    }
    return false;
};
const all = (m, f)=>{
    for (const [key, value] of m){
        if (!f(value, key)) return false;
    }
    return true;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iWXeP":[function(require,module,exports) {
/**
 * Utility module to work with sets.
 *
 * @module set
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "first", ()=>first);
parcelHelpers.export(exports, "from", ()=>from);
const create = ()=>new Set();
const toArray = (set)=>Array.from(set);
const first = (set)=>set.values().next().value || undefined;
const from = (entries)=>new Set(entries);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ef0AT":[function(require,module,exports) {
/**
 * Utility module to work with Arrays.
 *
 * @module array
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "copy", ()=>copy);
parcelHelpers.export(exports, "appendTo", ()=>appendTo);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "equalFlat", ()=>equalFlat);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "unfold", ()=>unfold);
parcelHelpers.export(exports, "fold", ()=>fold);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "unique", ()=>unique);
parcelHelpers.export(exports, "uniqueBy", ()=>uniqueBy);
parcelHelpers.export(exports, "map", ()=>map);
var _setJs = require("./set.js");
const last = (arr)=>arr[arr.length - 1];
const create = ()=>/** @type {Array<C>} */ [];
const copy = (a)=>/** @type {Array<D>} */ a.slice();
const appendTo = (dest, src)=>{
    for(let i = 0; i < src.length; i++)dest.push(src[i]);
};
const from = Array.from;
const every = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (!f(arr[i], i, arr)) return false;
    }
    return true;
};
const some = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (f(arr[i], i, arr)) return true;
    }
    return false;
};
const equalFlat = (a, b)=>a.length === b.length && every(a, (item, index)=>item === b[index]);
const flatten = (arr)=>fold(arr, /** @type {Array<ELEM>} */ [], (acc, val)=>acc.concat(val));
const unfold = (len, f)=>{
    const array = new Array(len);
    for(let i = 0; i < len; i++)array[i] = f(i, array);
    return array;
};
const fold = (arr, seed, folder)=>arr.reduce(folder, seed);
const isArray = Array.isArray;
const unique = (arr)=>from(_setJs.from(arr));
const uniqueBy = (arr, mapper)=>{
    /**
   * @type {Set<M>}
   */ const happened = _setJs.create();
    /**
   * @type {Array<T>}
   */ const result = [];
    for(let i = 0; i < arr.length; i++){
        const el = arr[i];
        const mapped = mapper(el);
        if (!happened.has(mapped)) {
            happened.add(mapped);
            result.push(el);
        }
    }
    return result;
};
const map = (arr, mapper)=>{
    /**
   * @type {Array<any>}
   */ const res = Array(arr.length);
    for(let i = 0; i < arr.length; i++)res[i] = mapper(/** @type {any} */ arr[i], i, /** @type {any} */ arr);
    return /** @type {any} */ res;
};

},{"./set.js":"iWXeP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhXHz":[function(require,module,exports) {
/**
 * Common Math expressions.
 *
 * @module math
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "floor", ()=>floor);
parcelHelpers.export(exports, "ceil", ()=>ceil);
parcelHelpers.export(exports, "abs", ()=>abs);
parcelHelpers.export(exports, "imul", ()=>imul);
parcelHelpers.export(exports, "round", ()=>round);
parcelHelpers.export(exports, "log10", ()=>log10);
parcelHelpers.export(exports, "log2", ()=>log2);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "sqrt", ()=>sqrt);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "isNaN", ()=>isNaN);
parcelHelpers.export(exports, "pow", ()=>pow);
parcelHelpers.export(exports, "exp10", ()=>exp10);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "isNegativeZero", ()=>isNegativeZero);
const floor = Math.floor;
const ceil = Math.ceil;
const abs = Math.abs;
const imul = Math.imul;
const round = Math.round;
const log10 = Math.log10;
const log2 = Math.log2;
const log = Math.log;
const sqrt = Math.sqrt;
const add = (a, b)=>a + b;
const min = (a, b)=>a < b ? a : b;
const max = (a, b)=>a > b ? a : b;
const isNaN = Number.isNaN;
const pow = Math.pow;
const exp10 = (exp)=>Math.pow(10, exp);
const sign = Math.sign;
const isNegativeZero = (n)=>n !== 0 ? n < 0 : 1 / n < 0;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9yVNx":[function(require,module,exports) {
/**
 * Efficient schema-less binary encoding with support for variable length encoding.
 *
 * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module encoding
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A BinaryEncoder handles the encoding to an Uint8Array.
 */ parcelHelpers.export(exports, "Encoder", ()=>Encoder);
parcelHelpers.export(exports, "createEncoder", ()=>createEncoder);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "hasContent", ()=>hasContent);
parcelHelpers.export(exports, "toUint8Array", ()=>toUint8Array);
parcelHelpers.export(exports, "verifyLen", ()=>verifyLen);
parcelHelpers.export(exports, "write", ()=>write);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "writeUint8", ()=>writeUint8);
parcelHelpers.export(exports, "setUint8", ()=>setUint8);
parcelHelpers.export(exports, "writeUint16", ()=>writeUint16);
parcelHelpers.export(exports, "setUint16", ()=>setUint16);
parcelHelpers.export(exports, "writeUint32", ()=>writeUint32);
parcelHelpers.export(exports, "writeUint32BigEndian", ()=>writeUint32BigEndian);
parcelHelpers.export(exports, "setUint32", ()=>setUint32);
parcelHelpers.export(exports, "writeVarUint", ()=>writeVarUint);
parcelHelpers.export(exports, "writeVarInt", ()=>writeVarInt);
parcelHelpers.export(exports, "_writeVarStringNative", ()=>_writeVarStringNative);
parcelHelpers.export(exports, "_writeVarStringPolyfill", ()=>_writeVarStringPolyfill);
parcelHelpers.export(exports, "writeVarString", ()=>writeVarString);
parcelHelpers.export(exports, "writeTerminatedString", ()=>writeTerminatedString);
parcelHelpers.export(exports, "writeTerminatedUint8Array", ()=>writeTerminatedUint8Array);
parcelHelpers.export(exports, "writeBinaryEncoder", ()=>writeBinaryEncoder);
parcelHelpers.export(exports, "writeUint8Array", ()=>writeUint8Array);
parcelHelpers.export(exports, "writeVarUint8Array", ()=>writeVarUint8Array);
parcelHelpers.export(exports, "writeOnDataView", ()=>writeOnDataView);
parcelHelpers.export(exports, "writeFloat32", ()=>writeFloat32);
parcelHelpers.export(exports, "writeFloat64", ()=>writeFloat64);
parcelHelpers.export(exports, "writeBigInt64", ()=>writeBigInt64);
parcelHelpers.export(exports, "writeBigUint64", ()=>writeBigUint64);
parcelHelpers.export(exports, "writeAny", ()=>writeAny);
/**
 * Now come a few stateful encoder that have their own classes.
 */ /**
 * Basic Run Length Encoder - a basic compression implementation.
 *
 * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.
 *
 * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf
 *
 * @note T must not be null!
 *
 * @template T
 */ parcelHelpers.export(exports, "RleEncoder", ()=>RleEncoder);
/**
 * Basic diff decoder using variable length encoding.
 *
 * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.
 */ parcelHelpers.export(exports, "IntDiffEncoder", ()=>IntDiffEncoder);
/**
 * A combination of IntDiffEncoder and RleEncoder.
 *
 * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.
 *
 * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])
 */ parcelHelpers.export(exports, "RleIntDiffEncoder", ()=>RleIntDiffEncoder);
/**
 * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.
 *
 * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write
 * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.
 *
 * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)
 */ parcelHelpers.export(exports, "UintOptRleEncoder", ()=>UintOptRleEncoder);
/**
 * Increasing Uint Optimized RLE Encoder
 *
 * The RLE encoder counts the number of same occurences of the same value.
 * The IncUintOptRle encoder counts if the value increases.
 * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded
 * as [1, 3, 5].
 */ parcelHelpers.export(exports, "IncUintOptRleEncoder", ()=>IncUintOptRleEncoder);
/**
 * A combination of the IntDiffEncoder and the UintOptRleEncoder.
 *
 * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes
 * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!
 *
 * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])
 *
 * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:
 * * 1 bit that denotes whether the next value is a count (LSB)
 * * 1 bit that denotes whether this value is negative (MSB - 1)
 * * 1 bit that denotes whether to continue reading the variable length integer (MSB)
 *
 * Therefore, only five bits remain to encode diff ranges.
 *
 * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.
 */ parcelHelpers.export(exports, "IntDiffOptRleEncoder", ()=>IntDiffOptRleEncoder);
/**
 * Optimized String Encoder.
 *
 * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.
 * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).
 *
 * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.
 *
 * The lengths are encoded using a UintOptRleEncoder.
 */ parcelHelpers.export(exports, "StringEncoder", ()=>StringEncoder);
var _mathJs = require("./math.js");
var _numberJs = require("./number.js");
var _binaryJs = require("./binary.js");
var _stringJs = require("./string.js");
var _arrayJs = require("./array.js");
class Encoder {
    constructor(){
        this.cpos = 0;
        this.cbuf = new Uint8Array(100);
        /**
     * @type {Array<Uint8Array>}
     */ this.bufs = [];
    }
}
const createEncoder = ()=>new Encoder();
const encode = (f)=>{
    const encoder = createEncoder();
    f(encoder);
    return toUint8Array(encoder);
};
const length = (encoder)=>{
    let len = encoder.cpos;
    for(let i = 0; i < encoder.bufs.length; i++)len += encoder.bufs[i].length;
    return len;
};
const hasContent = (encoder)=>encoder.cpos > 0 || encoder.bufs.length > 0;
const toUint8Array = (encoder)=>{
    const uint8arr = new Uint8Array(length(encoder));
    let curPos = 0;
    for(let i = 0; i < encoder.bufs.length; i++){
        const d = encoder.bufs[i];
        uint8arr.set(d, curPos);
        curPos += d.length;
    }
    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
};
const verifyLen = (encoder, len)=>{
    const bufferLen = encoder.cbuf.length;
    if (bufferLen - encoder.cpos < len) {
        encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
        encoder.cbuf = new Uint8Array(_mathJs.max(bufferLen, len) * 2);
        encoder.cpos = 0;
    }
};
const write = (encoder, num)=>{
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
        encoder.bufs.push(encoder.cbuf);
        encoder.cbuf = new Uint8Array(bufferLen * 2);
        encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
};
const set = (encoder, pos, num)=>{
    let buffer = null;
    // iterate all buffers and adjust position
    for(let i = 0; i < encoder.bufs.length && buffer === null; i++){
        const b = encoder.bufs[i];
        if (pos < b.length) buffer = b // found buffer
        ;
        else pos -= b.length;
    }
    if (buffer === null) // use current buffer
    buffer = encoder.cbuf;
    buffer[pos] = num;
};
const writeUint8 = write;
const setUint8 = set;
const writeUint16 = (encoder, num)=>{
    write(encoder, num & _binaryJs.BITS8);
    write(encoder, num >>> 8 & _binaryJs.BITS8);
};
const setUint16 = (encoder, pos, num)=>{
    set(encoder, pos, num & _binaryJs.BITS8);
    set(encoder, pos + 1, num >>> 8 & _binaryJs.BITS8);
};
const writeUint32 = (encoder, num)=>{
    for(let i = 0; i < 4; i++){
        write(encoder, num & _binaryJs.BITS8);
        num >>>= 8;
    }
};
const writeUint32BigEndian = (encoder, num)=>{
    for(let i = 3; i >= 0; i--)write(encoder, num >>> 8 * i & _binaryJs.BITS8);
};
const setUint32 = (encoder, pos, num)=>{
    for(let i = 0; i < 4; i++){
        set(encoder, pos + i, num & _binaryJs.BITS8);
        num >>>= 8;
    }
};
const writeVarUint = (encoder, num)=>{
    while(num > _binaryJs.BITS7){
        write(encoder, _binaryJs.BIT8 | _binaryJs.BITS7 & num);
        num = _mathJs.floor(num / 128) // shift >>> 7
        ;
    }
    write(encoder, _binaryJs.BITS7 & num);
};
const writeVarInt = (encoder, num)=>{
    const isNegative = _mathJs.isNegativeZero(num);
    if (isNegative) num = -num;
    //             |- whether to continue reading         |- whether is negative     |- number
    write(encoder, (num > _binaryJs.BITS6 ? _binaryJs.BIT8 : 0) | (isNegative ? _binaryJs.BIT7 : 0) | _binaryJs.BITS6 & num);
    num = _mathJs.floor(num / 64) // shift >>> 6
    ;
    // We don't need to consider the case of num === 0 so we can use a different
    // pattern here than above.
    while(num > 0){
        write(encoder, (num > _binaryJs.BITS7 ? _binaryJs.BIT8 : 0) | _binaryJs.BITS7 & num);
        num = _mathJs.floor(num / 128) // shift >>> 7
        ;
    }
};
/**
 * A cache to store strings temporarily
 */ const _strBuffer = new Uint8Array(30000);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str)=>{
    if (str.length < _maxStrBSize) {
        // We can encode the string into the existing buffer
        /* c8 ignore next */ const written = _stringJs.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
        writeVarUint(encoder, written);
        for(let i = 0; i < written; i++)write(encoder, _strBuffer[i]);
    } else writeVarUint8Array(encoder, _stringJs.encodeUtf8(str));
};
const _writeVarStringPolyfill = (encoder, str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for(let i = 0; i < len; i++)write(encoder, /** @type {number} */ encodedString.codePointAt(i));
};
const writeVarString = _stringJs.utf8TextEncoder && /** @type {any} */ _stringJs.utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeTerminatedString = (encoder, str)=>writeTerminatedUint8Array(encoder, _stringJs.encodeUtf8(str));
const writeTerminatedUint8Array = (encoder, buf)=>{
    for(let i = 0; i < buf.length; i++){
        const b = buf[i];
        if (b === 0 || b === 1) write(encoder, 1);
        write(encoder, buf[i]);
    }
    write(encoder, 0);
};
const writeBinaryEncoder = (encoder, append)=>writeUint8Array(encoder, toUint8Array(append));
const writeUint8Array = (encoder, uint8Array)=>{
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = _mathJs.min(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
        // Still something to write, write right half..
        // Append new buffer
        encoder.bufs.push(encoder.cbuf);
        // must have at least size of remaining buffer
        encoder.cbuf = new Uint8Array(_mathJs.max(bufferLen * 2, rightCopyLen));
        // copy array
        encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
        encoder.cpos = rightCopyLen;
    }
};
const writeVarUint8Array = (encoder, uint8Array)=>{
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len)=>{
    verifyLen(encoder, len);
    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
    encoder.cpos += len;
    return dview;
};
const writeFloat32 = (encoder, num)=>writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num)=>writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigInt64(0, num, false);
const writeBigUint64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigUint64(0, num, false);
const floatTestBed = new DataView(new ArrayBuffer(4));
/**
 * Check if a number can be encoded as a 32 bit float.
 *
 * @param {number} num
 * @return {boolean}
 */ const isFloat32 = (num)=>{
    floatTestBed.setFloat32(0, num);
    return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data)=>{
    switch(typeof data){
        case "string":
            // TYPE 119: STRING
            write(encoder, 119);
            writeVarString(encoder, data);
            break;
        case "number":
            if (_numberJs.isInteger(data) && _mathJs.abs(data) <= _binaryJs.BITS31) {
                // TYPE 125: INTEGER
                write(encoder, 125);
                writeVarInt(encoder, data);
            } else if (isFloat32(data)) {
                // TYPE 124: FLOAT32
                write(encoder, 124);
                writeFloat32(encoder, data);
            } else {
                // TYPE 123: FLOAT64
                write(encoder, 123);
                writeFloat64(encoder, data);
            }
            break;
        case "bigint":
            // TYPE 122: BigInt
            write(encoder, 122);
            writeBigInt64(encoder, data);
            break;
        case "object":
            if (data === null) // TYPE 126: null
            write(encoder, 126);
            else if (_arrayJs.isArray(data)) {
                // TYPE 117: Array
                write(encoder, 117);
                writeVarUint(encoder, data.length);
                for(let i = 0; i < data.length; i++)writeAny(encoder, data[i]);
            } else if (data instanceof Uint8Array) {
                // TYPE 116: ArrayBuffer
                write(encoder, 116);
                writeVarUint8Array(encoder, data);
            } else {
                // TYPE 118: Object
                write(encoder, 118);
                const keys = Object.keys(data);
                writeVarUint(encoder, keys.length);
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    writeVarString(encoder, key);
                    writeAny(encoder, data[key]);
                }
            }
            break;
        case "boolean":
            // TYPE 120/121: boolean (true/false)
            write(encoder, data ? 120 : 121);
            break;
        default:
            // TYPE 127: undefined
            write(encoder, 127);
    }
};
class RleEncoder extends Encoder {
    /**
   * @param {function(Encoder, T):void} writer
   */ constructor(writer){
        super();
        /**
     * The writer
     */ this.w = writer;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    /**
   * @param {T} v
   */ write(v) {
        if (this.s === v) this.count++;
        else {
            if (this.count > 0) // flush counter, unless this is the first value (count = 0)
            writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
            ;
            this.count = 1;
            // write first value
            this.w(this, v);
            this.s = v;
        }
    }
}
class IntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @param {number} v
   */ write(v) {
        writeVarInt(this, v - this.s);
        this.s = v;
    }
}
class RleIntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v && this.count > 0) this.count++;
        else {
            if (this.count > 0) // flush counter, unless this is the first value (count = 0)
            writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
            ;
            this.count = 1;
            // write first value
            writeVarInt(this, v - this.s);
            this.s = v;
        }
    }
}
/**
 * @param {UintOptRleEncoder} encoder
 */ const flushUintOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set sign to positive
        // case 2: write several values. set sign to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
        if (encoder.count > 1) writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
        ;
    }
};
class UintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v) this.count++;
        else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class IncUintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s + this.count === v) this.count++;
        else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
/**
 * @param {IntDiffOptRleEncoder} encoder
 */ const flushIntDiffOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        //          31 bit making up the diff | wether to write the counter
        // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)
        const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set first bit to positive
        // case 2: write several values. set first bit to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encodedDiff);
        if (encoder.count > 1) writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
        ;
    }
};
class IntDiffOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.diff === v - this.s) {
            this.s = v;
            this.count++;
        } else {
            flushIntDiffOptRleEncoder(this);
            this.count = 1;
            this.diff = v - this.s;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushIntDiffOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class StringEncoder {
    constructor(){
        /**
     * @type {Array<string>}
     */ this.sarr = [];
        this.s = "";
        this.lensE = new UintOptRleEncoder();
    }
    /**
   * @param {string} string
   */ write(string) {
        this.s += string;
        if (this.s.length > 19) {
            this.sarr.push(this.s);
            this.s = "";
        }
        this.lensE.write(string.length);
    }
    toUint8Array() {
        const encoder = new Encoder();
        this.sarr.push(this.s);
        this.s = "";
        writeVarString(encoder, this.sarr.join(""));
        writeUint8Array(encoder, this.lensE.toUint8Array());
        return toUint8Array(encoder);
    }
}

},{"./math.js":"jhXHz","./number.js":"cNQGC","./binary.js":"g6CPb","./string.js":"cA9Az","./array.js":"ef0AT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cNQGC":[function(require,module,exports) {
/**
 * Utility helpers for working with numbers.
 *
 * @module number
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_SAFE_INTEGER", ()=>MAX_SAFE_INTEGER);
parcelHelpers.export(exports, "MIN_SAFE_INTEGER", ()=>MIN_SAFE_INTEGER);
parcelHelpers.export(exports, "LOWEST_INT32", ()=>LOWEST_INT32);
parcelHelpers.export(exports, "HIGHEST_INT32", ()=>HIGHEST_INT32);
parcelHelpers.export(exports, "HIGHEST_UINT32", ()=>HIGHEST_UINT32);
parcelHelpers.export(exports, "isInteger", ()=>isInteger);
parcelHelpers.export(exports, "isNaN", ()=>isNaN);
parcelHelpers.export(exports, "parseInt", ()=>parseInt);
parcelHelpers.export(exports, "countBits", ()=>countBits);
var _mathJs = require("./math.js");
var _binaryJs = require("./binary.js");
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
const LOWEST_INT32 = -2147483648;
const HIGHEST_INT32 = _binaryJs.BITS31;
const HIGHEST_UINT32 = _binaryJs.BITS32;
const isInteger = Number.isInteger || ((num)=>typeof num === "number" && isFinite(num) && _mathJs.floor(num) === num);
const isNaN = Number.isNaN;
const parseInt = Number.parseInt;
const countBits = (n)=>{
    n &= _binaryJs.BITS32;
    let count = 0;
    while(n){
        n &= n - 1;
        count++;
    }
    return count;
};

},{"./math.js":"jhXHz","./binary.js":"g6CPb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g6CPb":[function(require,module,exports) {
/* eslint-env browser */ /**
 * Binary data constants.
 *
 * @module binary
 */ /**
 * n-th bit activated.
 *
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BIT1", ()=>BIT1);
parcelHelpers.export(exports, "BIT2", ()=>BIT2);
parcelHelpers.export(exports, "BIT3", ()=>BIT3);
parcelHelpers.export(exports, "BIT4", ()=>BIT4);
parcelHelpers.export(exports, "BIT5", ()=>BIT5);
parcelHelpers.export(exports, "BIT6", ()=>BIT6);
parcelHelpers.export(exports, "BIT7", ()=>BIT7);
parcelHelpers.export(exports, "BIT8", ()=>BIT8);
parcelHelpers.export(exports, "BIT9", ()=>BIT9);
parcelHelpers.export(exports, "BIT10", ()=>BIT10);
parcelHelpers.export(exports, "BIT11", ()=>BIT11);
parcelHelpers.export(exports, "BIT12", ()=>BIT12);
parcelHelpers.export(exports, "BIT13", ()=>BIT13);
parcelHelpers.export(exports, "BIT14", ()=>BIT14);
parcelHelpers.export(exports, "BIT15", ()=>BIT15);
parcelHelpers.export(exports, "BIT16", ()=>BIT16);
parcelHelpers.export(exports, "BIT17", ()=>BIT17);
parcelHelpers.export(exports, "BIT18", ()=>BIT18);
parcelHelpers.export(exports, "BIT19", ()=>BIT19);
parcelHelpers.export(exports, "BIT20", ()=>BIT20);
parcelHelpers.export(exports, "BIT21", ()=>BIT21);
parcelHelpers.export(exports, "BIT22", ()=>BIT22);
parcelHelpers.export(exports, "BIT23", ()=>BIT23);
parcelHelpers.export(exports, "BIT24", ()=>BIT24);
parcelHelpers.export(exports, "BIT25", ()=>BIT25);
parcelHelpers.export(exports, "BIT26", ()=>BIT26);
parcelHelpers.export(exports, "BIT27", ()=>BIT27);
parcelHelpers.export(exports, "BIT28", ()=>BIT28);
parcelHelpers.export(exports, "BIT29", ()=>BIT29);
parcelHelpers.export(exports, "BIT30", ()=>BIT30);
parcelHelpers.export(exports, "BIT31", ()=>BIT31);
parcelHelpers.export(exports, "BIT32", ()=>BIT32);
parcelHelpers.export(exports, "BITS0", ()=>BITS0);
parcelHelpers.export(exports, "BITS1", ()=>BITS1);
parcelHelpers.export(exports, "BITS2", ()=>BITS2);
parcelHelpers.export(exports, "BITS3", ()=>BITS3);
parcelHelpers.export(exports, "BITS4", ()=>BITS4);
parcelHelpers.export(exports, "BITS5", ()=>BITS5);
parcelHelpers.export(exports, "BITS6", ()=>BITS6);
parcelHelpers.export(exports, "BITS7", ()=>BITS7);
parcelHelpers.export(exports, "BITS8", ()=>BITS8);
parcelHelpers.export(exports, "BITS9", ()=>BITS9);
parcelHelpers.export(exports, "BITS10", ()=>BITS10);
parcelHelpers.export(exports, "BITS11", ()=>BITS11);
parcelHelpers.export(exports, "BITS12", ()=>BITS12);
parcelHelpers.export(exports, "BITS13", ()=>BITS13);
parcelHelpers.export(exports, "BITS14", ()=>BITS14);
parcelHelpers.export(exports, "BITS15", ()=>BITS15);
parcelHelpers.export(exports, "BITS16", ()=>BITS16);
parcelHelpers.export(exports, "BITS17", ()=>BITS17);
parcelHelpers.export(exports, "BITS18", ()=>BITS18);
parcelHelpers.export(exports, "BITS19", ()=>BITS19);
parcelHelpers.export(exports, "BITS20", ()=>BITS20);
parcelHelpers.export(exports, "BITS21", ()=>BITS21);
parcelHelpers.export(exports, "BITS22", ()=>BITS22);
parcelHelpers.export(exports, "BITS23", ()=>BITS23);
parcelHelpers.export(exports, "BITS24", ()=>BITS24);
parcelHelpers.export(exports, "BITS25", ()=>BITS25);
parcelHelpers.export(exports, "BITS26", ()=>BITS26);
parcelHelpers.export(exports, "BITS27", ()=>BITS27);
parcelHelpers.export(exports, "BITS28", ()=>BITS28);
parcelHelpers.export(exports, "BITS29", ()=>BITS29);
parcelHelpers.export(exports, "BITS30", ()=>BITS30);
parcelHelpers.export(exports, "BITS31", ()=>BITS31);
parcelHelpers.export(exports, "BITS32", ()=>BITS32);
const BIT1 = 1;
const BIT2 = 2;
const BIT3 = 4;
const BIT4 = 8;
const BIT5 = 16;
const BIT6 = 32;
const BIT7 = 64;
const BIT8 = 128;
const BIT9 = 256;
const BIT10 = 512;
const BIT11 = 1024;
const BIT12 = 2048;
const BIT13 = 4096;
const BIT14 = 8192;
const BIT15 = 16384;
const BIT16 = 32768;
const BIT17 = 65536;
const BIT18 = 131072;
const BIT19 = 262144;
const BIT20 = 524288;
const BIT21 = 1048576;
const BIT22 = 2097152;
const BIT23 = 4194304;
const BIT24 = 8388608;
const BIT25 = 16777216;
const BIT26 = 33554432;
const BIT27 = 67108864;
const BIT28 = 134217728;
const BIT29 = 268435456;
const BIT30 = 536870912;
const BIT31 = 1073741824;
const BIT32 = -2147483648;
const BITS0 = 0;
const BITS1 = 1;
const BITS2 = 3;
const BITS3 = 7;
const BITS4 = 15;
const BITS5 = 31;
const BITS6 = 63;
const BITS7 = 127;
const BITS8 = 255;
const BITS9 = 511;
const BITS10 = 1023;
const BITS11 = 2047;
const BITS12 = 4095;
const BITS13 = 8191;
const BITS14 = 16383;
const BITS15 = 32767;
const BITS16 = 65535;
const BITS17 = BIT18 - 1;
const BITS18 = BIT19 - 1;
const BITS19 = BIT20 - 1;
const BITS20 = BIT21 - 1;
const BITS21 = BIT22 - 1;
const BITS22 = BIT23 - 1;
const BITS23 = BIT24 - 1;
const BITS24 = BIT25 - 1;
const BITS25 = BIT26 - 1;
const BITS26 = BIT27 - 1;
const BITS27 = BIT28 - 1;
const BITS28 = BIT29 - 1;
const BITS29 = BIT30 - 1;
const BITS30 = BIT31 - 1;
const BITS31 = 0x7FFFFFFF;
const BITS32 = 0xFFFFFFFF;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cA9Az":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromCharCode", ()=>fromCharCode);
parcelHelpers.export(exports, "fromCodePoint", ()=>fromCodePoint);
parcelHelpers.export(exports, "MAX_UTF16_CHARACTER", ()=>MAX_UTF16_CHARACTER);
parcelHelpers.export(exports, "trimLeft", ()=>trimLeft);
parcelHelpers.export(exports, "fromCamelCase", ()=>fromCamelCase);
parcelHelpers.export(exports, "utf8ByteLength", ()=>utf8ByteLength);
parcelHelpers.export(exports, "_encodeUtf8Polyfill", ()=>_encodeUtf8Polyfill);
parcelHelpers.export(exports, "utf8TextEncoder", ()=>utf8TextEncoder);
parcelHelpers.export(exports, "_encodeUtf8Native", ()=>_encodeUtf8Native);
parcelHelpers.export(exports, "encodeUtf8", ()=>encodeUtf8);
parcelHelpers.export(exports, "_decodeUtf8Polyfill", ()=>_decodeUtf8Polyfill);
parcelHelpers.export(exports, "utf8TextDecoder", ()=>utf8TextDecoder);
parcelHelpers.export(exports, "_decodeUtf8Native", ()=>_decodeUtf8Native);
parcelHelpers.export(exports, "decodeUtf8", ()=>decodeUtf8);
parcelHelpers.export(exports, "splice", ()=>splice);
parcelHelpers.export(exports, "repeat", ()=>repeat);
var _arrayJs = require("./array.js");
const fromCharCode = String.fromCharCode;
const fromCodePoint = String.fromCodePoint;
const MAX_UTF16_CHARACTER = fromCharCode(65535);
/**
 * @param {string} s
 * @return {string}
 */ const toLowerCase = (s)=>s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s)=>s.replace(trimLeftRegex, "");
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator)=>trimLeft(s.replace(fromCamelCaseRegex, (match)=>`${separator}${toLowerCase(match)}`));
const utf8ByteLength = (str)=>unescape(encodeURIComponent(str)).length;
const _encodeUtf8Polyfill = (str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for(let i = 0; i < len; i++)buf[i] = /** @type {number} */ encodedString.codePointAt(i);
    return buf;
};
const utf8TextEncoder = /** @type {TextEncoder} */ typeof TextEncoder !== "undefined" ? new TextEncoder() : null;
const _encodeUtf8Native = (str)=>utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
const _decodeUtf8Polyfill = (buf)=>{
    let remainingLen = buf.length;
    let encodedString = "";
    let bufPos = 0;
    while(remainingLen > 0){
        const nextLen = remainingLen < 10000 ? remainingLen : 10000;
        const bytes = buf.subarray(bufPos, bufPos + nextLen);
        bufPos += nextLen;
        // Starting with ES5.1 we can supply a generic array-like object as arguments
        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ bytes);
        remainingLen -= nextLen;
    }
    return decodeURIComponent(escape(encodedString));
};
let utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", {
    fatal: true,
    ignoreBOM: true
});
/* c8 ignore start */ if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) // Safari doesn't handle BOM correctly.
// This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.
// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and
// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call
// Another issue is that from then on no BOM chars are recognized anymore
/* c8 ignore next */ utf8TextDecoder = null;
const _decodeUtf8Native = (buf)=>/** @type {TextDecoder} */ utf8TextDecoder.decode(buf);
const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;
const splice = (str, index, remove, insert = "")=>str.slice(0, index) + insert + str.slice(index + remove);
const repeat = (source, n)=>_arrayJs.unfold(n, ()=>source).join("");

},{"./array.js":"ef0AT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftn2I":[function(require,module,exports) {
/**
 * Efficient schema-less binary decoding with support for variable length encoding.
 *
 * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module decoding
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Decoder handles the decoding of an Uint8Array.
 */ parcelHelpers.export(exports, "Decoder", ()=>Decoder);
parcelHelpers.export(exports, "createDecoder", ()=>createDecoder);
parcelHelpers.export(exports, "hasContent", ()=>hasContent);
parcelHelpers.export(exports, "clone", ()=>clone);
parcelHelpers.export(exports, "readUint8Array", ()=>readUint8Array);
parcelHelpers.export(exports, "readVarUint8Array", ()=>readVarUint8Array);
parcelHelpers.export(exports, "readTailAsUint8Array", ()=>readTailAsUint8Array);
parcelHelpers.export(exports, "skip8", ()=>skip8);
parcelHelpers.export(exports, "readUint8", ()=>readUint8);
parcelHelpers.export(exports, "readUint16", ()=>readUint16);
parcelHelpers.export(exports, "readUint32", ()=>readUint32);
parcelHelpers.export(exports, "readUint32BigEndian", ()=>readUint32BigEndian);
parcelHelpers.export(exports, "peekUint8", ()=>peekUint8);
parcelHelpers.export(exports, "peekUint16", ()=>peekUint16);
parcelHelpers.export(exports, "peekUint32", ()=>peekUint32);
parcelHelpers.export(exports, "readVarUint", ()=>readVarUint);
parcelHelpers.export(exports, "readVarInt", ()=>readVarInt);
parcelHelpers.export(exports, "peekVarUint", ()=>peekVarUint);
parcelHelpers.export(exports, "peekVarInt", ()=>peekVarInt);
parcelHelpers.export(exports, "_readVarStringPolyfill", ()=>_readVarStringPolyfill);
parcelHelpers.export(exports, "_readVarStringNative", ()=>_readVarStringNative);
parcelHelpers.export(exports, "readVarString", ()=>readVarString);
parcelHelpers.export(exports, "readTerminatedUint8Array", ()=>readTerminatedUint8Array);
parcelHelpers.export(exports, "readTerminatedString", ()=>readTerminatedString);
parcelHelpers.export(exports, "peekVarString", ()=>peekVarString);
parcelHelpers.export(exports, "readFromDataView", ()=>readFromDataView);
parcelHelpers.export(exports, "readFloat32", ()=>readFloat32);
parcelHelpers.export(exports, "readFloat64", ()=>readFloat64);
parcelHelpers.export(exports, "readBigInt64", ()=>readBigInt64);
parcelHelpers.export(exports, "readBigUint64", ()=>readBigUint64);
parcelHelpers.export(exports, "readAny", ()=>readAny);
/**
 * T must not be null.
 *
 * @template T
 */ parcelHelpers.export(exports, "RleDecoder", ()=>RleDecoder);
parcelHelpers.export(exports, "IntDiffDecoder", ()=>IntDiffDecoder);
parcelHelpers.export(exports, "RleIntDiffDecoder", ()=>RleIntDiffDecoder);
parcelHelpers.export(exports, "UintOptRleDecoder", ()=>UintOptRleDecoder);
parcelHelpers.export(exports, "IncUintOptRleDecoder", ()=>IncUintOptRleDecoder);
parcelHelpers.export(exports, "IntDiffOptRleDecoder", ()=>IntDiffOptRleDecoder);
parcelHelpers.export(exports, "StringDecoder", ()=>StringDecoder);
var _binaryJs = require("./binary.js");
var _mathJs = require("./math.js");
var _numberJs = require("./number.js");
var _stringJs = require("./string.js");
var _errorJs = require("./error.js");
var _encodingJs = require("./encoding.js");
const errorUnexpectedEndOfArray = _errorJs.create("Unexpected end of array");
const errorIntegerOutOfRange = _errorJs.create("Integer out of Range");
class Decoder {
    /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */ constructor(uint8Array){
        /**
     * Decoding target.
     *
     * @type {Uint8Array}
     */ this.arr = uint8Array;
        /**
     * Current decoding position.
     *
     * @type {number}
     */ this.pos = 0;
    }
}
const createDecoder = (uint8Array)=>new Decoder(uint8Array);
const hasContent = (decoder)=>decoder.pos !== decoder.arr.length;
const clone = (decoder, newPos = decoder.pos)=>{
    const _decoder = createDecoder(decoder.arr);
    _decoder.pos = newPos;
    return _decoder;
};
const readUint8Array = (decoder, len)=>{
    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
    decoder.pos += len;
    return view;
};
const readVarUint8Array = (decoder)=>readUint8Array(decoder, readVarUint(decoder));
const readTailAsUint8Array = (decoder)=>readUint8Array(decoder, decoder.arr.length - decoder.pos);
const skip8 = (decoder)=>decoder.pos++;
const readUint8 = (decoder)=>decoder.arr[decoder.pos++];
const readUint16 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
    decoder.pos += 2;
    return uint;
};
const readUint32 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const readUint32BigEndian = (decoder)=>{
    const uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const peekUint8 = (decoder)=>decoder.arr[decoder.pos];
const peekUint16 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
const peekUint32 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
const readVarUint = (decoder)=>{
    let num = 0;
    let mult = 1;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        const r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & _binaryJs.BITS7) * mult // shift $r << (7*#iterations) and add it to num
        ;
        mult *= 128 // next iteration, shift 7 "more" to the left
        ;
        if (r < _binaryJs.BIT8) return num;
        /* c8 ignore start */ if (num > _numberJs.MAX_SAFE_INTEGER) throw errorIntegerOutOfRange;
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const readVarInt = (decoder)=>{
    let r = decoder.arr[decoder.pos++];
    let num = r & _binaryJs.BITS6;
    let mult = 64;
    const sign = (r & _binaryJs.BIT7) > 0 ? -1 : 1;
    if ((r & _binaryJs.BIT8) === 0) // don't continue reading
    return sign * num;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & _binaryJs.BITS7) * mult;
        mult *= 128;
        if (r < _binaryJs.BIT8) return sign * num;
        /* c8 ignore start */ if (num > _numberJs.MAX_SAFE_INTEGER) throw errorIntegerOutOfRange;
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const peekVarUint = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarUint(decoder);
    decoder.pos = pos;
    return s;
};
const peekVarInt = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarInt(decoder);
    decoder.pos = pos;
    return s;
};
const _readVarStringPolyfill = (decoder)=>{
    let remainingLen = readVarUint(decoder);
    if (remainingLen === 0) return "";
    else {
        let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen
        ;
        if (--remainingLen < 100) while(remainingLen--)encodedString += String.fromCodePoint(readUint8(decoder));
        else while(remainingLen > 0){
            const nextLen = remainingLen < 10000 ? remainingLen : 10000;
            // this is dangerous, we create a fresh array view from the existing buffer
            const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
            decoder.pos += nextLen;
            // Starting with ES5.1 we can supply a generic array-like object as arguments
            encodedString += String.fromCodePoint.apply(null, /** @type {any} */ bytes);
            remainingLen -= nextLen;
        }
        return decodeURIComponent(escape(encodedString));
    }
};
const _readVarStringNative = (decoder)=>/** @type any */ _stringJs.utf8TextDecoder.decode(readVarUint8Array(decoder));
const readVarString = _stringJs.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
const readTerminatedUint8Array = (decoder)=>{
    const encoder = _encodingJs.createEncoder();
    let b;
    while(true){
        b = readUint8(decoder);
        if (b === 0) return _encodingJs.toUint8Array(encoder);
        if (b === 1) b = readUint8(decoder);
        _encodingJs.write(encoder, b);
    }
};
const readTerminatedString = (decoder)=>_stringJs.decodeUtf8(readTerminatedUint8Array(decoder));
const peekVarString = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarString(decoder);
    decoder.pos = pos;
    return s;
};
const readFromDataView = (decoder, len)=>{
    const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
    decoder.pos += len;
    return dv;
};
const readFloat32 = (decoder)=>readFromDataView(decoder, 4).getFloat32(0, false);
const readFloat64 = (decoder)=>readFromDataView(decoder, 8).getFloat64(0, false);
const readBigInt64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigInt64(0, false);
const readBigUint64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigUint64(0, false);
/**
 * @type {Array<function(Decoder):any>}
 */ const readAnyLookupTable = [
    (decoder)=>undefined,
    (decoder)=>null,
    readVarInt,
    readFloat32,
    readFloat64,
    readBigInt64,
    (decoder)=>false,
    (decoder)=>true,
    readVarString,
    (decoder)=>{
        const len = readVarUint(decoder);
        /**
     * @type {Object<string,any>}
     */ const obj = {};
        for(let i = 0; i < len; i++){
            const key = readVarString(decoder);
            obj[key] = readAny(decoder);
        }
        return obj;
    },
    (decoder)=>{
        const len = readVarUint(decoder);
        const arr = [];
        for(let i = 0; i < len; i++)arr.push(readAny(decoder));
        return arr;
    },
    readVarUint8Array // CASE 116: Uint8Array
];
const readAny = (decoder)=>readAnyLookupTable[127 - readUint8(decoder)](decoder);
class RleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */ constructor(uint8Array, reader){
        super(uint8Array);
        /**
     * The reader
     */ this.reader = reader;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = this.reader(this);
            if (hasContent(this)) this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
            ;
            else this.count = -1 // read the current value forever
            ;
        }
        this.count--;
        return /** @type {T} */ this.s;
    }
}
class IntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @return {number}
   */ read() {
        this.s += readVarInt(this);
        return this.s;
    }
}
class RleIntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            this.s += readVarInt(this);
            if (hasContent(this)) this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
            ;
            else this.count = -1 // read the current value forever
            ;
        }
        this.count--;
        return /** @type {number} */ this.s;
    }
}
class UintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = _mathJs.isNegativeZero(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return /** @type {number} */ this.s;
    }
}
class IncUintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = _mathJs.isNegativeZero(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return /** @type {number} */ this.s++;
    }
}
class IntDiffOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            const diff = readVarInt(this);
            // if the first bit is set, we read more data
            const hasCount = diff & 1;
            this.diff = _mathJs.floor(diff / 2) // shift >> 1
            ;
            this.count = 1;
            if (hasCount) this.count = readVarUint(this) + 2;
        }
        this.s += this.diff;
        this.count--;
        return this.s;
    }
}
class StringDecoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        this.decoder = new UintOptRleDecoder(uint8Array);
        this.str = readVarString(this.decoder);
        /**
     * @type {number}
     */ this.spos = 0;
    }
    /**
   * @return {string}
   */ read() {
        const end = this.spos + this.decoder.read();
        const res = this.str.slice(this.spos, end);
        this.spos = end;
        return res;
    }
}

},{"./binary.js":"g6CPb","./math.js":"jhXHz","./number.js":"cNQGC","./string.js":"cA9Az","./error.js":"fYL2z","./encoding.js":"9yVNx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fYL2z":[function(require,module,exports) {
/**
 * Error helpers.
 *
 * @module error
 */ /**
 * @param {string} s
 * @return {Error}
 */ /* c8 ignore next */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "methodUnimplemented", ()=>methodUnimplemented);
parcelHelpers.export(exports, "unexpectedCase", ()=>unexpectedCase);
const create = (s)=>new Error(s);
const methodUnimplemented = ()=>{
    throw create("Method unimplemented");
};
const unexpectedCase = ()=>{
    throw create("Unexpected case");
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6PBGY":[function(require,module,exports) {
/**
 * Isomorphic module for true random numbers / buffers / uuids.
 *
 * Attention: falls back to Math.random if the browser does not support crypto.
 *
 * @module random
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rand", ()=>rand);
parcelHelpers.export(exports, "uint32", ()=>uint32);
parcelHelpers.export(exports, "uint53", ()=>uint53);
parcelHelpers.export(exports, "oneOf", ()=>oneOf);
parcelHelpers.export(exports, "uuidv4", ()=>uuidv4);
var _mathJs = require("./math.js");
var _binaryJs = require("./binary.js");
var _webcrypto = require("lib0/webcrypto");
const rand = Math.random;
const uint32 = ()=>(0, _webcrypto.getRandomValues)(new Uint32Array(1))[0];
const uint53 = ()=>{
    const arr = (0, _webcrypto.getRandomValues)(new Uint32Array(8));
    return (arr[0] & _binaryJs.BITS21) * (_binaryJs.BITS32 + 1) + (arr[1] >>> 0);
};
const oneOf = (arr)=>arr[_mathJs.floor(rand() * arr.length)];
// @ts-ignore
const uuidv4Template = "10000000-1000-4000-8000-100000000000";
const uuidv4 = ()=>uuidv4Template.replace(/[018]/g, /** @param {number} c */ (c)=>(c ^ uint32() & 15 >> c / 4).toString(16));

},{"./math.js":"jhXHz","./binary.js":"g6CPb","lib0/webcrypto":"7Hw8h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Hw8h":[function(require,module,exports) {
/* eslint-env browser */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subtle", ()=>subtle);
parcelHelpers.export(exports, "getRandomValues", ()=>getRandomValues);
const subtle = crypto.subtle;
const getRandomValues = crypto.getRandomValues.bind(crypto);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6ECaa":[function(require,module,exports) {
/**
 * Utility helpers to work with promises.
 *
 * @module promise
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "createEmpty", ()=>createEmpty);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "reject", ()=>reject);
parcelHelpers.export(exports, "resolve", ()=>resolve);
parcelHelpers.export(exports, "resolveWith", ()=>resolveWith);
parcelHelpers.export(exports, "until", ()=>until);
parcelHelpers.export(exports, "wait", ()=>wait);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
var _timeJs = require("./time.js");
const create = (f)=>/** @type {Promise<T>} */ new Promise(f);
const createEmpty = (f)=>new Promise(f);
const all = Promise.all.bind(Promise);
const reject = (reason)=>Promise.reject(reason);
const resolve = (res)=>Promise.resolve(res);
const resolveWith = (res)=>Promise.resolve(res);
const until = (timeout, check, intervalResolution = 10)=>create((resolve, reject)=>{
        const startTime = _timeJs.getUnixTime();
        const hasTimeout = timeout > 0;
        const untilInterval = ()=>{
            if (check()) {
                clearInterval(intervalHandle);
                resolve();
            } else if (hasTimeout) /* c8 ignore else */ {
                if (_timeJs.getUnixTime() - startTime > timeout) {
                    clearInterval(intervalHandle);
                    reject(new Error("Timeout"));
                }
            }
        };
        const intervalHandle = setInterval(untilInterval, intervalResolution);
    });
const wait = (timeout)=>create((resolve, reject)=>setTimeout(resolve, timeout));
const isPromise = (p)=>p instanceof Promise || p && p.then && p.catch && p.finally;

},{"./time.js":"gZsVK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZsVK":[function(require,module,exports) {
/**
 * Utility module to work with time.
 *
 * @module time
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDate", ()=>getDate);
parcelHelpers.export(exports, "getUnixTime", ()=>getUnixTime);
parcelHelpers.export(exports, "humanizeDuration", ()=>humanizeDuration);
var _metricJs = require("./metric.js");
var _mathJs = require("./math.js");
const getDate = ()=>new Date();
const getUnixTime = Date.now;
const humanizeDuration = (d)=>{
    if (d < 60000) {
        const p = _metricJs.prefix(d, -1);
        return _mathJs.round(p.n * 100) / 100 + p.prefix + "s";
    }
    d = _mathJs.floor(d / 1000);
    const seconds = d % 60;
    const minutes = _mathJs.floor(d / 60) % 60;
    const hours = _mathJs.floor(d / 3600) % 24;
    const days = _mathJs.floor(d / 86400);
    if (days > 0) return days + "d" + (hours > 0 || minutes > 30 ? " " + (minutes > 30 ? hours + 1 : hours) + "h" : "");
    if (hours > 0) /* c8 ignore next */ return hours + "h" + (minutes > 0 || seconds > 30 ? " " + (seconds > 30 ? minutes + 1 : minutes) + "min" : "");
    return minutes + "min" + (seconds > 0 ? " " + seconds + "s" : "");
};

},{"./metric.js":"gre3X","./math.js":"jhXHz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gre3X":[function(require,module,exports) {
/**
 * Utility module to convert metric values.
 *
 * @module metric
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "yotta", ()=>yotta);
parcelHelpers.export(exports, "zetta", ()=>zetta);
parcelHelpers.export(exports, "exa", ()=>exa);
parcelHelpers.export(exports, "peta", ()=>peta);
parcelHelpers.export(exports, "tera", ()=>tera);
parcelHelpers.export(exports, "giga", ()=>giga);
parcelHelpers.export(exports, "mega", ()=>mega);
parcelHelpers.export(exports, "kilo", ()=>kilo);
parcelHelpers.export(exports, "hecto", ()=>hecto);
parcelHelpers.export(exports, "deca", ()=>deca);
parcelHelpers.export(exports, "deci", ()=>deci);
parcelHelpers.export(exports, "centi", ()=>centi);
parcelHelpers.export(exports, "milli", ()=>milli);
parcelHelpers.export(exports, "micro", ()=>micro);
parcelHelpers.export(exports, "nano", ()=>nano);
parcelHelpers.export(exports, "pico", ()=>pico);
parcelHelpers.export(exports, "femto", ()=>femto);
parcelHelpers.export(exports, "atto", ()=>atto);
parcelHelpers.export(exports, "zepto", ()=>zepto);
parcelHelpers.export(exports, "yocto", ()=>yocto);
parcelHelpers.export(exports, "prefix", ()=>prefix);
var _mathJs = require("./math.js");
const yotta = 1e24;
const zetta = 1e21;
const exa = 1e18;
const peta = 1e15;
const tera = 1e12;
const giga = 1e9;
const mega = 1e6;
const kilo = 1e3;
const hecto = 1e2;
const deca = 10;
const deci = 0.1;
const centi = 0.01;
const milli = 1e-3;
const micro = 1e-6;
const nano = 1e-9;
const pico = 1e-12;
const femto = 1e-15;
const atto = 1e-18;
const zepto = 1e-21;
const yocto = 1e-24;
const prefixUp = [
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
];
const prefixDown = [
    "",
    "m",
    "\u03BC",
    "n",
    "p",
    "f",
    "a",
    "z",
    "y"
];
const prefix = (n, baseMultiplier = 0)=>{
    const nPow = n === 0 ? 0 : _mathJs.log10(n);
    let mult = 0;
    while(nPow < mult * 3 && baseMultiplier > -8){
        baseMultiplier--;
        mult--;
    }
    while(nPow >= 3 + mult * 3 && baseMultiplier < 8){
        baseMultiplier++;
        mult++;
    }
    const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];
    return {
        n: _mathJs.round((mult > 0 ? n / _mathJs.exp10(mult * 3) : n * _mathJs.exp10(mult * -3)) * 1e12) / 1e12,
        prefix
    };
};

},{"./math.js":"jhXHz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bzhu":[function(require,module,exports) {
/**
 * Utility functions to work with buffers (Uint8Array).
 *
 * @module buffer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createUint8ArrayFromLen", ()=>createUint8ArrayFromLen);
parcelHelpers.export(exports, "createUint8ArrayViewFromArrayBuffer", ()=>createUint8ArrayViewFromArrayBuffer);
parcelHelpers.export(exports, "createUint8ArrayFromArrayBuffer", ()=>createUint8ArrayFromArrayBuffer);
parcelHelpers.export(exports, "toBase64", ()=>toBase64);
parcelHelpers.export(exports, "fromBase64", ()=>fromBase64);
parcelHelpers.export(exports, "toBase64UrlEncoded", ()=>toBase64UrlEncoded);
parcelHelpers.export(exports, "fromBase64UrlEncoded", ()=>fromBase64UrlEncoded);
parcelHelpers.export(exports, "toHexString", ()=>toHexString);
parcelHelpers.export(exports, "fromHexString", ()=>fromHexString);
parcelHelpers.export(exports, "copyUint8Array", ()=>copyUint8Array);
parcelHelpers.export(exports, "encodeAny", ()=>encodeAny);
parcelHelpers.export(exports, "decodeAny", ()=>decodeAny);
parcelHelpers.export(exports, "shiftNBitsLeft", ()=>shiftNBitsLeft);
var _stringJs = require("./string.js");
var _environmentJs = require("./environment.js");
var _arrayJs = require("./array.js");
var _mathJs = require("./math.js");
var _encodingJs = require("./encoding.js");
var _decodingJs = require("./decoding.js");
var Buffer = require("6475e0e5014d10a8").Buffer;
const createUint8ArrayFromLen = (len)=>new Uint8Array(len);
const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length)=>new Uint8Array(buffer, byteOffset, length);
const createUint8ArrayFromArrayBuffer = (buffer)=>new Uint8Array(buffer);
/* c8 ignore start */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Browser = (bytes)=>{
    let s = "";
    for(let i = 0; i < bytes.byteLength; i++)s += _stringJs.fromCharCode(bytes[i]);
    // eslint-disable-next-line no-undef
    return btoa(s);
};
/* c8 ignore stop */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Node = (bytes)=>Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
/* c8 ignore start */ /**
 * @param {string} s
 * @return {Uint8Array}
 */ const fromBase64Browser = (s)=>{
    // eslint-disable-next-line no-undef
    const a = atob(s);
    const bytes = createUint8ArrayFromLen(a.length);
    for(let i = 0; i < a.length; i++)bytes[i] = a.charCodeAt(i);
    return bytes;
};
/* c8 ignore stop */ /**
 * @param {string} s
 */ const fromBase64Node = (s)=>{
    const buf = Buffer.from(s, "base64");
    return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
const toBase64 = _environmentJs.isBrowser ? toBase64Browser : toBase64Node;
const fromBase64 = _environmentJs.isBrowser ? fromBase64Browser : fromBase64Node;
const toBase64UrlEncoded = (buf)=>toBase64(buf).replaceAll("+", "-").replaceAll("/", "_").replaceAll("=", "");
const fromBase64UrlEncoded = (base64)=>fromBase64(base64.replaceAll("-", "+").replaceAll("_", "/"));
const toHexString = (buf)=>_arrayJs.map(buf, (b)=>b.toString(16).padStart(2, "0")).join("");
const fromHexString = (hex)=>{
    const hlen = hex.length;
    const buf = new Uint8Array(_mathJs.ceil(hlen / 2));
    for(let i = 0; i < hlen; i += 2)buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16);
    return buf;
};
const copyUint8Array = (uint8Array)=>{
    const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
    newBuf.set(uint8Array);
    return newBuf;
};
const encodeAny = (data)=>_encodingJs.encode((encoder)=>_encodingJs.writeAny(encoder, data));
const decodeAny = (buf)=>_decodingJs.readAny(_decodingJs.createDecoder(buf));
const shiftNBitsLeft = (bs, N)=>{
    if (N === 0) return bs;
    bs = new Uint8Array(bs);
    bs[0] <<= N;
    for(let i = 1; i < bs.length; i++){
        bs[i - 1] |= bs[i] >>> 8 - N;
        bs[i] <<= N;
    }
    return bs;
};

},{"6475e0e5014d10a8":"fCgem","./string.js":"cA9Az","./environment.js":"h8wYT","./array.js":"ef0AT","./math.js":"jhXHz","./encoding.js":"9yVNx","./decoding.js":"ftn2I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ "use strict";
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" // eslint-disable-line dot-notation
 ? Symbol["for"]("nodejs.util.inspect.custom") // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === "string") return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== "number") throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") encoding = "utf8";
    if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case "ascii":
        case "latin1":
        case "binary":
            return len;
        case "utf8":
        case "utf-8":
            return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return len * 2;
        case "hex":
            return len >>> 1;
        case "base64":
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return "";
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return "";
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return "";
    if (!encoding) encoding = "utf8";
    while(true)switch(encoding){
        case "hex":
            return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
            return utf8Slice(this, start, end);
        case "ascii":
            return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
            return latin1Slice(this, start, end);
        case "base64":
            return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === "string") val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = "utf8";
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for(;;)switch(encoding){
        case "hex":
            return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
            return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
            return asciiWrite(this, string, offset, length);
        case "base64":
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = "";
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== "string") throw new TypeError("encoding must be a string");
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === "number") val = val & 255;
    else if (typeof val === "boolean") val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, "message", {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, "code", {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return "Attempt to access memory outside buffer bounds";
}, RangeError);
E("ERR_INVALID_ARG_TYPE", function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, "offset");
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== "number") throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split("=")[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, "");
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return "";
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + "=";
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error("Invalid code point");
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports) {
"use strict";
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join("");
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==");
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=");
    }
    return parts.join("");
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"h8wYT":[function(require,module,exports) {
/**
 * Isomorphic module to work access the environment (query params, env variables).
 *
 * @module map
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "isMac", ()=>isMac);
parcelHelpers.export(exports, "hasParam", ()=>hasParam);
parcelHelpers.export(exports, "getParam", ()=>getParam);
parcelHelpers.export(exports, "getVariable", ()=>getVariable);
parcelHelpers.export(exports, "getConf", ()=>getConf);
parcelHelpers.export(exports, "hasConf", ()=>hasConf);
parcelHelpers.export(exports, "production", ()=>production);
parcelHelpers.export(exports, "supportsColor", ()=>supportsColor);
var _mapJs = require("./map.js");
var _stringJs = require("./string.js");
var _conditionsJs = require("./conditions.js");
var _storageJs = require("./storage.js");
var _functionJs = require("./function.js");
var process = require("2cfb8bcef1022e2a");
const isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
const isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
const isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
/**
 * @type {Map<string,string>}
 */ let params;
const args = [];
/* c8 ignore start */ const computeParams = ()=>{
    if (params === undefined) {
        if (isNode) {
            params = _mapJs.create();
            const pargs = process.argv;
            let currParamName = null;
            for(let i = 0; i < pargs.length; i++){
                const parg = pargs[i];
                if (parg[0] === "-") {
                    if (currParamName !== null) params.set(currParamName, "");
                    currParamName = parg;
                } else if (currParamName !== null) {
                    params.set(currParamName, parg);
                    currParamName = null;
                } else args.push(parg);
            }
            if (currParamName !== null) params.set(currParamName, "");
        // in ReactNative for example this would not be true (unless connected to the Remote Debugger)
        } else if (typeof location === "object") {
            params = _mapJs.create(); // eslint-disable-next-line no-undef
            (location.search || "?").slice(1).split("&").forEach((kv)=>{
                if (kv.length !== 0) {
                    const [key, value] = kv.split("=");
                    params.set(`--${_stringJs.fromCamelCase(key, "-")}`, value);
                    params.set(`-${_stringJs.fromCamelCase(key, "-")}`, value);
                }
            });
        } else params = _mapJs.create();
    }
    return params;
};
const hasParam = (name)=>computeParams().has(name);
const getParam = (name, defaultVal)=>computeParams().get(name) || defaultVal;
const getVariable = (name)=>isNode ? _conditionsJs.undefinedToNull(process.env[name.toUpperCase()]) : _conditionsJs.undefinedToNull(_storageJs.varStorage.getItem(name));
const getConf = (name)=>computeParams().get("--" + name) || getVariable(name);
const hasConf = (name)=>hasParam("--" + name) || getVariable(name) !== null;
const production = hasConf("production");
/* c8 ignore next 2 */ const forceColor = isNode && _functionJs.isOneOf(undefined, [
    "true",
    "1",
    "2"
]);
const supportsColor = !hasParam("no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color") /* c8 ignore stop */ );

},{"2cfb8bcef1022e2a":"d5jf4","./map.js":"eE1vX","./string.js":"cA9Az","./conditions.js":"dJDk6","./storage.js":"9FcRV","./function.js":"1O0Qj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5jf4":[function(require,module,exports) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
}
(function() {
    try {
        if (typeof setTimeout === "function") cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === "function") cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = ""; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error("process.binding is not supported");
};
process.cwd = function() {
    return "/";
};
process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
};
process.umask = function() {
    return 0;
};

},{}],"dJDk6":[function(require,module,exports) {
/**
 * Often used conditions.
 *
 * @module conditions
 */ /**
 * @template T
 * @param {T|null|undefined} v
 * @return {T|null}
 */ /* c8 ignore next */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "undefinedToNull", ()=>undefinedToNull);
const undefinedToNull = (v)=>v === undefined ? null : v;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9FcRV":[function(require,module,exports) {
/* eslint-env browser */ /**
 * Isomorphic variable storage.
 *
 * Uses LocalStorage in the browser and falls back to in-memory storage.
 *
 * @module storage
 */ /* c8 ignore start */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "varStorage", ()=>varStorage);
parcelHelpers.export(exports, "onChange", ()=>onChange);
parcelHelpers.export(exports, "offChange", ()=>offChange);
class VarStoragePolyfill {
    constructor(){
        this.map = new Map();
    }
    /**
   * @param {string} key
   * @param {any} newValue
   */ setItem(key, newValue) {
        this.map.set(key, newValue);
    }
    /**
   * @param {string} key
   */ getItem(key) {
        return this.map.get(key);
    }
}
/* c8 ignore stop */ /**
 * @type {any}
 */ let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
/* c8 ignore start */ try {
    // if the same-origin rule is violated, accessing localStorage might thrown an error
    if (typeof localStorage !== "undefined" && localStorage) {
        _localStorage = localStorage;
        usePolyfill = false;
    }
} catch (e) {}
const varStorage = _localStorage;
const onChange = (eventHandler)=>usePolyfill || addEventListener("storage", /** @type {any} */ eventHandler);
const offChange = (eventHandler)=>usePolyfill || removeEventListener("storage", /** @type {any} */ eventHandler);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1O0Qj":[function(require,module,exports) {
/**
 * Common functions and function call helpers.
 *
 * @module function
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "callAll", ()=>callAll);
parcelHelpers.export(exports, "nop", ()=>nop);
parcelHelpers.export(exports, "apply", ()=>apply);
parcelHelpers.export(exports, "id", ()=>id);
parcelHelpers.export(exports, "equalityStrict", ()=>equalityStrict);
parcelHelpers.export(exports, "equalityFlat", ()=>equalityFlat);
parcelHelpers.export(exports, "equalityDeep", ()=>equalityDeep);
parcelHelpers.export(exports, "isOneOf", ()=>isOneOf);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
parcelHelpers.export(exports, "is", ()=>is);
parcelHelpers.export(exports, "isTemplate", ()=>isTemplate);
var _arrayJs = require("./array.js");
var _objectJs = require("./object.js");
const callAll = (fs, args, i = 0)=>{
    try {
        for(; i < fs.length; i++)fs[i](...args);
    } finally{
        if (i < fs.length) callAll(fs, args, i + 1);
    }
};
const nop = ()=>{};
const apply = (f)=>f();
const id = (a)=>a;
const equalityStrict = (a, b)=>a === b;
const equalityFlat = (a, b)=>a === b || a != null && b != null && a.constructor === b.constructor && (_arrayJs.isArray(a) && _arrayJs.equalFlat(a, /** @type {Array<T>} */ b) || typeof a === "object" && _objectJs.equalFlat(a, b));
const equalityDeep = (a, b)=>{
    if (a == null || b == null) return equalityStrict(a, b);
    if (a.constructor !== b.constructor) return false;
    if (a === b) return true;
    switch(a.constructor){
        case ArrayBuffer:
            a = new Uint8Array(a);
            b = new Uint8Array(b);
        // eslint-disable-next-line no-fallthrough
        case Uint8Array:
            if (a.byteLength !== b.byteLength) return false;
            for(let i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
            break;
        case Set:
            if (a.size !== b.size) return false;
            for (const value of a){
                if (!b.has(value)) return false;
            }
            break;
        case Map:
            if (a.size !== b.size) return false;
            for (const key of a.keys()){
                if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) return false;
            }
            break;
        case Object:
            if (_objectJs.length(a) !== _objectJs.length(b)) return false;
            for(const key in a){
                if (!_objectJs.hasProperty(a, key) || !equalityDeep(a[key], b[key])) return false;
            }
            break;
        case Array:
            if (a.length !== b.length) return false;
            for(let i = 0; i < a.length; i++){
                if (!equalityDeep(a[i], b[i])) return false;
            }
            break;
        default:
            return false;
    }
    return true;
};
const isOneOf = (value, options)=>options.includes(value);
const isArray = _arrayJs.isArray;
const isString = (s)=>s && s.constructor === String;
const isNumber = (n)=>n != null && n.constructor === Number;
const is = (n, T)=>n && n.constructor === T;
const isTemplate = (T)=>/**
   * @param {any} n
   * @return {n is InstanceType<TYPE>}
   **/ (n)=>n && n.constructor === T;

},{"./array.js":"ef0AT","./object.js":"4uXcx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4uXcx":[function(require,module,exports) {
/**
 * Utility functions for working with EcmaScript objects.
 *
 * @module object
 */ /**
 * @return {Object<string,any>} obj
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "assign", ()=>assign);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "hasProperty", ()=>hasProperty);
parcelHelpers.export(exports, "equalFlat", ()=>equalFlat);
const create = ()=>Object.create(null);
const assign = Object.assign;
const keys = Object.keys;
const forEach = (obj, f)=>{
    for(const key in obj)f(obj[key], key);
};
const map = (obj, f)=>{
    const results = [];
    for(const key in obj)results.push(f(obj[key], key));
    return results;
};
const length = (obj)=>keys(obj).length;
const some = (obj, f)=>{
    for(const key in obj){
        if (f(obj[key], key)) return true;
    }
    return false;
};
const isEmpty = (obj)=>{
    // eslint-disable-next-line
    for(const _k in obj)return false;
    return true;
};
const every = (obj, f)=>{
    for(const key in obj){
        if (!f(obj[key], key)) return false;
    }
    return true;
};
const hasProperty = (obj, key)=>Object.prototype.hasOwnProperty.call(obj, key);
const equalFlat = (a, b)=>a === b || length(a) === length(b) && every(a, (val, key)=>(val !== undefined || hasProperty(b, key)) && b[key] === val);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klpvH":[function(require,module,exports) {
/**
 * Isomorphic logging module with support for colors!
 *
 * @module logging
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BOLD", ()=>(0, _loggingCommonJs.BOLD));
parcelHelpers.export(exports, "UNBOLD", ()=>(0, _loggingCommonJs.UNBOLD));
parcelHelpers.export(exports, "BLUE", ()=>(0, _loggingCommonJs.BLUE));
parcelHelpers.export(exports, "GREY", ()=>(0, _loggingCommonJs.GREY));
parcelHelpers.export(exports, "GREEN", ()=>(0, _loggingCommonJs.GREEN));
parcelHelpers.export(exports, "RED", ()=>(0, _loggingCommonJs.RED));
parcelHelpers.export(exports, "PURPLE", ()=>(0, _loggingCommonJs.PURPLE));
parcelHelpers.export(exports, "ORANGE", ()=>(0, _loggingCommonJs.ORANGE));
parcelHelpers.export(exports, "UNCOLOR", ()=>(0, _loggingCommonJs.UNCOLOR));
parcelHelpers.export(exports, "print", ()=>print);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "printError", ()=>printError);
parcelHelpers.export(exports, "printImg", ()=>printImg);
parcelHelpers.export(exports, "printImgBase64", ()=>printImgBase64);
parcelHelpers.export(exports, "group", ()=>group);
parcelHelpers.export(exports, "groupCollapsed", ()=>groupCollapsed);
parcelHelpers.export(exports, "groupEnd", ()=>groupEnd);
parcelHelpers.export(exports, "printDom", ()=>printDom);
parcelHelpers.export(exports, "printCanvas", ()=>printCanvas);
parcelHelpers.export(exports, "vconsoles", ()=>vconsoles);
/* c8 ignore start */ parcelHelpers.export(exports, "VConsole", ()=>VConsole);
parcelHelpers.export(exports, "createVConsole", ()=>createVConsole);
parcelHelpers.export(exports, "createModuleLogger", ()=>createModuleLogger);
var _environmentJs = require("./environment.js");
var _setJs = require("./set.js");
var _pairJs = require("./pair.js");
var _domJs = require("./dom.js");
var _jsonJs = require("./json.js");
var _mapJs = require("./map.js");
var _eventloopJs = require("./eventloop.js");
var _mathJs = require("./math.js");
var _loggingCommonJs = require("./logging.common.js");
/**
 * @type {Object<Symbol,pair.Pair<string,string>>}
 */ const _browserStyleMap = {
    [_loggingCommonJs.BOLD]: _pairJs.create("font-weight", "bold"),
    [_loggingCommonJs.UNBOLD]: _pairJs.create("font-weight", "normal"),
    [_loggingCommonJs.BLUE]: _pairJs.create("color", "blue"),
    [_loggingCommonJs.GREEN]: _pairJs.create("color", "green"),
    [_loggingCommonJs.GREY]: _pairJs.create("color", "grey"),
    [_loggingCommonJs.RED]: _pairJs.create("color", "red"),
    [_loggingCommonJs.PURPLE]: _pairJs.create("color", "purple"),
    [_loggingCommonJs.ORANGE]: _pairJs.create("color", "orange"),
    [_loggingCommonJs.UNCOLOR]: _pairJs.create("color", "black")
};
/**
 * @param {Array<string|Symbol|Object|number>} args
 * @return {Array<string|object|number>}
 */ /* c8 ignore start */ const computeBrowserLoggingArgs = (args)=>{
    const strBuilder = [];
    const styles = [];
    const currentStyle = _mapJs.create();
    /**
   * @type {Array<string|Object|number>}
   */ let logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) currentStyle.set(style.left, style.right);
        else {
            if (arg.constructor === String || arg.constructor === Number) {
                const style = _domJs.mapToStyleString(currentStyle);
                if (i > 0 || style.length > 0) {
                    strBuilder.push("%c" + arg);
                    styles.push(style);
                } else strBuilder.push(arg);
            } else break;
        }
    }
    if (i > 0) {
        // create logArgs with what we have so far
        logArgs = styles;
        logArgs.unshift(strBuilder.join(""));
    }
    // append the rest
    for(; i < args.length; i++){
        const arg = args[i];
        if (!(arg instanceof Symbol)) logArgs.push(arg);
    }
    return logArgs;
};
/* c8 ignore stop */ /* c8 ignore start */ const computeLoggingArgs = _environmentJs.supportsColor ? computeBrowserLoggingArgs : _loggingCommonJs.computeNoColorLoggingArgs;
const print = (...args)=>{
    console.log(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.print(args));
};
const warn = (...args)=>{
    console.warn(...computeLoggingArgs(args));
    args.unshift(_loggingCommonJs.ORANGE);
    vconsoles.forEach((vc)=>vc.print(args));
};
const printError = (err)=>{
    console.error(err);
    vconsoles.forEach((vc)=>vc.printError(err));
};
const printImg = (url, height)=>{
    if (_environmentJs.isBrowser) console.log("%c                      ", `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`);
    vconsoles.forEach((vc)=>vc.printImg(url, height));
};
const printImgBase64 = (base64, height)=>printImg(`data:image/gif;base64,${base64}`, height);
const group = (...args)=>{
    console.group(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.group(args));
};
const groupCollapsed = (...args)=>{
    console.groupCollapsed(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupCollapsed(args));
};
const groupEnd = ()=>{
    console.groupEnd();
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupEnd());
};
const printDom = (createNode)=>vconsoles.forEach((vc)=>vc.printDom(createNode()));
const printCanvas = (canvas, height)=>printImg(canvas.toDataURL(), height);
const vconsoles = _setJs.create();
/**
 * @param {Array<string|Symbol|Object|number>} args
 * @return {Array<Element>}
 */ /* c8 ignore start */ const _computeLineSpans = (args)=>{
    const spans = [];
    const currentStyle = new Map();
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) currentStyle.set(style.left, style.right);
        else {
            if (arg.constructor === String || arg.constructor === Number) {
                // @ts-ignore
                const span = _domJs.element("span", [
                    _pairJs.create("style", _domJs.mapToStyleString(currentStyle))
                ], [
                    _domJs.text(arg.toString())
                ]);
                if (span.innerHTML === "") span.innerHTML = "&nbsp;";
                spans.push(span);
            } else break;
        }
    }
    // append the rest
    for(; i < args.length; i++){
        let content = args[i];
        if (!(content instanceof Symbol)) {
            if (content.constructor !== String && content.constructor !== Number) content = " " + _jsonJs.stringify(content) + " ";
            spans.push(_domJs.element("span", [], [
                _domJs.text(/** @type {string} */ content)
            ]));
        }
    }
    return spans;
};
/* c8 ignore stop */ const lineStyle = "font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;";
class VConsole {
    /**
   * @param {Element} dom
   */ constructor(dom){
        this.dom = dom;
        /**
     * @type {Element}
     */ this.ccontainer = this.dom;
        this.depth = 0;
        vconsoles.add(this);
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   * @param {boolean} collapsed
   */ group(args, collapsed = false) {
        _eventloopJs.enqueue(()=>{
            const triangleDown = _domJs.element("span", [
                _pairJs.create("hidden", collapsed),
                _pairJs.create("style", "color:grey;font-size:120%;")
            ], [
                _domJs.text("\u25BC")
            ]);
            const triangleRight = _domJs.element("span", [
                _pairJs.create("hidden", !collapsed),
                _pairJs.create("style", "color:grey;font-size:125%;")
            ], [
                _domJs.text("\u25B6")
            ]);
            const content = _domJs.element("div", [
                _pairJs.create("style", `${lineStyle};padding-left:${this.depth * 10}px`)
            ], [
                triangleDown,
                triangleRight,
                _domJs.text(" ")
            ].concat(_computeLineSpans(args)));
            const nextContainer = _domJs.element("div", [
                _pairJs.create("hidden", collapsed)
            ]);
            const nextLine = _domJs.element("div", [], [
                content,
                nextContainer
            ]);
            _domJs.append(this.ccontainer, [
                nextLine
            ]);
            this.ccontainer = nextContainer;
            this.depth++;
            // when header is clicked, collapse/uncollapse container
            _domJs.addEventListener(content, "click", (_event)=>{
                nextContainer.toggleAttribute("hidden");
                triangleDown.toggleAttribute("hidden");
                triangleRight.toggleAttribute("hidden");
            });
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ groupCollapsed(args) {
        this.group(args, true);
    }
    groupEnd() {
        _eventloopJs.enqueue(()=>{
            if (this.depth > 0) {
                this.depth--;
                // @ts-ignore
                this.ccontainer = this.ccontainer.parentElement.parentElement;
            }
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ print(args) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                _domJs.element("div", [
                    _pairJs.create("style", `${lineStyle};padding-left:${this.depth * 10}px`)
                ], _computeLineSpans(args))
            ]);
        });
    }
    /**
   * @param {Error} err
   */ printError(err) {
        this.print([
            _loggingCommonJs.RED,
            _loggingCommonJs.BOLD,
            err.toString()
        ]);
    }
    /**
   * @param {string} url
   * @param {number} height
   */ printImg(url, height) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                _domJs.element("img", [
                    _pairJs.create("src", url),
                    _pairJs.create("height", `${_mathJs.round(height * 1.5)}px`)
                ])
            ]);
        });
    }
    /**
   * @param {Node} node
   */ printDom(node) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                node
            ]);
        });
    }
    destroy() {
        _eventloopJs.enqueue(()=>{
            vconsoles.delete(this);
        });
    }
}
const createVConsole = (dom)=>new VConsole(dom);
const createModuleLogger = (moduleName)=>_loggingCommonJs.createModuleLogger(print, moduleName);

},{"./environment.js":"h8wYT","./set.js":"iWXeP","./pair.js":"blx5T","./dom.js":"8bgtn","./json.js":"kW79v","./map.js":"eE1vX","./eventloop.js":"4SpJZ","./math.js":"jhXHz","./logging.common.js":"fApod","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"blx5T":[function(require,module,exports) {
/**
 * Working with value pairs.
 *
 * @module pair
 */ /**
 * @template L,R
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Pair", ()=>Pair);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "createReversed", ()=>createReversed);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "map", ()=>map);
class Pair {
    /**
   * @param {L} left
   * @param {R} right
   */ constructor(left, right){
        this.left = left;
        this.right = right;
    }
}
const create = (left, right)=>new Pair(left, right);
const createReversed = (right, left)=>new Pair(left, right);
const forEach = (arr, f)=>arr.forEach((p)=>f(p.left, p.right));
const map = (arr, f)=>arr.map((p)=>f(p.left, p.right));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bgtn":[function(require,module,exports) {
/* eslint-env browser */ /**
 * Utility module to work with the DOM.
 *
 * @module dom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "doc", ()=>doc);
parcelHelpers.export(exports, "createElement", ()=>createElement);
parcelHelpers.export(exports, "createDocumentFragment", ()=>createDocumentFragment);
parcelHelpers.export(exports, "createTextNode", ()=>createTextNode);
parcelHelpers.export(exports, "domParser", ()=>domParser);
parcelHelpers.export(exports, "emitCustomEvent", ()=>emitCustomEvent);
parcelHelpers.export(exports, "setAttributes", ()=>setAttributes);
parcelHelpers.export(exports, "setAttributesMap", ()=>setAttributesMap);
parcelHelpers.export(exports, "fragment", ()=>fragment);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "addEventListener", ()=>addEventListener);
parcelHelpers.export(exports, "removeEventListener", ()=>removeEventListener);
parcelHelpers.export(exports, "addEventListeners", ()=>addEventListeners);
parcelHelpers.export(exports, "removeEventListeners", ()=>removeEventListeners);
parcelHelpers.export(exports, "element", ()=>element);
parcelHelpers.export(exports, "canvas", ()=>canvas);
parcelHelpers.export(exports, "text", ()=>text);
parcelHelpers.export(exports, "pairToStyleString", ()=>pairToStyleString);
parcelHelpers.export(exports, "pairsToStyleString", ()=>pairsToStyleString);
parcelHelpers.export(exports, "mapToStyleString", ()=>mapToStyleString);
parcelHelpers.export(exports, "querySelector", ()=>querySelector);
parcelHelpers.export(exports, "querySelectorAll", ()=>querySelectorAll);
parcelHelpers.export(exports, "getElementById", ()=>getElementById);
parcelHelpers.export(exports, "parseFragment", ()=>parseFragment);
parcelHelpers.export(exports, "parseElement", ()=>parseElement);
parcelHelpers.export(exports, "replaceWith", ()=>replaceWith);
parcelHelpers.export(exports, "insertBefore", ()=>insertBefore);
parcelHelpers.export(exports, "appendChild", ()=>appendChild);
parcelHelpers.export(exports, "ELEMENT_NODE", ()=>ELEMENT_NODE);
parcelHelpers.export(exports, "TEXT_NODE", ()=>TEXT_NODE);
parcelHelpers.export(exports, "CDATA_SECTION_NODE", ()=>CDATA_SECTION_NODE);
parcelHelpers.export(exports, "COMMENT_NODE", ()=>COMMENT_NODE);
parcelHelpers.export(exports, "DOCUMENT_NODE", ()=>DOCUMENT_NODE);
parcelHelpers.export(exports, "DOCUMENT_TYPE_NODE", ()=>DOCUMENT_TYPE_NODE);
parcelHelpers.export(exports, "DOCUMENT_FRAGMENT_NODE", ()=>DOCUMENT_FRAGMENT_NODE);
parcelHelpers.export(exports, "checkNodeType", ()=>checkNodeType);
parcelHelpers.export(exports, "isParentOf", ()=>isParentOf);
var _pairJs = require("./pair.js");
var _mapJs = require("./map.js");
const doc = /** @type {Document} */ typeof document !== "undefined" ? document : {};
const createElement = (name)=>doc.createElement(name);
const createDocumentFragment = ()=>doc.createDocumentFragment();
const createTextNode = (text)=>doc.createTextNode(text);
const domParser = /** @type {DOMParser} */ typeof DOMParser !== "undefined" ? new DOMParser() : null;
const emitCustomEvent = (el, name, opts)=>el.dispatchEvent(new CustomEvent(name, opts));
const setAttributes = (el, attrs)=>{
    _pairJs.forEach(attrs, (key, value)=>{
        if (value === false) el.removeAttribute(key);
        else if (value === true) el.setAttribute(key, "");
        else // @ts-ignore
        el.setAttribute(key, value);
    });
    return el;
};
const setAttributesMap = (el, attrs)=>{
    attrs.forEach((value, key)=>{
        el.setAttribute(key, value);
    });
    return el;
};
const fragment = (children)=>{
    const fragment = createDocumentFragment();
    for(let i = 0; i < children.length; i++)appendChild(fragment, children[i]);
    return fragment;
};
const append = (parent, nodes)=>{
    appendChild(parent, fragment(nodes));
    return parent;
};
const remove = (el)=>el.remove();
const addEventListener = (el, name, f)=>el.addEventListener(name, f);
const removeEventListener = (el, name, f)=>el.removeEventListener(name, f);
const addEventListeners = (node, listeners)=>{
    _pairJs.forEach(listeners, (name, f)=>addEventListener(node, name, f));
    return node;
};
const removeEventListeners = (node, listeners)=>{
    _pairJs.forEach(listeners, (name, f)=>removeEventListener(node, name, f));
    return node;
};
const element = (name, attrs = [], children = [])=>append(setAttributes(createElement(name), attrs), children);
const canvas = (width, height)=>{
    const c = /** @type {HTMLCanvasElement} */ createElement("canvas");
    c.height = height;
    c.width = width;
    return c;
};
const text = createTextNode;
const pairToStyleString = (pair)=>`${pair.left}:${pair.right};`;
const pairsToStyleString = (pairs)=>pairs.map(pairToStyleString).join("");
const mapToStyleString = (m)=>_mapJs.map(m, (value, key)=>`${key}:${value};`).join("");
const querySelector = (el, query)=>el.querySelector(query);
const querySelectorAll = (el, query)=>el.querySelectorAll(query);
const getElementById = (id)=>/** @type {HTMLElement} */ doc.getElementById(id);
/**
 * @param {string} html
 * @return {HTMLElement}
 */ const _parse = (html)=>domParser.parseFromString(`<html><body>${html}</body></html>`, "text/html").body;
const parseFragment = (html)=>fragment(/** @type {any} */ _parse(html).childNodes);
const parseElement = (html)=>/** @type HTMLElement */ _parse(html).firstElementChild;
const replaceWith = (oldEl, newEl)=>oldEl.replaceWith(newEl);
const insertBefore = (parent, el, ref)=>parent.insertBefore(el, ref);
const appendChild = (parent, child)=>parent.appendChild(child);
const ELEMENT_NODE = doc.ELEMENT_NODE;
const TEXT_NODE = doc.TEXT_NODE;
const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
const COMMENT_NODE = doc.COMMENT_NODE;
const DOCUMENT_NODE = doc.DOCUMENT_NODE;
const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;
const checkNodeType = (node, type)=>node.nodeType === type;
const isParentOf = (parent, child)=>{
    let p = child.parentNode;
    while(p && p !== parent)p = p.parentNode;
    return p === parent;
} /* c8 ignore stop */ ;

},{"./pair.js":"blx5T","./map.js":"eE1vX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kW79v":[function(require,module,exports) {
/**
 * JSON utility functions.
 *
 * @module json
 */ /**
 * Transform JavaScript object to JSON.
 *
 * @param {any} object
 * @return {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringify", ()=>stringify);
parcelHelpers.export(exports, "parse", ()=>parse);
const stringify = JSON.stringify;
const parse = JSON.parse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4SpJZ":[function(require,module,exports) {
/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */ /**
 * Utility module to work with EcmaScript's event loop.
 *
 * @module eventloop
 */ /**
 * @type {Array<function>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "enqueue", ()=>enqueue);
parcelHelpers.export(exports, "timeout", ()=>timeout);
parcelHelpers.export(exports, "interval", ()=>interval);
parcelHelpers.export(exports, "Animation", ()=>Animation);
parcelHelpers.export(exports, "animationFrame", ()=>animationFrame);
parcelHelpers.export(exports, "idleCallback", ()=>idleCallback);
parcelHelpers.export(exports, "createDebouncer", ()=>createDebouncer);
let queue = [];
const _runQueue = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue = [];
};
const enqueue = (f)=>{
    queue.push(f);
    if (queue.length === 1) setTimeout(_runQueue, 0);
};
/**
 * @typedef {Object} TimeoutObject
 * @property {function} TimeoutObject.destroy
 */ /**
 * @param {function(number):void} clearFunction
 */ const createTimeoutClass = (clearFunction)=>class TT {
        /**
   * @param {number} timeoutId
   */ constructor(timeoutId){
            this._ = timeoutId;
        }
        destroy() {
            clearFunction(this._);
        }
    };
const Timeout = createTimeoutClass(clearTimeout);
const timeout = (timeout, callback)=>new Timeout(setTimeout(callback, timeout));
const Interval = createTimeoutClass(clearInterval);
const interval = (timeout, callback)=>new Interval(setInterval(callback, timeout));
const Animation = createTimeoutClass((arg)=>typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
const animationFrame = (cb)=>typeof requestAnimationFrame === "undefined" ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));
/* c8 ignore next */ // @ts-ignore
const Idle = createTimeoutClass((arg)=>typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));
const idleCallback = (cb)=>typeof requestIdleCallback !== "undefined" ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);
const createDebouncer = (timeout)=>{
    let timer = -1;
    return (f)=>{
        clearTimeout(timer);
        if (f) timer = /** @type {any} */ setTimeout(f, timeout);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fApod":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BOLD", ()=>BOLD);
parcelHelpers.export(exports, "UNBOLD", ()=>UNBOLD);
parcelHelpers.export(exports, "BLUE", ()=>BLUE);
parcelHelpers.export(exports, "GREY", ()=>GREY);
parcelHelpers.export(exports, "GREEN", ()=>GREEN);
parcelHelpers.export(exports, "RED", ()=>RED);
parcelHelpers.export(exports, "PURPLE", ()=>PURPLE);
parcelHelpers.export(exports, "ORANGE", ()=>ORANGE);
parcelHelpers.export(exports, "UNCOLOR", ()=>UNCOLOR);
parcelHelpers.export(exports, "computeNoColorLoggingArgs", ()=>computeNoColorLoggingArgs);
parcelHelpers.export(exports, "createModuleLogger", ()=>createModuleLogger);
var _symbolJs = require("./symbol.js");
var _timeJs = require("./time.js");
var _environmentJs = require("./environment.js");
var _functionJs = require("./function.js");
const BOLD = _symbolJs.create();
const UNBOLD = _symbolJs.create();
const BLUE = _symbolJs.create();
const GREY = _symbolJs.create();
const GREEN = _symbolJs.create();
const RED = _symbolJs.create();
const PURPLE = _symbolJs.create();
const ORANGE = _symbolJs.create();
const UNCOLOR = _symbolJs.create();
const computeNoColorLoggingArgs = (args)=>{
    const strBuilder = [];
    const logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        if (arg.constructor === String || arg.constructor === Number) strBuilder.push(arg);
        else if (arg.constructor === Object) logArgs.push(JSON.stringify(arg));
    }
    return logArgs;
};
/* c8 ignore stop */ const loggingColors = [
    GREEN,
    PURPLE,
    ORANGE,
    BLUE
];
let nextColor = 0;
let lastLoggingTime = _timeJs.getUnixTime();
const createModuleLogger = (_print, moduleName)=>{
    const color = loggingColors[nextColor];
    const debugRegexVar = _environmentJs.getVariable("log");
    const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
    nextColor = (nextColor + 1) % loggingColors.length;
    moduleName += ": ";
    return !doLogging ? _functionJs.nop : (...args)=>{
        const timeNow = _timeJs.getUnixTime();
        const timeDiff = timeNow - lastLoggingTime;
        lastLoggingTime = timeNow;
        _print(color, moduleName, UNCOLOR, ...args.map((arg)=>typeof arg === "string" || typeof arg === "symbol" ? arg : JSON.stringify(arg)), color, " +" + timeDiff + "ms");
    };
} /* c8 ignore stop */ ;

},{"./symbol.js":"c24xy","./time.js":"gZsVK","./environment.js":"h8wYT","./function.js":"1O0Qj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c24xy":[function(require,module,exports) {
/**
 * Utility module to work with EcmaScript Symbols.
 *
 * @module symbol
 */ /**
 * Return fresh symbol.
 *
 * @return {Symbol}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
const create = Symbol;
const isSymbol = (s)=>typeof s === "symbol";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFgMm":[function(require,module,exports) {
/**
 * Utility module to create and manipulate Iterators.
 *
 * @module iterator
 */ /**
 * @template T,R
 * @param {Iterator<T>} iterator
 * @param {function(T):R} f
 * @return {IterableIterator<R>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapIterator", ()=>mapIterator);
parcelHelpers.export(exports, "createIterator", ()=>createIterator);
parcelHelpers.export(exports, "iteratorFilter", ()=>iteratorFilter);
parcelHelpers.export(exports, "iteratorMap", ()=>iteratorMap);
const mapIterator = (iterator, f)=>({
        [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next () {
            const r = iterator.next();
            return {
                value: r.done ? undefined : f(r.value),
                done: r.done
            };
        }
    });
const createIterator = (next)=>({
        /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next
    });
const iteratorFilter = (iterator, filter)=>createIterator(()=>{
        let res;
        do res = iterator.next();
        while (!res.done && !filter(res.value));
        return res;
    });
const iteratorMap = (iterator, fmap)=>createIterator(()=>{
        const { done, value } = iterator.next();
        return {
            done,
            value: done ? undefined : fmap(value)
        };
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g8NHk":[function(require,module,exports) {
/**
 * @module provider/websocket
 */ /* eslint-env browser */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messageSync", ()=>messageSync);
parcelHelpers.export(exports, "messageQueryAwareness", ()=>messageQueryAwareness);
parcelHelpers.export(exports, "messageAwareness", ()=>messageAwareness);
parcelHelpers.export(exports, "messageAuth", ()=>messageAuth);
/**
 * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.
 * The document name is attached to the provided url. I.e. the following example
 * creates a websocket connection to http://localhost:1234/my-document-name
 *
 * @example
 *   import * as Y from 'yjs'
 *   import { WebsocketProvider } from 'y-websocket'
 *   const doc = new Y.Doc()
 *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)
 *
 * @extends {Observable<string>}
 */ parcelHelpers.export(exports, "WebsocketProvider", ()=>WebsocketProvider);
var _yjs = require("yjs"); // eslint-disable-line
var _broadcastchannel = require("lib0/broadcastchannel");
var _time = require("lib0/time");
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _sync = require("y-protocols/sync");
var _auth = require("y-protocols/auth");
var _awareness = require("y-protocols/awareness");
var _observable = require("lib0/observable");
var _math = require("lib0/math");
var _url = require("lib0/url");
var _environment = require("lib0/environment");
var process = require("43b6cd2f9b5e450b");
const messageSync = 0;
const messageQueryAwareness = 3;
const messageAwareness = 1;
const messageAuth = 2;
/**
 *                       encoder,          decoder,          provider,          emitSynced, messageType
 * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}
 */ const messageHandlers = [];
messageHandlers[messageSync] = (encoder, decoder, provider, emitSynced, _messageType)=>{
    _encoding.writeVarUint(encoder, messageSync);
    const syncMessageType = _sync.readSyncMessage(decoder, encoder, provider.doc, provider);
    if (emitSynced && syncMessageType === _sync.messageYjsSyncStep2 && !provider.synced) provider.synced = true;
};
messageHandlers[messageQueryAwareness] = (encoder, _decoder, provider, _emitSynced, _messageType)=>{
    _encoding.writeVarUint(encoder, messageAwareness);
    _encoding.writeVarUint8Array(encoder, _awareness.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));
};
messageHandlers[messageAwareness] = (_encoder, decoder, provider, _emitSynced, _messageType)=>{
    _awareness.applyAwarenessUpdate(provider.awareness, _decoding.readVarUint8Array(decoder), provider);
};
messageHandlers[messageAuth] = (_encoder, decoder, provider, _emitSynced, _messageType)=>{
    _auth.readAuthMessage(decoder, provider.doc, (_ydoc, reason)=>permissionDeniedHandler(provider, reason));
};
// @todo - this should depend on awareness.outdatedTime
const messageReconnectTimeout = 30000;
/**
 * @param {WebsocketProvider} provider
 * @param {string} reason
 */ const permissionDeniedHandler = (provider, reason)=>console.warn(`Permission denied to access ${provider.url}.\n${reason}`);
/**
 * @param {WebsocketProvider} provider
 * @param {Uint8Array} buf
 * @param {boolean} emitSynced
 * @return {encoding.Encoder}
 */ const readMessage = (provider, buf, emitSynced)=>{
    const decoder = _decoding.createDecoder(buf);
    const encoder = _encoding.createEncoder();
    const messageType = _decoding.readVarUint(decoder);
    const messageHandler = provider.messageHandlers[messageType];
    if (/** @type {any} */ messageHandler) messageHandler(encoder, decoder, provider, emitSynced, messageType);
    else console.error("Unable to compute message");
    return encoder;
};
/**
 * @param {WebsocketProvider} provider
 */ const setupWS = (provider)=>{
    if (provider.shouldConnect && provider.ws === null) {
        const websocket = new provider._WS(provider.url);
        websocket.binaryType = "arraybuffer";
        provider.ws = websocket;
        provider.wsconnecting = true;
        provider.wsconnected = false;
        provider.synced = false;
        websocket.onmessage = (event)=>{
            provider.wsLastMessageReceived = _time.getUnixTime();
            const encoder = readMessage(provider, new Uint8Array(event.data), true);
            if (_encoding.length(encoder) > 1) websocket.send(_encoding.toUint8Array(encoder));
        };
        websocket.onerror = (event)=>{
            provider.emit("connection-error", [
                event,
                provider
            ]);
        };
        websocket.onclose = (event)=>{
            provider.emit("connection-close", [
                event,
                provider
            ]);
            provider.ws = null;
            provider.wsconnecting = false;
            if (provider.wsconnected) {
                provider.wsconnected = false;
                provider.synced = false;
                // update awareness (all users except local left)
                _awareness.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter((client)=>client !== provider.doc.clientID), provider);
                provider.emit("status", [
                    {
                        status: "disconnected"
                    }
                ]);
            } else provider.wsUnsuccessfulReconnects++;
            // Start with no reconnect timeout and increase timeout by
            // using exponential backoff starting with 100ms
            setTimeout(setupWS, _math.min(_math.pow(2, provider.wsUnsuccessfulReconnects) * 100, provider.maxBackoffTime), provider);
        };
        websocket.onopen = ()=>{
            provider.wsLastMessageReceived = _time.getUnixTime();
            provider.wsconnecting = false;
            provider.wsconnected = true;
            provider.wsUnsuccessfulReconnects = 0;
            provider.emit("status", [
                {
                    status: "connected"
                }
            ]);
            // always send sync step 1 when connected
            const encoder = _encoding.createEncoder();
            _encoding.writeVarUint(encoder, messageSync);
            _sync.writeSyncStep1(encoder, provider.doc);
            websocket.send(_encoding.toUint8Array(encoder));
            // broadcast local awareness state
            if (provider.awareness.getLocalState() !== null) {
                const encoderAwarenessState = _encoding.createEncoder();
                _encoding.writeVarUint(encoderAwarenessState, messageAwareness);
                _encoding.writeVarUint8Array(encoderAwarenessState, _awareness.encodeAwarenessUpdate(provider.awareness, [
                    provider.doc.clientID
                ]));
                websocket.send(_encoding.toUint8Array(encoderAwarenessState));
            }
        };
        provider.emit("status", [
            {
                status: "connecting"
            }
        ]);
    }
};
/**
 * @param {WebsocketProvider} provider
 * @param {ArrayBuffer} buf
 */ const broadcastMessage = (provider, buf)=>{
    const ws = provider.ws;
    if (provider.wsconnected && ws && ws.readyState === ws.OPEN) ws.send(buf);
    if (provider.bcconnected) _broadcastchannel.publish(provider.bcChannel, buf, provider);
};
class WebsocketProvider extends (0, _observable.Observable) {
    /**
   * @param {string} serverUrl
   * @param {string} roomname
   * @param {Y.Doc} doc
   * @param {object} opts
   * @param {boolean} [opts.connect]
   * @param {awarenessProtocol.Awareness} [opts.awareness]
   * @param {Object<string,string>} [opts.params]
   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill
   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds
   * @param {number} [opts.maxBackoffTime] Maximum amount of time to wait before trying to reconnect (we try to reconnect using exponential backoff)
   * @param {boolean} [opts.disableBc] Disable cross-tab BroadcastChannel communication
   */ constructor(serverUrl, roomname, doc, { connect = true, awareness = new _awareness.Awareness(doc), params = {}, WebSocketPolyfill = WebSocket, resyncInterval = -1, maxBackoffTime = 2500, disableBc = false } = {}){
        super();
        // ensure that url is always ends with /
        while(serverUrl[serverUrl.length - 1] === "/")serverUrl = serverUrl.slice(0, serverUrl.length - 1);
        const encodedParams = _url.encodeQueryParams(params);
        this.maxBackoffTime = maxBackoffTime;
        this.bcChannel = serverUrl + "/" + roomname;
        this.url = serverUrl + "/" + roomname + (encodedParams.length === 0 ? "" : "?" + encodedParams);
        this.roomname = roomname;
        this.doc = doc;
        this._WS = WebSocketPolyfill;
        this.awareness = awareness;
        this.wsconnected = false;
        this.wsconnecting = false;
        this.bcconnected = false;
        this.disableBc = disableBc;
        this.wsUnsuccessfulReconnects = 0;
        this.messageHandlers = messageHandlers.slice();
        /**
     * @type {boolean}
     */ this._synced = false;
        /**
     * @type {WebSocket?}
     */ this.ws = null;
        this.wsLastMessageReceived = 0;
        /**
     * Whether to connect to other peers or not
     * @type {boolean}
     */ this.shouldConnect = connect;
        /**
     * @type {number}
     */ this._resyncInterval = 0;
        if (resyncInterval > 0) this._resyncInterval = /** @type {any} */ setInterval(()=>{
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                // resend sync step 1
                const encoder = _encoding.createEncoder();
                _encoding.writeVarUint(encoder, messageSync);
                _sync.writeSyncStep1(encoder, doc);
                this.ws.send(_encoding.toUint8Array(encoder));
            }
        }, resyncInterval);
        /**
     * @param {ArrayBuffer} data
     * @param {any} origin
     */ this._bcSubscriber = (data, origin)=>{
            if (origin !== this) {
                const encoder = readMessage(this, new Uint8Array(data), false);
                if (_encoding.length(encoder) > 1) _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoder), this);
            }
        };
        /**
     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)
     * @param {Uint8Array} update
     * @param {any} origin
     */ this._updateHandler = (update, origin)=>{
            if (origin !== this) {
                const encoder = _encoding.createEncoder();
                _encoding.writeVarUint(encoder, messageSync);
                _sync.writeUpdate(encoder, update);
                broadcastMessage(this, _encoding.toUint8Array(encoder));
            }
        };
        this.doc.on("update", this._updateHandler);
        /**
     * @param {any} changed
     * @param {any} _origin
     */ this._awarenessUpdateHandler = ({ added, updated, removed }, _origin)=>{
            const changedClients = added.concat(updated).concat(removed);
            const encoder = _encoding.createEncoder();
            _encoding.writeVarUint(encoder, messageAwareness);
            _encoding.writeVarUint8Array(encoder, _awareness.encodeAwarenessUpdate(awareness, changedClients));
            broadcastMessage(this, _encoding.toUint8Array(encoder));
        };
        this._exitHandler = ()=>{
            _awareness.removeAwarenessStates(this.awareness, [
                doc.clientID
            ], "app closed");
        };
        if (_environment.isNode && typeof process !== "undefined") process.on("exit", this._exitHandler);
        awareness.on("update", this._awarenessUpdateHandler);
        this._checkInterval = /** @type {any} */ setInterval(()=>{
            if (this.wsconnected && messageReconnectTimeout < _time.getUnixTime() - this.wsLastMessageReceived) // no message received in a long time - not even your own awareness
            // updates (which are updated every 15 seconds)
            /** @type {WebSocket} */ this.ws.close();
        }, messageReconnectTimeout / 10);
        if (connect) this.connect();
    }
    /**
   * @type {boolean}
   */ get synced() {
        return this._synced;
    }
    set synced(state) {
        if (this._synced !== state) {
            this._synced = state;
            this.emit("synced", [
                state
            ]);
            this.emit("sync", [
                state
            ]);
        }
    }
    destroy() {
        if (this._resyncInterval !== 0) clearInterval(this._resyncInterval);
        clearInterval(this._checkInterval);
        this.disconnect();
        if (typeof process !== "undefined") process.off("exit", this._exitHandler);
        this.awareness.off("update", this._awarenessUpdateHandler);
        this.doc.off("update", this._updateHandler);
        super.destroy();
    }
    connectBc() {
        if (this.disableBc) return;
        if (!this.bcconnected) {
            _broadcastchannel.subscribe(this.bcChannel, this._bcSubscriber);
            this.bcconnected = true;
        }
        // send sync step1 to bc
        // write sync step 1
        const encoderSync = _encoding.createEncoder();
        _encoding.writeVarUint(encoderSync, messageSync);
        _sync.writeSyncStep1(encoderSync, this.doc);
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderSync), this);
        // broadcast local state
        const encoderState = _encoding.createEncoder();
        _encoding.writeVarUint(encoderState, messageSync);
        _sync.writeSyncStep2(encoderState, this.doc);
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderState), this);
        // write queryAwareness
        const encoderAwarenessQuery = _encoding.createEncoder();
        _encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderAwarenessQuery), this);
        // broadcast local awareness state
        const encoderAwarenessState = _encoding.createEncoder();
        _encoding.writeVarUint(encoderAwarenessState, messageAwareness);
        _encoding.writeVarUint8Array(encoderAwarenessState, _awareness.encodeAwarenessUpdate(this.awareness, [
            this.doc.clientID
        ]));
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderAwarenessState), this);
    }
    disconnectBc() {
        // broadcast message with local awareness state set to null (indicating disconnect)
        const encoder = _encoding.createEncoder();
        _encoding.writeVarUint(encoder, messageAwareness);
        _encoding.writeVarUint8Array(encoder, _awareness.encodeAwarenessUpdate(this.awareness, [
            this.doc.clientID
        ], new Map()));
        broadcastMessage(this, _encoding.toUint8Array(encoder));
        if (this.bcconnected) {
            _broadcastchannel.unsubscribe(this.bcChannel, this._bcSubscriber);
            this.bcconnected = false;
        }
    }
    disconnect() {
        this.shouldConnect = false;
        this.disconnectBc();
        if (this.ws !== null) this.ws.close();
    }
    connect() {
        this.shouldConnect = true;
        if (!this.wsconnected && this.ws === null) {
            setupWS(this);
            this.connectBc();
        }
    }
}

},{"43b6cd2f9b5e450b":"d5jf4","yjs":"gj9M9","lib0/broadcastchannel":"gKGkU","lib0/time":"gZsVK","lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","y-protocols/sync":"kgJVk","y-protocols/auth":"flacp","y-protocols/awareness":"57xPu","lib0/observable":"20Rfd","lib0/math":"jhXHz","lib0/url":"60si9","lib0/environment":"h8wYT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKGkU":[function(require,module,exports) {
/* eslint-env browser */ /**
 * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.
 *
 * ```js
 * // In browser window A:
 * broadcastchannel.subscribe('my events', data => console.log(data))
 * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab
 *
 * // In browser window B:
 * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'
 * ```
 *
 * @module broadcastchannel
 */ // @todo before next major: use Uint8Array instead as buffer object
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribe", ()=>subscribe);
parcelHelpers.export(exports, "unsubscribe", ()=>unsubscribe);
parcelHelpers.export(exports, "publish", ()=>publish);
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
var _bufferJs = require("./buffer.js");
var _storageJs = require("./storage.js");
/**
 * @typedef {Object} Channel
 * @property {Set<function(any, any):any>} Channel.subs
 * @property {any} Channel.bc
 */ /**
 * @type {Map<string, Channel>}
 */ const channels = new Map();
/* c8 ignore start */ class LocalStoragePolyfill {
    /**
   * @param {string} room
   */ constructor(room){
        this.room = room;
        /**
     * @type {null|function({data:ArrayBuffer}):void}
     */ this.onmessage = null;
        /**
     * @param {any} e
     */ this._onChange = (e)=>e.key === room && this.onmessage !== null && this.onmessage({
                data: _bufferJs.fromBase64(e.newValue || "")
            });
        _storageJs.onChange(this._onChange);
    }
    /**
   * @param {ArrayBuffer} buf
   */ postMessage(buf) {
        _storageJs.varStorage.setItem(this.room, _bufferJs.toBase64(_bufferJs.createUint8ArrayFromArrayBuffer(buf)));
    }
    close() {
        _storageJs.offChange(this._onChange);
    }
}
/* c8 ignore stop */ // Use BroadcastChannel or Polyfill
/* c8 ignore next */ const BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
/**
 * @param {string} room
 * @return {Channel}
 */ const getChannel = (room)=>_mapJs.setIfUndefined(channels, room, ()=>{
        const subs = _setJs.create();
        const bc = new BC(room);
        /**
     * @param {{data:ArrayBuffer}} e
     */ /* c8 ignore next */ bc.onmessage = (e)=>subs.forEach((sub)=>sub(e.data, "broadcastchannel"));
        return {
            bc,
            subs
        };
    });
const subscribe = (room, f)=>{
    getChannel(room).subs.add(f);
    return f;
};
const unsubscribe = (room, f)=>{
    const channel = getChannel(room);
    const unsubscribed = channel.subs.delete(f);
    if (unsubscribed && channel.subs.size === 0) {
        channel.bc.close();
        channels.delete(room);
    }
    return unsubscribed;
};
const publish = (room, data, origin = null)=>{
    const c = getChannel(room);
    c.bc.postMessage(data);
    c.subs.forEach((sub)=>sub(data, origin));
};

},{"./map.js":"eE1vX","./set.js":"iWXeP","./buffer.js":"3bzhu","./storage.js":"9FcRV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kgJVk":[function(require,module,exports) {
/**
 * @module sync-protocol
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messageYjsSyncStep1", ()=>messageYjsSyncStep1);
parcelHelpers.export(exports, "messageYjsSyncStep2", ()=>messageYjsSyncStep2);
parcelHelpers.export(exports, "messageYjsUpdate", ()=>messageYjsUpdate);
parcelHelpers.export(exports, "writeSyncStep1", ()=>writeSyncStep1);
parcelHelpers.export(exports, "writeSyncStep2", ()=>writeSyncStep2);
parcelHelpers.export(exports, "readSyncStep1", ()=>readSyncStep1);
parcelHelpers.export(exports, "readSyncStep2", ()=>readSyncStep2);
parcelHelpers.export(exports, "writeUpdate", ()=>writeUpdate);
parcelHelpers.export(exports, "readUpdate", ()=>readUpdate);
parcelHelpers.export(exports, "readSyncMessage", ()=>readSyncMessage);
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _yjs = require("yjs");
const messageYjsSyncStep1 = 0;
const messageYjsSyncStep2 = 1;
const messageYjsUpdate = 2;
const writeSyncStep1 = (encoder, doc)=>{
    _encoding.writeVarUint(encoder, messageYjsSyncStep1);
    const sv = _yjs.encodeStateVector(doc);
    _encoding.writeVarUint8Array(encoder, sv);
};
const writeSyncStep2 = (encoder, doc, encodedStateVector)=>{
    _encoding.writeVarUint(encoder, messageYjsSyncStep2);
    _encoding.writeVarUint8Array(encoder, _yjs.encodeStateAsUpdate(doc, encodedStateVector));
};
const readSyncStep1 = (decoder, encoder, doc)=>writeSyncStep2(encoder, doc, _decoding.readVarUint8Array(decoder));
const readSyncStep2 = (decoder, doc, transactionOrigin)=>{
    try {
        _yjs.applyUpdate(doc, _decoding.readVarUint8Array(decoder), transactionOrigin);
    } catch (error) {
        // This catches errors that are thrown by event handlers
        console.error("Caught error while handling a Yjs update", error);
    }
};
const writeUpdate = (encoder, update)=>{
    _encoding.writeVarUint(encoder, messageYjsUpdate);
    _encoding.writeVarUint8Array(encoder, update);
};
const readUpdate = readSyncStep2;
const readSyncMessage = (decoder, encoder, doc, transactionOrigin)=>{
    const messageType = _decoding.readVarUint(decoder);
    switch(messageType){
        case messageYjsSyncStep1:
            readSyncStep1(decoder, encoder, doc);
            break;
        case messageYjsSyncStep2:
            readSyncStep2(decoder, doc, transactionOrigin);
            break;
        case messageYjsUpdate:
            readUpdate(decoder, doc, transactionOrigin);
            break;
        default:
            throw new Error("Unknown message type");
    }
    return messageType;
};

},{"lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","yjs":"gj9M9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"flacp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messagePermissionDenied", ()=>messagePermissionDenied);
parcelHelpers.export(exports, "writePermissionDenied", ()=>writePermissionDenied);
parcelHelpers.export(exports, "readAuthMessage", ()=>readAuthMessage);
var _yjs = require("yjs"); // eslint-disable-line
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
const messagePermissionDenied = 0;
const writePermissionDenied = (encoder, reason)=>{
    _encoding.writeVarUint(encoder, messagePermissionDenied);
    _encoding.writeVarString(encoder, reason);
};
const readAuthMessage = (decoder, y, permissionDeniedHandler)=>{
    switch(_decoding.readVarUint(decoder)){
        case messagePermissionDenied:
            permissionDeniedHandler(y, _decoding.readVarString(decoder));
    }
};

},{"yjs":"gj9M9","lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57xPu":[function(require,module,exports) {
/**
 * @module awareness-protocol
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "outdatedTimeout", ()=>outdatedTimeout);
/**
 * @typedef {Object} MetaClientState
 * @property {number} MetaClientState.clock
 * @property {number} MetaClientState.lastUpdated unix timestamp
 */ /**
 * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information
 * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of
 * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.
 *
 * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override
 * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is
 * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that
 * a remote client is offline, it may propagate a message with
 * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a
 * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.
 *
 * Before a client disconnects, it should propagate a `null` state with an updated clock.
 *
 * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.
 *
 * @extends {Observable<string>}
 */ parcelHelpers.export(exports, "Awareness", ()=>Awareness);
parcelHelpers.export(exports, "removeAwarenessStates", ()=>removeAwarenessStates);
parcelHelpers.export(exports, "encodeAwarenessUpdate", ()=>encodeAwarenessUpdate);
parcelHelpers.export(exports, "modifyAwarenessUpdate", ()=>modifyAwarenessUpdate);
parcelHelpers.export(exports, "applyAwarenessUpdate", ()=>applyAwarenessUpdate);
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _time = require("lib0/time");
var _math = require("lib0/math");
var _observable = require("lib0/observable");
var _function = require("lib0/function");
var _yjs = require("yjs"); // eslint-disable-line
const outdatedTimeout = 30000;
class Awareness extends (0, _observable.Observable) {
    /**
   * @param {Y.Doc} doc
   */ constructor(doc){
        super();
        this.doc = doc;
        /**
     * @type {number}
     */ this.clientID = doc.clientID;
        /**
     * Maps from client id to client state
     * @type {Map<number, Object<string, any>>}
     */ this.states = new Map();
        /**
     * @type {Map<number, MetaClientState>}
     */ this.meta = new Map();
        this._checkInterval = /** @type {any} */ setInterval(()=>{
            const now = _time.getUnixTime();
            if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ this.meta.get(this.clientID).lastUpdated) // renew local clock
            this.setLocalState(this.getLocalState());
            /**
       * @type {Array<number>}
       */ const remove = [];
            this.meta.forEach((meta, clientid)=>{
                if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) remove.push(clientid);
            });
            if (remove.length > 0) removeAwarenessStates(this, remove, "timeout");
        }, _math.floor(outdatedTimeout / 10));
        doc.on("destroy", ()=>{
            this.destroy();
        });
        this.setLocalState({});
    }
    destroy() {
        this.emit("destroy", [
            this
        ]);
        this.setLocalState(null);
        super.destroy();
        clearInterval(this._checkInterval);
    }
    /**
   * @return {Object<string,any>|null}
   */ getLocalState() {
        return this.states.get(this.clientID) || null;
    }
    /**
   * @param {Object<string,any>|null} state
   */ setLocalState(state) {
        const clientID = this.clientID;
        const currLocalMeta = this.meta.get(clientID);
        const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;
        const prevState = this.states.get(clientID);
        if (state === null) this.states.delete(clientID);
        else this.states.set(clientID, state);
        this.meta.set(clientID, {
            clock,
            lastUpdated: _time.getUnixTime()
        });
        const added = [];
        const updated = [];
        const filteredUpdated = [];
        const removed = [];
        if (state === null) removed.push(clientID);
        else if (prevState == null) {
            if (state != null) added.push(clientID);
        } else {
            updated.push(clientID);
            if (!_function.equalityDeep(prevState, state)) filteredUpdated.push(clientID);
        }
        if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) this.emit("change", [
            {
                added,
                updated: filteredUpdated,
                removed
            },
            "local"
        ]);
        this.emit("update", [
            {
                added,
                updated,
                removed
            },
            "local"
        ]);
    }
    /**
   * @param {string} field
   * @param {any} value
   */ setLocalStateField(field, value) {
        const state = this.getLocalState();
        if (state !== null) this.setLocalState({
            ...state,
            [field]: value
        });
    }
    /**
   * @return {Map<number,Object<string,any>>}
   */ getStates() {
        return this.states;
    }
}
const removeAwarenessStates = (awareness, clients, origin)=>{
    const removed = [];
    for(let i = 0; i < clients.length; i++){
        const clientID = clients[i];
        if (awareness.states.has(clientID)) {
            awareness.states.delete(clientID);
            if (clientID === awareness.clientID) {
                const curMeta = /** @type {MetaClientState} */ awareness.meta.get(clientID);
                awareness.meta.set(clientID, {
                    clock: curMeta.clock + 1,
                    lastUpdated: _time.getUnixTime()
                });
            }
            removed.push(clientID);
        }
    }
    if (removed.length > 0) {
        awareness.emit("change", [
            {
                added: [],
                updated: [],
                removed
            },
            origin
        ]);
        awareness.emit("update", [
            {
                added: [],
                updated: [],
                removed
            },
            origin
        ]);
    }
};
const encodeAwarenessUpdate = (awareness, clients, states = awareness.states)=>{
    const len = clients.length;
    const encoder = _encoding.createEncoder();
    _encoding.writeVarUint(encoder, len);
    for(let i = 0; i < len; i++){
        const clientID = clients[i];
        const state = states.get(clientID) || null;
        const clock = /** @type {MetaClientState} */ awareness.meta.get(clientID).clock;
        _encoding.writeVarUint(encoder, clientID);
        _encoding.writeVarUint(encoder, clock);
        _encoding.writeVarString(encoder, JSON.stringify(state));
    }
    return _encoding.toUint8Array(encoder);
};
const modifyAwarenessUpdate = (update, modify)=>{
    const decoder = _decoding.createDecoder(update);
    const encoder = _encoding.createEncoder();
    const len = _decoding.readVarUint(decoder);
    _encoding.writeVarUint(encoder, len);
    for(let i = 0; i < len; i++){
        const clientID = _decoding.readVarUint(decoder);
        const clock = _decoding.readVarUint(decoder);
        const state = JSON.parse(_decoding.readVarString(decoder));
        const modifiedState = modify(state);
        _encoding.writeVarUint(encoder, clientID);
        _encoding.writeVarUint(encoder, clock);
        _encoding.writeVarString(encoder, JSON.stringify(modifiedState));
    }
    return _encoding.toUint8Array(encoder);
};
const applyAwarenessUpdate = (awareness, update, origin)=>{
    const decoder = _decoding.createDecoder(update);
    const timestamp = _time.getUnixTime();
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    const len = _decoding.readVarUint(decoder);
    for(let i = 0; i < len; i++){
        const clientID = _decoding.readVarUint(decoder);
        let clock = _decoding.readVarUint(decoder);
        const state = JSON.parse(_decoding.readVarString(decoder));
        const clientMeta = awareness.meta.get(clientID);
        const prevState = awareness.states.get(clientID);
        const currClock = clientMeta === undefined ? 0 : clientMeta.clock;
        if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
            if (state === null) {
                // never let a remote client remove this local state
                if (clientID === awareness.clientID && awareness.getLocalState() != null) // remote client removed the local state. Do not remote state. Broadcast a message indicating
                // that this client still exists by increasing the clock
                clock++;
                else awareness.states.delete(clientID);
            } else awareness.states.set(clientID, state);
            awareness.meta.set(clientID, {
                clock,
                lastUpdated: timestamp
            });
            if (clientMeta === undefined && state !== null) added.push(clientID);
            else if (clientMeta !== undefined && state === null) removed.push(clientID);
            else if (state !== null) {
                if (!_function.equalityDeep(state, prevState)) filteredUpdated.push(clientID);
                updated.push(clientID);
            }
        }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) awareness.emit("change", [
        {
            added,
            updated: filteredUpdated,
            removed
        },
        origin
    ]);
    if (added.length > 0 || updated.length > 0 || removed.length > 0) awareness.emit("update", [
        {
            added,
            updated,
            removed
        },
        origin
    ]);
};

},{"lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","lib0/time":"gZsVK","lib0/math":"jhXHz","lib0/observable":"20Rfd","lib0/function":"1O0Qj","yjs":"gj9M9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"60si9":[function(require,module,exports) {
/**
 * Utility module to work with urls.
 *
 * @module url
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeQueryParams", ()=>decodeQueryParams);
parcelHelpers.export(exports, "encodeQueryParams", ()=>encodeQueryParams);
var _objectJs = require("./object.js");
const decodeQueryParams = (url)=>{
    /**
   * @type {Object<string,string>}
   */ const query = {};
    const urlQuerySplit = url.split("?");
    const pairs = urlQuerySplit[urlQuerySplit.length - 1].split("&");
    for(let i = 0; i < pairs.length; i++){
        const item = pairs[i];
        if (item.length > 0) {
            const pair = item.split("=");
            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || "");
        }
    }
    return query;
};
const encodeQueryParams = (params)=>_objectJs.map(params, (val, key)=>`${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join("&");

},{"./object.js":"4uXcx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82TGT":[function(require,module,exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while(++index < length)result[index] = iteratee(array[index], index, array);
    return result;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) return baseFindIndex(array, baseIsNaN, fromIndex);
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") try {
        result = !!(value + "");
    } catch (e) {}
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Symbol = root.Symbol, getPrototype = overArg(Object.getPrototypeOf, Object), propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length)this.add(values[index]);
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */ function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) return result;
    if (iteratee) values = arrayMap(values, baseUnary(iteratee));
    if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
    }
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while(valuesIndex--){
                if (values[valuesIndex] === computed) continue outer;
            }
            result.push(value);
        } else if (!includes(values, computed, comparator)) result.push(value);
    }
    return result;
}
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
            else arrayPush(result, value);
        } else if (!isStrict) result[result.length] = value;
    }
    return result;
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeysIn(object) {
    if (!isObject(object)) return nativeKeysIn(object);
    var isProto = isPrototype(object), result = [];
    for(var key in object)if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
    return result;
}
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */ function basePick(object, props) {
    object = Object(object);
    return basePickBy(object, props, function(value, key) {
        return key in object;
    });
}
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */ function basePickBy(object, props, predicate) {
    var index = -1, length = props.length, result = {};
    while(++index < length){
        var key = props[index], value = object[key];
        if (predicate(value, key)) result[key] = value;
    }
    return result;
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while(object){
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
    }
    return result;
};
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function nativeKeysIn(object) {
    var result = [];
    if (object != null) for(var key in Object(object))result.push(key);
    return result;
}
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) return value;
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */ function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */ var omit = baseRest(function(object, props) {
    if (object == null) return {};
    props = arrayMap(baseFlatten(props, 1), toKey);
    return basePick(object, baseDifference(getAllKeysIn(object), props));
});
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
module.exports = omit;

},{}],"bAVQb":[function(require,module,exports) {
/* eslint-disable no-param-reassign */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-unused-expressions */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _base = require("./base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class node extends (0, _baseDefault.default) {
    constructor(options){
        super();
        this._lock = null;
        this._openLock = null;
        this.lm = null;
        this.options = {
            id: (0, _utilsDefault.default).guid(),
            name: "",
            text: "",
            image: "",
            groupId: null,
            xPos: 0,
            yPos: 0,
            height: 10,
            width: 10,
            borderStyle: "solid",
            borderWidth: 1,
            borderColor: "#000",
            borderOpacity: 1,
            lineColor: "#000000",
            lineOpacity: 1,
            lineEffect: "",
            lineWidth: 5,
            opacity: 1,
            textOpacity: 1,
            showDelete: true,
            showAddAndDeleteConditionally: false,
            showResize: true,
            showAdd: true,
            showRelationshipConnector: true,
            showRelationshipDelete: true,
            showRelationshipProperties: true,
            showRelationshipReassign: true,
            showRotate: true,
            showMenu: true,
            showColorTab: true,
            showTextTab: true,
            showAITab: true,
            showShapeTab: true,
            showImageTab: true,
            showEffectTab: true,
            spaceBetweenNodesWhenAdding: 30,
            disableMenuAsTemplate: false,
            disableDrag: false,
            allowDrag: true,
            allowMenu: true,
            allowContext: true,
            allowResize: true,
            isLocked: false,
            isComment: false,
            backgroundColor: "90-#031634-#2D579A",
            foregroundColor: "#fff",
            isCategory: false,
            humanTouch: false,
            categoryName: "",
            fontSize: 18,
            fontFamily: "Roboto",
            shapeHint: "rectangle",
            vectorPath: "",
            rotate: {
                rotationAngle: 0
            },
            textXAlign: "middle",
            textYAlign: "middle",
            link: {
                show: false,
                type: "",
                data: "",
                thumbnail: {
                    width: 175,
                    height: 175
                }
            },
            filters: {
                vect: null,
                text: null
            },
            ai: {
                textToChildNodes: "",
                textToImage: ""
            }
        };
        Object.assign(this.options, options);
        if (this.options.name === "") this.options.name = this.options.id;
        this.constants = {
            statusPanelAtRest: 33,
            statusPanelExpanded: 200
        };
    }
    // get vect() {
    //   return this.vect;
    // }
    // get text() {
    //   return this.text;
    // }
    // get link() {
    //   return this.link;
    // }
    // set vect(val) {
    //   this.vect = val;
    // }
    // set text(val) {
    //   this.text = val;
    // }
    // set link(val) {
    //   this.link = val;
    // }
    _url(opt) {
        return this.options.ajax.rootUrl + this.options.ajax.urlFlavor + opt;
    }
    del() {
        const _unlinkId = this.options.id;
        this.slate.nodes.closeAllMenus();
        this.slate.nodes.closeAllLineOptions();
        this.relationships.removeAll();
        this.slate.options.allowDrag = true;
        // unlink any links
        this.slate.nodes.allNodes.forEach((nd)=>{
            if (nd.options.link && nd.options.link.show && nd.options.link.data === _unlinkId) {
                Object.assign(nd.options.link, {
                    show: false,
                    type: "",
                    data: ""
                });
                nd.link.hide();
            }
        });
        this.slate.nodes.remove(this);
    }
    getTransformString(opts = {}) {
        const _transforms = [];
        let rotationTransform;
        if (opts.action === "resize") {
            const resizeTransform = `s${opts.sx},${opts.sy}`;
            _transforms.push(resizeTransform);
        }
        if (opts.rotate) rotationTransform = `R${opts.rotate.rotationAngle}, ${opts.rotate.point.x}, ${opts.rotate.point.y}`;
        else if (this.options.rotate.rotationAngle) rotationTransform = `R${this.options.rotate.rotationAngle}, ${this.options.rotate.point.x - (opts.dx || 0)}, ${this.options.rotate.point.y - (opts.dy || 0)}`;
        if (rotationTransform) _transforms.push(rotationTransform);
        if (opts.action === "translate") {
            const translationTransform = `T${opts.dx}, ${opts.dy}`;
            // console.log("node transform string ", translationTransform);
            _transforms.push(translationTransform);
        }
        return _transforms.join(" ");
    }
    rotateMoveVector({ dx, dy }) {
        const _rotationAngle = -this.options.rotate.rotationAngle * Math.PI / 180 // conversion to radians
        ;
        return {
            dx: dx * Math.cos(_rotationAngle) - dy * Math.sin(_rotationAngle),
            dy: dx * Math.sin(_rotationAngle) + dy * Math.cos(_rotationAngle)
        };
    }
    translateWith({ dx, dy }) {
        // need a rotateMoveVector for both the vect and the text
        const newMoveVector = this.rotateMoveVector({
            dx,
            dy
        });
        const translateContext = {
            action: "translate",
            dx: newMoveVector.dx,
            dy: newMoveVector.dy
        };
        const transformString = this.getTransformString(translateContext);
        // during movement, the only thing that is updated is the transform property on
        // both the text and vect -- the actual attr update happens at the "up" in the
        // relationships.js module -- and the transform("") there causes these transient
        // transforms to be removed and replaced with the permanent attr updates.
        // note the "up" function there calls into the utils.transformPath on Slatebox.js
        // proper where the transform("") and the attr permanent record is done.
        this.vect.transform(transformString);
        this.text.transform(transformString);
        this.setPosition({
            x: this.vect.ox + dx,
            y: this.vect.oy + dy
        });
    }
    debugPosition() {
        const coords = `${this.options.id}\n x: ${this.options.xPos}, y: ${this.options.yPos}`;
        this.editor.set(coords);
    }
    setPosition(p, blnKeepMenusOpen, activeNode, opts = {}) {
        this.options.xPos = p.x;
        this.options.yPos = p.y;
        const lc = this.linkCoords();
        // not setting the text attr here -- this is
        // this.text.attr(this.textCoords(p));
        // this.text.attr(this.textCoords({x: this.options.xPos, y: this.options.yPos = p.y });
        this.link.transform([
            "t",
            lc.x,
            ",",
            lc.y,
            "s",
            ".8",
            ",",
            ".8",
            "r",
            "180"
        ].join());
        // close all open menus
        if (blnKeepMenusOpen !== true) {
            this.slate.nodes.closeAllMenus({
                exception: activeNode
            });
            this.slate.nodes.closeAllLineOptions();
        }
    }
    setStartDrag() {
        this.slate.options.allowDrag = false;
        // this.slate.stopEditing();
        this.connectors && this.connectors.reset();
        this.context && this.context.remove();
    }
    setEndDrag() {
        if (this.slate && this.slate.options.enabled) // could be null in case of the tempNode
        this.slate.options.allowDrag = true;
        this.slate.displayLocks();
    }
    serialize(lineWidthOverride) {
        const self = this;
        const jsonNode = {};
        Object.assign(jsonNode, {
            options: self.options
        });
        jsonNode.relationships = {
            associations: []
        } // , children: []
        ;
        self.relationships.associations.forEach((association)=>{
            jsonNode.relationships.associations.push(self._bindRel(association, lineWidthOverride));
        });
        return jsonNode;
    }
    _bindRel(obj, lineWidthOverride) {
        return {
            childId: obj.child.options.id,
            parentId: obj.parent.options.id,
            isStraightLine: obj.blnStraight,
            lineColor: obj.lineColor,
            lineEffect: obj.lineEffect,
            lineOpacity: obj.lineOpacity,
            lineWidth: lineWidthOverride || obj.lineWidth
        };
    }
    addRelationships(json, cb) {
        // add parents
        const self = this;
        const _lines = [];
        if (json.relationships) // add associations
        {
            if (json.relationships && json.relationships.associations && json.relationships.associations.forEach) json.relationships.associations.forEach((association)=>{
                const _pr = association;
                let _pn = null;
                self.slate.nodes.allNodes.forEach((node)=>{
                    if (node.options.id === _pr.parentId && self.options.id !== node.options.id) _pn = node;
                });
                if (_pn) {
                    const _conn = _pn.relationships.addAssociation(self, _pr);
                    _lines.push(_conn.line);
                }
            });
        }
        cb?.apply(self, [
            _lines
        ]);
    }
    toFront() {
        this.relationships?.associations?.forEach((assoc)=>{
            assoc.line.toFront();
        });
        this.vect.toFront();
        this.text.toFront();
        this.link.toFront();
        this.slate?.grid.toBack();
        this.slate?.canvas.bgToBack();
        this.slate.reorderNodes();
    }
    toBack() {
        this.link.toBack();
        this.text.toBack();
        this.vect.toBack();
        this.relationships?.associations?.forEach((assoc)=>{
            assoc.line.toBack();
        });
        this.slate?.grid.toBack();
        this.slate?.canvas.bgToBack();
        this.slate.reorderNodes();
    }
    hide() {
        this.vect.hide();
        this.text.hide();
        this.options.link.show && this.link.hide();
    }
    show() {
        this.vect.show();
        this.text.show();
        this.options.link.show && this.link.show();
    }
    applyFilters(filter) {
        const self = this;
        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile()) {
            if (filter) {
                // presumes that the filter has been added to the slate
                if (!self.options.filters[filter.apply]) self.options.filters[filter.apply] = {};
                self.options.filters[filter.apply] = filter.id;
            }
            Object.keys(self.options?.filters).forEach((key)=>{
                if (self[key]) {
                    if (self.options.filters[key]) self[key].attr("filter", `url(#${self.options.filters[key]})`);
                    else self[key].attr("filter", "");
                }
            });
        }
    }
    toggleFilters(blnHide) {
        const self = this;
        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile()) Object.keys(self.options?.filters).forEach((key)=>{
            if (self[key]) {
                if (self.options.filters[key]) {
                    if (blnHide) self[key].attr("filter", "");
                    else self[key].attr("filter", `url(#${self.options.filters[key]})`);
                }
            }
        });
    }
    applyBorder(pkg) {
        // first update the border prop if used
        if (pkg) this.options[pkg.prop] = pkg.val;
        // next define the full suite
        const vectOpts = {
            stroke: this.options.borderColor,
            "stroke-dasharray": this.options.borderStyle || null,
            "stroke-width": this.options.borderWidth != null ? this.options.borderWidth : 1,
            "stroke-opacity": this.options.borderOpacity != null ? this.options.borderOpacity : 1,
            "stroke-linecap": "round"
        };
        if (this.vect) this.vect.attr(vectOpts);
        return vectOpts;
    }
    // returns an invisible path with the correct position of a path being dragged. MAKE SURE TO REMOVE IT AFTER YOU ARE DONE WITH IT or there will be a growing number of invisible paths rendering the slate unusable
    getTempPathWithCorrectPositionFor({ pathElement, dx, dy, rotationAngle }) {
        const tempPath = this.slate.paper.path(pathElement.attr("path").toString()).attr({
            opacity: 0
        });
        const _transforms = [];
        const bb = tempPath.getBBox();
        if (dx != null && dy != null) {
            if (this.options.rotate.rotationAngle) {
                const newMoveVector = this.rotateMoveVector({
                    dx,
                    dy
                });
                _transforms.push(`T${newMoveVector.dx},${newMoveVector.dy}`);
            } else _transforms.push(`T${dx},${dy}`);
        }
        if (rotationAngle != null) _transforms.push(`r${rotationAngle}, ${bb.cx}, ${bb.cy}`);
        else if (this.options.rotate.rotationAngle) _transforms.push(`r${this.options.rotate.rotationAngle}, ${this.options.rotate.point.x}, ${this.options.rotate.point.y}`);
        tempPath.transform("");
        const transformPath = (0, _getTransformedPathDefault.default)(tempPath.attr("path").toString(), _transforms);
        tempPath.attr({
            path: transformPath
        });
        return tempPath;
    }
    hideOwnMenus() {
        this.link.hide();
        this.menu.hide();
    // this._lock && this._lock.hide();
    // this._openLock && this._openLock.hide();
    }
    spin(opts) {
        let ii = 0;
        const _aa = opts && opts.angle || 280;
        const _dur = opts && opts.duration || 5000;
        function _spinner(_angle) {
            ii++;
            const _ra = ii % 2 === 0 ? this.options.rotate.rotationAngle - _angle : this.options.rotate.rotationAngle + _angle;
            const _rotate = {
                rotate: this.options.rotate,
                rotationAngle: _ra
            };
            this.rotate.animateSet(_rotate, {
                duration: _dur,
                cb: ()=>{
                    _spinner(_aa);
                }
            });
        }
        _spinner(_aa);
    }
    move(pkg) {
        const _mPkg = {
            dur: pkg.dur || 500,
            moves: [
                {
                    id: this.options.id,
                    x: pkg.x,
                    y: pkg.y
                }
            ]
        };
        const _pkg = this.slate.nodes.nodeMovePackage(_mPkg);
        this.slate.nodes.moveNodes(_pkg, {
            animate: true,
            cb: ()=>{
                pkg.cb && pkg.cb();
            }
        });
    }
    zoom(zoomPercent, duration, cb) {
        /*
    var _startZoom = this.slate.options.viewPort.zoom.w;
    var _targetZoom = this.slate.options.viewPort.originalWidth * (100 / parseInt(zoomPercent));
    var _zoomDif = Math.abs(_targetZoom - _startZoom);
    */ // UNTIL PAN AND ZOOM WORKS CORRECTLY, THIS WILL
        // ALWAYS BE A SIMPLE PROXY TO ZOOMING THE SLATE
        this.slate.canvas.zoom({
            dur: duration,
            zoomPercent,
            callbacks: {
                during (percentComplete, easing) {
                // additional calcs
                },
                after (zoomVal) {
                    cb && cb.apply(this, [
                        {
                            id: this.options.id,
                            operation: "zoom",
                            zoomLevel: zoomVal
                        }
                    ]);
                }
            }
        });
    }
    position(location, cb, easing, dur) {
        const self = this;
        easing = easing || "easeTo" // 'swingFromTo'
        ;
        dur = dur || 500;
        const _vpt = self.vect.getBBox();
        const zr = self.slate.options.viewPort.zoom.r;
        const d = (0, _utilsDefault.default).getDimensions(self.slate.options.container);
        const cw = d.width;
        const ch = d.height;
        const nw = self.options.width * zr;
        const nh = self.options.height * zr;
        const pad = 10;
        // get upper left coords
        let _x = _vpt.x * zr;
        let _y = _vpt.y * zr;
        switch(location){
            case "lowerright":
                _x = _x - (cw - nw) - pad;
                _y = _y - (ch - nh) - pad;
                break;
            case "lowerleft":
                _x -= pad;
                _y = _y - (ch - nh) - pad;
                break;
            case "upperright":
                _x = _x - (cw - nw) - pad;
                _y -= pad;
                break;
            case "upperleft":
                _x -= pad;
                _y -= pad;
                break;
            default:
                // center
                _x -= cw / 2 - nw / 2;
                _y -= ch / 2 - nh / 2;
                break;
        }
        if (_x === self.slate.options.viewPort.left && _y === self.slate.options.viewPort.top) cb.apply();
        else self.slate.canvas.move({
            x: _x,
            y: _y,
            dur,
            callbacks: {
                after () {
                    cb?.apply(self, [
                        {
                            id: self.options.id,
                            operation: "position",
                            location,
                            easing
                        }
                    ]);
                }
            },
            isAbsolute: true,
            easing
        });
    }
    toggleImage(opts) {
        if (this.options.vectorPath && this.options.remoteImage) {
            if (opts.active) {
                const _svgAsImage = this.options.remoteImage;
                this.hidden = {
                    vectorPath: this.options.vectorPath
                };
                this.shapes.set({
                    shape: "rect",
                    keepResizerOpen: opts.keepResizerOpen
                });
                this.images.set(_svgAsImage, this.options.width, this.options.height, opts.keepResizerOpen);
                this.text && this.text.hide();
            } else if (this.hidden) {
                this.images.set("", this.options.width, this.options.height);
                this.customShapes.set(this.hidden.vectorPath);
                if (opts.width && opts.height) this.resize.set(opts.width, opts.height);
                this.text && this.text.show();
                this.relationships.showOwn();
                setTimeout(()=>{
                    this.menu.show();
                }, 100);
                delete this.hidden;
            }
        }
    }
    disable() {
        this.options.allowMenu = false;
        this.options.allowDrag = false;
        this.hideOwnMenus();
        if (this.slate.options.showLocks && this.options.isLocked) this.showLock();
    // this.relationships.unwireHoverEvents();
    }
    enable() {
        this.options.allowMenu = true // _prevAllowMenu || true;
        ;
        this.options.allowDrag = true // _prevAllowDrag || true;
        ;
        this.hideLock();
    // this.relationships.wireHoverEvents();
    }
    showLock() {
        const self = this;
        const _vpt = self.vect.getBBox();
        const r = self.slate.paper;
        if (!self._lock && self.slate.options.showLocks) self._lock = r.lockClosed().transform([
            "t",
            _vpt.x2 - 10,
            ",",
            _vpt.y2 - 10,
            "s",
            0.9,
            0.9
        ].join()).attr({
            fill: "#fff",
            stroke: "#000"
        });
        return self._lock;
    }
    mark() {
        const self = this;
        if (!self.marker) {
            const rect = self.vect.getBBox();
            const z = self.slate.options.viewPort.zoom.r;
            const padding = 10;
            const clr = (0, _utilsDefault.default).whiteOrBlack(self.slate.options.containerStyle.backgroundColor);
            self.marker = self.slate.paper.rect(rect.x - padding, rect.y - padding, rect.width + padding * 2, rect.height + padding * 2).attr({
                "stroke-dasharray": "-",
                fill: clr,
                opacity: 0.5
            });
            self.marker.toBack();
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
    }
    unmark() {
        const self = this;
        self.marker?.remove();
        delete self.marker;
    }
    hideLock() {
        this.hideOpenLock();
        this._lock && this._lock.remove();
        this._lock = null;
        this.slate && this.slate.unglow();
    }
    showOpenLock() {
        const self = this;
        const _vpt = this.vect.getBBox();
        const r = this.slate.paper;
        self._openLock = r.lockOpen().transform([
            "t",
            _vpt.x2 - 10,
            ",",
            _vpt.y2 - 10,
            "s",
            0.9,
            0.9
        ].join()).attr({
            fill: "#fff",
            stroke: "#000"
        });
        self._openLock.mouseover((e)=>{
            self._openLock.attr({
                "stroke-width": "2px",
                "stroke-color": "#000"
            });
            self._openLock.style.cursor = "pointer";
        });
        self._openLock.mouseout(()=>{
            self.hideOpenLock();
            self.showLock();
        });
        self._openLock.mousedown(()=>{
            self.enable();
            self.options.isLocked = false;
            const pkg = {
                type: "onNodeUnlocked",
                data: {
                    id: self.options.id
                }
            };
            self.context.broadcast(pkg);
        });
        return self._openLock;
    }
    hideOpenLock() {
        this._openLock && this._openLock.remove();
        this._openLock = null;
    }
    initLock() {
        if (this.vect && this.options.isLocked) this.showLock();
    }
    offset() {
        let _x = this.options.xPos - this.slate.options.viewPort.left;
        let _y = this.options.yPos - this.slate.options.viewPort.top;
        if (this.options.vectorPath === "ellipse") {
            _x -= this.options.width / 2;
            _y -= this.options.height / 2;
        }
        return {
            x: _x,
            y: _y
        };
    }
    textCoords(opts = {}) {
        const _useX = opts.x || this.vect.ox || 0;
        const _useY = opts.y || this.vect.oy || 0;
        // these are the center defaults
        // start
        let _offsetX = this.options?.textOffset?.x || 0;
        // middle
        let _offsetY = this.options?.textOffset?.y || 0;
        const bbox = this.vect.getBBox();
        const _scale = 1;
        switch(this.options.textXAlign){
            case "end":
                _offsetX = _offsetX * _scale + this.options.textOffset.width;
                break;
            case "middle":
                _offsetX = _offsetX * _scale + this.options.textOffset.width / 2;
                break;
            default:
                break;
        }
        switch(this.options.textYAlign){
            case "hanging":
                _offsetY = _offsetY * _scale - bbox.height / 2;
                break;
            case "baseline":
                _offsetY = _offsetY * _scale + bbox.height / 2;
                break;
            default:
                break;
        }
        const tx = _useX + _offsetX;
        const ty = _useY + _offsetY;
        const _tc = {
            x: tx,
            y: ty
        };
        return _tc;
    }
    linkCoords() {
        let x = this.options.xPos - 20;
        let y = this.options.yPos + this.options.height / 2 - 22;
        if (this.vect.type !== "rect") {
            y = this.options.yPos + this.options.height / 2 - 22;
            x = this.options.xPos - 20;
        }
        return {
            x,
            y
        };
    }
    _rotate(_opts) {
        const opts = {
            angle: 0,
            cb: null,
            dur: 0
        };
        Object.assign(opts, _opts);
        const ta = [
            "r",
            opts.angle
        ].join("");
        if (opts.dur === 0) {
            this.vect.transform(ta);
            this.text.transform(ta);
            if (this.options.link.show) this.link.transform(ta);
            opts.cb && opts.cb();
        } else {
            const lm = this.slate.paper.set();
            lm.push(this.vect);
            lm.push(this.text);
            if (this.options.link.show) lm.push(this.link);
            lm.animate({
                transform: ta
            }, opts.dur, ">", ()=>{
                opts.cb && opts.cb();
            });
        }
    }
}
exports.default = node;

},{"./base":"cmkOb","../helpers/getTransformedPath":"6wubb","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmkOb":[function(require,module,exports) {
/* eslint-disable new-cap */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const availablePlugins = {};
class base {
    constructor(initPayload){
        // register any plugins
        if (this.constructor.name !== "plugin") this.registerPlugins(initPayload);
    }
    registerPlugins(initPayload) {
        const root = this.constructor.name;
        // console.log("registering plugins ", root, base.plugins, base.plugins[root]);
        if (availablePlugins[root]) availablePlugins[root].forEach((p)=>{
            const { name, plugin } = p;
            if (!this.plugins) this.plugins = {};
            this.plugins[name] = new plugin(initPayload);
        });
    }
    static registerPlugin(details) {
        if (!details.name || !details.plugin) throw new Error("Plugins must provide a name and a plugin (class definition)");
        const root = Object.getPrototypeOf(details.plugin).name;
        // console.log("creating plugin root ", root);
        if (!availablePlugins[root]) availablePlugins[root] = [];
        availablePlugins[root] = [
            ...availablePlugins[root],
            details
        ];
    }
}
exports.default = base;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6wl7A":[function(require,module,exports) {
/* eslint-disable new-cap */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _getDepCoords = require("../helpers/getDepCoords");
var _getDepCoordsDefault = parcelHelpers.interopDefault(_getDepCoords);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _editor = require("../node/editor");
var _editorDefault = parcelHelpers.interopDefault(_editor);
var _relationships = require("../node/relationships");
var _relationshipsDefault = parcelHelpers.interopDefault(_relationships);
var _rotate = require("../node/rotate");
var _rotateDefault = parcelHelpers.interopDefault(_rotate);
var _menu = require("../node/menu");
var _menuDefault = parcelHelpers.interopDefault(_menu);
var _connectors = require("../node/connectors");
var _connectorsDefault = parcelHelpers.interopDefault(_connectors);
var _resize = require("../node/resize");
var _resizeDefault = parcelHelpers.interopDefault(_resize);
var _images = require("../node/images");
var _imagesDefault = parcelHelpers.interopDefault(_images);
var _shapes = require("../node/shapes");
var _shapesDefault = parcelHelpers.interopDefault(_shapes);
var _customShapes = require("../node/customShapes");
var _customShapesDefault = parcelHelpers.interopDefault(_customShapes);
var _colorPicker = require("../node/colorPicker");
var _colorPickerDefault = parcelHelpers.interopDefault(_colorPicker);
var _context = require("../node/context");
var _contextDefault = parcelHelpers.interopDefault(_context);
var _lineOptions = require("../node/lineOptions");
var _lineOptionsDefault = parcelHelpers.interopDefault(_lineOptions);
var _gridLines = require("../node/gridLines");
var _gridLinesDefault = parcelHelpers.interopDefault(_gridLines);
var _links = require("../node/links");
var _linksDefault = parcelHelpers.interopDefault(_links);
class nodeController {
    constructor(slate1){
        this.slate = slate1;
        this.ensureBe = null;
        this.allNodes = [];
    }
    _refreshBe() {
        const self = this;
        window.clearTimeout(self.ensureBe);
        self.ensureBe = window.setTimeout(()=>{
            self.slate.birdsEye?.refresh(false);
        }, 10);
    }
    _getParentChild(obj) {
        let _parent;
        let _child;
        this.allNodes.forEach((node)=>{
            if (node.options.id === obj.parent) _parent = node;
            else if (node.options.id === obj.child) _child = node;
        });
        return {
            p: _parent,
            c: _child
        };
    }
    static remove(a, obj) {
        return a.filter((ax)=>ax.options.id !== obj.options.id);
    }
    copyNodePositions(source, useMainCanvas = false) {
        const self = this;
        source.forEach((src)=>{
            // if (src.options.id !== self.tempNodeId) {
            let cn = self.allNodes.find((n)=>n.options.id === src.options.id);
            if (!cn) {
                self.add(src);
                cn = self.allNodes.find((n)=>n.options.id === src.options.id);
            }
            cn.setPosition({
                x: src.options.xPos,
                y: src.options.yPos
            });
            const opts = {};
            if (useMainCanvas) {
                const tempPath = self.slate.paper.path(cn.vect.attr("path")) // Meteor.currentSlate.paper
                ;
                opts.boundingClientRect = tempPath[0].getBoundingClientRect();
                tempPath.remove();
            }
            cn.rotate.applyImageRotation(opts);
        // }
        });
        (0, _lodashInvokeDefault.default)(self.allNodes.map((n)=>n.relationships), "refresh");
    }
    packageLayout() {
        const self = this;
        const knownGraphVizShapes = [
            "rect",
            "rectangle",
            "circle",
            "star",
            "trapezium",
            "triangle",
            "pentagon",
            "parallelogram",
            "octagon",
            "hexagon",
            "rarrow",
            "larrow"
        ];
        const eligibleNodes = self.slate.options.disableAutoLayoutOfManuallyPositionedNodes ? self.allNodes.filter((nn)=>!nn.options.humanTouch) : self.allNodes;
        // package up all the unique associations and the width/height of every node
        let associations = eligibleNodes.map((nx)=>nx.relationships.associations.map((a)=>{
                return {
                    parentId: a.parent.options.id,
                    childId: a.child.options.id,
                    lineWidth: a.lineWidth,
                    lineOpacity: a.lineOpacity,
                    showParentArrow: a.showParentArrow,
                    showChildArrow: a.showChildArrow
                };
            })).flat();
        const nodes = {};
        eligibleNodes.forEach((nx)=>{
            if (!nodes[nx.options.id]) nodes[nx.options.id] = {
                width: +nx.options.width,
                height: +nx.options.height,
                shape: knownGraphVizShapes.includes(nx.options.shapeHint) || "polygon",
                color: nx.options.backgroundColor,
                textColor: nx.options.foregroundColor,
                text: nx.options.text,
                groupId: nx.options.groupId
            };
        });
        const subgraphs = {};
        eligibleNodes.forEach((nx)=>{
            if (!subgraphs[nx.options.groupId]) subgraphs[nx.options.groupId] = [];
            subgraphs[nx.options.groupId].push(nx.options.id);
        });
        return {
            layoutType: self.slate.options.layoutType,
            associations,
            nodes,
            uniqueIds: Object.keys(nodes),
            subgraphs
        };
    }
    applyLayout(layout, cb) {
        const self = this;
        // console.log('received layout', layout)
        /*
    "exportNodes": {
      "010C580B": {
        "x": "279.5",
        "y": "322"
      },
      "ad79211ead0a": {
        "x": "183.5",
        "y": "186"
      },
      "c2134651593b": {
        "x": "376.5",
        "y": "186"
      },
      "0bad6428b74a": {
        "x": "87.5",
        "y": "50"
      },
      "2aab8002c94c": {
        "x": "280.5",
        "y": "50"
      }
    }
    */ const orient = self.slate.getOrientation(null, true) // - always pin to no zoom (1)
        ;
        const allMoves = [];
        self.allNodes.forEach((n, i)=>{
            if (layout.exportNodes?.[n.options.id]) {
                let { x, y } = layout.exportNodes[n.options.id];
                x = parseFloat(x);
                y = parseFloat(y);
                // console.log(
                //   'target aquired',
                //   n.options.id,
                //   x,
                //   y,
                //   x * -2 + x,
                //   y * -2 + y,
                //   n.options.xPos,
                //   n.options.yPos
                // )
                allMoves.push({
                    id: n.options.id,
                    x: orient.left - x - n.options.xPos + orient.width,
                    y: orient.top - y - n.options.yPos + orient.height
                });
            }
        });
        let batchSize = 6;
        if (self.allNodes.length > 15) batchSize = 12;
        if (layout.allAtOnce || self.slate.nodes.allNodes.length > 12) batchSize = 1;
        const batches = (0, _utilsDefault.default).chunk((0, _lodashClonedeepDefault.default)(allMoves), Math.ceil(allMoves.length / batchSize));
        // console.log(
        //   'received layout2',
        //   batchSize,
        //   allMoves.length,
        //   self.allNodes.length,
        //   batches.length
        // )
        const sendMove = (batch)=>{
            let dur = 300;
            if (layout.allAtOnce) dur = 0;
            const pkg = self.slate.nodes.nodeMovePackage({
                dur,
                moves: batch
            });
            self.slate.collab?.exe({
                type: "onNodesMove",
                data: pkg
            });
            if (batches.length > 0) setTimeout(()=>{
                sendMove(batches.pop());
            }, 250);
            else {
                if (layout.skipCenter) self.slate.controller.centerOnNodes({
                    dur: 500
                });
                else self.slate.controller.scaleToFitAndCenter();
                // finally invoke toFront for all nodes
                self.slate.nodes.allNodes.forEach((n)=>n.toBack());
                cb && cb();
            }
        };
        // kick it off
        sendMove(batches.pop());
    }
    getStickies(blnEmpty) {
        // stickies
        const stickies = slate.nodes.allNodes.filter((n)=>n?.options?.filters?.vect === "postItNote" && n?.options?.disableDrag === false && n?.options?.text?.length > blnEmpty ? 10000 : 0).map((n)=>({
                xPos: n.options.xPos,
                yPos: n.options.yPos,
                width: n.options.width,
                height: n.options.height,
                id: n.options.id
            }));
    }
    getProjectNameNode() {
        return this.slate.nodes.allNodes.find((n)=>n.options.text.match(/project name/gi));
    }
    parseTemplateIntoCategories() {
        const categories = slate.nodes.allNodes.filter((n)=>n.options.isCategory && n.options.categoryName?.length).map((nx)=>({
                xPos: nx.options.xPos,
                yPos: nx.options.yPos,
                width: nx.options.width,
                height: nx.options.height,
                categoryName: nx.options.categoryName
            }));
        // console.log(
        //   'rectnagles, categories',
        //   slate?.nodes?.allNodes?.length,
        //   rectangles,
        //   categories
        // )
        const matched = {};
        categories.forEach((categ)=>{
            if (!matched[categ.categoryName]) matched[categ.categoryName] = {
                top: categ.yPos,
                left: categ.xPos,
                bottom: categ.yPos + categ.height,
                right: categ.xPos + categ.width
            };
        });
        return matched;
    }
    addRange(_nodes, cb) {
        const self = this;
        _nodes.forEach((node)=>{
            self.add(node);
        });
        cb?.();
        return self;
    }
    removeRange(_nodes) {
        const self = this;
        _nodes.forEach((node)=>{
            self.allNodes = nodeController.remove(self.allNodes, node);
        });
        return self;
    }
    add(nodes, useMainCanvas, cb) {
        const self = this;
        if (!Array.isArray(nodes)) nodes = [
            nodes
        ];
        nodes.forEach((node)=>{
            node.slate = self.slate // parent
            ;
            self.allNodes.push(node);
            self.addToCanvas(node, useMainCanvas);
        });
        cb?.();
    }
    remove(nodes) {
        const self = this;
        if (!Array.isArray(nodes)) nodes = [
            nodes
        ];
        nodes.forEach((node)=>{
            self.allNodes = nodeController.remove(self.allNodes, node);
            node.slate = null;
            self.removeFromCanvas(node);
        });
    }
    nodeMovePackage(opts = {}) {
        // if exporting a move package with moves applied (e.g., you're
        // planning on manipulating the slate programmatically and this is
        // not an export bound for collaboration (at first)) -- then we need
        // to apply the final results to a copy of the slate because they are need
        // for the calculations below, and those calcs are mutable, so they
        // cannot be applied to the current slate.
        let _use = this.slate;
        let divCopy = null;
        if (opts && opts.moves) {
            divCopy = document.createElement("div");
            const _did = `copy_${(0, _utilsDefault.default).guid()}`;
            divCopy.setAttribute("id", _did);
            divCopy.setAttribute("style", `width:1px;height:1px;display:none;`);
            document.body.appendChild(divCopy);
            _use = this.slate.copy({
                container: _did,
                moves: opts.moves
            });
        }
        const nds = opts?.nodes || _use.nodes.allNodes;
        const _ret = {
            dur: opts ? opts.dur : 300,
            easing: opts ? opts.easing : ">",
            textPositions: (()=>nds.map((node)=>({
                        id: node.options.id,
                        textPosition: {
                            x: node.text.attrs.x,
                            y: node.text.attrs.y,
                            transform: node.getTransformString()
                        }
                    })))(),
            nodeOptions: nds.map((node)=>{
                return {
                    id: node.options.id,
                    vectorPath: node.options.vectorPath,
                    xPos: node.options.xPos,
                    yPos: node.options.yPos
                };
            }),
            associations: (()=>{
                const assoc = [];
                if (opts.relationships && opts.nodes) opts.relationships.forEach((a)=>{
                    assoc.push({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr("path").toString(),
                        id: a.line.id
                    });
                });
                else _use.nodes.allNodes.forEach((node)=>{
                    node.relationships.associations.forEach((a)=>{
                        assoc.push({
                            parentId: a.parent.options.id,
                            childId: a.child.options.id,
                            linePath: a.line.attr("path").toString(),
                            id: a.line.id
                        });
                    });
                });
                return (0, _lodashUniqDefault.default)(assoc, (a)=>a.id);
            })()
        };
        if (divCopy) document.body.removeChild(divCopy);
        return _ret;
    }
    moveNodes(pkg, options = {}) {
        this.closeAllLineOptions();
        this.closeAllMenus();
        // _node.hideOwnMenus();
        const allAssoc = [];
        this.allNodes.forEach((node)=>{
            node.relationships.associations.forEach((a)=>{
                allAssoc.push(a);
            });
        });
        const uniqAssoc = (0, _lodashUniqDefault.default)(allAssoc, (a)=>a.id);
        const p = pkg.data || pkg;
        const d = p.dur || 300;
        const e = p.easing || ">";
        const { associations, nodeOptions, textPositions } = p;
        let cntr = 0;
        function _potentiallyFinalize(isAssoc) {
            cntr += 1;
            if (associations.length === nodeOptions.length && cntr === nodeOptions.length && options.cb) {
                options.cb();
                delete options.cb;
            }
        }
        nodeOptions.forEach((opts)=>{
            const nodeObject = this.allNodes.find((node)=>node.options.id === opts.id);
            if (nodeObject) {
                Object.assign(nodeObject.options, opts);
                const dps = (0, _getDepCoordsDefault.default)({
                    x: opts.xPos,
                    y: opts.yPos
                }, nodeObject.options);
                const { lx, ty } = dps;
                const currentTextPosition = textPositions.find((tp)=>tp.id === opts.id);
                if (options.animate) {
                    nodeObject.text.animate(currentTextPosition.textPosition, d, e);
                    nodeObject.link.animate({
                        x: lx,
                        y: ty
                    }, d, e);
                } else {
                    nodeObject.text.attr(currentTextPosition.textPosition);
                    nodeObject.link.attr({
                        x: lx,
                        y: ty
                    });
                }
                if (this.slate.options.debugMode && !this.slate.options.isbirdsEye) nodeObject.debugPosition();
                if (options.animate) {
                    if (nodeObject) nodeObject.vect.animate({
                        path: opts.vectorPath,
                        transform: nodeObject.getTransformString()
                    }, d, e, ()=>{
                        nodeObject.vect.attr({
                            path: opts.vectorPath
                        });
                        nodeObject.images.imageSizeCorrection();
                        _potentiallyFinalize();
                    });
                } else {
                    if (nodeObject) nodeObject.vect.attr({
                        path: opts.vectorPath
                    });
                    let rotationOptions = {};
                    if (options.useMainCanvas) {
                        const tempPath = this.slate.paper.path(nodeObject.vect.attr("path")) // Meteor.currentSlate.paper.
                        ;
                        rotationOptions = {
                            boundingClientRect: tempPath[0].getBoundingClientRect()
                        };
                        tempPath.remove();
                    }
                    nodeObject.rotate.applyImageRotation(rotationOptions);
                    nodeObject.images.imageSizeCorrection();
                    _potentiallyFinalize();
                }
            }
        });
        // this is important only when collaboration is active
        const ensureRefreshed = ()=>{
            const currentCollaborators = this.slate.collab.currentCollaborators();
            if (currentCollaborators.length > 1) nodeOptions.forEach((opts)=>{
                const nodeObject = this.allNodes.find((node)=>node.options.id === opts.id);
                nodeObject.relationships.refreshOwnRelationships();
            });
        };
        associations.forEach((assoc, aCnt)=>{
            const a = uniqAssoc.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId);
            if (a) {
                if (options.animate) a.line.animate({
                    path: assoc.linePath
                }, d, e, ()=>{
                    a.line.attr({
                        path: assoc.linePath
                    });
                    if (aCnt + 1 === associations.length) ensureRefreshed();
                });
                else {
                    a.line.attr({
                        path: assoc.linePath
                    });
                    if (aCnt + 1 === associations.length) ensureRefreshed();
                }
            }
        });
        this.slate.birdsEye?.refresh(true);
    }
    getRelevantAssociationsWith(nodes) {
        const _relationshipsToTranslate = [];
        const _relationshipsToRefresh = [];
        nodes.forEach((node)=>{
            const otherSelectedNodes = nodes.filter((n)=>n.options.id !== node.options.id);
            node.relationships.associations.forEach((assoc)=>{
                if (otherSelectedNodes.map((n)=>n.relationships.associations).some((associations)=>associations.find((a)=>a.id === assoc.id))) {
                    if (!_relationshipsToTranslate.some((r)=>r.id === assoc.id)) _relationshipsToTranslate.push(assoc) // connections which move with both nodes
                    ;
                } else if (!_relationshipsToRefresh.some((r)=>r.id === assoc.id)) _relationshipsToRefresh.push(assoc) // connections which move on one end only
                ;
            });
        });
        return {
            relationshipsToRefresh: _relationshipsToRefresh,
            relationshipsToTranslate: _relationshipsToTranslate
        };
    }
    translateRelationships(relationships, { dx, dy }) {
        relationships.forEach((r)=>{
            r.line.transform(`T${dx}, ${dy}`);
        });
    }
    saveRelationships(relationships, { dx, dy }) {
        relationships.forEach((r)=>{
            const newLinePath = (0, _utilsDefault.default)._transformPath(r.line.attr("path").toString(), `T${dx},${dy}`).toString();
            r.line.attr({
                path: newLinePath
            });
            r.line.transform("");
        });
    }
    removeRelationship(rm) {
        const pc = this._getParentChild(rm);
        const _parent = pc.p;
        const _child = pc.c;
        if (_parent && _child) {
            // _parent.relationships.removeChild(_child);
            // _child.relationships.removeParent(_parent);
            _parent.relationships.removeAssociation(_child);
            _child.relationships.removeAssociation(_parent);
        }
    }
    refreshAllRelationships() {
        this.allNodes.forEach((node)=>{
            node.relationships.refreshOwnRelationships();
        });
    }
    addRelationship(add) {
        const pc = this._getParentChild(add);
        const _parent = pc.p;
        const _child = pc.c;
        if (_parent && _child) switch(add.type){
            case "association":
                _parent.relationships.addAssociation(_child, add.options);
                break;
            default:
                break;
        }
    }
    closeAllLineOptions(exception) {
        this.allNodes.forEach((node)=>{
            node.relationships.associations.forEach((association)=>{
                if (association.id !== exception) node.lineOptions?.hide(association.id);
            });
        });
    }
    closeAllMenus({ exception, nodes } = {}) {
        (nodes || this.allNodes).forEach((node)=>{
            if (node.options.id !== exception) {
                node.menu.hide();
                node.lineOptions?.hideAll();
                node.resize?.hide();
                node.rotate?.hide();
            }
        });
    }
    closeAllConnectors() {
        this.allNodes.forEach((node)=>{
            node.connectors?.remove();
            node.resize?.hide();
            node.rotate?.hide();
        });
    }
    one(id) {
        let cn = null;
        this.allNodes.forEach((node)=>{
            if (node.options.id === id) cn = node;
        });
        return cn;
    }
    removeFromCanvas(_node) {
        [
            "vect",
            "text",
            "link"
        ].forEach((tt)=>{
            _node[tt].remove();
        });
        this._refreshBe();
    }
    addToCanvas(_node, useMainCanvas) {
        _node.slate = this.slate;
        let vect = null;
        let link = null;
        const vectOpt = {
            fill: _node.options.backgroundColor || "#fff",
            "fill-opacity": _node.options.opacity != null ? _node.options.opacity : 1
        };
        Object.assign(vectOpt, _node.applyBorder());
        const _x = _node.options.xPos;
        const _y = _node.options.yPos;
        const paperToUse = this.slate.paper;
        const percent = 1;
        const _width = _node.options.width;
        const _height = _node.options.height;
        const _transforms = [
            `T${_x * percent}, ${_y * percent}`,
            `s${_width / 150 * percent}, ${_height / 100 * percent}, ${_x}, ${_y}`
        ];
        _node.options.isEllipse = _node.options.isEllipse || _node.options.vectorPath === "ellipse";
        let potentiallyResize = false;
        switch(_node.options.vectorPath){
            case "ellipse":
                _node.options.vectorPath = (0, _getTransformedPathDefault.default)("M150,50 a75,50 0 1,1 0,-1 z", _transforms);
                break;
            case "rectangle":
                _node.options.vectorPath = (0, _getTransformedPathDefault.default)("M1,1 h150 v100 h-150 v-100 z", _transforms);
                break;
            case "roundedrectangle":
                _node.options.vectorPath = (0, _getTransformedPathDefault.default)("M1,1 h130 a10,10 0 0 1 10,10 v80 a10,10 0 0 1 -10,10 h-130 a10,10 0 0 1 -10,-10 v-80 a10,10 0 0 1 10,-10 z", _transforms);
                break;
            default:
                potentiallyResize = true;
                break;
        }
        if (_node.options.vectorPath === "M2,12 L22,12") vectOpt["stroke-dasharray"] = "2px";
        vect = paperToUse.path(_node.options.vectorPath).attr(vectOpt);
        vect.node.style.cursor = "pointer";
        // need to set in case toback or tofront is called and the load order changes in the context plugin
        vect.node.setAttribute("rel", _node.options.id);
        vect.data({
            id: _node.options.id
        });
        _node.vect = vect;
        // _node.vect.ox = _x;
        // _node.vect.oy = _y;
        // get the text coords before the transform is applied
        // var tc = _node.textCoords();
        _node.vect.transform(_node.getTransformString());
        // update xPos, yPos in case it is different than actual
        const bbox = vect.getBBox();
        _node.options.xPos = bbox.x;
        _node.options.yPos = bbox.y;
        if (!_node.options.origVectWidth && _node.options.shapeHint === "custom") _node.options.origVectWidth = bbox.width;
        if (!_node.options.origVectHeight && _node.options.shapeHint === "custom") _node.options.origVectHeight = bbox.height;
        const lc = _node.linkCoords();
        // apply the text coords prior to transform
        // text = paperToUse.text(tc.x, tc.y, (_node.options.text || '')).attr({ "font-size": _node.options.fontSize + "pt", fill: _node.options.foregroundColor || "#000" });
        link = paperToUse.linkArrow().transform([
            "t",
            lc.x,
            ",",
            lc.y,
            "s",
            ".8",
            ",",
            ".8",
            "r",
            "180"
        ].join()).attr({
            cursor: "pointer"
        });
        // create and set editor
        _node.editor = new (0, _editorDefault.default)(this.slate, _node);
        _node.editor.set() // creates and sets the text
        ;
        _node.text.transform(_node.getTransformString());
        // set link
        _node.link = link;
        _node.both = new _node.slate.paper.set();
        _node.both.push(_node.vect);
        _node.both.push(_node.text);
        // relationships
        _node.relationships = new (0, _relationshipsDefault.default)(this.slate, _node);
        _node.relationships.wireDragEvents();
        // rotate
        _node.rotate = new (0, _rotateDefault.default)(this.slate, _node);
        // connectors
        _node.connectors = new (0, _connectorsDefault.default)(this.slate, _node);
        // menu
        _node.menu = new (0, _menuDefault.default)(this.slate, _node);
        // resizer
        _node.resize = new (0, _resizeDefault.default)(this.slate, _node);
        // images
        _node.images = new (0, _imagesDefault.default)(this.slate, _node);
        // context
        _node.context = new (0, _contextDefault.default)(this.slate, _node);
        // lineOptions
        _node.lineOptions = new (0, _lineOptionsDefault.default)(this.slate, _node);
        // shapes
        _node.shapes = new (0, _shapesDefault.default)(this.slate, _node);
        // customShapes
        _node.customShapes = new (0, _customShapesDefault.default)(this.slate, _node);
        // colorPicker
        _node.colorPicker = new (0, _colorPickerDefault.default)(this.slate, _node);
        // gridLines
        _node.gridLines = new (0, _gridLinesDefault.default)(this.slate, _node);
        //links
        _node.links = new (0, _linksDefault.default)(this.slate, _node);
        if (_node.options.image && !_node.options.imageOrigHeight) _node.options.imageOrigHeight = _node.options.height;
        if (_node.options.image && !_node.options.imageOrigWidth) _node.options.imageOrigWidth = _node.options.width;
        if (_node.options.image && _node.options.image !== "") _node.images.set(_node.options.image, _node.options.imageOrigWidth, _node.options.imageOrigHeight, useMainCanvas);
        if (!_node.options.link || !_node.options.link.show) _node.link.hide();
        //
        if (potentiallyResize) _node.resize.set(_width, _height);
        // apply any node filters to vect and/or text
        _node.applyFilters();
        this._refreshBe();
        return vect;
    }
}
exports.default = nodeController;

},{"lodash.uniq":"iDalh","lodash.invoke":"6VYuy","lodash.clonedeep":"i3u1q","../helpers/getTransformedPath":"6wubb","../helpers/refreshRelationships":"1UeYf","../helpers/getDepCoords":"hVTn1","../helpers/utils":"8QI6M","../node/editor":"klp05","../node/relationships":"8zQA0","../node/rotate":"6en3b","../node/menu":"91LgF","../node/connectors":"h710n","../node/resize":"4vYbQ","../node/images":"jLcMC","../node/shapes":"kA5hP","../node/customShapes":"edbtN","../node/colorPicker":"jJAST","../node/context":"185nI","../node/lineOptions":"c3gfk","../node/gridLines":"6cFRW","../node/links":"4BxQS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6VYuy":[function(require,module,exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var global = arguments[3];
var FUNC_ERROR_TEXT = "Expected a function";
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var funcTag = "[object Function]", genTag = "[object GeneratorFunction]", symbolTag = "[object Symbol]";
/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") try {
        result = !!(value + "");
    } catch (e) {}
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Symbol = root.Symbol, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = isKey(path, object) ? [
        path
    ] : castPath(path);
    var index = 0, length = path.length;
    while(object != null && index < length)object = object[toKey(path[index++])];
    return index && index == length ? object : undefined;
}
/**
 * The base implementation of `_.invoke` without support for individual
 * method arguments.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} args The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 */ function baseInvoke(object, path, args) {
    if (!isKey(path, object)) {
        path = castPath(path);
        object = parent(object, path);
        path = last(path);
    }
    var func = object == null ? object : object[toKey(path)];
    return func == null ? undefined : apply(func, object, args);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */ function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) start = -start > length ? 0 : length + start;
    end = end > length ? length : end;
    if (end < 0) end += length;
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while(++index < length)result[index] = array[index + start];
    return result;
}
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == "string") return value;
    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (isArray(value)) return false;
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */ function parent(object, path) {
    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) result.push("");
    string.replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
});
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) return value;
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */ function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : undefined;
}
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != "function" || resolver && typeof resolver != "function") throw new TypeError(FUNC_ERROR_TEXT);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
}
// Assign cache to `_.memoize`.
memoize.Cache = MapCache;
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? "" : baseToString(value);
}
/**
 * Invokes the method at `path` of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
 *
 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
 * // => [2, 3]
 */ var invoke = baseRest(baseInvoke);
module.exports = invoke;

},{}],"1UeYf":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>refreshRelationships);
var _closestPoint = require("./closestPoint");
var _closestPointDefault = parcelHelpers.interopDefault(_closestPoint);
var _getHorizontalCurve = require("./getHorizontalCurve");
var _getHorizontalCurveDefault = parcelHelpers.interopDefault(_getHorizontalCurve);
var _getCorrectMidPoints = require("./getCorrectMidPoints");
var _getCorrectMidPointsDefault = parcelHelpers.interopDefault(_getCorrectMidPoints);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
function refreshRelationships({ relationships, nodes, dx = 0, dy = 0 }) {
    relationships.forEach((r)=>{
        const midPoints = (0, _getCorrectMidPointsDefault.default)(r);
        let tempOriginNode;
        let tempEndNode;
        let linePath;
        if (nodes.some((n)=>n.options.id === r.parent.options.id)) {
            tempOriginNode = r.parent.getTempPathWithCorrectPositionFor({
                pathElement: r.parent.vect,
                dx,
                dy
            });
            tempEndNode = r.child.getTempPathWithCorrectPositionFor({
                // this one is all about rotation
                pathElement: r.child.vect,
                dx: 0,
                dy: 0
            });
            const childPathContext = (0, _closestPointDefault.default)(tempEndNode || r.child.vect, midPoints.parent);
            const pointOnChildPath = childPathContext.bestPoint;
            const parentPathContext = (0, _closestPointDefault.default)(tempOriginNode || r.parent.vect, pointOnChildPath);
            const pointOnParentPath = parentPathContext.bestPoint;
            linePath = (0, _getHorizontalCurveDefault.default)(pointOnParentPath, pointOnChildPath);
        } else {
            tempEndNode = r.child.getTempPathWithCorrectPositionFor({
                pathElement: r.child.vect,
                dx,
                dy
            });
            tempOriginNode = r.parent.getTempPathWithCorrectPositionFor({
                // this one is all about rotation
                pathElement: r.parent.vect,
                dx: 0,
                dy: 0
            });
            const childPathContext = (0, _closestPointDefault.default)(tempEndNode || r.child.vect, midPoints.parent);
            const pointOnChildPath = childPathContext.bestPoint;
            const parentPathContext = (0, _closestPointDefault.default)(tempOriginNode || r.parent.vect, pointOnChildPath);
            const pointOnParentPath = parentPathContext.bestPoint;
            linePath = (0, _getHorizontalCurveDefault.default)(pointOnParentPath, pointOnChildPath);
        }
        const _attr = {
            stroke: r.lineColor,
            fill: "none",
            "stroke-width": r.lineWidth,
            "fill-opacity": r.lineOpacity,
            opacity: r.lineOpacity,
            filter: !(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile() && r.lineEffect ? `url(#${r.lineEffect})` : ""
        };
        // stop connection re-draws when shift+alt drag until the move is up because the lines are hidden anyways
        if (!(r.isAlt && r.isShift) || r.isAlt && r.isShift && r.isUp) _attr.path = linePath;
        if (r.showChildArrow) Object.assign(_attr, {
            "arrow-end": "classic"
        });
        else Object.assign(_attr, {
            "arrow-end": "none"
        });
        if (r.showParentArrow) Object.assign(_attr, {
            "arrow-start": "classic"
        });
        else Object.assign(_attr, {
            "arrow-start": "none"
        });
        r.line.attr(_attr);
        if (tempOriginNode) tempOriginNode.remove();
        if (tempEndNode) tempEndNode.remove();
    });
    // always push the grid back
    if (nodes.length > 0) {
        nodes[0].slate?.grid?.toBack();
        nodes[0].slate?.canvas?.bgToBack();
    }
}

},{"./closestPoint":"6gfM6","./getHorizontalCurve":"dzUMr","./getCorrectMidPoints":"b3ZJc","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6gfM6":[function(require,module,exports) {
/* eslint-disable no-sequences */ /* eslint-disable no-unused-expressions */ /* eslint-disable no-cond-assign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>closestPoint);
function closestPoint(pathNode, point) {
    const pathLength = pathNode.getTotalLength();
    let precision = 64 // increase this value for better performance at a risk of worse point approximation; in future this should be scaled according to number of path segments (there could be a better solution)
    ;
    let best;
    let bestLength;
    let bestDistance = Infinity;
    function distance2(p) {
        // squared distance between two points
        const dx = p.x - point.x;
        const dy = p.y - point.y;
        return dx * dx + dy * dy;
    }
    // linear scan for coarse approximation
    for(let scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision)if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) best = scan, bestLength = scanLength, bestDistance = scanDistance;
    // binary search for precise estimate
    precision /= 2;
    while(precision > 0.5){
        let before;
        let after;
        let beforeLength;
        let afterLength;
        let beforeDistance;
        let afterDistance;
        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) best = before, bestLength = beforeLength, bestDistance = beforeDistance;
        else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) best = after, bestLength = afterLength, bestDistance = afterDistance;
        else precision /= 2;
    }
    return {
        bestPoint: best,
        bestLength
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dzUMr":[function(require,module,exports) {
// returns a horizontally curved line
// export default function getHorizontalCurve(originPoint, endPoint) {
//   const x1 = originPoint.x
//   const y1 = originPoint.y
//   const x2 = endPoint.x
//   const y2 = endPoint.y
//   const middlePointX = (x1 + x2) / 2
//   return [
//     'M',
//     x1.toFixed(2),
//     y1.toFixed(2),
//     'C',
//     middlePointX.toFixed(2),
//     y1.toFixed(2),
//     middlePointX.toFixed(2),
//     y2.toFixed(2),
//     x2.toFixed(2),
//     y2.toFixed(2),
//   ].join(' ')
// }
// Function to generate a horizontally curved line or a right-angle connection
// Function to generate a dynamically curved line with the last segment straight towards the end point
// Function to generate a dynamically curved line with the last segment straight towards the end point
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getPath);
function getPath(originPoint, endPoint, curveSwoop = 0.3, lineType = "orthogonal", curveType = "quadratic") {
    const x1 = originPoint.x;
    const y1 = originPoint.y;
    const x2 = endPoint.x;
    const y2 = endPoint.y;
    // Determine the predominant direction of the connection
    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    const approachAxis = dx > dy ? "vertical" : "horizontal";
    if (lineType === "bezier") {
        // Standard swoop for a natural cubic Bezier curve
        const swoop = Math.min(dx, dy) * curveSwoop // This factor can be adjusted for more or less curvature
        ;
        if (curveType === "quadratic") {
            // Calculate control point for a quadratic Bezier curve
            const controlX = approachAxis === "horizontal" ? (x1 + x2) / 2 : x1 + swoop * (y2 - y1) / dy;
            const controlY = approachAxis === "horizontal" ? y1 + swoop * (x2 - x1) / dx : (y1 + y2) / 2;
            const pp = [
                "M",
                x1.toFixed(2),
                y1.toFixed(2),
                "Q",
                controlX.toFixed(2),
                controlY.toFixed(2),
                x2.toFixed(2),
                y2.toFixed(2)
            ].join(" ");
            console.log("pp is", pp);
            return pp;
        } else {
            let controlX1, controlY1, controlX2, controlY2;
            if (approachAxis === "horizontal") {
                controlX1 = x1 + swoop;
                controlY1 = y1;
                controlX2 = x2 - swoop;
                controlY2 = y2;
            } else {
                controlX1 = x1;
                controlY1 = y1 + swoop;
                controlX2 = x2;
                controlY2 = y2 - swoop;
            }
            return [
                "M",
                x1.toFixed(2),
                y1.toFixed(2),
                "C",
                controlX1.toFixed(2),
                controlY1.toFixed(2),
                controlX2.toFixed(2),
                controlY2.toFixed(2),
                x2.toFixed(2),
                y2.toFixed(2)
            ].join(" ");
        }
    } else if (lineType === "orthogonal") // Generate orthogonal line (right-angle)
    return [
        "M",
        x1.toFixed(2),
        y1.toFixed(2),
        "L",
        x1.toFixed(2),
        y2.toFixed(2),
        "L",
        x2.toFixed(2),
        y2.toFixed(2)
    ].join(" ");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b3ZJc":[function(require,module,exports) {
/* eslint-disable no-lonely-if */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCorrectMidPoints);
function getCorrectMidPoints(opts = {}) {
    const originBB = opts.parent ? opts.parent.vect.getBBox() : opts.parent.vect.getBBox();
    const endBB = opts.child ? opts.child.vect.getBBox() : opts.child.vect.getBBox();
    function inn(val) {
        return !Number.isNaN(parseFloat(val)) && Number.isFinite(val);
    }
    const pcx = inn(originBB.cx) && originBB.cx;
    const pcy = inn(originBB.cy) && originBB.cy;
    const ccx = inn(endBB.cx) && endBB.cx;
    const ccy = inn(endBB.cy) && endBB.cy;
    let relevantParentMiddlePoint;
    const px1 = originBB.x;
    const py1 = originBB.y;
    const px2 = originBB.x2;
    const py2 = originBB.y;
    const px3 = originBB.x2;
    const py3 = originBB.y2;
    const px4 = originBB.x;
    const py4 = originBB.y2;
    /*
    generic line equation
    y = ((y2-y1)/(x2-x1)) * (x-x1) + y1

    line 1: line passing through upper left corner and bottom right corner
    y = ((py3 - py1)/(px3 - px1)) * (x - px1) + py1

    line 2: line passing through bottom left corner and upper right corner
    y = ((py2 - py4)/(px2 - px4)) * (x - px4) + py4
   */ // NOTE: comments below apply to a Cartesian coordinate system; the svg coordinate system is slightly different with (0,0) in upper left corner of the plane
    // it means that regular above means below here
    if (ccy >= (py3 - py1) / (px3 - px1) * (ccx - px1) + py1) {
        // means that child center point is above line 1
        if (ccy >= (py2 - py4) / (px2 - px4) * (ccx - px4) + py4) // means that child center point is above line 2
        relevantParentMiddlePoint = {
            x: pcx,
            y: py3
        };
        else // means that child center point is either below line 2 or is on line 2
        relevantParentMiddlePoint = {
            x: px1,
            y: pcy
        };
    } else // means that child center point is below line 1
    if (ccy >= (py2 - py4) / (px2 - px4) * (ccx - px4) + py4) // means that child center point is above line 2
    relevantParentMiddlePoint = {
        x: px2,
        y: pcy
    };
    else // means that child center point is either below line 2 or is on line 2
    relevantParentMiddlePoint = {
        x: pcx,
        y: py1
    };
    let relevantChildMiddlePoint;
    const cx1 = endBB.x;
    const cy1 = endBB.y;
    const cx2 = endBB.x2;
    const cy2 = endBB.y;
    const cx3 = endBB.x2;
    const cy3 = endBB.y2;
    const cx4 = endBB.x;
    const cy4 = endBB.y2;
    /*
   generic line equation
   y = ((y2-y1)/(x2-x1)) * (x-x1) + y1

   line 1: line passing through upper left corner and bottom right corner
   y = ((cy3 - cy1)/(cx3 - cx1)) * (x - cx1) + cy1

   line 2: line passing through bottom left corner and upper right corner
   y = ((cy2 - cy4)/(cx2 - cx4)) * (x - cx4) + cy4
   */ // NOTE: comments below apply to a Cartesian coordinate system; the svg coordinate system is slightly different with (0,0) in upper left corner of the plane
    // it means that regular above means below here
    if (pcy >= (cy3 - cy1) / (cx3 - cx1) * (pcx - cx1) + cy1) {
        // means that child center point is above line 1
        if (pcy >= (cy2 - cy4) / (cx2 - cx4) * (pcx - cx4) + cy4) // means that child center point is above line 2
        relevantChildMiddlePoint = {
            x: ccx,
            y: cy3
        };
        else // means that child center point is either below line 2 or is on line 2
        relevantChildMiddlePoint = {
            x: cx1,
            y: ccy
        };
    } else // means that child center point is below line 1
    if (pcy >= (cy2 - cy4) / (cx2 - cx4) * (pcx - cx4) + cy4) // means that child center point is above line 2
    relevantChildMiddlePoint = {
        x: cx2,
        y: ccy
    };
    else // means that child center point is either below line 2 or is on line 2
    relevantChildMiddlePoint = {
        x: ccx,
        y: cy1
    };
    return {
        child: relevantChildMiddlePoint,
        parent: relevantParentMiddlePoint
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVTn1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDepCoords);
function getDepCoords(p, options) {
    let lx = p.x - 5;
    let tx = p.x + options.width / 2;
    let ty = p.y + options.height / 2;
    if (options.vectorPath === "ellipse") {
        lx = p.cx - 5;
        tx = p.cx;
        ty = p.cy;
    }
    return {
        lx,
        tx,
        ty
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klp05":[function(require,module,exports) {
/* eslint-disable no-param-reassign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class editor {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    setTextOffset() {
        if (this.node.options.allowDrag) {
            this.node.options.textBounds = this.node.vect.getBBox();
            this.node.options.textOffset = {
                x: this.node.options.textBounds.cx - this.node.options.textBounds.width / 2 - this.node.options.xPos,
                y: this.node.options.textBounds.cy - this.node.options.yPos,
                width: this.node.options.textBounds.width,
                height: this.node.options.textBounds.height
            };
        }
    }
    set(t, s, f, c, opacity, ta, tb, isCategory) {
        const tempShim = `\xa7` // utils.guid().substring(3);
        ;
        if (!t && t !== "") t = this.node.options.text || tempShim;
        if (!s) s = this.node.options.fontSize || 12;
        if (opacity == null) opacity = this.node.options.textOpacity || 1;
        if (!f) f = this.node.options.fontFamily || "Roboto";
        if (!c) c = this.node.options.foregroundColor || "#000";
        if (!ta) ta = this.node.options.textXAlign || "middle";
        if (!tb) tb = this.node.options.textYAlign || "middle";
        // ensure text is always legible if it is set to the same as background
        if (c === this.node.options.backgroundColor) c = (0, _utilsDefault.default).whiteOrBlack(this.node.options.backgroundColor);
        this.node.options.text = t;
        this.node.options.fontSize = s;
        this.node.options.fontFamily = f;
        this.node.options.foregroundColor = c;
        this.node.options.textOpacity = opacity;
        this.node.options.textXAlign = ta;
        this.node.options.textYAlign = tb;
        if (this.slate.options.autoResizeNodesBasedOnText && !this.node.options.ignoreTextFit) {
            let widthScalar = 1;
            let heightScalar = 1;
            let nodebb = this.node.vect.getBBox();
            if (this.node.options.text !== tempShim) {
                const textDimens = (0, _utilsDefault.default).getTextWidth(this.node.options.text, `${this.node.options.fontSize}pt ${this.node.options.fontFamily}`);
                const { transWidth, transHeight } = (0, _utilsDefault.default).obtainProportionateWidthAndHeightForResizing(0, 0, textDimens.width, textDimens.height, this.node.options.origVectWidth, this.node.options.origVectHeight, this.slate.isCtrl, this.node.options.shapeHint === "custom");
                widthScalar = transWidth / nodebb.width;
                heightScalar = transHeight / nodebb.height;
            }
            const scaledVectPath = (0, _raphaelSvg.Raphael).transformPath(this.node.options.vectorPath, `s${widthScalar}, ${heightScalar}`).toString();
            this.node.options.vectorPath = scaledVectPath;
            this.node.vect.attr({
                path: scaledVectPath
            });
            nodebb = this.node.vect.getBBox();
            this.node.options.width = nodebb.width;
            this.node.options.height = nodebb.height;
            this.node.options.xPos = nodebb.x;
            this.node.options.yPos = nodebb.y;
            this.node.relationships && this.node.relationships.refreshOwnRelationships();
        }
        let coords = null;
        this.setTextOffset();
        coords = this.node.textCoords();
        if (!this.node.text) this.node.text = this.slate.paper.text(this.node.options.xPos + coords.x, this.node.options.yPos + coords.y, t);
        coords = this.node.textCoords({
            x: this.node.options.xPos,
            y: this.node.options.yPos
        });
        this.node.text.attr(coords);
        this.node.text.attr({
            text: t
        });
        this.node.text.attr({
            "font-size": `${s}pt`
        });
        this.node.text.attr({
            "font-family": f
        });
        this.node.text.attr({
            fill: c
        });
        this.node.text.attr({
            "text-anchor": ta
        });
        this.node.text.attr({
            "text-baseline": tb
        });
        this.node.text.attr({
            "fill-opacity": opacity
        });
        this.node.text.attr({
            class: "slatebox-text"
        });
        const noSelect = [
            "-webkit-user-select",
            "-moz-user-select",
            "-ms-user-select",
            "user-select"
        ].map((sx)=>`${sx}: none;`).join(" ");
        this.node.text.attr({
            style: noSelect
        });
        if (tempShim === t) {
            this.node.options.text = "";
            this.node.text.attr({
                text: ""
            });
        } else setTimeout(()=>{
            this.node.text.attr({
                text: t
            });
        }, 10);
    }
}
exports.default = editor;

},{"../helpers/utils":"8QI6M","../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8zQA0":[function(require,module,exports) {
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _getHorizontalCurve = require("../helpers/getHorizontalCurve");
var _getHorizontalCurveDefault = parcelHelpers.interopDefault(_getHorizontalCurve);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class relationships {
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.PATH_COMPLEXITY_LIMIT = 100000;
        self.associations = [];
        self._isLastAlt = false;
        self._isLastShift = false;
        self.selectedNodes = [];
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self._dx = 0;
        self._dy = 0;
        self.collabSent = null;
        self.slate.draggingNode = false;
        self.ft = null;
        self.kdTree = null;
        self.gracefulClear = null;
        self.dragEvents = {
            move (dx, dy) {
                if (!self.slate.isShift) self.enactMove(dx, dy);
            },
            async up () {
                if (!self.slate.isShift) self.finishDrag(true);
            },
            dragger (x, y, e) {
                if (!self.slate.canvas.isDragging) {
                    self.slate.nodes.closeAllMenus();
                    if (self.slate.isShift) {
                        if (!self.slate.candidatesForSelection[self.node.options.id]) {
                            self.slate.candidatesForSelection[self.node.options.id] = true;
                            self.slate.multiSelection.add(self.node);
                        } else {
                            delete self.slate.candidatesForSelection[self.node.options.id];
                            self.slate.multiSelection.remove(self.node);
                        }
                        (0, _utilsDefault.default).stopEvent(e);
                    } else {
                        self.slate.multiSelection.clear();
                        self.slate.candidatesForSelection = {};
                        self.node.toggleImage({
                            active: true
                        });
                        // hide filters
                        self.slate.toggleFilters(true) //, self.node.options.id
                        ;
                        // self.slate.canvas._bg?.hide();
                        if (self.node.events?.onClick) self.node.events.onClick.apply(self, [
                            function() {
                                self._initDrag(self, e);
                            }
                        ]);
                        else self._initDrag(self, e);
                    }
                }
            }
        };
    }
    showMenu(e) {
        const self = this;
        self.slate.nodes.closeAllMenus({
            exception: self.node.options.id
        });
        self.slate.enable();
        if (self.node?.menu?.show && self.node.options.allowMenu && !self.node.menu.isOpen()) {
            if (self.node?.options.groupId) self.slate.multiSelection.showGroup(self.node?.options.groupId);
            self.node.menu.show();
        }
        (0, _utilsDefault.default).stopEvent(e);
    }
    finishDrag(blnBroadcast) {
        const self = this;
        self.slate.draggingNode = false;
        self.selectedNodes.forEach((nd)=>{
            // the transformPath here converts the transient transforms that happened during the movement
            // to become permanent on the "attr" properties.
            (0, _utilsDefault.default).transformPath(nd, `T${self._dx},${self._dy}`);
            nd.vect.currentDx = 0;
            nd.vect.currentDy = 0;
            if (self.slate.options.debugMode) nd.debugPosition();
            if (!self.slate.keyboardActive) nd.editor.setTextOffset();
        });
        (0, _refreshRelationshipsDefault.default)({
            relationships: self.relationshipsToRefresh,
            nodes: self.selectedNodes,
            dx: 0,
            dy: 0
        });
        self.slate.nodes.saveRelationships(self.relationshipsToTranslate, {
            dx: self._dx,
            dy: self._dy
        });
        if (blnBroadcast) {
            self.send({
                nodes: self.selectedNodes,
                relationships: self.relationshipsToRefresh.concat(self.relationshipsToTranslate)
            });
            self.selectedNodes.forEach((n)=>{
                n.relationships.showAll(true);
            });
            if (self.foreignPoints?.length > 0) {
                self.kdTree.dispose();
                delete self.foreignPoints;
                clearTimeout(self.gracefulClear);
                self.gracefulClear = setTimeout(()=>{
                    self.node.gridLines.clear();
                }, 200);
            }
        }
        // console.log("here we go", self.selectedNodes);
        // self.slate.canvas._bg?.show();
        // finish drag
        self.slate.toggleFilters(false);
        self.showMenu();
    }
    enactMove(dx, dy) {
        const self = this;
        dx = Math.ceil(dx);
        dy = Math.ceil(dy);
        // adjust the dx and dy if snapping to grid
        // if (slate.options.viewPort.showGrid && slate.options.viewPort.snapToGrid) {
        //   let gridSize = slate.options.viewPort.gridSize || 10;
        //   dx = Math.round(dx / gridSize) * gridSize;
        //   dy = Math.round(dy / gridSize) * gridSize;
        // }
        const z = self.slate.options.viewPort.zoom.r;
        dx += dx / z - dx;
        dy += dy / z - dy;
        self.selectedNodes.forEach((nd, i)=>{
            nd.vect.currentDx = dx;
            nd.vect.currentDy = dy;
            nd.translateWith({
                dx,
                dy
            });
            // console.log("yPos ", i, node.options.yPos);
            // only snap and show guidelines for primary moving node, none of its children
            if (i === 0 && nd.options.id !== self.slate.tempNodeId && !self.slate.keyboardActive) {
                // const nbb = node.vect.getBBox();
                const nearest = self.kdTree.knn([
                    nd.options.xPos,
                    nd.options.yPos
                ], 2) // , 1);
                ;
                nearest.forEach((n)=>{
                    ({ dx, dy } = self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox));
                });
            }
        });
        self.slate.nodes.translateRelationships(self.relationshipsToTranslate, {
            dx,
            dy
        });
        (0, _refreshRelationshipsDefault.default)({
            relationships: self.relationshipsToRefresh,
            nodes: self.selectedNodes,
            dx,
            dy
        });
        self._dx = dx;
        self._dy = dy;
    }
    _broadcast(pkg) {
        this.slate.collab?.send(pkg);
    }
    _hitTest(mp) {
        const self = this;
        let overNode = null;
        const off = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        self.slate.nodes.allNodes.forEach((nd)=>{
            if (nd.options.id !== self.slate.tempNodeId && nd.options.id !== self.node.options.id && nd.options.allowContext && nd.options.allowResize) {
                const _bb = nd.vect.getBBox();
                const _zr = self.slate.options.viewPort.zoom.r;
                const xp = self.slate.options.viewPort.left + mp.x - off.left;
                const yp = self.slate.options.viewPort.top + mp.y - off.top;
                const c = {
                    x: xp + (xp / _zr - xp),
                    y: yp + (yp / _zr - yp)
                };
                if (c.x > _bb.x && c.x < _bb.x + _bb.width && c.y > _bb.y && c.y < _bb.y + _bb.height) overNode = nd;
            }
        });
        return overNode;
    }
    _remove(associations, type, obj) {
        const _na = [];
        const self = this;
        associations.forEach((association)=>{
            if (association[type].options.id === obj.options.id) self.removeRelationship(association);
            else _na.push(association);
        });
        return _na;
    }
    _initDrag(vect, e) {
        const self = this;
        self.selectedNodes = [];
        self.relationshipsToRefresh = [];
        self.relationshipsToTranslate = [];
        self.collabSent = false;
        self.slate.draggingNode = true;
        self._dx = 0;
        self._dy = 0;
        self.node.options.humanTouch = true;
        self.slate.multiSelection?.end();
        if (self.slate.options.linking) self.slate.options.linking.onNode.apply(vect, [
            self
        ]);
        else if (self.node.options.allowDrag && !self.node.options.disableDrag) {
            self.selectedNodes = self.getSelectedNodes();
            const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
            self.relationshipsToTranslate = _associations.relationshipsToTranslate;
            self.relationshipsToRefresh = _associations.relationshipsToRefresh;
            self.selectedNodes.forEach((n)=>{
                n.setStartDrag();
                n.vect.ox = n.options.xPos;
                n.vect.oy = n.options.yPos;
            });
            const selectedIds = self.selectedNodes.map((n)=>n.options.id);
            self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>selectedIds.indexOf(n.options.id) === -1).map((n)=>({
                    id: n.options.id,
                    bbox: n.vect.getBBox(),
                    point: [
                        n.options.xPos,
                        n.options.yPos
                    ]
                }));
            self.kdTree = (0, _staticKdtreeDefault.default)(self.foreignPoints.map((fp)=>fp.point));
            self.conditionallyHideAll();
        } else (0, _utilsDefault.default).stopEvent(e);
    }
    async initiateTempNode(e, _parent, _assocPkg) {
        const self = this;
        const mp = (0, _utilsDefault.default).mousePos(e);
        const _slate = _parent.slate;
        const off = (0, _utilsDefault.default).positionedOffset(_slate.options.container);
        const _zr = self.slate.options.viewPort.zoom.r;
        const xp = _slate.options.viewPort.left + mp.x - off.left;
        const yp = _slate.options.viewPort.top + mp.y - off.top;
        const _xPos = xp + (xp / _zr - xp);
        const _yPos = yp + (yp / _zr - yp);
        const _path = (0, _utilsDefault.default)._transformPath((0, _sbIconsDefault.default).icons.handle, `T${_xPos - 15}, ${_yPos - 15}`);
        const _tempNode = new (0, _nodeDefault.default)({
            id: self.slate.tempNodeId,
            xPos: _xPos,
            yPos: _yPos,
            lineColor: "#990000",
            backgroundColor: "#ffffff",
            vectorPath: _path,
            width: 30,
            height: 30
        });
        _slate.nodes.add(_tempNode, true);
        const _tempRelationship = _parent.relationships.addAssociation(_tempNode, _assocPkg, true);
        _tempRelationship.hoveredOver = null;
        _tempRelationship.lastHoveredOver = null;
        // initiates the drag
        _tempNode.vect.start(e) // , off.x, off.y);
        ;
        _slate.options.allowDrag = false;
        _tempNode.vect.mousemove((ex)=>{
            // is there a current hit?
            if (_tempRelationship.hoveredOver === null) {
                _tempRelationship.hoveredOver = self._hitTest((0, _utilsDefault.default).mousePos(ex));
                if (_tempRelationship.hoveredOver !== null) // yes, currently over a node -- scale it
                _tempRelationship.hoveredOver.vect.animate({
                    "stroke-width": 5
                }, 500, ()=>{
                    _tempRelationship.hoveredOver.vect.animate({
                        "stroke-width": self.node.options.borderWidth
                    }, 500, ()=>{
                        _tempRelationship.hoveredOver = null;
                    });
                });
            }
        });
        _tempNode.vect.mouseup((ex)=>{
            _parent.relationships.removeAssociation(_tempNode);
            _tempNode.slate.nodes.remove(_tempNode);
            const overNode = self._hitTest((0, _utilsDefault.default).mousePos(ex));
            if (overNode !== null) {
                // overNode.vect.transform("s1,1,");
                // check if overNode has any parents
                const _relevantAssociations = overNode.relationships.associations.filter((association)=>overNode.options.id === association.child.options.id);
                overNode.options.parents = _relevantAssociations.map((a1)=>a1.parent.options.id);
                // check if the two nodes are already associated -- multiple associations between two nodes are currently not supported
                const relevantAssociation = _parent.relationships.associations.find((association)=>association.child.options.id === overNode.options.id && association.parent.options.id === _parent.options.id || association.parent.options.id === overNode.options.id && association.child.options.id === _parent.options.id);
                if (!relevantAssociation) {
                    _parent.relationships.addAssociation(overNode, _assocPkg);
                    const _pkgx = {
                        type: "addRelationship",
                        data: {
                            type: "association",
                            parent: _parent.options.id,
                            child: overNode.options.id
                        }
                    };
                    self.slate.birdsEye?.relationshipsChanged(_pkgx);
                    self._broadcast(_pkgx);
                }
            }
            if (self.slate.options.enabled) _parent.slate.options.allowDrag = true;
        });
    }
    _visibility(action) {
        if (this.node.options.id !== this.slate.tempNodeId) for(let i = this.associations.length; i < this.associations.length; i += 1)this.associations[i].line[action]();
    }
    removeAll() {
        const self = this;
        self.associations.forEach((association)=>{
            association.child.relationships.removeAssociation(self.node) // .parent);
            ;
            association.parent.relationships.removeAssociation(self.node);
            self.removeRelationship(association);
        });
        self.associations = [];
    }
    removeAssociation(_node) {
        this.associations = this._remove(this.associations, "child", _node);
        this.associations = this._remove(this.associations, "parent", _node);
        return this;
    }
    setKeys({ isShift, isAlt }) {
        this._isLastShift = isShift;
        this._isLastAlt = isAlt;
    }
    addAssociation(_node, assocPkg) {
        assocPkg = assocPkg || {};
        // make sure this doesn't already exist
        let _connection = this.associations.find((a1)=>a1.child.options.id === _node.options.id);
        if (!_connection) {
            const _copts = {
                id: (0, _utilsDefault.default).guid(),
                parent: this.node,
                child: _node,
                lineColor: assocPkg.lineColor || this.node.options.lineColor,
                lineWidth: assocPkg.lineWidth || this.node.options.lineWidth,
                lineType: assocPkg.lineType || this.node.options.lineType,
                lineCurveType: assocPkg.lineCurveType || this.node.options.lineCurveType,
                lineOpacity: assocPkg.lineOpacity != null ? assocPkg.lineOpacity : this.node.options.lineOpacity,
                lineEffect: assocPkg.lineEffect || this.node.options.lineEffect,
                blnStraight: assocPkg.isStraightLine || false,
                showParentArrow: assocPkg.showParentArrow || false,
                showChildArrow: assocPkg.showChildArrow || true
            };
            _connection = this.createNewRelationship(_copts);
            _connection.line.toBack();
            this.associations.push(_connection);
            _node.relationships.associations.push(_connection);
            this.wireLineEvents(_connection);
        }
        _node.slate.allLines.push(_connection) // helper for managing raw line attrs
        ;
        return _connection;
    }
    createNewRelationship(opts) {
        const { paper } = this.slate;
        const association = {
            parent: null,
            child: null,
            lineColor: "#fff",
            lineOpacity: 1,
            lineEffect: "",
            lineWidth: 20,
            lineType: "bezier",
            lineCurveType: "cubic",
            blnStraight: false,
            showParentArrow: false,
            showChildArrow: true
        };
        Object.assign(association, opts);
        const _attr = {
            stroke: association.lineColor,
            class: "association",
            fill: "none",
            "stroke-width": association.lineWidth,
            "fill-opacity": association.lineOpacity,
            filter: association.lineEffect && !(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile() ? `url(#${association.lineEffect})` : "",
            opacity: association.lineOpacity
        };
        // these two generic points will be adjusted after the line is created
        const origPoint = {
            x: 1,
            y: 1
        };
        const endPoint = {
            x: 200,
            y: 200
        };
        if (!association.line) Object.assign(association, {
            line: paper.path((0, _getHorizontalCurveDefault.default)(origPoint, endPoint, 0.5, association.lineType, association.lineCurveType)).attr(_attr)
        });
        if (association.child && association.parent) (0, _refreshRelationshipsDefault.default)({
            relationships: [
                association
            ],
            nodes: [
                association.parent
            ]
        });
        return association;
    }
    removeRelationship(association) {
        const self = this;
        self.node.slate?.allLines.splice(self.slate?.allLines.findIndex((l)=>l.id === association.id));
        association.line.remove();
    }
    wireLineEvents(c) {
        const self = this;
        if (self.node.options.allowMenu) {
            c.line.node.style.cursor = "pointer";
            c.line.mousedown((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                self.node.lineOptions.show(e, c);
            });
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
    }
    getSelectedNodes() {
        const self = this;
        self.selectedNodes = [];
        if (self.node.options.isLocked === false) {
            self.selectedNodes.push(self.node);
            this.syncAssociations(self.node, (c, a1)=>{
                if (!self.selectedNodes.some((n)=>n.options.id === c.options.id) && c.options.isLocked === false) self.selectedNodes.push(c);
            });
        }
        return self.selectedNodes;
    }
    syncAssociations(nd, cb) {
        const self = this;
        if (!self.slate.isCtrl || self.slate.isCtrl && self.slate.isShift) nd.relationships.associations.forEach((a1)=>{
            if (a1.child.options.id !== self.node.options.id && a1.child.options.id !== nd.options.id) {
                if (cb) cb(a1.child, a1);
                if (self.slate.isCtrl && self.slate.isShift) self.syncAssociations(a1.child, cb);
            }
        });
    }
    updateAssociationsWith(opts) {
        const conditionalSet = {};
        if (opts.conditional) {
            opts.conditional.forEach((setContext, i)=>{
                conditionalSet[i] = setContext;
            });
            delete opts.conditional;
        }
        this.associations.forEach((a1)=>{
            Object.assign(a1, opts);
            Object.keys(conditionalSet).forEach((sc)=>{
                const setContext = conditionalSet[sc];
                if (setContext.condition(a1, setContext.data)) a1[setContext.key] = setContext.getValue(a1, setContext.data);
            });
        });
    }
    updateSingleAssociationWith(key, opts) {
        const association = this.associations.find(a, key);
        if (association) Object.assign(association, opts);
    }
    send(opts) {
        if (this.node.context && !this.node.context.isVisible() && this.node.options.allowDrag && !this.node.options.disableDrag) {
            const pkg = {
                type: "onNodesMove"
            };
            if (opts.nodes && opts.relationships) pkg.data = this.slate.nodes.nodeMovePackage({
                nodes: opts.nodes,
                relationships: opts.relationships,
                dur: 300
            });
            else pkg.data = this.slate.nodes.nodeMovePackage({
                dur: 300
            });
            this.slate.collab?.send(pkg);
            this.slate.birdsEye?.nodeChanged(pkg);
            this.collabSent = true;
        }
    }
    conditionallyHideAll() {
        const self = this;
        if (self.node.options.id !== self.slate.tempNodeId) {
            const exceeds = self.node.options.vectorPath.length > self.PATH_COMPLEXITY_LIMIT;
            if (exceeds) self.hideAll(true);
            self.associations.forEach((a1)=>{
                const cexceed = exceeds || a1.child.options.vectorPath.length > self.PATH_COMPLEXITY_LIMIT;
                a1.child.relationships.hideAll(cexceed);
            });
        }
    }
    hideAll(_blnOverride) {
        if (this.slate.isAlt && this.slate.isShift || _blnOverride) this._visibility("hide");
    }
    hideOwn() {
        this.associations.forEach((association)=>{
            association.line.hide();
        });
    }
    showOwn() {
        this.associations.forEach((association)=>{
            association.line.show();
        });
    }
    showAll(_blnOverride) {
        if (this._isLastAlt && this._isLastShift || _blnOverride) this._visibility("show");
    }
    refreshOwnRelationships() {
        (0, _refreshRelationshipsDefault.default)({
            relationships: this.associations,
            nodes: [
                this.node
            ]
        });
    }
    wireDragEvents() {
        const self = this;
        function showText() {
            self.slate.events?.onTextPaneRequested?.apply(this, [
                self.node,
                ()=>{}
            ]);
        }
        if (!self.slate.isReadOnly() && (!self.slate.isCommentOnly() || self.slate.isCommentOnly() && self.node.options.isComment)) {
            self.node.vect.drag(self.dragEvents.move, self.dragEvents.dragger, self.dragEvents.up);
            self.node.text.mousedown((e)=>{
                self.node.vect.start(e);
            });
            self.node.vect.dblclick(()=>{
                showText();
            });
            self.node.text.dblclick(()=>{
                showText();
            });
        }
    }
}
exports.default = relationships;

},{"static-kdtree":"i8GTt","../helpers/refreshRelationships":"1UeYf","../helpers/getHorizontalCurve":"dzUMr","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i8GTt":[function(require,module,exports) {
"use strict";
module.exports = createKDTree;
module.exports.deserialize = deserializeKDTree;
var ndarray = require("56ffc39bd4963f65");
var ndselect = require("16a6ab361ede6e90");
var pack = require("bbe191e4ce289018");
var ops = require("57e5497dd202c34a");
var ndscratch = require("e791068dba03be58");
var pool = require("b6d5133cd896236");
var inorderTree = require("2fe4779a6e794c93");
var bits = require("1dba2711fd8d0fea");
var KDTHeap = require("21c7575bab5643eb");
function KDTree(points, ids, n, d) {
    this.points = points;
    this.ids = ids;
    this.dimension = d;
    this.length = n;
}
var proto = KDTree.prototype;
proto.serialize = function() {
    if (this.length > 0) return {
        p: Array.prototype.slice.call(this.points.data, 0, this.length * this.dimension),
        i: Array.prototype.slice.call(this.ids, 0, this.length)
    };
    else return {
        d: this.dimension
    };
};
//Range query
proto.range = function kdtRangeQuery(lo, hi, visit) {
    var n = this.length;
    if (n < 1) return;
    //Check degenerate case
    var d = this.dimension;
    for(var i = 0; i < d; ++i){
        if (hi[i] < lo[i]) return;
    }
    var points = this.points;
    var ids = this.ids;
    //Walk tree in level order, skipping subtrees which do not intersect range
    var visitRange = ndscratch.malloc([
        n,
        2,
        d
    ]);
    var visitIndex = pool.mallocInt32(n);
    var rangeData = visitRange.data;
    var pointData = points.data;
    var visitCount = 1;
    var visitTop = 0;
    var retval;
    visitIndex[0] = 0;
    pack(lo, visitRange.pick(0, 0));
    pack(hi, visitRange.pick(0, 1));
    while(visitTop < visitCount){
        var idx = visitIndex[visitTop];
        var k = bits.log2(idx + 1) % d;
        var loidx = visitRange.index(visitTop, 0, 0);
        var hiidx = visitRange.index(visitTop, 1, 0);
        var pidx = points.index(idx, 0);
        var visitPoint = true;
        for(var i = 0; i < d; ++i){
            var pc = pointData[pidx + i];
            if (pc < rangeData[loidx + i] || rangeData[hiidx + i] < pc) {
                visitPoint = false;
                break;
            }
        }
        if (visitPoint) {
            retval = visit(ids[idx]);
            if (retval !== undefined) break;
        }
        //Visit children
        var pk = pointData[pidx + k];
        var hk = rangeData[hiidx + k];
        var lk = rangeData[loidx + k];
        if (lk <= pk) {
            var left = 2 * idx + 1;
            if (left < n) {
                visitIndex[visitCount] = left;
                var y = visitRange.index(visitCount, 0, 0);
                for(var i = 0; i < d; ++i)rangeData[y + i] = rangeData[loidx + i];
                var z = visitRange.index(visitCount, 1, 0);
                for(var i = 0; i < d; ++i)rangeData[z + i] = rangeData[hiidx + i];
                rangeData[z + k] = Math.min(hk, pk);
                visitCount += 1;
            }
        }
        if (pk <= hk) {
            var right = 2 * (idx + 1);
            if (right < n) {
                visitIndex[visitCount] = right;
                var y = visitRange.index(visitCount, 0, 0);
                for(var i = 0; i < d; ++i)rangeData[y + i] = rangeData[loidx + i];
                var z = visitRange.index(visitCount, 1, 0);
                for(var i = 0; i < d; ++i)rangeData[z + i] = rangeData[hiidx + i];
                rangeData[y + k] = Math.max(lk, pk);
                visitCount += 1;
            }
        }
        //Increment pointer
        visitTop += 1;
    }
    ndscratch.free(visitRange);
    pool.free(visitIndex);
    return retval;
};
proto.rnn = function(point, radius, visit) {
    if (radius < 0) return;
    var n = this.length;
    if (n < 1) return;
    var d = this.dimension;
    var points = this.points;
    var ids = this.ids;
    //Walk tree in level order, skipping subtrees which do not intersect sphere
    var visitDistance = ndscratch.malloc([
        n,
        d
    ]);
    var visitIndex = pool.mallocInt32(n);
    var distanceData = visitDistance.data;
    var pointData = points.data;
    var visitCount = 1;
    var visitTop = 0;
    var r2 = radius * radius;
    var retval;
    //Initialize top of queue
    visitIndex[0] = 0;
    for(var i = 0; i < d; ++i)visitDistance.set(0, i, 0);
    //Walk over queue
    while(visitTop < visitCount){
        var idx = visitIndex[visitTop];
        var pidx = points.index(idx, 0);
        //Check if point in sphere
        var d2 = 0.0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 <= r2) {
            retval = visit(ids[idx]);
            if (retval !== undefined) break;
        }
        //Visit children
        var k = bits.log2(idx + 1) % d;
        var ds = 0.0;
        var didx = visitDistance.index(visitTop, 0);
        for(var i = 0; i < d; ++i)if (i !== k) ds += distanceData[didx + i];
        //Handle split axis
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = distanceData[didx + k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        if (d2l <= r2) {
            var left = 2 * idx + 1;
            if (left < n) {
                visitIndex[visitCount] = left;
                var y = visitDistance.index(visitCount, 0);
                for(var i = 0; i < d; ++i)distanceData[y + i] = distanceData[didx + i];
                distanceData[y + k] = lk;
                visitCount += 1;
            }
        }
        if (d2h <= r2) {
            var right = 2 * (idx + 1);
            if (right < n) {
                visitIndex[visitCount] = right;
                var y = visitDistance.index(visitCount, 0);
                for(var i = 0; i < d; ++i)distanceData[y + i] = distanceData[didx + i];
                distanceData[y + k] = hk;
                visitCount += 1;
            }
        }
        //Increment pointer
        visitTop += 1;
    }
    ndscratch.free(visitDistance);
    pool.free(visitIndex);
    return retval;
};
proto.nn = function(point, maxDistance) {
    var n = this.length;
    if (n < 1) return -1;
    if (typeof maxDistance === "number") {
        if (maxDistance < 0) return -1;
    } else maxDistance = Infinity;
    var d = this.dimension;
    var points = this.points;
    var pointData = points.data;
    var dataVector = pool.mallocFloat64(d);
    var toVisit = new KDTHeap(n, d + 1);
    var index = toVisit.index;
    var data = toVisit.data;
    index[0] = 0;
    for(var i = 0; i <= d; ++i)data[i] = 0;
    toVisit.count += 1;
    var nearest = -1;
    var nearestD = maxDistance;
    while(toVisit.count > 0){
        if (data[0] >= nearestD) break;
        var idx = index[0];
        var pidx = points.index(idx, 0);
        var d2 = 0.0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 < nearestD) {
            nearestD = d2;
            nearest = idx;
        }
        //Compute distance bounds for children
        var k = bits.log2(idx + 1) % d;
        var ds = 0;
        for(var i = 0; i < d; ++i){
            var dd = data[i + 1];
            if (i !== k) ds += dd;
            dataVector[i] = dd;
        }
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = dataVector[k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        toVisit.pop();
        if (d2l < nearestD) {
            var left = 2 * idx + 1;
            if (left < n) {
                var vcount = toVisit.count;
                index[vcount] = left;
                var vptr = vcount * (d + 1);
                data[vptr] = d2l;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = lk;
                toVisit.push();
            }
        }
        if (d2h < nearestD) {
            var right = 2 * (idx + 1);
            if (right < n) {
                var vcount = toVisit.count;
                index[vcount] = right;
                var vptr = vcount * (d + 1);
                data[vptr] = d2h;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = hk;
                toVisit.push();
            }
        }
    }
    pool.freeFloat64(dataVector);
    toVisit.dispose();
    if (nearest < 0) return -1;
    return this.ids[nearest];
};
proto.knn = function(point, maxPoints, maxDistance) {
    //Check degenerate cases
    if (typeof maxDistance === "number") {
        if (maxDistance < 0) return [];
    } else maxDistance = Infinity;
    var n = this.length;
    if (n < 1) return [];
    if (typeof maxPoints === "number") {
        if (maxPoints <= 0) return [];
        maxPoints = Math.min(maxPoints, n) | 0;
    } else maxPoints = n;
    var ids = this.ids;
    var d = this.dimension;
    var points = this.points;
    var pointData = points.data;
    var dataVector = pool.mallocFloat64(d);
    //List of closest points
    var closestPoints = new KDTHeap(maxPoints, 1);
    var cl_index = closestPoints.index;
    var cl_data = closestPoints.data;
    var toVisit = new KDTHeap(n, d + 1);
    var index = toVisit.index;
    var data = toVisit.data;
    index[0] = 0;
    for(var i = 0; i <= d; ++i)data[i] = 0;
    toVisit.count += 1;
    var nearest = -1;
    var nearestD = maxDistance;
    while(toVisit.count > 0){
        if (data[0] >= nearestD) break;
        var idx = index[0];
        var pidx = points.index(idx, 0);
        var d2 = 0.0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 < nearestD) {
            if (closestPoints.count >= maxPoints) closestPoints.pop();
            var pcount = closestPoints.count;
            cl_index[pcount] = idx;
            cl_data[pcount] = -d2;
            closestPoints.push();
            if (closestPoints.count >= maxPoints) nearestD = -cl_data[0];
        }
        //Compute distance bounds for children
        var k = bits.log2(idx + 1) % d;
        var ds = 0;
        for(var i = 0; i < d; ++i){
            var dd = data[i + 1];
            if (i !== k) ds += dd;
            dataVector[i] = dd;
        }
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = dataVector[k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        toVisit.pop();
        if (d2l < nearestD) {
            var left = 2 * idx + 1;
            if (left < n) {
                var vcount = toVisit.count;
                index[vcount] = left;
                var vptr = vcount * (d + 1);
                data[vptr] = d2l;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = lk;
                toVisit.push();
            }
        }
        if (d2h < nearestD) {
            var right = 2 * (idx + 1);
            if (right < n) {
                var vcount = toVisit.count;
                index[vcount] = right;
                var vptr = vcount * (d + 1);
                data[vptr] = d2h;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = hk;
                toVisit.push();
            }
        }
    }
    pool.freeFloat64(dataVector);
    toVisit.dispose();
    //Sort result
    var result = new Array(closestPoints.count);
    var ids = this.ids;
    for(var i = closestPoints.count - 1; i >= 0; --i){
        result[i] = ids[cl_index[0]];
        closestPoints.pop();
    }
    closestPoints.dispose();
    return result;
};
proto.dispose = function kdtDispose() {
    pool.free(this.points.data);
    pool.freeInt32(this.ids);
    this.points = null;
    this.ids = null;
    this.length = 0;
};
function Queue() {
    this.data = [];
    this.offset = 0;
}
Queue.prototype.size = function() {
    return this.data.length - this.offset;
};
Queue.prototype.push = function(item) {
    return this.data.push(item);
};
Queue.prototype.pop = function() {
    if (this.size() === 0) return undefined;
    var ret = this.data[this.offset];
    this.offset++;
    if (this.data.length > 1024 && this.offset * 2 > this.data.length) {
        this.data = this.data.slice(this.offset);
        this.offset = 0;
    }
    return ret;
};
function createKDTree(points) {
    var n, d, indexed;
    if (Array.isArray(points)) {
        n = points.length;
        if (n === 0) return new KDTree(null, null, 0, 0);
        d = points[0].length;
        indexed = ndarray(pool.mallocDouble(n * (d + 1)), [
            n,
            d + 1
        ]);
        pack(points, indexed.hi(n, d));
    } else {
        n = points.shape[0];
        d = points.shape[1];
        //Round up data type size
        var type = points.dtype;
        if (type === "int8" || type === "int16" || type === "int32") type = "int32";
        else if (type === "uint8" || type === "uint8_clamped" || type === "buffer" || type === "uint16" || type === "uint32") type = "uint32";
        else if (type === "float32") type = "float32";
        else type = "float64";
        indexed = ndarray(pool.malloc(n * (d + 1), type), [
            n,
            d + 1
        ]);
        ops.assign(indexed.hi(n, d), points);
    }
    for(var i = 0; i < n; ++i)indexed.set(i, d, i);
    var pointArray = ndscratch.malloc([
        n,
        d
    ], points.dtype);
    var indexArray = pool.mallocInt32(n);
    var pointer = 0;
    var pointData = pointArray.data;
    var arrayData = indexed.data;
    var l2_n = bits.log2(bits.nextPow2(n));
    var sel_cmp = ndselect.compile(indexed.order, true, indexed.dtype);
    //Walk tree in level order
    var toVisit = new Queue();
    toVisit.push(indexed);
    while(pointer < n){
        var head = toVisit.pop();
        var array = head;
        var nn = array.shape[0] | 0;
        //Find median
        if (nn > 1) {
            var k = bits.log2(pointer + 1) % d;
            var median;
            var n_2 = inorderTree.root(nn);
            median = sel_cmp(array, n_2, function(a, b) {
                return a.get(k) - b.get(k);
            });
            //Copy into new array
            var pptr = pointArray.index(pointer, 0);
            var mptr = median.offset;
            for(var i = 0; i < d; ++i)pointData[pptr++] = arrayData[mptr++];
            indexArray[pointer] = arrayData[mptr];
            pointer += 1;
            //Queue new items
            toVisit.push(array.hi(n_2));
            if (nn > 2) toVisit.push(array.lo(n_2 + 1));
        } else {
            //Copy into new array
            var mptr = array.offset;
            var pptr = pointArray.index(pointer, 0);
            for(var i = 0; i < d; ++i)pointData[pptr + i] = arrayData[mptr++];
            indexArray[pointer] = arrayData[mptr];
            pointer += 1;
        }
    }
    //Release indexed
    pool.free(indexed.data);
    return new KDTree(pointArray, indexArray, n, d);
}
function deserializeKDTree(data) {
    var points = data.p;
    var ids = data.i;
    if (points) {
        var nd = points.length;
        var pointArray = pool.mallocFloat64(nd);
        for(var i = 0; i < nd; ++i)pointArray[i] = points[i];
        var n = ids.length;
        var idArray = pool.mallocInt32(n);
        for(var i = 0; i < n; ++i)idArray[i] = ids[i];
        var d = nd / n | 0;
        return new KDTree(ndarray(pointArray, [
            n,
            d
        ]), idArray, n, d);
    } else return new KDTree(null, null, 0, data.d);
}

},{"56ffc39bd4963f65":"1nDU8","16a6ab361ede6e90":"6mCoB","bbe191e4ce289018":"48txd","57e5497dd202c34a":"kXyuI","e791068dba03be58":"7acsC","b6d5133cd896236":"1RryJ","2fe4779a6e794c93":"7V1A8","1dba2711fd8d0fea":"9kWjw","21c7575bab5643eb":"epTUT"}],"1nDU8":[function(require,module,exports) {
var iota = require("291764fc3ebef119");
var isBuffer = require("1241284d4b1d2198");
var hasTypedArrays = typeof Float64Array !== "undefined";
function compare1st(a, b) {
    return a[0] - b[0];
}
function order() {
    var stride = this.stride;
    var terms = new Array(stride.length);
    var i;
    for(i = 0; i < terms.length; ++i)terms[i] = [
        Math.abs(stride[i]),
        i
    ];
    terms.sort(compare1st);
    var result = new Array(terms.length);
    for(i = 0; i < result.length; ++i)result[i] = terms[i][1];
    return result;
}
function compileConstructor(dtype, dimension) {
    var className = [
        "View",
        dimension,
        "d",
        dtype
    ].join("");
    if (dimension < 0) className = "View_Nil" + dtype;
    var useGetters = dtype === "generic";
    if (dimension === -1) {
        //Special case for trivial arrays
        var code = "function " + className + "(a){this.data=a;};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + className + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
    } else if (dimension === 0) {
        //Special case for 0d arrays
        var code = "function " + className + "(a,d) {this.data = a;this.offset = d};var proto=" + className + ".prototype;proto.dtype='" + dtype + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + className + "_copy() {return new " + className + "(this.data,this.offset)};proto.pick=function " + className + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + className + "_get(){return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + className + "_set(v){return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
    }
    var code = [
        "'use strict'"
    ];
    //Create constructor for view
    var indices = iota(dimension);
    var args = indices.map(function(i) {
        return "i" + i;
    });
    var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i;
    }).join("+");
    var shapeArg = indices.map(function(i) {
        return "b" + i;
    }).join(",");
    var strideArg = indices.map(function(i) {
        return "c" + i;
    }).join(",");
    code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension);
    //view.size:
    code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){return " + indices.map(function(i) {
        return "this.shape[" + i + "]";
    }).join("*"), "}})");
    //view.order:
    if (dimension === 1) code.push("proto.order=[0]");
    else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
            code.push("function " + className + "_order(){");
            if (dimension === 2) code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
            else if (dimension === 3) code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})");
        } else code.push("ORDER})");
    }
    //view.set(i0, ..., v):
    code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
    if (useGetters) code.push("return this.data.set(" + index_str + ",v)}");
    else code.push("return this.data[" + index_str + "]=v}");
    //view.get(i0, ...):
    code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
    if (useGetters) code.push("return this.data.get(" + index_str + ")}");
    else code.push("return this.data[" + index_str + "]}");
    //view.index:
    code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}");
    //view.hi():
    code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i) {
        return [
            "(typeof i",
            i,
            "!=='number'||i",
            i,
            "<0)?this.shape[",
            i,
            "]:i",
            i,
            "|0"
        ].join("");
    }).join(",") + "," + indices.map(function(i) {
        return "this.stride[" + i + "]";
    }).join(",") + ",this.offset)}");
    //view.lo():
    var a_vars = indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    });
    var c_vars = indices.map(function(i) {
        return "c" + i + "=this.stride[" + i + "]";
    });
    code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
    for(var i = 0; i < dimension; ++i)code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){d=i" + i + "|0;b+=c" + i + "*d;a" + i + "-=d}");
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "c" + i;
    }).join(",") + ",b)}");
    //view.step():
    code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i + "=this.stride[" + i + "]";
    }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
    for(var i = 0; i < dimension; ++i)code.push("if(typeof i" + i + "==='number'){d=i" + i + "|0;if(d<0){c+=b" + i + "*(a" + i + "-1);a" + i + "=ceil(-a" + i + "/d)}else{a" + i + "=ceil(a" + i + "/d)}b" + i + "*=d}");
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i;
    }).join(",") + ",c)}");
    //view.transpose():
    var tShape = new Array(dimension);
    var tStride = new Array(dimension);
    for(var i = 0; i < dimension; ++i){
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
    }
    code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
        return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
    }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}");
    //view.pick():
    code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
    for(var i = 0; i < dimension; ++i)code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
    code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
    //Add return statement
    code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i) {
        return "shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "stride[" + i + "]";
    }).join(",") + ",offset)}");
    //Compile procedure
    var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
    return procedure(CACHED_CONSTRUCTORS[dtype], order);
}
function arrayDType(data) {
    if (isBuffer(data)) return "buffer";
    if (hasTypedArrays) switch(Object.prototype.toString.call(data)){
        case "[object Float64Array]":
            return "float64";
        case "[object Float32Array]":
            return "float32";
        case "[object Int8Array]":
            return "int8";
        case "[object Int16Array]":
            return "int16";
        case "[object Int32Array]":
            return "int32";
        case "[object Uint8Array]":
            return "uint8";
        case "[object Uint16Array]":
            return "uint16";
        case "[object Uint32Array]":
            return "uint32";
        case "[object Uint8ClampedArray]":
            return "uint8_clamped";
        case "[object BigInt64Array]":
            return "bigint64";
        case "[object BigUint64Array]":
            return "biguint64";
    }
    if (Array.isArray(data)) return "array";
    return "generic";
}
var CACHED_CONSTRUCTORS = {
    "float32": [],
    "float64": [],
    "int8": [],
    "int16": [],
    "int32": [],
    "uint8": [],
    "uint16": [],
    "uint32": [],
    "array": [],
    "uint8_clamped": [],
    "bigint64": [],
    "biguint64": [],
    "buffer": [],
    "generic": []
};
function wrappedNDArrayCtor(data, shape, stride, offset) {
    if (data === undefined) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
    } else if (typeof data === "number") data = [
        data
    ];
    if (shape === undefined) shape = [
        data.length
    ];
    var d = shape.length;
    if (stride === undefined) {
        stride = new Array(d);
        for(var i = d - 1, sz = 1; i >= 0; --i){
            stride[i] = sz;
            sz *= shape[i];
        }
    }
    if (offset === undefined) {
        offset = 0;
        for(var i = 0; i < d; ++i)if (stride[i] < 0) offset -= (shape[i] - 1) * stride[i];
    }
    var dtype = arrayDType(data);
    var ctor_list = CACHED_CONSTRUCTORS[dtype];
    while(ctor_list.length <= d + 1)ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
    var ctor = ctor_list[d + 1];
    return ctor(data, shape, stride, offset);
}
module.exports = wrappedNDArrayCtor;

},{"291764fc3ebef119":"hvCq1","1241284d4b1d2198":"9JmUB"}],"hvCq1":[function(require,module,exports) {
"use strict";
function iota(n) {
    var result = new Array(n);
    for(var i = 0; i < n; ++i)result[i] = i;
    return result;
}
module.exports = iota;

},{}],"9JmUB":[function(require,module,exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ // The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
}

},{}],"6mCoB":[function(require,module,exports) {
"use strict";
module.exports = ndSelect;
module.exports.compile = lookupCache;
//Macros
var ARRAY = "a";
var RANK = "K";
var CMP = "C";
var DATA = "d";
var OFFSET = "o";
var RND = "R";
var TMP = "T";
var LO = "L";
var HI = "H";
var PIVOT = "X";
function SHAPE(i) {
    return "s" + i;
}
function STRIDE(i) {
    return "t" + i;
}
function STEP(i) {
    return "u" + i;
}
function STEP_CMP(i) {
    return "v" + i;
}
function INDEX(i) {
    return "i" + i;
}
function PICK(i) {
    return "p" + i;
}
function PTR(i) {
    return "x" + i;
}
//Create new order where index 0 is slowest index
function permuteOrder(order) {
    var norder = order.slice();
    norder.splice(order.indexOf(0), 1);
    norder.unshift(0);
    return norder;
}
//Generate quick select procedure
function compileQuickSelect(order, useCompare, dtype) {
    order = permuteOrder(order);
    var dimension = order.length;
    var useGetter = dtype === "generic";
    var funcName = "ndSelect" + dtype + order.join("_") + "_" + (useCompare ? "cmp" : "lex");
    var code = [];
    //Get arguments for code
    var args = [
        ARRAY,
        RANK
    ];
    if (useCompare) args.push(CMP);
    //Unpack ndarray variables
    var vars = [
        DATA + "=" + ARRAY + ".data",
        OFFSET + "=" + ARRAY + ".offset|0",
        RND + "=Math.random",
        TMP
    ];
    for(var i = 0; i < 2; ++i)vars.push(PTR(i) + "=0");
    for(var i = 0; i < dimension; ++i)vars.push(SHAPE(i) + "=" + ARRAY + ".shape[" + i + "]|0", STRIDE(i) + "=" + ARRAY + ".stride[" + i + "]|0", INDEX(i) + "=0");
    for(var i = 1; i < dimension; ++i)if (i > 1) vars.push(STEP_CMP(i) + "=(" + STRIDE(i) + "-" + SHAPE(i - 1) + "*" + STRIDE(i - 1) + ")|0", STEP(order[i]) + "=(" + STRIDE(order[i]) + "-" + SHAPE(order[i - 1]) + "*" + STRIDE(order[i - 1]) + ")|0");
    else vars.push(STEP_CMP(i) + "=" + STRIDE(i), STEP(order[i]) + "=" + STRIDE(order[i]));
    if (useCompare) for(var i = 0; i < 2; ++i)vars.push(PICK(i) + "=" + ARRAY + ".pick(0)");
    vars.push(PIVOT + "=0", LO + "=0", HI + "=" + SHAPE(order[0]) + "-1");
    function compare(out, i0, i1) {
        if (useCompare) code.push(PICK(0), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");", PICK(1), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");", out, "=", CMP, "(", PICK(0), ",", PICK(1), ");");
        else {
            code.push(PTR(0), "=", OFFSET, "+", STRIDE(0), "*(", i0, ");", PTR(1), "=", OFFSET, "+", STRIDE(0), "*(", i1, ");");
            if (dimension > 1) code.push("_cmp:");
            for(var i = dimension - 1; i > 0; --i)code.push("for(", INDEX(i), "=0;", INDEX(i), "<", SHAPE(i), ";", INDEX(i), "++){");
            if (useGetter) code.push(out, "=", DATA, ".get(", PTR(0), ")-", DATA, ".get(", PTR(1), ");");
            else code.push(out, "=", DATA, "[", PTR(0), "]-", DATA, "[", PTR(1), "];");
            if (dimension > 1) code.push("if(", out, ")break _cmp;");
            for(var i = 1; i < dimension; ++i)code.push(PTR(0), "+=", STEP_CMP(i), ";", PTR(1), "+=", STEP_CMP(i), "}");
        }
    }
    function swap(i0, i1) {
        code.push(PTR(0), "=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");", PTR(1), "=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");");
        for(var i = dimension - 1; i > 0; --i)code.push("for(", INDEX(order[i]), "=0;", INDEX(order[i]), "<", SHAPE(order[i]), ";", INDEX(order[i]), "++){");
        if (useGetter) code.push(TMP, "=", DATA, ".get(", PTR(0), ");", DATA, ".set(", PTR(0), ",", DATA, ".get(", PTR(1), "));", DATA, ".set(", PTR(1), ",", TMP, ");");
        else code.push(TMP, "=", DATA, "[", PTR(0), "];", DATA, "[", PTR(0), "]=", DATA, "[", PTR(1), "];", DATA, "[", PTR(1), "]=", TMP, ";");
        for(var i = 1; i < dimension; ++i)code.push(PTR(0), "+=", STEP(order[i]), ";", PTR(1), "+=", STEP(order[i]), "}");
    }
    code.push("while(", LO, "<", HI, "){", PIVOT, "=(", RND, "()*(", HI, "-", LO, "+1)+", LO, ")|0;");
    //Partition array by pivot
    swap(PIVOT, HI) // Store pivot temporarily at the end of the array
    ;
    code.push(PIVOT, "=", LO, ";", "for(", INDEX(0), "=", LO, ";", INDEX(0), "<", HI, ";", INDEX(0), "++){") // Loop over other elements (unequal to the pivot), note that HI now points to the pivot
    ;
    compare(TMP, INDEX(0), HI) // Lexicographical compare of element with pivot
    ;
    code.push("if(", TMP, "<0){");
    swap(PIVOT, INDEX(0)) // Swap current element with element at index PIVOT if it is less than the pivot
    ;
    code.push(PIVOT, "++;");
    code.push("}}");
    swap(PIVOT, HI) // Store pivot right after all elements that are less than the pivot (implying that all elements >= the pivot are behind the pivot)
    ;
    //Check pivot bounds
    code.push("if(", PIVOT, "===", RANK, "){", LO, "=", PIVOT, ";", "break;", "}else if(", RANK, "<", PIVOT, "){", HI, "=", PIVOT, "-1;", "}else{", LO, "=", PIVOT, "+1;", "}", "}");
    if (useCompare) code.push(PICK(0), ".offset=", OFFSET, "+", LO, "*", STRIDE(0), ";", "return ", PICK(0), ";");
    else code.push("return ", ARRAY, ".pick(", LO, ");");
    //Compile and link js together
    var procCode = [
        "'use strict';function ",
        funcName,
        "(",
        args,
        "){",
        "var ",
        vars.join(),
        ";",
        code.join(""),
        "};return ",
        funcName
    ].join("");
    var proc = new Function(procCode);
    return proc();
}
var CACHE = {};
function lookupCache(order, useCompare, dtype) {
    var typesig = order.join() + useCompare + dtype;
    var proc = CACHE[typesig];
    if (proc) return proc;
    return CACHE[typesig] = compileQuickSelect(order, useCompare, dtype);
}
function ndSelect(array, k, compare) {
    k |= 0;
    if (array.dimension === 0 || array.shape[0] <= k || k < 0) return null;
    var useCompare = !!compare;
    var proc = lookupCache(array.order, useCompare, array.dtype);
    if (useCompare) return proc(array, k, compare);
    else return proc(array, k);
}

},{}],"48txd":[function(require,module,exports) {
"use strict";
var ndarray = require("7871a0abdaf74ad1");
var do_convert = require("6880363315b7fa08");
module.exports = function convert(arr, result) {
    var shape = [], c = arr, sz = 1;
    while(Array.isArray(c)){
        shape.push(c.length);
        sz *= c.length;
        c = c[0];
    }
    if (shape.length === 0) return ndarray();
    if (!result) result = ndarray(new Float64Array(sz), shape);
    do_convert(result, arr);
    return result;
};

},{"7871a0abdaf74ad1":"1nDU8","6880363315b7fa08":"kOMeM"}],"kOMeM":[function(require,module,exports) {
module.exports = require("2b9d3126a0b5ee34")({
    "args": [
        "array",
        "scalar",
        "index"
    ],
    "pre": {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    "body": {
        "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
        "args": [
            {
                "name": "_inline_1_arg0_",
                "lvalue": true,
                "rvalue": false,
                "count": 1
            },
            {
                "name": "_inline_1_arg1_",
                "lvalue": false,
                "rvalue": true,
                "count": 1
            },
            {
                "name": "_inline_1_arg2_",
                "lvalue": false,
                "rvalue": true,
                "count": 4
            }
        ],
        "thisVars": [],
        "localVars": [
            "_inline_1_i",
            "_inline_1_v"
        ]
    },
    "post": {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    "funcName": "convert",
    "blockSize": 64
});

},{"2b9d3126a0b5ee34":"7GqVQ"}],"7GqVQ":[function(require,module,exports) {
"use strict";
var createThunk = require("1b3ac231c79cadda");
function Procedure() {
    this.argTypes = [];
    this.shimArgs = [];
    this.arrayArgs = [];
    this.arrayBlockIndices = [];
    this.scalarArgs = [];
    this.offsetArgs = [];
    this.offsetArgIndex = [];
    this.indexArgs = [];
    this.shapeArgs = [];
    this.funcName = "";
    this.pre = null;
    this.body = null;
    this.post = null;
    this.debug = false;
}
function compileCwise(user_args) {
    //Create procedure
    var proc = new Procedure();
    //Parse blocks
    proc.pre = user_args.pre;
    proc.body = user_args.body;
    proc.post = user_args.post;
    //Parse arguments
    var proc_args = user_args.args.slice(0);
    proc.argTypes = proc_args;
    for(var i = 0; i < proc_args.length; ++i){
        var arg_type = proc_args[i];
        if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
            proc.argTypes[i] = "array";
            proc.arrayArgs.push(i);
            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
            proc.shimArgs.push("array" + i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) throw new Error("cwise: pre() block may not reference array args");
            if (i < proc.post.args.length && proc.post.args[i].count > 0) throw new Error("cwise: post() block may not reference array args");
        } else if (arg_type === "scalar") {
            proc.scalarArgs.push(i);
            proc.shimArgs.push("scalar" + i);
        } else if (arg_type === "index") {
            proc.indexArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) throw new Error("cwise: pre() block may not reference array index");
            if (i < proc.body.args.length && proc.body.args[i].lvalue) throw new Error("cwise: body() block may not write to array index");
            if (i < proc.post.args.length && proc.post.args[i].count > 0) throw new Error("cwise: post() block may not reference array index");
        } else if (arg_type === "shape") {
            proc.shapeArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) throw new Error("cwise: pre() block may not write to array shape");
            if (i < proc.body.args.length && proc.body.args[i].lvalue) throw new Error("cwise: body() block may not write to array shape");
            if (i < proc.post.args.length && proc.post.args[i].lvalue) throw new Error("cwise: post() block may not write to array shape");
        } else if (typeof arg_type === "object" && arg_type.offset) {
            proc.argTypes[i] = "offset";
            proc.offsetArgs.push({
                array: arg_type.array,
                offset: arg_type.offset
            });
            proc.offsetArgIndex.push(i);
        } else throw new Error("cwise: Unknown argument type " + proc_args[i]);
    }
    //Make sure at least one array argument was specified
    if (proc.arrayArgs.length <= 0) throw new Error("cwise: No array arguments specified");
    //Make sure arguments are correct
    if (proc.pre.args.length > proc_args.length) throw new Error("cwise: Too many arguments in pre() block");
    if (proc.body.args.length > proc_args.length) throw new Error("cwise: Too many arguments in body() block");
    if (proc.post.args.length > proc_args.length) throw new Error("cwise: Too many arguments in post() block");
    //Check debug flag
    proc.debug = !!user_args.printCode || !!user_args.debug;
    //Retrieve name
    proc.funcName = user_args.funcName || "cwise";
    //Read in block size
    proc.blockSize = user_args.blockSize || 64;
    return createThunk(proc);
}
module.exports = compileCwise;

},{"1b3ac231c79cadda":"fBD3l"}],"fBD3l":[function(require,module,exports) {
"use strict";
// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }
var compile = require("dbf125f9d3121fe");
function createThunk(proc) {
    var code = [
        "'use strict'",
        "var CACHED={}"
    ];
    var vars = [];
    var thunkName = proc.funcName + "_cwise_thunk";
    //Build thunk
    code.push([
        "return function ",
        thunkName,
        "(",
        proc.shimArgs.join(","),
        "){"
    ].join(""));
    var typesig = [];
    var string_typesig = [];
    var proc_args = [
        [
            "array",
            proc.arrayArgs[0],
            ".shape.slice(",
            Math.max(0, proc.arrayBlockIndices[0]),
            proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
        ].join("")
    ];
    var shapeLengthConditions = [], shapeConditions = [];
    // Process array arguments
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        var j = proc.arrayArgs[i];
        vars.push([
            "t",
            j,
            "=array",
            j,
            ".dtype,",
            "r",
            j,
            "=array",
            j,
            ".order"
        ].join(""));
        typesig.push("t" + j);
        typesig.push("r" + j);
        string_typesig.push("t" + j);
        string_typesig.push("r" + j + ".join()");
        proc_args.push("array" + j + ".data");
        proc_args.push("array" + j + ".stride");
        proc_args.push("array" + j + ".offset|0");
        if (i > 0) {
            shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
            shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
        }
    }
    // Check for shape equality
    if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
        code.push("}");
    }
    // Process scalar arguments
    for(var i = 0; i < proc.scalarArgs.length; ++i)proc_args.push("scalar" + proc.scalarArgs[i]);
    // Check for cached function (and if not present, generate it)
    vars.push([
        "type=[",
        string_typesig.join(","),
        "].join()"
    ].join(""));
    vars.push("proc=CACHED[type]");
    code.push("var " + vars.join(","));
    code.push([
        "if(!proc){",
        "CACHED[type]=proc=compile([",
        typesig.join(","),
        "])}",
        "return proc(",
        proc_args.join(","),
        ")}"
    ].join(""));
    if (proc.debug) console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
    //Compile thunk
    var thunk = new Function("compile", code.join("\n"));
    return thunk(compile.bind(undefined, proc));
}
module.exports = createThunk;

},{"dbf125f9d3121fe":"lX50N"}],"lX50N":[function(require,module,exports) {
"use strict";
var uniq = require("14bb0a1dfafc14aa");
// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
    for(i = 0; i < dimension; ++i)vars.push([
        "i",
        i,
        "=0"
    ].join(""));
    //Compute scan deltas
    for(j = 0; j < nargs; ++j)for(i = 0; i < dimension; ++i){
        pidx = idx;
        idx = order[i];
        if (i === 0) vars.push([
            "d",
            j,
            "s",
            i,
            "=t",
            j,
            "p",
            idx
        ].join(""));
        else vars.push([
            "d",
            j,
            "s",
            i,
            "=(t",
            j,
            "p",
            idx,
            "-s",
            pidx,
            "*t",
            j,
            "p",
            pidx,
            ")"
        ].join(""));
    }
    if (vars.length > 0) code.push("var " + vars.join(","));
    //Scan loop
    for(i = dimension - 1; i >= 0; --i){
        idx = order[i];
        code.push([
            "for(i",
            i,
            "=0;i",
            i,
            "<s",
            idx,
            ";++i",
            i,
            "){"
        ].join(""));
    }
    //Push body of inner loop
    code.push(body);
    //Advance scan pointers
    for(i = 0; i < dimension; ++i){
        pidx = idx;
        idx = order[i];
        for(j = 0; j < nargs; ++j)code.push([
            "p",
            j,
            "+=d",
            j,
            "s",
            i
        ].join(""));
        if (has_index) {
            if (i > 0) code.push([
                "index[",
                pidx,
                "]-=s",
                pidx
            ].join(""));
            code.push([
                "++index[",
                idx,
                "]"
            ].join(""));
        }
        code.push("}");
    }
    return code.join("\n");
}
// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
    for(var i = 0; i < nargs; ++i)code.push([
        "var offset",
        i,
        "=p",
        i
    ].join(""));
    //Generate loops for unmatched dimensions
    // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
    // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
    for(var i = matched; i < dimension; ++i){
        code.push([
            "for(var j" + i + "=SS[",
            order[i],
            "]|0;j",
            i,
            ">0;){"
        ].join("")) // Iterate back to front
        ;
        code.push([
            "if(j",
            i,
            "<",
            blockSize,
            "){"
        ].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
        ;
        code.push([
            "s",
            order[i],
            "=j",
            i
        ].join(""));
        code.push([
            "j",
            i,
            "=0"
        ].join(""));
        code.push([
            "}else{s",
            order[i],
            "=",
            blockSize
        ].join(""));
        code.push([
            "j",
            i,
            "-=",
            blockSize,
            "}"
        ].join(""));
        if (has_index) code.push([
            "index[",
            order[i],
            "]=j",
            i
        ].join(""));
    }
    for(var i = 0; i < nargs; ++i){
        var indexStr = [
            "offset" + i
        ];
        for(var j = matched; j < dimension; ++j)indexStr.push([
            "j",
            j,
            "*t",
            i,
            "p",
            order[j]
        ].join(""));
        code.push([
            "p",
            i,
            "=(",
            indexStr.join("+"),
            ")"
        ].join(""));
    }
    code.push(innerFill(order, proc, body));
    for(var i = matched; i < dimension; ++i)code.push("}");
    return code.join("\n");
}
//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
    var matched = 0, dimension = orders[0].length;
    while(matched < dimension){
        for(var j = 1; j < orders.length; ++j){
            if (orders[j][matched] !== orders[0][matched]) return matched;
        }
        ++matched;
    }
    return matched;
}
//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
    var code = block.body;
    var pre = [];
    var post = [];
    for(var i = 0; i < block.args.length; ++i){
        var carg = block.args[i];
        if (carg.count <= 0) continue;
        var re = new RegExp(carg.name, "g");
        var ptrStr = "";
        var arrNum = proc.arrayArgs.indexOf(i);
        switch(proc.argTypes[i]){
            case "offset":
                var offArgIndex = proc.offsetArgIndex.indexOf(i);
                var offArg = proc.offsetArgs[offArgIndex];
                arrNum = offArg.array;
                ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
                ;
            case "array":
                ptrStr = "p" + arrNum + ptrStr;
                var localStr = "l" + i;
                var arrStr = "a" + arrNum;
                if (proc.arrayBlockIndices[arrNum] === 0) {
                    if (carg.count === 1) {
                        if (dtypes[arrNum] === "generic") {
                            if (carg.lvalue) {
                                pre.push([
                                    "var ",
                                    localStr,
                                    "=",
                                    arrStr,
                                    ".get(",
                                    ptrStr,
                                    ")"
                                ].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                                ;
                                code = code.replace(re, localStr);
                                post.push([
                                    arrStr,
                                    ".set(",
                                    ptrStr,
                                    ",",
                                    localStr,
                                    ")"
                                ].join(""));
                            } else code = code.replace(re, [
                                arrStr,
                                ".get(",
                                ptrStr,
                                ")"
                            ].join(""));
                        } else code = code.replace(re, [
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join(""));
                    } else if (dtypes[arrNum] === "generic") {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            ".get(",
                            ptrStr,
                            ")"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) post.push([
                            arrStr,
                            ".set(",
                            ptrStr,
                            ",",
                            localStr,
                            ")"
                        ].join(""));
                    } else {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) post.push([
                            arrStr,
                            "[",
                            ptrStr,
                            "]=",
                            localStr
                        ].join(""));
                    }
                } else {
                    var reStrArr = [
                        carg.name
                    ], ptrStrArr = [
                        ptrStr
                    ];
                    for(var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++){
                        reStrArr.push("\\s*\\[([^\\]]+)\\]");
                        ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j) // Matched index times stride
                        ;
                    }
                    re = new RegExp(reStrArr.join(""), "g");
                    ptrStr = ptrStrArr.join("+");
                    if (dtypes[arrNum] === "generic") /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/ throw new Error("cwise: Generic arrays not supported in combination with blocks!");
                    else // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                    code = code.replace(re, [
                        arrStr,
                        "[",
                        ptrStr,
                        "]"
                    ].join(""));
                }
                break;
            case "scalar":
                code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
                break;
            case "index":
                code = code.replace(re, "index");
                break;
            case "shape":
                code = code.replace(re, "shape");
                break;
        }
    }
    return [
        pre.join("\n"),
        code,
        post.join("\n")
    ].join("\n").trim();
}
function typeSummary(dtypes) {
    var summary = new Array(dtypes.length);
    var allEqual = true;
    for(var i = 0; i < dtypes.length; ++i){
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) digits = "";
        else digits = digits[0];
        if (t.charAt(0) === 0) summary[i] = "u" + t.charAt(1) + digits;
        else summary[i] = t.charAt(0) + digits;
        if (i > 0) allEqual = allEqual && summary[i] === summary[i - 1];
    }
    if (allEqual) return summary[0];
    return summary.join("");
}
//Generates a cwise operator
function generateCWiseOp(proc, typesig) {
    //Compute dimension
    // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
    var orders = new Array(proc.arrayArgs.length);
    var dtypes = new Array(proc.arrayArgs.length);
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
    }
    //Determine where block and loop indices start and end
    var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
    ;
    var loopBegin = [], loopEnd = [] // These indices are iterated over
    ;
    var loopOrders = [] // orders restricted to the loop indices
    ;
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        if (proc.arrayBlockIndices[i] < 0) {
            loopBegin.push(0);
            loopEnd.push(dimension);
            blockBegin.push(dimension);
            blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
            loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
            ;
            loopEnd.push(proc.arrayBlockIndices[i] + dimension);
            blockBegin.push(0);
            blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for(var j = 0; j < orders[i].length; j++)if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) newOrder.push(orders[i][j] - loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
        ;
        loopOrders.push(newOrder);
    }
    //First create arguments for procedure
    var arglist = [
        "SS"
    ] // SS is the overall shape over which we iterate
    ;
    var code = [
        "'use strict'"
    ];
    var vars = [];
    for(var j = 0; j < dimension; ++j)vars.push([
        "s",
        j,
        "=SS[",
        j,
        "]"
    ].join("")) // The limits for each dimension.
    ;
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        arglist.push("a" + i) // Actual data array
        ;
        arglist.push("t" + i) // Strides
        ;
        arglist.push("p" + i) // Offset in the array at which the data starts (also used for iterating over the data)
        ;
        for(var j = 0; j < dimension; ++j)vars.push([
            "t",
            i,
            "p",
            j,
            "=t",
            i,
            "[",
            loopBegin[i] + j,
            "]"
        ].join(""));
        for(var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j)vars.push([
            "t",
            i,
            "b",
            j,
            "=t",
            i,
            "[",
            blockBegin[i] + j,
            "]"
        ].join(""));
    }
    for(var i = 0; i < proc.scalarArgs.length; ++i)arglist.push("Y" + i);
    if (proc.shapeArgs.length > 0) vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
    ;
    if (proc.indexArgs.length > 0) {
        // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
        var zeros = new Array(dimension);
        for(var i = 0; i < dimension; ++i)zeros[i] = "0";
        vars.push([
            "index=[",
            zeros.join(","),
            "]"
        ].join(""));
    }
    for(var i = 0; i < proc.offsetArgs.length; ++i){
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for(var j = 0; j < off_arg.offset.length; ++j){
            if (off_arg.offset[j] === 0) continue;
            else if (off_arg.offset[j] === 1) init_string.push([
                "t",
                off_arg.array,
                "p",
                j
            ].join(""));
            else init_string.push([
                off_arg.offset[j],
                "*t",
                off_arg.array,
                "p",
                j
            ].join(""));
        }
        if (init_string.length === 0) vars.push("q" + i + "=0");
        else vars.push([
            "q",
            i,
            "=",
            init_string.join("+")
        ].join(""));
    }
    //Prepare this variables
    var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
    vars = vars.concat(thisVars);
    if (vars.length > 0) code.push("var " + vars.join(","));
    for(var i = 0; i < proc.arrayArgs.length; ++i)code.push("p" + i + "|=0");
    //Inline prelude
    if (proc.pre.body.length > 3) code.push(processBlock(proc.pre, proc, dtypes));
    //Process body
    var body = processBlock(proc.body, proc, dtypes);
    var matched = countMatches(loopOrders);
    if (matched < dimension) code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
    ;
    else code.push(innerFill(loopOrders[0], proc, body));
    //Inline epilog
    if (proc.post.body.length > 3) code.push(processBlock(proc.post, proc, dtypes));
    if (proc.debug) console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
    var loopName = [
        proc.funcName || "unnamed",
        "_cwise_loop_",
        orders[0].join("s"),
        "m",
        matched,
        typeSummary(dtypes)
    ].join("");
    var f = new Function([
        "function ",
        loopName,
        "(",
        arglist.join(","),
        "){",
        code.join("\n"),
        "} return ",
        loopName
    ].join(""));
    return f();
}
module.exports = generateCWiseOp;

},{"14bb0a1dfafc14aa":"itPtS"}],"itPtS":[function(require,module,exports) {
"use strict";
function unique_pred(list, compare) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i){
        b = a;
        a = list[i];
        if (compare(a, b)) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique_eq(list) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i, b = a){
        b = a;
        a = list[i];
        if (a !== b) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique(list, compare, sorted) {
    if (list.length === 0) return list;
    if (compare) {
        if (!sorted) list.sort(compare);
        return unique_pred(list, compare);
    }
    if (!sorted) list.sort();
    return unique_eq(list);
}
module.exports = unique;

},{}],"kXyuI":[function(require,module,exports) {
"use strict";
var compile = require("79fc6cf2b6fc441b");
var EmptyProc = {
    body: "",
    args: [],
    thisVars: [],
    localVars: []
};
function fixup(x) {
    if (!x) return EmptyProc;
    for(var i = 0; i < x.args.length; ++i){
        var a = x.args[i];
        if (i === 0) x.args[i] = {
            name: a,
            lvalue: true,
            rvalue: !!x.rvalue,
            count: x.count || 1
        };
        else x.args[i] = {
            name: a,
            lvalue: false,
            rvalue: true,
            count: 1
        };
    }
    if (!x.thisVars) x.thisVars = [];
    if (!x.localVars) x.localVars = [];
    return x;
}
function pcompile(user_args) {
    return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
    });
}
function makeOp(user_args) {
    var args = [];
    for(var i = 0; i < user_args.args.length; ++i)args.push("a" + i);
    var wrapper = new Function("P", [
        "return function ",
        user_args.funcName,
        "_ndarrayops(",
        args.join(","),
        ") {P(",
        args.join(","),
        ");return a0}"
    ].join(""));
    return wrapper(pcompile(user_args));
}
var assign_ops = {
    add: "+",
    sub: "-",
    mul: "*",
    div: "/",
    mod: "%",
    band: "&",
    bor: "|",
    bxor: "^",
    lshift: "<<",
    rshift: ">>",
    rrshift: ">>>"
};
(function() {
    for(var id in assign_ops){
        var op = assign_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a" + op + "=b"
            },
            rvalue: true,
            funcName: id + "eq"
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a" + op + "=s"
            },
            rvalue: true,
            funcName: id + "seq"
        });
    }
})();
var unary_ops = {
    not: "!",
    bnot: "~",
    neg: "-",
    recip: "1.0/"
};
(function() {
    for(var id in unary_ops){
        var op = unary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=" + op + "b"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array"
            ],
            body: {
                args: [
                    "a"
                ],
                body: "a=" + op + "a"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
    }
})();
var binary_ops = {
    and: "&&",
    or: "||",
    eq: "===",
    neq: "!==",
    lt: "<",
    gt: ">",
    leq: "<=",
    geq: ">="
};
(function() {
    for(var id in binary_ops){
        var op = binary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=a" + op + "b"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a=a" + op + "s"
            },
            rvalue: true,
            count: 2,
            funcName: id + "seq"
        });
    }
})();
var math_unary = [
    "abs",
    "acos",
    "asin",
    "atan",
    "ceil",
    "cos",
    "exp",
    "floor",
    "log",
    "round",
    "sin",
    "sqrt",
    "tan"
];
(function() {
    for(var i = 0; i < math_unary.length; ++i){
        var f = math_unary[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a"
                ],
                body: "a=this_f(a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
    }
})();
var math_comm = [
    "max",
    "min",
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_comm.length; ++i){
        var f = math_comm[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "s"
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
        exports[f + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "seq"
        });
    }
})();
var math_noncomm = [
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_noncomm.length; ++i){
        var f = math_noncomm[i];
        exports[f + "op"] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "op"
        });
        exports[f + "ops"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "ops"
        });
        exports[f + "opeq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opeq"
        });
        exports[f + "opseq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opseq"
        });
    }
})();
exports.any = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(a){return true}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return false"
    },
    funcName: "any"
});
exports.all = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(!x){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "all"
});
exports.sum = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s+=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "sum"
});
exports.prod = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=1"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s*=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "prod"
});
exports.norm2squared = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm2squared"
});
exports.norm2 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return Math.sqrt(this_s)"
    },
    funcName: "norm2"
});
exports.norminf = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 4
            }
        ],
        body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norminf"
});
exports.norm1 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 3
            }
        ],
        body: "this_s+=a<0?-a:a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm1"
});
exports.sup = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.inf = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.argmin = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.argmax = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.random = makeOp({
    args: [
        "array"
    ],
    pre: {
        args: [],
        body: "this_f=Math.random",
        thisVars: [
            "this_f"
        ]
    },
    body: {
        args: [
            "a"
        ],
        body: "a=this_f()",
        thisVars: [
            "this_f"
        ]
    },
    funcName: "random"
});
exports.assign = makeOp({
    args: [
        "array",
        "array"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assign"
});
exports.assigns = makeOp({
    args: [
        "array",
        "scalar"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assigns"
});
exports.equals = compile({
    args: [
        "array",
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            },
            {
                name: "y",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "equals"
});

},{"79fc6cf2b6fc441b":"7GqVQ"}],"7acsC":[function(require,module,exports) {
"use strict";
var ndarray = require("1022cfeb42e4d237");
var ops = require("7b525c95be7aa4b3");
var pool = require("d481b23e4a057541");
function clone(array) {
    var dtype = array.dtype;
    if (dtype === "generic" || dtype === "array") dtype = "double";
    var data = pool.malloc(array.size, dtype);
    var result = ndarray(data, array.shape);
    ops.assign(result, array);
    return result;
}
exports.clone = clone;
function malloc(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    return ndarray(pool.malloc(sz, dtype), shape, stride, 0);
}
exports.malloc = malloc;
function free(array) {
    if (array.dtype === "generic" || array.dtype === "array") return;
    pool.free(array.data);
}
exports.free = free;
function zeros(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i)buf[i] = 0;
    return ndarray(buf, shape, stride, 0);
}
exports.zeros = zeros;
function ones(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i)buf[i] = 1;
    return ndarray(buf, shape, stride, 0);
}
exports.ones = ones;
function eye(shape, dtype) {
    var i, offset;
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(i = 0; i < sz; ++i)buf[i] = 0;
    var mindim = Infinity;
    var offsum = 0;
    for(i = shape.length - 1; i >= 0; i--){
        offsum += stride[i];
        mindim = Math.min(mindim, shape[i]);
    }
    for(i = 0, offset = 0; i < mindim; i++, offset += offsum)buf[offset] = 1;
    return ndarray(buf, shape, stride, 0);
}
exports.eye = eye;

},{"1022cfeb42e4d237":"1nDU8","7b525c95be7aa4b3":"kXyuI","d481b23e4a057541":"1RryJ"}],"1RryJ":[function(require,module,exports) {
var global = arguments[3];
"use strict";
var bits = require("3eb05de2c0cfab98");
var dup = require("d2c8ae35a091f669");
var Buffer = require("128e674301e79368").Buffer;
//Legacy pool support
if (!global.__TYPEDARRAY_POOL) global.__TYPEDARRAY_POOL = {
    UINT8: dup([
        32,
        0
    ]),
    UINT16: dup([
        32,
        0
    ]),
    UINT32: dup([
        32,
        0
    ]),
    BIGUINT64: dup([
        32,
        0
    ]),
    INT8: dup([
        32,
        0
    ]),
    INT16: dup([
        32,
        0
    ]),
    INT32: dup([
        32,
        0
    ]),
    BIGINT64: dup([
        32,
        0
    ]),
    FLOAT: dup([
        32,
        0
    ]),
    DOUBLE: dup([
        32,
        0
    ]),
    DATA: dup([
        32,
        0
    ]),
    UINT8C: dup([
        32,
        0
    ]),
    BUFFER: dup([
        32,
        0
    ])
};
var hasUint8C = typeof Uint8ClampedArray !== "undefined";
var hasBigUint64 = typeof BigUint64Array !== "undefined";
var hasBigInt64 = typeof BigInt64Array !== "undefined";
var POOL = global.__TYPEDARRAY_POOL;
//Upgrade pool
if (!POOL.UINT8C) POOL.UINT8C = dup([
    32,
    0
]);
if (!POOL.BIGUINT64) POOL.BIGUINT64 = dup([
    32,
    0
]);
if (!POOL.BIGINT64) POOL.BIGINT64 = dup([
    32,
    0
]);
if (!POOL.BUFFER) POOL.BUFFER = dup([
    32,
    0
]);
//New technique: Only allocate from ArrayBufferView and Buffer
var DATA = POOL.DATA, BUFFER = POOL.BUFFER;
exports.free = function free(array) {
    if (Buffer.isBuffer(array)) BUFFER[bits.log2(array.length)].push(array);
    else {
        if (Object.prototype.toString.call(array) !== "[object ArrayBuffer]") array = array.buffer;
        if (!array) return;
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
    }
};
function freeArrayBuffer(buffer) {
    if (!buffer) return;
    var n = buffer.length || buffer.byteLength;
    var log_n = bits.log2(n);
    DATA[log_n].push(buffer);
}
function freeTypedArray(array) {
    freeArrayBuffer(array.buffer);
}
exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeBigUint64 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeBigInt64 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
exports.freeArrayBuffer = freeArrayBuffer;
exports.freeBuffer = function freeBuffer(array) {
    BUFFER[bits.log2(array.length)].push(array);
};
exports.malloc = function malloc(n, dtype) {
    if (dtype === undefined || dtype === "arraybuffer") return mallocArrayBuffer(n);
    else switch(dtype){
        case "uint8":
            return mallocUint8(n);
        case "uint16":
            return mallocUint16(n);
        case "uint32":
            return mallocUint32(n);
        case "int8":
            return mallocInt8(n);
        case "int16":
            return mallocInt16(n);
        case "int32":
            return mallocInt32(n);
        case "float":
        case "float32":
            return mallocFloat(n);
        case "double":
        case "float64":
            return mallocDouble(n);
        case "uint8_clamped":
            return mallocUint8Clamped(n);
        case "bigint64":
            return mallocBigInt64(n);
        case "biguint64":
            return mallocBigUint64(n);
        case "buffer":
            return mallocBuffer(n);
        case "data":
        case "dataview":
            return mallocDataView(n);
        default:
            return null;
    }
    return null;
};
function mallocArrayBuffer(n) {
    var n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var d = DATA[log_n];
    if (d.length > 0) return d.pop();
    return new ArrayBuffer(n);
}
exports.mallocArrayBuffer = mallocArrayBuffer;
function mallocUint8(n) {
    return new Uint8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocUint8 = mallocUint8;
function mallocUint16(n) {
    return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocUint16 = mallocUint16;
function mallocUint32(n) {
    return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocUint32 = mallocUint32;
function mallocInt8(n) {
    return new Int8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocInt8 = mallocInt8;
function mallocInt16(n) {
    return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocInt16 = mallocInt16;
function mallocInt32(n) {
    return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocInt32 = mallocInt32;
function mallocFloat(n) {
    return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
function mallocDouble(n) {
    return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
function mallocUint8Clamped(n) {
    if (hasUint8C) return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
    else return mallocUint8(n);
}
exports.mallocUint8Clamped = mallocUint8Clamped;
function mallocBigUint64(n) {
    if (hasBigUint64) return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
    else return null;
}
exports.mallocBigUint64 = mallocBigUint64;
function mallocBigInt64(n) {
    if (hasBigInt64) return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
    else return null;
}
exports.mallocBigInt64 = mallocBigInt64;
function mallocDataView(n) {
    return new DataView(mallocArrayBuffer(n), 0, n);
}
exports.mallocDataView = mallocDataView;
function mallocBuffer(n) {
    n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var cache = BUFFER[log_n];
    if (cache.length > 0) return cache.pop();
    return new Buffer(n);
}
exports.mallocBuffer = mallocBuffer;
exports.clearCache = function clearCache() {
    for(var i = 0; i < 32; ++i){
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.BIGUINT64[i].length = 0;
        POOL.BIGINT64[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
    }
};

},{"3eb05de2c0cfab98":"9kWjw","d2c8ae35a091f669":"VRu11","128e674301e79368":"fCgem"}],"9kWjw":[function(require,module,exports) {
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */ "use strict";
"use restrict";
//Number of bits in an integer
var INT_BITS = 32;
//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 0x7fffffff;
exports.INT_MIN = -1 << INT_BITS - 1;
//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
    return (v > 0) - (v < 0);
};
//Computes absolute value of integer
exports.abs = function(v) {
    var mask = v >> INT_BITS - 1;
    return (v ^ mask) - mask;
};
//Computes minimum of integers x and y
exports.min = function(x, y) {
    return y ^ (x ^ y) & -(x < y);
};
//Computes maximum of integers x and y
exports.max = function(x, y) {
    return x ^ (x ^ y) & -(x < y);
};
//Checks if a number is a power of two
exports.isPow2 = function(v) {
    return !(v & v - 1) && !!v;
};
//Computes log base 2 of v
exports.log2 = function(v) {
    var r, shift;
    r = (v > 0xFFFF) << 4;
    v >>>= r;
    shift = (v > 0xFF) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 0xF) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 0x3) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
};
//Computes log base 10 of v
exports.log10 = function(v) {
    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};
//Counts number of bits
exports.popCount = function(v) {
    v = v - (v >>> 1 & 0x55555555);
    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
};
//Counts number of trailing zeros
function countTrailingZeros(v) {
    var c = 32;
    v &= -v;
    if (v) c--;
    if (v & 0x0000FFFF) c -= 16;
    if (v & 0x00FF00FF) c -= 8;
    if (v & 0x0F0F0F0F) c -= 4;
    if (v & 0x33333333) c -= 2;
    if (v & 0x55555555) c -= 1;
    return c;
}
exports.countTrailingZeros = countTrailingZeros;
//Rounds to next power of 2
exports.nextPow2 = function(v) {
    v += v === 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
};
//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v - (v >>> 1);
};
//Computes parity of word
exports.parity = function(v) {
    v ^= v >>> 16;
    v ^= v >>> 8;
    v ^= v >>> 4;
    v &= 0xf;
    return 0x6996 >>> v & 1;
};
var REVERSE_TABLE = new Array(256);
(function(tab) {
    for(var i = 0; i < 256; ++i){
        var v = i, r = i, s = 7;
        for(v >>>= 1; v; v >>>= 1){
            r <<= 1;
            r |= v & 1;
            --s;
        }
        tab[i] = r << s & 0xff;
    }
})(REVERSE_TABLE);
//Reverse bits in a 32 bit word
exports.reverse = function(v) {
    return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
};
//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
    x &= 0xFFFF;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y &= 0xFFFF;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
};
//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
    v = v >>> n & 0x55555555;
    v = (v | v >>> 1) & 0x33333333;
    v = (v | v >>> 2) & 0x0F0F0F0F;
    v = (v | v >>> 4) & 0x00FF00FF;
    v = (v | v >>> 16) & 0x000FFFF;
    return v << 16 >> 16;
};
//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
    x &= 0x3FF;
    x = (x | x << 16) & 4278190335;
    x = (x | x << 8) & 251719695;
    x = (x | x << 4) & 3272356035;
    x = (x | x << 2) & 1227133513;
    y &= 0x3FF;
    y = (y | y << 16) & 4278190335;
    y = (y | y << 8) & 251719695;
    y = (y | y << 4) & 3272356035;
    y = (y | y << 2) & 1227133513;
    x |= y << 1;
    z &= 0x3FF;
    z = (z | z << 16) & 4278190335;
    z = (z | z << 8) & 251719695;
    z = (z | z << 4) & 3272356035;
    z = (z | z << 2) & 1227133513;
    return x | z << 2;
};
//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
    v = v >>> n & 1227133513;
    v = (v | v >>> 2) & 3272356035;
    v = (v | v >>> 4) & 251719695;
    v = (v | v >>> 8) & 4278190335;
    v = (v | v >>> 16) & 0x3FF;
    return v << 22 >> 22;
};
//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
    var t = v | v - 1;
    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],"VRu11":[function(require,module,exports) {
"use strict";
function dupe_array(count, value, i) {
    var c = count[i] | 0;
    if (c <= 0) return [];
    var result = new Array(c), j;
    if (i === count.length - 1) for(j = 0; j < c; ++j)result[j] = value;
    else for(j = 0; j < c; ++j)result[j] = dupe_array(count, value, i + 1);
    return result;
}
function dupe_number(count, value) {
    var result, i;
    result = new Array(count);
    for(i = 0; i < count; ++i)result[i] = value;
    return result;
}
function dupe(count, value) {
    if (typeof value === "undefined") value = 0;
    switch(typeof count){
        case "number":
            if (count > 0) return dupe_number(count | 0, value);
            break;
        case "object":
            if (typeof count.length === "number") return dupe_array(count, value, 0);
            break;
    }
    return [];
}
module.exports = dupe;

},{}],"7V1A8":[function(require,module,exports) {
"use strict";
var bits = require("97d3e112e4bf25e7");
function rootInorder(n) {
    var ptree = (bits.nextPow2(n + 1) >>> 1) - 1;
    var f = n - ptree;
    if (bits.nextPow2(f) - 1 >= ptree) return ptree;
    return (ptree >>> 1) + f;
}
exports.root = rootInorder;
function beginInorder(n) {
    return 0;
}
exports.begin = beginInorder;
function endInorder(n) {
    return n - 1;
}
exports.end = endInorder;
//This is really horrible because n is not necessarily a power of 2
// If it was, we could just do:
//
//    height = bits.countTrailingZeros(~x)
//
// Instead, we just binary search because doing the right thing here is way too complicated.
function heightInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return heightInorder(n - r - 1, x - r - 1);
    else if (x === r) return bits.log2(n);
    return heightInorder(r, x);
}
exports.height = heightInorder;
function prevInorder(n, x) {
    return Math.max(x - 1, 0);
}
exports.prev = prevInorder;
function nextInorder(n, x) {
    return Math.min(x + 1, n - 1);
}
exports.next = nextInorder;
//The version for n = (1<<k)-1:
//
//  parent = (x & ~(1<<(h+1))) + (1<<h)
//
function parentInorder(n, x) {
    if (n <= 0) return -1;
    var r = rootInorder(n);
    if (x > r) {
        var q = parentInorder(n - r - 1, x - r - 1);
        if (q < 0) return r;
        else return q + r + 1;
    } else if (x === r) return -1;
    var q = parentInorder(r, x);
    if (q < 0) return r;
    return q;
}
exports.parent = parentInorder;
//Again, we get screwed because n is not a power of two -1.  If it was, we could do:
//
//    left = x - (1 << (h-1) )
//
// Where h is the height of the node
//
function leftInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return leftInorder(n - r - 1, x - r - 1) + r + 1;
    else if (x === r) return rootInorder(x);
    return leftInorder(r, x);
}
exports.left = leftInorder;
//for power of two minus one:
//
//    right = x + (1<<(h-1))
//
function rightInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return rightInorder(n - r - 1, x - r - 1) + r + 1;
    else if (x === r) return rootInorder(n - r - 1) + r + 1;
    return rightInorder(r, x);
}
exports.right = rightInorder;
function leafInorder(n, x) {
    return heightInorder(n, x) === 0;
}
exports.leaf = leafInorder;
function loInorder(n, x) {
    n |= 0;
    x |= 0;
    var l = 0;
    while(n > 1){
        var r = rootInorder(n);
        if (x > r) {
            l += r + 1;
            n -= r + 1;
            x -= r + 1;
        } else if (x === r) break;
        else n = r;
    }
    return l;
}
exports.lo = loInorder;
function hiInorder(n, x) {
    n |= 0;
    x |= 0;
    var l = 0;
    while(n > 1){
        var r = rootInorder(n);
        if (x > r) {
            l += r + 1;
            n -= r + 1;
            x -= r + 1;
        } else if (x === r) {
            l += n - 1;
            break;
        } else n = r;
    }
    return l;
}
exports.hi = hiInorder;

},{"97d3e112e4bf25e7":"aFqxf"}],"aFqxf":[function(require,module,exports) {
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */ "use strict";
"use restrict";
//Number of bits in an integer
var INT_BITS = 32;
//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 0x7fffffff;
exports.INT_MIN = -1 << INT_BITS - 1;
//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
    return (v > 0) - (v < 0);
};
//Computes absolute value of integer
exports.abs = function(v) {
    var mask = v >> INT_BITS - 1;
    return (v ^ mask) - mask;
};
//Computes minimum of integers x and y
exports.min = function(x, y) {
    return y ^ (x ^ y) & -(x < y);
};
//Computes maximum of integers x and y
exports.max = function(x, y) {
    return x ^ (x ^ y) & -(x < y);
};
//Checks if a number is a power of two
exports.isPow2 = function(v) {
    return !(v & v - 1) && !!v;
};
//Computes log base 2 of v
exports.log2 = function(v) {
    var r, shift;
    r = (v > 0xFFFF) << 4;
    v >>>= r;
    shift = (v > 0xFF) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 0xF) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 0x3) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
};
//Computes log base 10 of v
exports.log10 = function(v) {
    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};
//Counts number of bits
exports.popCount = function(v) {
    v = v - (v >>> 1 & 0x55555555);
    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
};
//Counts number of trailing zeros
function countTrailingZeros(v) {
    var c = 32;
    v &= -v;
    if (v) c--;
    if (v & 0x0000FFFF) c -= 16;
    if (v & 0x00FF00FF) c -= 8;
    if (v & 0x0F0F0F0F) c -= 4;
    if (v & 0x33333333) c -= 2;
    if (v & 0x55555555) c -= 1;
    return c;
}
exports.countTrailingZeros = countTrailingZeros;
//Rounds to next power of 2
exports.nextPow2 = function(v) {
    v += v === 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
};
//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v - (v >>> 1);
};
//Computes parity of word
exports.parity = function(v) {
    v ^= v >>> 16;
    v ^= v >>> 8;
    v ^= v >>> 4;
    v &= 0xf;
    return 0x6996 >>> v & 1;
};
var REVERSE_TABLE = new Array(256);
(function(tab) {
    for(var i = 0; i < 256; ++i){
        var v = i, r = i, s = 7;
        for(v >>>= 1; v; v >>>= 1){
            r <<= 1;
            r |= v & 1;
            --s;
        }
        tab[i] = r << s & 0xff;
    }
})(REVERSE_TABLE);
//Reverse bits in a 32 bit word
exports.reverse = function(v) {
    return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
};
//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
    x &= 0xFFFF;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y &= 0xFFFF;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
};
//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
    v = v >>> n & 0x55555555;
    v = (v | v >>> 1) & 0x33333333;
    v = (v | v >>> 2) & 0x0F0F0F0F;
    v = (v | v >>> 4) & 0x00FF00FF;
    v = (v | v >>> 16) & 0x000FFFF;
    return v << 16 >> 16;
};
//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
    x &= 0x3FF;
    x = (x | x << 16) & 4278190335;
    x = (x | x << 8) & 251719695;
    x = (x | x << 4) & 3272356035;
    x = (x | x << 2) & 1227133513;
    y &= 0x3FF;
    y = (y | y << 16) & 4278190335;
    y = (y | y << 8) & 251719695;
    y = (y | y << 4) & 3272356035;
    y = (y | y << 2) & 1227133513;
    x |= y << 1;
    z &= 0x3FF;
    z = (z | z << 16) & 4278190335;
    z = (z | z << 8) & 251719695;
    z = (z | z << 4) & 3272356035;
    z = (z | z << 2) & 1227133513;
    return x | z << 2;
};
//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
    v = v >>> n & 1227133513;
    v = (v | v >>> 2) & 3272356035;
    v = (v | v >>> 4) & 251719695;
    v = (v | v >>> 8) & 4278190335;
    v = (v | v >>> 16) & 0x3FF;
    return v << 22 >> 22;
};
//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
    var t = v | v - 1;
    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],"epTUT":[function(require,module,exports) {
"use strict";
module.exports = KDTHeap;
var pool = require("e29e78138d3ce401");
function heapParent(i) {
    if (i & 1) return i - 1 >> 1;
    return (i >> 1) - 1;
}
function KDTHeap(n, d) {
    this.count = 0;
    this.dataSize = d;
    this.index = pool.mallocInt32(n);
    this.data = pool.mallocFloat64(n * d);
}
var proto = KDTHeap.prototype;
proto.heapSwap = function(_i, _j) {
    var data = this.data;
    var index = this.index;
    var d = this.dataSize;
    var tmp = index[_i];
    index[_i] = index[_j];
    index[_j] = tmp;
    var aptr = d * _i;
    var bptr = d * _j;
    for(var _k = 0; _k < d; ++_k){
        var t2 = data[aptr];
        data[aptr] = data[bptr];
        data[bptr] = t2;
        aptr += 1;
        bptr += 1;
    }
};
proto.heapUp = function(i) {
    var d = this.dataSize;
    var index = this.index;
    var data = this.data;
    var w = data[d * i];
    while(i > 0){
        var parent = heapParent(i);
        if (parent >= 0) {
            var pw = data[d * parent];
            if (w < pw) {
                this.heapSwap(i, parent);
                i = parent;
                continue;
            }
        }
        break;
    }
};
proto.heapDown = function(i) {
    var d = this.dataSize;
    var index = this.index;
    var data = this.data;
    var count = this.count;
    var w = data[d * i];
    while(true){
        var tw = w;
        var left = 2 * i + 1;
        var right = 2 * (i + 1);
        var next = i;
        if (left < count) {
            var lw = data[d * left];
            if (lw < tw) {
                next = left;
                tw = lw;
            }
        }
        if (right < count) {
            var rw = data[d * right];
            if (rw < tw) next = right;
        }
        if (next === i) break;
        this.heapSwap(i, next);
        i = next;
    }
};
//Clear item from top of heap
proto.pop = function() {
    this.count -= 1;
    this.heapSwap(0, this.count);
    this.heapDown(0);
};
//Assume object already written to data
proto.push = function() {
    this.heapUp(this.count);
    this.count += 1;
};
proto.dispose = function() {
    pool.freeInt32(this.index);
    pool.freeFloat64(this.data);
};

},{"e29e78138d3ce401":"1RryJ"}],"6en3b":[function(require,module,exports) {
/* eslint-disable no-use-before-define */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class rotate {
    static getRotationAngle(origPoint, newPoint, centerPoint) {
        const vx = origPoint.x - centerPoint.x;
        const vy = origPoint.y - centerPoint.y;
        const ux = newPoint.x - centerPoint.x;
        const uy = newPoint.y - centerPoint.y;
        const magnitudeV = Math.sqrt(vx ** 2 + vy ** 2);
        const magnitudeU = Math.sqrt(ux ** 2 + uy ** 2);
        let angleDegrees;
        if (vx === 0 && vy === 0 || ux === 0 && uy === 0 || vx === ux && vy === uy) ;
        else {
            const cosine = (vx * ux + vy * uy) / (magnitudeV * magnitudeU);
            const angleRadians = Math.acos(cosine);
            angleDegrees = angleRadians * 180 / Math.PI // unsigned angle
            ;
            const detVxU = vx * uy - vy * ux // cross product of V and U (VxU)
            ;
            if (detVxU < 0) angleDegrees = -angleDegrees // add negative sign
            ;
        }
        return angleDegrees;
    }
    set(rotateAngle) {
        const self = this;
        const useRotationAngle = rotateAngle || self.rotationAngle;
        self.rotate.transform(`R${self.rotationAngle}, ${self.origCenter.x}, ${self.origCenter.y}`);
        const rotationContext = {
            rotate: {
                rotationAngle: (self.node.options.rotate.rotationAngle + useRotationAngle) % 360,
                point: self.origCenter
            }
        };
        const transformString = self.node.getTransformString(rotationContext);
        self.node.vect.transform(transformString);
        self.node.text.transform(transformString);
    }
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.rotate = null;
        self.rotateTemp = null;
        self._dragAllowed = false;
        self._isResizing = false;
        self._initPosFix = false;
        self.origCenter = {} // during rotation raphael changes the center point of bbox for some reason
        ;
        self.rotationAngle = null;
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.selectedNodes = [];
        self.rotateEvents = {
            start () {
                const s = this;
                self.selectedNodes = self.node.relationships.getSelectedNodes();
                const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
                self.relationshipsToTranslate = _associations.relationshipsToTranslate;
                self.relationshipsToRefresh = _associations.relationshipsToRefresh;
                self.slate.isBeingResized = true;
                self._initPosFix = false;
                self.rotateTemp.attr({
                    x: self.rotateTemp.attr("x") - 1000,
                    y: self.rotateTemp.attr("y") - 1000,
                    width: 10000,
                    height: 10000
                });
                self.rotate.ox = self.rotate.attr("x");
                self.rotate.oy = self.rotate.attr("y");
                self.node.relationships.updateAssociationsWith({
                    activeNode: self.node.options.id,
                    currentDx: 0,
                    currentDy: 0,
                    action: "rotate"
                });
                self._isResizing = true;
                const tempPath = self.slate.paper.path(self.node.vect.attr("path"));
                const noRotationBB = tempPath.getBBox();
                if (!self.node.options.rotate?.point || Object.entries(self.node.options.rotate.point).length === 0) self.node.options.rotate.point = {
                    x: noRotationBB.cx,
                    y: noRotationBB.cy
                };
                tempPath.remove();
                self.slate.multiSelection?.end();
                s.ox = noRotationBB.x;
                s.oy = noRotationBB.y;
                self.origCenter = self.node.options.rotate.point;
                self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>n.options.id !== self.node.options.id).map((n)=>({
                        id: n.options.id,
                        bbox: n.vect.getBBox(),
                        point: [
                            n.options.xPos,
                            n.options.yPos
                        ]
                    }));
                self.kdTree = (0, _staticKdtreeDefault.default)(self.foreignPoints.map((fp)=>fp.point));
                self.node.setStartDrag();
                self.node.connectors.remove();
                self.node.resize.hide();
                self._dragAllowed = self.slate.options.allowDrag;
                self.slate.disable(false, true);
                self.slate.toggleFilters(true, self.node.options.id);
            },
            move (dx, dy) {
                const s = this;
                try {
                    // for snapping
                    const nearest = self.kdTree.knn([
                        node.options.xPos,
                        node.options.yPos
                    ], 5);
                    nearest.forEach((n)=>{
                        self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox, false, 200);
                    });
                    /*
          Rotation angle is obtained using vector properties. Further explanation can be found here: https://stackoverflow.com/questions/10507620/finding-the-angle-between-vectors
          Vectors are of form:
          v = <vx, vy>
          u = <ux, uy>
          Notation explanation:
          ||v|| - magnitude of vector v
          v . u - dot product of vectors u and v (commutative)
          v x u - cross product of vectors v and u (not commutative!); for 2D vectors it is essentially the determinant of a 2D matrix created by v and u
    
          cos(angle) = (v . u)/(||v|| * ||u||)
          angle = arccos((v . u)/(||v|| * ||u||))
          angle is unsigned, i.e. it assumes values 0 and PI radians
    
          If v x u < 0 then the angle needs a negative sign; otherwise the sign is already correct.
    
          If either vector is a 0 vector, i.e. v = <0, 0> or u = <0, 0> then the angle between v and u does not exist
          and the function will return an undefined angle.
    
          The returned angle is converted to degrees and is between -180 and 180.
          */ self.rotationAngle = rotate.getRotationAngle({
                        x: s.ox,
                        y: s.oy
                    }, {
                        x: s.ox + dx,
                        y: s.oy + dy
                    }, self.origCenter);
                    if (self.rotationAngle) // const _ra = Math.abs(Math.ceil(self.node.vect.matrix.split().rotate));
                    // const _ra = Math.abs(Math.ceil(self.rotationAngle)); //
                    // if (!self.node.snappedAt && ([0, 45, 90, 135, 180, 225, 270].indexOf(_ra) > -1)) { //% 45 === 0 || _ra === 0 || (_ra + 1) % 270 === 0)) {
                    //   console.log("snapped ra is ", self.node.options.rotate.rotationAngle, self.rotationAngle, _ra, self.node.vect.matrix.split().rotate);
                    //   //self.rotationAngle = _ra;
                    //   //self.rotationAngle = Math.abs(Math.ceil(self.rotationAngle));
                    //   self.node.snappedAt = _ra; // self.rotationAngle;
                    //   _rta();
                    // } else if (self.rotationAngle >= self.node.snappedAt + 25 || self.rotationAngle <= self.node.snappedAt - 25) {
                    //   delete self.node.snappedAt;
                    // }
                    {
                        if (!self.node.snappedAt) self.set();
                    }
                } catch (err) {
                    finalize();
                }
            },
            up () {
                finalize();
                self.slate.toggleFilters(false, self.node.options.id);
            }
        };
        function finalize() {
            const _ran = self.node.snappedAt || self.rotationAngle;
            if (_ran) {
                const rotationContext = {
                    rotationAngle: (self.node.options.rotate.rotationAngle + _ran) % 360,
                    point: self.origCenter
                };
                Object.assign(self.node.options.rotate, rotationContext);
                const bb = self.node.vect.getBBox();
                self.node.options.width = bb.width;
                self.node.options.height = bb.height;
                self.rotateTemp.remove();
                self.node.relationships.updateAssociationsWith({
                    rotationAngle: self.node.options.rotate.rotationAngle
                });
                self.node.gridLines.clear();
                delete self.foreignPoints;
                delete self.kdTree;
                delete self.node.snappedAt;
            }
            self.slate.isBeingResized = false;
            self.node.menu.hide();
            self._isResizing = false;
            self.slate.enable(false, true);
            self.node.setEndDrag();
            self.node.relationships.refreshOwnRelationships();
            self.node.relationships.showOwn();
            self.rotate.remove();
            if (self.node.events?.onRotated?.apply) self.node.events?.onRotated?.apply(self, [
                _self.send
            ]);
            else self.send();
        }
    }
    show(x, y) {
        const self = this;
        if (self.node.options.allowResize) {
            self.rotateTemp?.remove();
            const r = self.slate.paper;
            self.rotate = r.path("M16.659,24c-5.078,0-9.213-3.987-9.475-9h2.975l-4.5-5l-4.5,5h3.025 c0.264,6.671,5.74,12,12.475,12c3.197,0,6.104-1.21,8.315-3.185l-2.122-2.122C21.188,23.127,19.027,24,16.659,24z M29.133,14c-0.265-6.669-5.74-12-12.475-12c-3.197,0-6.104,1.21-8.315,3.185   l2.122,2.122C12.129,5.873,14.29,5,16.659,5c5.077,0,9.213,3.987,9.475,9h-2.975l4.5,5l4.5-5H29.133z").attr({
                fill: "#fff",
                stroke: "#000",
                x: x - 5,
                y: y - 5
            });
            let rotatePathBB = self.rotate.getBBox();
            const rotatePathString = (0, _utilsDefault.default)._transformPath(self.rotate.attr("path"), `T${x - rotatePathBB.x - 15},${y - rotatePathBB.y - 15}`);
            self.rotate.attr({
                path: rotatePathString
            });
            rotatePathBB = self.rotate.getBBox();
            self.rotateTemp = r.rect(rotatePathBB.x, rotatePathBB.y, rotatePathBB.width, rotatePathBB.height).attr({
                fill: "#f00",
                opacity: 0.00000001
            }).toFront();
            self.rotate.mouseover((e)=>{
                self.rotate.attr({
                    cursor: "alias"
                });
            });
            self.rotateTemp.mouseover((e)=>{
                self.rotateTemp.attr({
                    cursor: "alias"
                });
            });
            self.rotateTemp.drag(self.rotateEvents.move, self.rotateEvents.start, self.rotateEvents.up);
        }
        return self.rotate;
    }
    hide() {
        this.rotate?.remove();
        this.rotateTemp?.remove();
    }
    send() {
        // broadcast change to birdsEye and collaborators
        const pkg = {
            type: "onNodeRotated",
            data: {
                id: this.node.options.id,
                rotate: this.node.options.rotate,
                textOffset: this.node.options.textOffset,
                imageOrigWidth: this.node.options.imageOrigWidth,
                imageOrigHeight: this.node.options.imageOrigHeight,
                associations: this.node.relationships.associations.map((a)=>({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr("path").toString()
                    }))
            }
        };
        this.slate.birdsEye?.nodeChanged(pkg);
        this.slate.collab?.send(pkg);
    }
    applyImageRotation(opts = {}) {
        const { r } = this.slate.options.viewPort.zoom;
        this.node.vect.transform("");
        this.node.text.transform("");
        const boundingClientRect = opts.boundingClientRect || this.node.vect[0].getBoundingClientRect();
        // clone current node to get actual dimensions with no hidden transforms (transform("") doesn't affect bbox -- it still has dimensions as if transforms were still there)
        const tempPath = this.slate.paper.path(this.node.vect.attr("path"));
        const bb = tempPath.getBBox();
        const transformString = this.node.getTransformString(opts);
        this.node.vect.transform(transformString);
        this.node.text.transform(transformString);
        if (this.node.vect.pattern) {
            const img = this.node.vect.pattern.getElementsByTagName("image")[0];
            img.setAttribute("y", (boundingClientRect.height / r - bb.height) / 2 - 4);
            img.setAttribute("x", (boundingClientRect.width / r - bb.width) / 2 - 4);
        }
        tempPath.remove();
    }
    animateSet(data, opts) {
        const self = this;
        const transformString = `...R${data.rotationAngle},${data.rotate.point.x}, ${data.rotate.point.y}`;
        self.node.vect.animate({
            transform: transformString
        }, opts.duration || 500, opts.easing || ">", ()=>{
            const tstr = self.node.getTransformString();
            self.node.vect.transform(tstr);
            // self.node.text.transform(tstr);
            if (opts.cb) opts.cb();
        });
        self.node.text.animate({
            transform: transformString
        }, opts.duration || 500, opts.easing || ">", ()=>{
            const tstr = self.node.getTransformString();
            self.node.text.transform(tstr);
        });
        opts.associations.forEach((assoc)=>{
            const a = self.node.relationships.associations.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId);
            if (a) a.line.animate({
                path: assoc.linePath
            }, opts.duration || 500, opts.easing || ">", ()=>{
                a.line.attr({
                    path: assoc.linePath
                });
            });
        });
    }
}
exports.default = rotate;

},{"static-kdtree":"i8GTt","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"91LgF":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
class menu {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this._m = null;
        this._isOpen = false;
    }
    isOpen() {
        return this._isOpen;
    }
    show() {
        const self = this;
        const r = self.slate.paper;
        if (self._m) {
            (0, _lodashInvokeDefault.default)(self._m, "remove");
            self._m = null;
        }
        const bb = self.node.vect.getBBox();
        const _x = bb.x;
        const _y = bb.y;
        self._m = r.set();
        self._isOpen = true;
        // right, bottom, and settings connectors
        self.node.connectors.show(_x, _y, self._m, ()=>{
            if (self.slate.events?.onMenuRequested) self.slate.events?.onMenuRequested(self.node, ()=>{});
        });
    }
    hide(exceptionElemId) {
        if (this._m) {
            this._m.forEach((m)=>{
                if (m.id !== exceptionElemId) m.remove();
            });
            this._m.items = exceptionElemId ? null : this._m.items.filter((item)=>item.id !== exceptionElemId);
            this.node?.connectors?.iconBar?.remove();
            if (this.node?.connectors?.iconBar) this.node.connectors.iconBar = null;
        }
        this.node.rotate.hide();
        this._isOpen = false;
    }
}
exports.default = menu;

},{"lodash.invoke":"6VYuy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h710n":[function(require,module,exports) {
/* eslint-disable new-cap */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class connectors {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.buttons = null;
        this.iconBar = null;
        this._lastUnpinned = {
            options: {
                xPos: null,
                width: null,
                yPos: null
            }
        };
    }
    _broadcast(skipCenter, options, targetXPos, targetYPos) {
        const self = this;
        const pkg = {
            type: "onNodeAdded",
            data: {
                id: self.node.options.id,
                skipCenter,
                options,
                targetXPos,
                targetYPos
            }
        };
        this.slate.collab && this.slate.collab.send(pkg);
    }
    remove() {
        const self = this;
        if (self.buttons) Object.keys(self.buttons).forEach((btn)=>{
            self.buttons[btn].remove();
        });
        self.iconBar?.remove();
        self.iconBar = null;
        self.node.menu._isOpen = false;
    }
    removeSettingsButton() {
        this.buttons.setting.remove();
    }
    show(x, y, _m, onSettingsClicked) {
        const self = this;
        const r = self.slate.paper;
        const bb = self.node.vect.getBBox();
        const widthOffset = bb.width / 2;
        const btnAttr = {
            fill: "#fff",
            stroke: "#000"
        };
        function conditionallyShow(nodeType, deleteOverride) {
            switch(nodeType){
                case "delete":
                    if (self.node.options.showDelete) self.buttons.trash = r.trash().transform([
                        "t",
                        x + widthOffset - (deleteOverride || 80),
                        ",",
                        y - 58
                    ].join()).attr({
                        fill: "#fff",
                        stroke: "#f00"
                    });
                    else if (self.node.options.showAddAndDeleteConditionally && self.node.options.copiedFromId) {
                        const copiedTimestamps = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId).map((nx)=>nx.options.copiedAt);
                        if (self.node.options.copiedAt >= Math.max(...copiedTimestamps)) self.buttons.trash = r.trash().transform([
                            "t",
                            x + widthOffset - (deleteOverride || 80),
                            ",",
                            y - 58
                        ].join()).attr({
                            fill: "#fff",
                            stroke: "#f00"
                        });
                    }
                    break;
                case "add":
                    {
                        const copies = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.id).length;
                        if (self.node.options.showAdd || copies === 0 && self.node.options.showAddAndDeleteConditionally && !self.node.options.copiedFromId) self.buttons.unPinned = r.plus().transform([
                            "t",
                            x + widthOffset + 40,
                            ",",
                            y - 58
                        ].join()).attr(btnAttr);
                        else if (self.node.options.showAddAndDeleteConditionally && self.node.options.copiedFromId) {
                            const copiedTimestamps = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId).map((nx)=>nx.options.copiedAt);
                            if (self.node.options.copiedAt >= Math.max(...copiedTimestamps)) self.buttons.unPinned = r.plus().transform([
                                "t",
                                x + widthOffset + 40,
                                ",",
                                y - 58
                            ].join()).attr(btnAttr);
                        }
                        break;
                    }
                default:
                    break;
            }
        }
        self.buttons = {};
        if (self.slate.isCommentOnly() && self.node.options.isComment || !self.slate.isCommentOnly()) {
            if (self.node.options.showMenu) self.buttons.setting = r.setting().transform([
                "t",
                x + widthOffset,
                ",",
                y - 58
            ].join()).attr(btnAttr);
            if (self.node.options.isComment && self.slate.canRemoveComments()) conditionallyShow("delete", 40);
        }
        if (!self.node.options.isLocked && !self.node.options.isComment && !self.slate.isCommentOnly()) {
            conditionallyShow("add");
            conditionallyShow("delete");
            if (self.node.options.showRelationshipConnector) self.buttons.handle = r.handle().transform([
                "t",
                x + widthOffset - 40,
                ",",
                y - 58
            ].join()).attr(btnAttr);
        }
        [
            "mousedown"
        ].forEach((eventType)=>{
            if (self.buttons.setting) self.buttons.setting[eventType]((e)=>{
                self.slate.unglow();
                onSettingsClicked.apply(self);
                (0, _utilsDefault.default).stopEvent(e);
                // self.remove();
                if (self.slate.multiSelection) self.slate.multiSelection.end();
                if (self.node.context) self.node.context.remove();
                if (self.node.links) self.node.links.unset();
            });
            if (self.buttons.unPinned) self.buttons.unPinned[eventType](function unp(e) {
                (0, _utilsDefault.default).stopEvent(e);
                this.loop();
                self.slate.unglow();
                self.node.connectors?.addNode();
                self.node.menu?.hide();
                self.node.context?.remove();
            });
            if (self.buttons.trash) self.buttons.trash[eventType]((e)=>{
                const gid = self.node.options.groupId;
                (0, _utilsDefault.default).stopEvent(e);
                self.node.del();
                self.slate.unglow();
                const delPkg = {
                    type: "onNodeDeleted",
                    data: {
                        id: self.node.options.id,
                        isComment: self.node.options.isComment
                    }
                };
                self.slate.collab?.send(delPkg);
                self.slate.birdsEye?.nodeDeleted(delPkg);
                if (gid) // reselect the group after the node is deleted
                self.slate.multiSelection.showGroup(gid);
            });
            if (self.buttons.handle) self.buttons.handle[eventType]((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                self.slate.unglow();
                self.node.relationships.initiateTempNode(e, self.node, true);
            });
        });
        if (Object.keys(self.buttons).length > 1) {
            const isComment = self.node.options.isComment;
            const barWidth = Object.keys(self.buttons).length * 40;
            // console.log('isComment barWidth', isComment, barWidth, widthOffset)
            if (!self.iconBar) self.iconBar = r.rect(x + widthOffset - (isComment ? 45 : 85), y - 63, barWidth, 43, 3).attr({
                stroke: "#000",
                fill: "#fff"
            }).toFront();
        }
        Object.keys(self.buttons).forEach((btn)=>{
            const button = self.buttons[btn];
            button.toFront();
            _m.push(button);
            button.mouseover(function mo() {
                self.slate.glow(this);
            });
            button.mouseout(()=>{
                self.slate.unglow();
            });
        });
        if (!self.node.options.isLocked && !self.node.options.isComment && !self.slate.isCommentOnly()) {
            if (self.node.options.showResize) {
                const rs = self.node.resize.show(x + bb.width, y + bb.height);
                _m.push(rs);
            }
            if (self.node.options.showRotate) {
                const rotate = self.node.rotate.show(x, y);
                _m.push(rotate);
            }
        }
        return self;
    }
    reset() {
        this._lastUnpinned = {
            options: {
                xPos: null,
                width: null,
                yPos: null
            }
        };
    }
    createNode(skipCenter, options, targetXPos, targetYPos, doBroadcast) {
        const self = this;
        const newNode = new (0, _nodeDefault.default)(options);
        self.slate.nodes.add(newNode);
        (0, _utilsDefault.default).transformPath(newNode, `T${targetXPos - newNode.options.xPos}, ${targetYPos - newNode.options.yPos}`);
        newNode.options.xPos = targetXPos;
        newNode.options.yPos = targetYPos;
        newNode.editor.set();
        // const coords = newNode.textCoords({
        //   x: newNode.options.xPos,
        //   y: newNode.options.yPos,
        // })
        // newNode.editor.setTextOffset()
        // newNode.text.attr(coords)
        self._lastUnpinned = newNode.options;
        if (self.slate.options.mindMapMode) self.node.relationships.addAssociation(newNode);
        self.slate.birdsEye?.refresh(false);
        if (doBroadcast) self._broadcast(skipCenter, options, targetXPos, targetYPos);
        // var _pkg = { type: "addRelationship", data: { type: 'association', parent: self.node.options.id, child: newNode.options.id} };
        // self.slate.collab && self.slate.collab.send(_pkg);
        // fire the editor if the menu can be shown
        if (doBroadcast && newNode.options.showMenu && skipCenter === undefined) newNode.position("center", ()=>{
            // fire event
            self.slate.events?.onTextPaneRequested?.apply(this, [
                newNode,
                (opts)=>{
                // ('changed', opts);
                }
            ]);
        });
        return newNode;
    }
    // eslint-disable-next-line consistent-return
    addNode(skipCenter) {
        const self = this;
        // add new node to the right of this one.
        // const _snap = self.slate.snapshot()
        const copies = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId && n.options.copiedAt >= self.node.options.copiedAt).length;
        if (copies === 1) self.reset();
        const options = JSON.parse(JSON.stringify(self.node.options));
        // assign a new guid to this node and remove the old id from the snapshot
        // otherwise the snapshot contains the previous id, and the node contains
        // the new id -- and the broadcast of the snap for collaboration causes
        // the old id to be assigned to the new node, created duplicate nodes with the same id
        const newId = (0, _utilsDefault.default).guid();
        // let snapNode = _snap.nodes.allNodes.find((n) => n.options.id === options.id)
        // console.log(
        //   'found snapNode',
        //   newId,
        //   options.id,
        //   _snap.nodes.allNodes,
        //   snapNode
        // )
        // snapNode.options.id = newId
        if (!self.node.options.width) {
            const bb = self.node.vect.getBBox();
            self.node.options.width = bb.width;
            self.node.options.height = bb.height;
        }
        options.id = newId;
        const targetXPos = (self._lastUnpinned.xPos || self.node.options.xPos) + (self._lastUnpinned.width || self.node.options.width || 220) + self.node.options.spaceBetweenNodesWhenAdding || 30;
        const targetYPos = self._lastUnpinned.yPos || self.node.options.yPos;
        // console.log(
        //   'targetXPos',
        //   targetXPos,
        //   self._lastUnpinned.width,
        //   self.node.options.width,
        //   self.node.options.spaceBetweenNodesWhenAdding
        // )
        // const textDimens = utils.getTextWidth(
        //   self.node.options.text,
        //   `${self.node.options.fontSize}pt ${self.node.options.fontFamily}`
        // )
        // // don't replace text if the shape is alpha, otherwise the intent here is to copy the text
        // console.log(
        //   'textDimens',
        //   self.node.options.text,
        //   `${self.node.options.fontSize}pt ${self.node.options.fontFamily}`,
        //   textDimens.width,
        //   textDimens.fontBoundingBoxAscent + textDimens.fontBoundingBoxDescent
        // )
        if (options.opacity === 1) options.text = "";
        options.copiedFromId = self.node.options.copiedFromId || self.node.options.id;
        options.copiedAt = new Date().valueOf();
        // use the next theme shape if this slate is set to sync the theme
        if (!self.slate.options.basedOnThemeId) return self.createNode(skipCenter, options, targetXPos, targetYPos, true);
        // adjust the node's shape and color prior to insertion
        self.slate.events.onThemeRequired({
            themeId: self.slate.options.basedOnThemeId
        }, (err, theme)=>{
            if (err) console.error("Unable to apply theme", err);
            else {
                const children = self.slate.findChildren([
                    options.id
                ]);
                let nextChild = children.length + 1;
                if (nextChild > Object.keys(theme.styles).length) nextChild = 1;
                const base = theme.styles[`child_${nextChild}`];
                // if (base && base.opacity === 0) {
                //   // scope the size to just the text if this is opacity-less
                //   base.width = textDimens.width
                //   base.height =
                //     textDimens.fontBoundingBoxAscent +
                //     textDimens.fontBoundingBoxDescent
                //   base.vectorPath = options.vectorPath
                // }
                // console.log(
                //   'modifying options',
                //   options.width,
                //   options.height,
                //   options.vectorPath,
                //   base.width,
                //   base.height
                // )
                if (base) Object.assign(options, (0, _lodashOmitDefault.default)(base, "vectorPath"));
            }
            return self.createNode(skipCenter, options, targetXPos, targetYPos, true);
        });
    }
}
exports.default = connectors;

},{"../helpers/utils":"8QI6M","../core/node":"bAVQb","lodash.omit":"82TGT","../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4vYbQ":[function(require,module,exports) {
/* eslint-disable no-use-before-define */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashThrottle = require("lodash.throttle");
var _lodashThrottleDefault = parcelHelpers.interopDefault(_lodashThrottle);
var _lodashClone = require("lodash.clone");
var _lodashCloneDefault = parcelHelpers.interopDefault(_lodashClone);
var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
class resize {
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.resize = null;
        self.resizeTemp = null;
        self.origX = null;
        self.origY = null;
        self.lastDx = null;
        self.lastDy = null;
        self._minWidth = 5;
        self._minHeight = 5;
        self._dragAllowed = false;
        self._origWidth = null;
        self._origHeight = null;
        self._isResizing = false;
        self.origPath = null;
        self.origPoint = {};
        self.resizeEvents = {
            start () {
                const s = this;
                self.node.toggleImage({
                    active: true,
                    keepResizerOpen: true
                });
                self.origPath = self.node.options.vectorPath;
                self.origPoint = self.node.options.rotate.point;
                self.origX = self.resizeTemp.attr("x");
                self.origY = self.resizeTemp.attr("y");
                self.node.options.hasResized = true;
                // create a huge dragging area in order to prevent mouse from losing focus on the correct element
                self.resizeTemp.attr({
                    x: self.resizeTemp.attr("x") - 1000,
                    y: self.resizeTemp.attr("y") - 1000,
                    width: 10000,
                    height: 10000
                });
                self.slate.isBeingResized = true;
                self.node.relationships.updateAssociationsWith({
                    activeNode: self.node.options.id,
                    currentDx: 0,
                    currentDy: 0,
                    action: "resize"
                });
                self.lastDx = 0;
                self.lastDy = 0;
                const bbr = self.resize.getBBox();
                self.resize.ox = bbr.x;
                self.resize.oy = bbr.y;
                self._isResizing = true;
                self.slate.multiSelection?.end();
                // the resize coords at the start
                s.ox = s.attr("x");
                s.oy = s.attr("y");
                self.node.setStartDrag();
                self.node.connectors.remove();
                self.node.rotate.hide();
                self._dragAllowed = self.slate.options.allowDrag;
                self.slate.disable(false, true);
                if (self.node.options.text !== " ") {
                    self._minWidth = 10;
                    self._minHeight = 10;
                }
                self._origWidth = self.node.options.width;
                self._origHeight = self.node.options.height;
                self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>n.options.id !== self.node.options.id).map((n)=>({
                        id: n.options.id,
                        bbox: n.vect.getBBox(),
                        point: [
                            n.options.xPos,
                            n.options.yPos
                        ]
                    }));
                self.kdTree = (0, _staticKdtreeDefault.default)(self.foreignPoints.map((fp)=>fp.point));
                self.node.relationships.conditionallyHideAll();
                self.slate.toggleFilters(false);
            },
            move (dx, dy) {
                const s = this;
                try {
                    const zoomRatio = self.slate.options.viewPort.zoom.r;
                    // for snapping
                    if (self.slate.options.viewPort.showGrid && self.slate.options.viewPort.snapToGrid) {
                        const gridSize = self.slate.options.viewPort.gridSize || 10;
                        dx = Math.round(dx / gridSize) * gridSize;
                        dy = Math.round(dy / gridSize) * gridSize;
                    }
                    dx += dx / zoomRatio - dx;
                    dy += dy / zoomRatio - dy;
                    const nearest = self.kdTree.knn([
                        node.options.xPos,
                        node.options.yPos
                    ], 5);
                    nearest.forEach((n)=>{
                        self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox, false, 200);
                    });
                    // let transWidth = self._origWidth
                    // let transHeight = self._origHeight
                    // if (self.node.options.shapeHint === 'custom') {
                    const { transWidth, transHeight } = (0, _utilsDefault.default).obtainProportionateWidthAndHeightForResizing(dx, dy, self._origWidth, self._origHeight, self.node.options.shapeHint === "custom" ? self.node.options.origVectWidth : null, self.node.options.shapeHint === "custom" ? self.node.options.origVectHeight : null, self.slate.isCtrl, self.node.options.shapeHint === "custom");
                    // }
                    if (transWidth > self._minWidth) s.attr({
                        x: s.ox + dx
                    });
                    else // tx = 0;
                    s.attr({
                        x: s.ox
                    });
                    if (transHeight > self._minHeight) s.attr({
                        y: s.oy + dy
                    });
                    else // ty = 0;
                    s.attr({
                        y: s.oy
                    });
                    // if (transWidth > self._minWidth && transHeight > self._minHeight) {
                    const ts = `T${dx}, ${dy}`;
                    self.resize.transform(ts);
                    // }
                    self.node.events?.onResizing?.apply(self, [
                        transWidth,
                        transHeight
                    ]);
                    self.set(transWidth, transHeight, {
                        isMoving: true,
                        getRotationPoint: self.node.options.rotate.rotationAngle
                    });
                    self.node.images.imageSizeCorrection() // self is a potential performance choke point
                    ;
                    self.lastDx = dx * 2;
                    self.lastDy = dy * 2;
                } catch (err) {
                    finalize();
                }
            },
            async up () {
                self.slate.toggleFilters(false);
                finalize();
            }
        };
        function finalize() {
            // self.resizeTemp.attr({ x: self.origX + self.lastDx, y: self.origY + self.lastDy, width: self.resize.attr("width"), height: self.resize.attr("height") });
            // self.node.options.vectorPath = _optimizedContext.path;
            self.node.vect.attr({
                path: self.node.options.vectorPath
            });
            self.node.relationships.showAll(true);
            self.slate.isBeingResized = false;
            self._isResizing = false;
            self.slate.enable(false, true);
            self.resize.remove();
            self.resizeTemp.remove();
            self.node.setEndDrag();
            // self.node.relationships.wireHoverEvents();
            const _bbox = self.node.vect.getBBox();
            self.node.toggleImage({
                active: false,
                width: _bbox.width,
                height: _bbox.height
            });
            self.node.options.width = _bbox.width;
            self.node.options.height = _bbox.height;
            self.node.options.xPos = _bbox.x;
            self.node.options.yPos = _bbox.y;
            if (self.node.options.image) self.node.options.ignoreTextFit = true;
            else self.node.options.ignoreTextFit = false;
            self.node.editor.setTextOffset();
            self.node.text.attr(self.node.textCoords({
                x: self.node.options.xPos,
                y: self.node.options.yPos
            }));
            self.node.gridLines.clear();
            delete self.foreignPoints;
            delete self.kdTree;
            if (self.node.events && self.node.events?.onResized) self.node.events.onResized.apply(self, [
                self.send
            ]);
            else self.send();
        }
    }
    show(x, y) {
        const self = this;
        if (self.node.options.allowResize) {
            self.resizeTemp?.remove();
            const r = self.slate.paper;
            const resizePath = (0, _utilsDefault.default)._transformPath((0, _sbIconsDefault.default).icons.resize, `t${x - 5},${y - 5} r95`);
            self.resize = r.path(resizePath).attr({
                fill: "#fff",
                stroke: "#000"
            });
            self.resizeTemp = r.rect(x - 6, y - 6, 20, 20).attr({
                fill: "#f00",
                opacity: 0.00000001
            }).toFront();
            self.resizeTemp.mouseover((e)=>{
                self.node.overMenuButton = true;
                self.resizeTemp.attr({
                    cursor: "pointer"
                });
            });
            self.resizeTemp.mouseout((e)=>{
                self.node.overMenuButton = false;
            });
            self.resizeTemp.drag(self.resizeEvents.move, self.resizeEvents.start, self.resizeEvents.up);
            return self.resize;
        }
    }
    hide() {
        this.resizeTemp?.remove();
        this.resize?.remove();
    }
    send() {
        // broadcast change to birdsEye and collaborators
        const textAttrs = this.node.text.attrs;
        const pkg = {
            type: "onNodeResized",
            data: {
                id: this.node.options.id,
                textPosition: {
                    x: textAttrs.x,
                    y: textAttrs.y
                },
                rotate: this.node.options.rotate,
                vectorPath: this.node.options.vectorPath,
                associations: this.node.relationships.associations.map((a)=>({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr("path").toString()
                    }))
            }
        };
        const currentRotationPoint = (0, _lodashCloneDefault.default)(this.node.options.rotate.point);
        this.slate.birdsEye?.nodeChanged(pkg);
        this.node.options.rotate.point = currentRotationPoint;
        this.slate.collab?.send(pkg);
    }
    lazySend() {
        (0, _lodashThrottleDefault.default)(this.send, 700);
    }
    animateSet(data, opts) {
        const self = this;
        self.node.text.animate(data.textPosition, opts.duration || 500, opts.easing || ">");
        self.node.vect.animate({
            path: data.vectorPath,
            transform: `R${data.rotate.rotationAngle}, ${data.rotate.point.x}, ${data.rotate.point.y}`
        }, opts.duration || 500, opts.easing || ">", ()=>{
            const { image, imageOrigHeight, imageOrigWidth } = self.node.options;
            if (image && !!imageOrigHeight && !!imageOrigWidth) self.node.images.imageSizeCorrection();
        });
        opts.associations.forEach((assoc)=>{
            const a = self.node.relationships.associations.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId);
            if (opts.animate) {
                if (a) a.line.animate({
                    path: assoc.linePath
                }, opts.duration || 500, opts.easing || ">", ()=>{
                    a.line.attr({
                        path: assoc.linePath
                    });
                });
            } else if (a) a.line.attr({
                path: assoc.linePath
            });
        });
    }
    // obtainProportionateWidthAndHeightForResizing(
    //   dx,
    //   dy,
    //   origVectWidth,
    //   origVectHeight
    // ) {
    //   let transWidth = (self._origWidth || self.node.options.width) + dx * 2
    //   let transHeight = (self._origHeight || self.node.options.height) + dy * 2
    //   const useOrigVectorWidth = self.node.options.origVectWidth ?? origVectWidth
    //   const useOrigVectorHeight =
    //     self.node.options.origVectHeight ?? origVectHeight
    //   if (!self.slate.isCtrl && useOrigVectorWidth && useOrigVectorHeight) {
    //     const max = Math.max(transWidth, transHeight)
    //     // keep it proportional to the original dimensions unless ctrl is pressed while resizing
    //     if (max === transWidth) {
    //       // change height
    //       transWidth = (useOrigVectorWidth * transHeight) / useOrigVectorHeight
    //     } else {
    //       // change width
    //       transHeight = (useOrigVectorHeight * transWidth) / useOrigVectorWidth
    //     }
    //   }
    //   return { transWidth, transHeight }
    // }
    set(width, height, opts = {}) {
        // let latt, tatt;
        const self = this;
        let pathWithPotentialTransformations = self.node.vect.attr("path").toString();
        if (opts.getRotationPoint) self.origPoint = self.node.options.rotate.point;
        if (self.origPoint && Object.entries(self.origPoint).length > 0 && self.node.options.rotate.rotationAngle > 0) pathWithPotentialTransformations = (0, _raphaelSvg.Raphael).transformPath(pathWithPotentialTransformations, `R${self.node.options.rotate.rotationAngle}, ${self.origPoint.x}, ${self.origPoint.y}`);
        self.node.vect.transform("");
        self.node.text.transform("");
        self.node.vect.attr({
            path: pathWithPotentialTransformations
        });
        self.node.text.attr({
            path: pathWithPotentialTransformations
        });
        const rotationBB = self.node.vect.getBBox();
        let widthScalar = 1;
        let heightScalar = 1;
        if (width > self._minWidth) {
            widthScalar = width / rotationBB.width;
            self.node.options.width = width;
        } else {
            widthScalar = self._minWidth / rotationBB.width;
            self.node.options.width = self._minWidth;
        }
        if (height > self._minHeight) {
            heightScalar = height / rotationBB.height;
            self.node.options.height = height;
        } else {
            heightScalar = self._minHeight / rotationBB.height;
            self.node.options.height = self._minHeight;
        }
        const scaleTransform = `s${widthScalar}, ${heightScalar}`;
        const scaledVectPath = (0, _raphaelSvg.Raphael).transformPath(self.node.vect.attr("path").toString(), scaleTransform).toString();
        pathWithPotentialTransformations = scaledVectPath;
        self.node.vect.attr({
            path: scaledVectPath
        });
        if (self.origPoint && Object.entries(self.origPoint).length > 0 && self.node.options.rotate.rotationAngle > 0) pathWithPotentialTransformations = (0, _raphaelSvg.Raphael).transformPath(pathWithPotentialTransformations, `R${-self.node.options.rotate.rotationAngle}, ${self.origPoint.x}, ${self.origPoint.y}`).toString();
        self.node.vect.attr({
            path: pathWithPotentialTransformations
        });
        self.node.options.vectorPath = pathWithPotentialTransformations;
        const noRotationBB = self.node.vect.getBBox();
        self.node.options.rotate.point = {
            x: noRotationBB.cx,
            y: noRotationBB.cy
        };
        self.node.setPosition({
            x: noRotationBB.x,
            y: noRotationBB.y
        }, true);
        self.node.rotate.applyImageRotation();
        const lc = self.node.linkCoords();
        self.node.link.transform([
            "t",
            lc.x,
            ",",
            lc.y,
            "s",
            ".8",
            ",",
            ".8",
            "r",
            "180"
        ].join());
        self.node.relationships.refreshOwnRelationships();
        self.node.editor.setTextOffset();
        self.node.text.attr(self.node.textCoords({
            x: self.node.options.xPos,
            y: self.node.options.yPos
        }));
    }
}
exports.default = resize;

},{"lodash.throttle":"bGJVT","lodash.clone":"j9BUC","static-kdtree":"i8GTt","../deps/raphael/raphael.svg":"jK21R","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGJVT":[function(require,module,exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var global = arguments[3];
var FUNC_ERROR_TEXT = "Expected a function";
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** `Object#toString` result references. */ var symbolTag = "[object Symbol]";
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) return trailingEdge(time);
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) return invokeFunc(time);
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) clearTimeout(timerId);
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) return leadingEdge(lastCallTime);
            if (maxing) {
                // Handle invocations in a tight loop.
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */ function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
    if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
    });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == "number") return value;
    if (isSymbol(value)) return NAN;
    if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") return value === 0 ? value : +value;
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = throttle;

},{}],"j9BUC":[function(require,module,exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = "__lodash_hash_undefined__";
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == "object" && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function("return this")();
/** Detect free variable `exports`. */ var freeExports = exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && true && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */ function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
}
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */ function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
}
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */ function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) break;
    }
    return array;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */ function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") try {
        result = !!(value + "");
    } catch (e) {}
    return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root["__core-js_shared__"];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, "DataView"), Map = getNative(root, "Map"), Promise = getNative(root, "Promise"), Set = getNative(root, "Set"), WeakMap = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        "hash": new Hash,
        "map": new (Map || ListCache),
        "string": new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    return this.__data__["delete"](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */ function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
    if (result !== undefined) return result;
    if (!isObject(value)) return value;
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray(value, result);
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) return cloneBuffer(value, isDeep);
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) return object ? value : {};
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) return copySymbols(value, baseAssign(result, value));
        } else {
            if (!cloneableTags[tag]) return object ? value : {};
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
    arrayEach(props || value, function(subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
}
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */ function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    return objectToString.call(value);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != "constructor") result.push(key);
    return result;
}
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */ function cloneBuffer(buffer, isDeep) {
    if (isDeep) return buffer.slice();
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
}
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */ function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */ function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */ function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
}
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */ function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */ function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
}
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */ function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */ function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */ function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
            return new Ctor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
            return new Ctor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
            return cloneSymbol(object);
    }
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */ function clone(value) {
    return baseClone(value, false, true);
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = clone;

},{}],"jLcMC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _emile = require("../deps/emile");
class images {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    getTargetImageDimensions() {
        let transImageHeight;
        let transImageWidth;
        const origImageRatio = this.node.options.imageOrigWidth / this.node.options.imageOrigHeight;
        const noRotationPath = this.slate.paper.path(this.node.vect.attr("path"));
        const noRotationBB = noRotationPath.getBBox();
        const nodeRatio = noRotationBB.width / noRotationBB.height;
        if (origImageRatio < nodeRatio) {
            transImageWidth = noRotationBB.width;
            transImageHeight = noRotationBB.width / origImageRatio;
        } else if (origImageRatio > nodeRatio) {
            transImageHeight = noRotationBB.height;
            transImageWidth = noRotationBB.height * origImageRatio;
        } else {
            transImageWidth = noRotationBB.width;
            transImageHeight = noRotationBB.height;
        }
        noRotationPath.remove();
        return {
            width: transImageWidth,
            height: transImageHeight
        };
    }
    imageSizeCorrection() {
        if (this.node.vect.pattern) {
            const targetImageDimensions = this.getTargetImageDimensions();
            const img = this.node.vect.pattern.getElementsByTagName("image")[0];
            img.setAttribute("height", targetImageDimensions.height);
            img.setAttribute("width", targetImageDimensions.width);
        }
    }
    set(img, w, h, blnKeepResizerOpen) {
        this.node.vect.data({
            relativeFill: true
        });
        this.node.options.image = img;
        this.node.options.origImage = {
            w,
            h
        } // needed for image copying if done later
        ;
        this.node.options.imageOrigHeight = h // for scaling node to image size purposes; this value should never be changed
        ;
        this.node.options.imageOrigWidth = w;
        this.node.options["fill-opacity"] = 1;
        const sz = {
            fill: `url(${this.node.options.image})`,
            "stroke-width": this.node.options.borderWidth,
            stroke: "#000"
        };
        const targetImageDimensions = this.getTargetImageDimensions();
        this.node.vect.imageOrigHeight = targetImageDimensions.height;
        this.node.vect.imageOrigWidth = targetImageDimensions.width;
        this.node.vect.attr({
            "fill-opacity": 1
        }) // IMPORTANT: for some reason Raphael breaks when setting 'sz' object and this at the same time
        ;
        this.node.vect.attr(sz);
        const rotatedBB = this.node.vect.getBBox();
        this.node.options.width = rotatedBB.width;
        this.node.options.height = rotatedBB.height;
        this.node.relationships.refreshOwnRelationships();
        if (blnKeepResizerOpen) {
            this.node.setPosition({
                x: rotatedBB.x,
                y: rotatedBB.y
            }, true);
            this.node.menu?.hide();
            this.node.rotate?.hide();
        } else this.node.setPosition({
            x: rotatedBB.x,
            y: rotatedBB.y
        });
        this.node.connectors?.remove();
    }
}
exports.default = images;

},{"../deps/emile":"dd61Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kA5hP":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class shapes {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    async set(pkg = {
        sendCollab: false
    }) {
        this.slate.unglow();
        let _path = "";
        switch(pkg.shape){
            case "ellipse":
                _path = (0, _utilsDefault.default)._transformPath(`M${this.node.options.xPos + 75},${this.node.options.yPos + 50} m -75,0 a75,50 0 1,0 150,0 a 75,50 0 1,0 -150,0Z`);
                this.node.options.isEllipse = true;
                break;
            case "rect":
                if (pkg.rx > 0) _path = (0, _utilsDefault.default)._transformPath(`M${this.node.options.xPos},${this.node.options.yPos} h130 a10,10 0 0 1 10,10 v80 a10,10 0 0 1 -10,10 h-130 a10,10 0 0 1 -10,-10 v-80 a10,10 0 0 1 10,-10 z`);
                else _path = (0, _utilsDefault.default)._transformPath(`M${this.node.options.xPos},${this.node.options.yPos} h150 v100 h-150 v-100 z`);
                this.node.options.isEllipse = false;
                break;
            default:
                _path = (0, _utilsDefault.default)._transformPath(pkg.shape, `T${this.node.options.xPos},${this.node.options.yPos}`);
                this.node.options.isEllipse = false;
                break;
        }
        this.node.options.vectorPath = _path;
        this.node.options.shapeHint = pkg.hint;
        this.node.options.origVectWidth = pkg.width;
        this.node.options.origVectHeight = pkg.height;
        this.node.options.width = pkg.width || this.node.options.width;
        this.node.options.height = pkg.height || this.node.options.height;
        this.node.vect.attr({
            path: _path
        });
        this.node.editor.setTextOffset();
        this.node.text.attr(this.node.textCoords({
            x: this.node.options.xPos,
            y: this.node.options.yPos
        }));
        // apply image fill rotation
        if (this.node.vect.pattern) {
            this.node.images.imageSizeCorrection();
            this.node.rotate.applyImageRotation();
        }
        this.node.text.toFront();
        this.node.link.toFront();
        this.node.relationships.refreshOwnRelationships();
        if (pkg.keepResizerOpen) {
            this.node.menu?.hide();
            this.node.rotate?.hide();
        }
        // needed for tofront and toback ops of the context menu
        this.node.vect.data({
            id: this.node.options.id
        });
        this.node.context.create();
        if (pkg.sendCollab) {
            const _pkg = {
                type: "onNodeShapeChanged",
                data: {
                    id: this.node.options.id,
                    shape: pkg.shape,
                    hint: pkg.hint,
                    width: pkg.width,
                    height: pkg.height,
                    sendCollab: false,
                    rx: pkg.rx
                }
            };
            this.slate.collab?.send(_pkg);
            this.slate.birdsEye?.nodeChanged(_pkg);
        }
    }
}
exports.default = shapes;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edbtN":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class customShapes {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    set(path, width, height, sendCollab) {
        let upath = path;
        if (width && height) {
            // calculate the scale of the path
            const scale = Math.max(this.node.options.width, this.node.options.height) / Math.max(width, height);
            upath = (0, _utilsDefault.default)._transformPath(path, [
                "s",
                scale,
                ",",
                scale
            ].join(""));
        }
        this.node.shapes.set({
            shape: upath.toString(),
            sendCollab: sendCollab != null ? sendCollab : true
        });
    }
}
exports.default = customShapes;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJAST":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class colorPicker {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    set(cast) {
        this.node.options.image = "";
        this.node.options.backgroundColor = cast.color;
        if (cast.opacity != null) this.node.options.opacity = cast.opacity;
        this.node.vect.attr({
            fill: cast.color,
            "fill-opacity": this.node.options.opacity
        });
        if (cast.color === "" && this.node.options.text !== "") {
            this.node.vect.attr({
                stroke: this.node.options.borderColor || "#000"
            });
            this.node.options.borderWidth = 0;
        } else this.node.vect.attr({
            stroke: this.node.options.borderColor || "#000",
            "stroke-width": this.node.options.borderWidth
        });
        this.node.relationships.refreshOwnRelationships();
    }
}
exports.default = colorPicker;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"185nI":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class context {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this._contextMenu = null;
        this._priorAllowDrag = true;
    }
    ctx(e) {
        this._priorAllowDrag = this.node.options.allowDrag;
        this.node.options.allowDrag = false;
        this.remove();
        this.buildContext(e);
        setTimeout(()=>{
            this.node.options.allowDrag = this._priorAllowDrag;
        }, 2);
        return (0, _utilsDefault.default).stopEvent(e);
    }
    create() {
        if (this.node.text && this.node.text.node && this.node.options.allowContext && !this.node.slate.isAlt && !this.node.slate.isShift) {
            this.node.text.node.oncontextmenu = this.ctx;
            this.node.vect.node.oncontextmenu = this.ctx;
        }
    }
    buildContext(e) {
        this._contextMenu = document.createElement("div");
        this._contextMenu.setAttribute("id", `contextMenu_${this.node.options.id}`);
        this._contextMenu.setAttribute("class", "sb_cm");
        document.body.appendChild(this._contextMenu);
        this.setContext(e);
    }
    menuItems() {
        const tmp = "<div style='padding:5px;' class='sbthis._contextMenuItem' rel='{func}'>{text}</div>";
        let inside = tmp.replace(/{func}/g, "tofront").replace(/{text}/g, "to front");
        inside += tmp.replace(/{func}/g, "toback").replace(/{text}/g, "to back");
        if (this._priorAllowDrag) inside += tmp.replace(/{func}/g, "lock").replace(/{text}/g, "lock");
        else inside += tmp.replace(/{func}/g, "unlock").replace(/{text}/g, "unlock");
        inside += tmp.replace(/{func}/g, "close").replace(/{text}/g, "close");
        return inside;
    }
    setContext(e) {
        const self = this;
        this._contextMenu.innerHTML = this.menuItems();
        const all = (0, _utilsDefault.default).select("div.contextMenuItem");
        for(let s = all.length; s < all.length; s += 1){
            const elem = all[s];
            elem.onclick = ()=>{
                const act = this.getAttribute("rel");
                let _reorder = false;
                const pkg = {
                    type: "",
                    data: {
                        id: self.node.options.id
                    }
                };
                switch(act){
                    case "tofront":
                        self.node.toFront();
                        _reorder = true;
                        pkg.type = "onNodeToFront";
                        break;
                    case "toback":
                        self.node.toBack();
                        _reorder = true;
                        pkg.type = "onNodeToBack";
                        break;
                    case "lock":
                        self.node.options.isLocked = true // self is not a part of the self.node.disable function on purpose
                        ;
                        self.node.disable();
                        pkg.type = "onNodeLocked";
                        break;
                    case "unlock":
                        self.node.options.isLocked = false // self is not a part of the self.node.enable function on purpose
                        ;
                        self.node.enable();
                        pkg.type = "onNodeUnlocked";
                        break;
                    case "close":
                    default:
                        break;
                }
                if (_reorder) {
                    let zIndex = 0;
                    for(let node = self.node.slate.paper.bottom; node != null; node = node.next)if (node.type === "ellipse" || node.type === "rect") {
                        zIndex += 1;
                        const _id = node.data("id");
                        // not all rects have an id (the menu box is a rect, but it has no options.id because it is not a node
                        // so you cannot always show self...
                        if (_id) {
                            const reorderedNode = self.node.slate.nodes.allNodes.find((n)=>n.options.id === _id);
                            reorderedNode.sortorder = zIndex;
                        }
                    }
                    self.node.slate.nodes.allNodes.sort((a, b)=>a.sortorder < b.sortorder ? -1 : 1);
                }
                if (pkg.type !== "") self.broadcast(pkg);
                this.remove();
            };
        }
        const mp = (0, _utilsDefault.default).mousePos(e);
        const _x = mp.x;
        const _y = mp.y;
        this._contextMenu.style.left = `${_x}px`;
        this._contextMenu.style.top = `${_y}px`;
    }
    broadcast(pkg) {
        // broadcast
        if (this.node.slate.collab) this.node.slate.collab.send(pkg);
        if (this.node.slate.birdsEye) this.node.slate.birdsEye.nodeChanged(pkg);
    }
    remove() {
        this.node.slate?.removeContextMenus();
        this._contextMenu = null;
    }
    isVisible() {
        return this._contextMenu !== null;
    }
}
exports.default = context;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c3gfk":[function(require,module,exports) {
/* eslint-disable no-param-reassign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class lineOptions {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.m = {};
    }
    broadcast(pkg) {
        pkg.data.id = this.node.options.id;
        this.slate.collab?.send(pkg);
    }
    set(pkg) {
        const a = this.node.relationships.associations[pkg.index];
        if (pkg.updateChild) a.child.options[pkg.prop] = pkg.val;
        else this.node.options[pkg.prop] = pkg.val;
        if (pkg.val === "toggle") a[pkg.prop] = a[pkg.prop] ? (pkg.prop, false) : true;
        else a[pkg.prop] = pkg.val;
        (0, _refreshRelationshipsDefault.default)({
            relationships: [
                a
            ],
            nodes: [
                this.node
            ]
        });
    }
    show(e, c) {
        const self = this;
        self.hideAll();
        self.slate.nodes.closeAllLineOptions(c.id);
        const a = self.node.relationships.associations.find((ax)=>ax.id === c.id);
        const r = self.slate.paper;
        const mp = (0, _utilsDefault.default).mousePos(e);
        const off = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        const z = self.slate.options.viewPort.zoom.r;
        const opacity = "1.0";
        let x = (mp.x + self.slate.options.viewPort.left - off.left - 90) / z;
        let y = (mp.y + self.slate.options.viewPort.top - off.top - 30) / z;
        const bb = a.line.getBBox();
        x = bb.cx;
        y = bb.cy;
        self.m[c.id] = r.set();
        const transformToolbar = (xx, yy)=>[
                "t",
                x + xx,
                ",",
                y + yy
            ].join();
        const toolbarAttr = {
            fill: "#fff",
            "fill-opacity": opacity,
            stroke: "#333",
            "stroke-width": 1,
            cursor: "pointer"
        };
        const toolbar = [];
        const reassign = self.node.options.showRelationshipReassign ? r.handle().attr(toolbarAttr).transform(transformToolbar(15, 0)) : null;
        const props = self.node.options.showRelationshipProperties ? r.setting().attr(toolbarAttr).transform(transformToolbar(-15, 0)) : null;
        const del = self.node.options.showRelationshipDelete ? r.trash().transform(transformToolbar(-45, 0)).attr({
            fill: "#fff",
            stroke: "#f00"
        }) : null;
        if (reassign) toolbar.push(reassign);
        if (toolbar) toolbar.push(props);
        if (del) toolbar.push(del);
        const toolbarGlows = [];
        toolbar.forEach((toolbarElem)=>{
            toolbarElem.mouseover(function g() {
                toolbarGlows.push(this.glow());
                (0, _utilsDefault.default).stopEvent(e);
            });
            toolbarElem.mouseout(()=>{
                toolbarGlows.forEach((t)=>{
                    t.remove();
                });
                (0, _utilsDefault.default).stopEvent(e);
            });
        });
        if (props) props.mousedown((ex)=>{
            (0, _utilsDefault.default).stopEvent(ex);
            toolbarGlows.forEach((t)=>{
                t.remove();
            });
            const assoc = self.node.relationships.associations.find((ax)=>ax.id === c.id);
            if (self.slate.events?.onLineMenuRequested) {
                self.hideAll();
                self.slate.events?.onLineMenuRequested(self.node, assoc, ()=>{
                // finished
                });
            }
        });
        function removeRelationship(ex) {
            toolbarGlows.forEach((t)=>{
                t.remove();
            });
            (0, _utilsDefault.default).stopEvent(ex);
            if (self.slate.options.enabled) {
                const pkg = {
                    type: "removeRelationship",
                    data: {
                        parent: c.parent.options.id,
                        child: c.child.options.id
                    }
                };
                self.slate.nodes.removeRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
                self.broadcast(pkg);
                self.hide(c.id);
            }
        }
        // reassign relationship
        if (reassign) reassign.mousedown(()=>{
            removeRelationship();
            self.node.relationships.initiateTempNode(e, c.parent, {
                showChildArrow: a.showChildArrow,
                showParentArrow: a.showParentArrow
            });
        });
        // remove relationship
        if (del) del.mousedown(()=>{
            removeRelationship();
        });
        toolbar.forEach((toolbarElem)=>{
            self.m[c.id].push(toolbarElem);
        });
        return self;
    }
    hide(id) {
        if (this.m[id]) {
            (0, _lodashInvokeDefault.default)(this.m[id], "remove");
            this.m[id] = null;
        }
    }
    hideAll() {
        const self = this;
        // self.slate.unglow();
        self.node.relationships.associations.map((r)=>r.id).forEach((id)=>{
            self.hide(id);
        });
    }
}
exports.default = lineOptions;

},{"lodash.invoke":"6VYuy","../helpers/refreshRelationships":"1UeYf","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6cFRW":[function(require,module,exports) {
/* eslint-disable no-param-reassign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class gridLines {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.guideWings = 20000;
        this.guideAttrs = {
            "stroke-dasharray": "--",
            stroke: "#000"
        };
        this.guideLines = {
            rightVerticals: {},
            leftVerticals: {},
            topHorizontals: {},
            bottomHorizontals: {}
        };
    }
    clear() {
        const self = this;
        [
            "rightVerticals",
            "leftVerticals",
            "topHorizontals",
            "bottomHorizontals"
        ].forEach((p)=>{
            if (self.guideLines[p]) Object.keys(self.guideLines[p]).forEach((k)=>self.guideLines[p][k].remove());
            self.guideLines[p] = {};
        });
    }
    draw(id, dx, dy, bb, translateNode = true, guideVisibleAt = 100, guideSnapAt = 20) {
        const self = this;
        const snapToObjects = self.slate.options.viewPort.snapToObjects != null ? self.slate.options.viewPort.snapToObjects : true;
        let pinnedY = false;
        let pinnedX = false;
        const nbb = self.node.vect.getBBox();
        self.guideAttrs.stroke = (0, _utilsDefault.default).whiteOrBlack(self.slate.options.containerStyle.backgroundColor);
        // RIGHT VERTICAL LINE boundary
        if (nbb.x - bb.x2 < guideVisibleAt && nbb.x - bb.x2 >= 0 || bb.x2 - nbb.x2 < guideVisibleAt && bb.x2 - nbb.x2 >= 0) {
            if (!self.guideLines.rightVerticals[id]) self.guideLines.rightVerticals[id] = self.slate.paper.path(`M ${bb.x2} ${bb.y - self.guideWings} L ${bb.x2} ${bb.y2 + self.guideWings}`).attr(self.guideAttrs);
            pinnedX = nbb.x - bb.x2 < guideSnapAt && nbb.x - bb.x2 >= 0 || bb.x2 - nbb.x2 < guideSnapAt && bb.x2 - nbb.x2 >= 0;
            if (pinnedX && snapToObjects) {
                if (nbb.x - bb.x2 < guideSnapAt && nbb.x - bb.x2 >= 0) dx -= nbb.x - bb.x2;
                else dx += bb.x2 - nbb.x2;
            }
        } else {
            self.guideLines?.rightVerticals[id]?.remove();
            delete self.guideLines?.rightVerticals[id];
        }
        // LEFT VERTICAL LINE boundary
        if (!pinnedX && (bb.x - nbb.x2 < guideVisibleAt && bb.x - nbb.x2 >= 0 || nbb.x - bb.x < guideVisibleAt && nbb.x - bb.x >= 0)) {
            if (!self.guideLines.leftVerticals[id]) self.guideLines.leftVerticals[id] = self.slate.paper.path(`M ${bb.x} ${bb.y - self.guideWings} L ${bb.x} ${bb.y2 + self.guideWings}`).attr(self.guideAttrs);
            pinnedX = bb.x - nbb.x2 < guideSnapAt && bb.x - nbb.x2 >= 0 || nbb.x - bb.x < guideSnapAt && nbb.x - bb.x >= 0;
            if (pinnedX && snapToObjects) {
                if (bb.x - nbb.x2 < guideSnapAt && bb.x - nbb.x2 >= 0) dx += bb.x - nbb.x2;
                else dx -= nbb.x - bb.x;
            }
        } else {
            self.guideLines?.leftVerticals[id]?.remove();
            delete self.guideLines?.leftVerticals[id];
        }
        // TOP HORIZONTAL LINE boundary
        if (bb.y - nbb.y2 < guideVisibleAt && bb.y - nbb.y2 >= 0 || nbb.y - bb.y < guideVisibleAt && nbb.y - bb.y >= 0) {
            if (!self.guideLines.topHorizontals[id]) self.guideLines.topHorizontals[id] = self.slate.paper.path(`M ${bb.x - self.guideWings} ${bb.y} L ${bb.x2 + self.guideWings} ${bb.y}`).attr(self.guideAttrs);
            pinnedY = bb.y - nbb.y2 < guideSnapAt && bb.y - nbb.y2 >= 0 || nbb.y - bb.y < guideSnapAt && nbb.y - bb.y >= 0;
            if (pinnedY && snapToObjects) {
                if (bb.y - nbb.y2 < guideSnapAt && bb.y - nbb.y2 >= 0) // coming from top
                dy += bb.y - nbb.y2;
                else // coming from underneath
                dy -= nbb.y - bb.y;
            }
        } else {
            self.guideLines?.topHorizontals[id]?.remove();
            delete self.guideLines?.topHorizontals[id];
        }
        // BOTTOM HORIZONTAL LINE boundary
        if (!pinnedY && (nbb.y - bb.y2 < guideVisibleAt && nbb.y - bb.y2 >= 0 || bb.y2 - nbb.y2 < guideVisibleAt && bb.y2 - nbb.y2 >= 0)) {
            if (!self.guideLines.bottomHorizontals[id]) self.guideLines.bottomHorizontals[id] = self.slate.paper.path(`M ${bb.x - self.guideWings} ${bb.y2} L ${bb.x2 + self.guideWings} ${bb.y2}`).attr(self.guideAttrs);
            pinnedY = nbb.y - bb.y2 < guideSnapAt && nbb.y - bb.y2 >= 0 || bb.y2 - nbb.y2 < guideSnapAt && bb.y2 - nbb.y2 >= 0;
            if (pinnedY && snapToObjects) {
                if (nbb.y - bb.y2 < guideSnapAt && nbb.y - bb.y2 >= 0) dy -= nbb.y - bb.y2;
                else dy += bb.y2 - nbb.y2;
            }
        } else {
            self.guideLines?.bottomHorizontals[id]?.remove();
            delete self.guideLines?.bottomHorizontals[id];
        }
        if (translateNode && (pinnedX || pinnedY)) self.node.translateWith({
            dx,
            dy
        });
        return {
            dx,
            dy
        };
    }
}
exports.default = gridLines;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BxQS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class links {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.node.link.click((e)=>{
            this.click();
        });
    }
    set(pkg1, sendCollab) {
        // {
        //   type: 'url|currentSlate|externalSlate',
        //   data: 'https://xxx|id_of_node'
        // }
        this.node.options.link = pkg1;
        if (sendCollab) {
            const cpkg = {
                type: "onNodeLinkAdded",
                data: pkg1
            };
            if (this.slate.collab) this.slate.collab.send(cpkg);
        }
    }
    unset(sendCollab) {
        this.node.options.link = null;
        if (sendCollab) {
            const cpkg = {
                type: "onNodeLinkRemoved",
                data: pkg
            };
            if (this.slate.collab) this.slate.collab.send(cpkg);
        }
    }
    click() {
        //`url("https://api.miniature.io/?token=ozwPwKuD6CYUiE9K&url=miniature.io?url=${_self._.options.link.data}&size=200")`
        const self = this;
        switch(this.node.options.link.type){
            case "url":
                window.open(self.node.options.link.data, "sb_external");
                break;
            case "externalSlate":
                break;
            case "currentSlate":
                {
                    const n = self.slate.nodes.one(self.node.options.link.data);
                    n.position("center", ()=>{
                    // done
                    }, "swingTo", 500);
                    break;
                }
        }
    }
}
exports.default = links;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpcw7":[function(require,module,exports) {
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _index = require("../index");
class multiSelection {
    constructor(slate){
        const self = this;
        self.slate = slate;
        self.selRect = null // used during selection
        ;
        self.ox = null;
        self.oy = null;
        self._init = null;
        self.marker = null // stays after selection
        ;
        self.selectedNodes = [];
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.origPos = null;
        self.resizer = null;
        self.minSize = 100;
        self._icons = [];
        self.iconBg = null;
        self.moveX = 0;
        self.moveY = 0;
        self.asIndiv = false;
        self.attrs = {
            create: {
                fill: "#fff",
                stroke: "#000"
            },
            mouseOut: {
                fill: "#fff",
                stroke: "#000"
            },
            mouseOver: {
                fill: "#ccc",
                cursor: "pointer"
            }
        };
    }
    init() {
        const self = this;
        if (self.slate.options.isbirdsEye) return;
        function finalize() {
            // self.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
            self.slate.options.allowDrag = true;
            self.slate.birdsEye?.refresh(true);
            self.selectedNodes.forEach((node)=>{
                (0, _utilsDefault.default).transformPath(node, `T${self.moveX},${self.moveY}`);
                node.vect.currentDx = 0;
                node.vect.currentDy = 0;
            });
            (0, _refreshRelationshipsDefault.default)({
                relationships: self.relationshipsToRefresh,
                nodes: self.selectedNodes,
                moveX: self.moveX,
                moveY: self.moveY
            });
            self.slate.nodes.saveRelationships(self.relationshipsToTranslate, {
                dx: self.moveX,
                dy: self.moveY
            });
            multiSelection.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
            self.broadcastMove();
            self.showIcons();
            self.origPos = self.marker.getBBox();
            self.marker.toBack();
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
        const c = self.slate.options.container;
        if (self.slate.options.showMultiSelect) {
            self._init = document.createElement("div");
            self._init.setAttribute("class", "slateMultiSelect");
            self._init.style.position = "absolute";
            self._init.style.height = "30px";
            self._init.style.left = "10px";
            self._init.style.color = "#081272";
            self._init.style.fontSize = "11pt";
            self._init.style.fontFamily = "trebuchet ms";
            self._init.style.top = "5px";
            self._init.style.display = "block";
            self._init.style.padding = "5px";
            self._init.style.margin = "5px;";
            self._init.style.backgroundColor = "#fff";
            self._init.style.cursor = "pointer";
            self._init.style["user-select"] = "none";
            self._init.innerHTML = "[multi-select]";
            self._init.style.zIndex = "0";
            c.appendChild(self._init);
            self.markerEvents = {
                init () {
                    self.hideIcons();
                    multiSelection.hideConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
                    self.moveX = 0;
                    self.moveY = 0;
                    self.slate.options.allowDrag = false;
                    self.marker.ox = self.marker.attr("x");
                    self.marker.oy = self.marker.attr("y");
                    self.selectedNodes.forEach((node)=>{
                        node.unmark();
                        const bb = node.vect.getBBox();
                        node.vect.ox = bb.x;
                        node.vect.oy = bb.y;
                    });
                },
                move (dx, dy) {
                    try {
                        const _zr = self.slate.options.viewPort.zoom.r;
                        dx += dx / _zr - dx;
                        dy += dy / _zr - dy;
                        self.moveX = dx;
                        self.moveY = dy;
                        const att = {
                            x: self.marker.ox + dx,
                            y: self.marker.oy + dy
                        };
                        self.marker.attr(att);
                        self.selectedNodes.forEach((node)=>{
                            node.vect.currentDx = dx;
                            node.vect.currentDy = dy;
                            node.translateWith({
                                dx,
                                dy
                            });
                        });
                        const _nx = self.origPos.x + self.origPos.width + dx - 5;
                        const _ny = self.origPos.y + self.origPos.height + dy - 5;
                        self.resizer.transform([
                            "t",
                            _nx,
                            ",",
                            _ny,
                            " r95 s1.5,1.5"
                        ].join(""));
                    } catch (err) {
                        finalize();
                    }
                },
                up (e) {
                    if (self.asIndiv) self.selectedNodes.forEach((node)=>{
                        node.mark();
                    });
                    finalize(e);
                }
            };
            self.resizeEvents = {
                init () {
                    self.hideIcons();
                    multiSelection.hideConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
                    self.moveX = 0;
                    self.moveY = 0;
                    self.slate.options.allowDrag = false;
                    self.selectedNodes.forEach((node)=>{
                        node.unmark();
                        const bb = node.vect.getBBox();
                        node.vect.ox = bb.x;
                        node.vect.oy = bb.y;
                    });
                    self.marker.toBack();
                    self.slate?.grid.toBack();
                    self.slate?.canvas.bgToBack();
                },
                move (dx, dy) {
                    const _zr = self.slate.options.viewPort.zoom.r;
                    dx += dx / _zr - dx;
                    dy += dy / _zr - dy;
                    self.moveX = dx;
                    self.moveY = dy;
                    let _width = self.origPos.width + dx * 2;
                    let _height = self.origPos.height + dy * 2;
                    const _nx = self.origPos.x + self.origPos.width + dx - 5;
                    const _ny = self.origPos.y + self.origPos.height + dy - 5;
                    let rw = true;
                    let rh = true;
                    if (_width < self.minSize) {
                        _width = self.minSize;
                        rw = false;
                    }
                    if (_height < self.minSize) {
                        _height = self.minSize;
                        rh = false;
                    }
                    self.resizer.transform([
                        "t",
                        _nx,
                        ",",
                        _ny,
                        " r95 s1.5,1.5"
                    ].join(""));
                    const att = {
                        width: _width,
                        height: _height
                    };
                    if (rw) Object.assign(att, {
                        x: self.origPos.x - dx
                    });
                    if (rh) Object.assign(att, {
                        y: self.origPos.y - dy
                    });
                    self.marker.attr(att);
                },
                up () {
                    multiSelection.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
                    self.selectedNodes.forEach((node)=>{
                        const transWidth = node.options.width + self.moveX;
                        const transHeight = node.options.height + self.moveY;
                        node.resize.set(transWidth, transHeight, {
                            isMoving: true,
                            getRotationPoint: node.options.rotate.rotationAngle
                        });
                        node.images.imageSizeCorrection();
                        if (self.asIndiv) node.mark();
                    });
                    (0, _refreshRelationshipsDefault.default)({
                        relationships: self.relationshipsToRefresh.concat(self.relationshipsToTranslate),
                        nodes: self.selectedNodes,
                        dx: 0,
                        dy: 0
                    });
                    self.broadcastMove();
                    self.origPos = self.marker.getBBox();
                    const _nx = self.origPos.x + self.origPos.width;
                    const _ny = self.origPos.y + self.origPos.height;
                    self.resizer.transform([
                        "t",
                        _nx - 5,
                        ",",
                        _ny - 5
                    ].join(""));
                    self.refreshMarker();
                    self.showIcons();
                    self.marker.toBack();
                    self.slate?.grid.toBack();
                    self.slate?.canvas.bgToBack();
                    self.slate.enable();
                }
            };
            (0, _utilsDefault.default).addEvent(self._init, "click", (e)=>{
                switch(self._init.innerHTML){
                    case "[multi-select]":
                        self.start();
                        break;
                    case "selecting [click to stop]...":
                        self.end(false);
                        self.endSelection();
                        break;
                    default:
                        break;
                }
            });
        }
    }
    hide() {
        const self = this;
        if (self._init) self._init.style.display = "none";
    }
    show() {
        const self = this;
        if (self._init) self._init.style.display = "block";
    }
    add(node) {
        const self = this;
        self.asIndiv = true;
        if (!self.selectedNodes.find((n)=>n.options.id === node.options.id)) self.selectedNodes.push(node);
        self.hideIcons();
        self.prepSelectedNodes();
    }
    clear() {
        const self = this;
        self.asIndiv = false;
        self.selectedNodes.forEach((node)=>{
            node.unmark();
        });
        self.selectedNodes = [];
        self.hideIcons();
        self.prepSelectedNodes();
    }
    remove(node) {
        const self = this;
        node.unmark();
        self.selectedNodes = self.selectedNodes.filter((n)=>n.options.id !== node.options.id);
        self.asIndiv = self.selectedNodes.length > 0;
        self.hideIcons();
        self.prepSelectedNodes();
    }
    start() {
        const self = this;
        self.slate.disable() // options.allowDrag = false;
        ;
        if (self._init) self._init.innerHTML = "selecting [click to stop]...";
        document.head.insertAdjacentHTML("beforeend", `<style id='svg-no-select-text'>.slatebox-text { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }</style>`);
        // document.head.insertAdjacentHTML("beforeend", `<style id='svg-no-select-text'>svg text { pointer-events: none; }</style>`);
        const c = self.slate.options.container;
        self.slate.onSelectionStart = (e)=>{
            if (self.slate.options.showMultiSelect) {
                self.end();
                const p = self.xy(e);
                self.selRect = self.slate.paper.rect(p.x, p.y, 10, 10).attr({
                    "stroke-dasharray": "-"
                });
                (0, _utilsDefault.default).addEvent(self.slate.canvas.get(), "mousemove", self._move.bind(self), null);
                (0, _utilsDefault.default).addEvent(self.slate.canvas.get(), "mouseup", self._mouseUp.bind(self), null, true);
                (0, _utilsDefault.default).addEvent(self.slate.canvas.get(), "mouseleave", self._select.bind(self), null, true);
                window.addEventListener("beforeunload", self._enableOnRefresh);
                self.ox = p.x;
                self.oy = p.y;
            }
        };
    }
    _enableOnRefresh() {
        const self = this;
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.selectedNodes = [];
        self.slate.enable();
        self.broadcastMove() // broadcast an "empty" move to save the enabled state of the slate
        ;
    }
    createCopiedNodes(nodeOptions, assocDetails) {
        const self = this;
        nodeOptions.forEach((n)=>{
            const nn = new (0, _index.Slatebox).node(n);
            self.slate.nodes.add(nn);
        });
        assocDetails.forEach((a)=>{
            const parentNode = self.slate.nodes.one(a.parentNodeId);
            const childNode = self.slate.nodes.one(a.childNodeId);
            const assocPkg = a.assocPkg;
            assocPkg.child = self.slate.nodes.one(a.assocPkg.childId);
            assocPkg.parent = self.slate.nodes.one(a.assocPkg.parentId);
            delete assocPkg.childId;
            delete assocPkg.parentId;
            parentNode.relationships.addAssociation(childNode, assocPkg);
        });
    }
    showIcons() {
        const self = this;
        if (self.marker !== null) {
            const groupIds = (0, _lodashUniqDefault.default)(self.selectedNodes.map((n)=>n.options.groupId));
            const isGrouped = groupIds.length === 1 && groupIds[0] !== null;
            const markerBB = self.marker.getBBox();
            const multiX = markerBB.x + markerBB.width + 45;
            // TODO: decide if you want to use a settings button here
            const showSettings = true;
            const heightSpacer = 50;
            self.iconBg?.remove();
            self.iconBg = self.slate.paper.rect(multiX - 10, markerBB.y + heightSpacer - 10, 50, heightSpacer * 4, 5).attr({
                ...self.attrs.create,
                opacity: 0.3
            }).toBack();
            const del = self.slate.paper.trash().attr({
                fill: "#fff",
                stroke: "#f00"
            }).transform([
                "t",
                multiX,
                ",",
                markerBB.y + heightSpacer * 4,
                "s",
                ",",
                "1.25",
                "1.25"
            ].join());
            del.mouseover((e)=>{
                del.attr(self.attrs.mouseOver);
                (0, _utilsDefault.default).stopEvent(e);
            });
            del.mouseout((e)=>{
                del.attr({
                    fill: "#fff",
                    stroke: "#f00"
                });
                (0, _utilsDefault.default).stopEvent(e);
            });
            del.mousedown((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                self.del();
            });
            const copy = self.slate.paper.copy().attr(self.attrs.create).transform([
                "t",
                multiX,
                ",",
                markerBB.y + heightSpacer * 2,
                "s",
                ",",
                "1.25",
                "1.25"
            ].join());
            copy.mouseover((e)=>{
                copy.attr(self.attrs.mouseOver);
                (0, _utilsDefault.default).stopEvent(e);
            });
            copy.mouseout((e)=>{
                copy.attr(self.attrs.mouseOut);
                (0, _utilsDefault.default).stopEvent(e);
            });
            copy.mousedown((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                const snap = self.slate.snapshot();
                const nGroupId = self.selectedNodes[0].options.groupId ? (0, _utilsDefault.default).guid().replace(/-/gi, "").substring(0, 8).toUpperCase() : null;
                const orient = self.slate.getOrientation(self.selectedNodes);
                const pad = 75;
                const relationalMap = {};
                const nodeOptions = [];
                const assocDetails = [];
                self.selectedNodes.forEach((node)=>{
                    const c = (0, _lodashClonedeepDefault.default)(node.options);
                    c.xPos += orient.width + pad;
                    c.groupId = nGroupId;
                    c.id = (0, _utilsDefault.default).guid().replace(/-/gi, "").substring(0, 12);
                    relationalMap[node.options.id] = c.id;
                    c.vectorPath = (0, _utilsDefault.default)._transformPath(c.vectorPath, `T${orient.width + pad},0`);
                    nodeOptions.push(c);
                    const nn = new (0, _index.Slatebox).node(c);
                    self.slate.nodes.add(nn);
                });
                // next add relationships
                const an = self.slate.nodes.allNodes;
                self.selectedNodes.forEach((node)=>{
                    const nn = an.find((n)=>n.options.id === relationalMap[node.options.id]);
                    // with nn as "parent", add all its children
                    node.relationships.associations.filter((a)=>a.parent.options.id === node.options.id).forEach((a)=>{
                        const assocPkg = (0, _lodashClonedeepDefault.default)(a);
                        delete assocPkg.line // ensure new line is created
                        ;
                        assocPkg.id = (0, _utilsDefault.default).guid().replace(/-/gi, "").substring(0, 12);
                        assocPkg.activeNode = relationalMap[assocPkg.activeNode];
                        let childNode = an.find((n)=>n.options.id === relationalMap[a.child.options.id]);
                        if (!childNode) childNode = an.find((n)=>n.options.id === a.child.options.id);
                        const sendAssocPkg = (0, _lodashOmitDefault.default)(assocPkg, [
                            "child",
                            "parent"
                        ]);
                        sendAssocPkg.childId = assocPkg.child.options.id;
                        sendAssocPkg.parentId = assocPkg.parent.options.id;
                        assocDetails.push({
                            parentNodeId: nn.options.id,
                            childNodeId: childNode.options.id,
                            assocPkg: sendAssocPkg
                        });
                        nn.relationships.addAssociation(childNode, assocPkg);
                    });
                });
                // send collaboration info
                const pkg = {
                    type: "onNodeAdded",
                    data: {
                        multiSelectCopy: true,
                        nodeOptions,
                        assocDetails
                    }
                };
                self.slate.collab.send(pkg);
            });
            self._icons.push(copy);
            if (!isGrouped) {
                const group = self.slate.paper.plus().attr(self.attrs.create).transform([
                    "t",
                    multiX,
                    ",",
                    markerBB.y + heightSpacer,
                    "s",
                    ",",
                    "1.25",
                    "1.25"
                ].join());
                group.mouseover((e)=>{
                    group.attr(self.attrs.mouseOver);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                group.mouseout((e)=>{
                    group.attr(self.attrs.mouseOut);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                group.mousedown((e)=>{
                    const groupId = (0, _utilsDefault.default).guid().replace(/-/gi, "").substring(0, 8).toUpperCase();
                    self.selectedNodes.forEach((n)=>{
                        n.options.groupId = groupId;
                    });
                    (0, _utilsDefault.default).stopEvent(e);
                    self.endSelection();
                    self.end();
                    self.showGroup(groupId);
                });
                self._icons.push(group);
            } else {
                const ungroup = self.slate.paper.minus().attr(self.attrs.create).transform([
                    "t",
                    multiX,
                    ",",
                    markerBB.y + heightSpacer,
                    "s",
                    ",",
                    "1.25",
                    "1.25"
                ].join());
                ungroup.mouseover((e)=>{
                    ungroup.attr(self.attrs.mouseOver);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                ungroup.mouseout((e)=>{
                    ungroup.attr(self.attrs.mouseOut);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                ungroup.mousedown((e)=>{
                    self.selectedNodes.forEach((n)=>{
                        n.options.groupId = null;
                    });
                    (0, _utilsDefault.default).stopEvent(e);
                    self.hideIcons();
                    self.showIcons();
                });
                self._icons.push(ungroup);
            }
            if (showSettings) {
                const settings = self.slate.paper.setting().attr(self.attrs.create).transform([
                    "t",
                    multiX,
                    ",",
                    markerBB.y + heightSpacer * 3,
                    "s",
                    ",",
                    "1.25",
                    "1.25"
                ].join());
                settings.mouseover((e)=>{
                    settings.attr(self.attrs.mouseOver);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                settings.mouseout((e)=>{
                    settings.attr(self.attrs.mouseOut);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                settings.mousedown((e)=>{
                    (0, _utilsDefault.default).stopEvent(e);
                    if (self.slate.events?.onMenuRequested) self.slate.events?.onMenuRequested(self.selectedNodes, ()=>{});
                });
                self._icons.push(settings);
            }
            self._icons.push(del);
        }
    }
    hideIcons() {
        const self = this;
        self.iconBg?.remove();
        self._icons?.forEach((i)=>i.remove());
    }
    isSelecting() {
        const self = this;
        return self.marker !== null;
    }
    del() {
        const self = this;
        self.slate.events.onConfirmRequested(`Confirm Deletion`, `Are you sure you want to remove these ${self.selectedNodes.length} node(s)?`, (blnConfirm)=>{
            if (blnConfirm) {
                self.selectedNodes.forEach((node)=>{
                    node.del();
                    self.slate.unglow();
                    const delPkg = {
                        type: "onNodeDeleted",
                        data: {
                            id: node.options.id
                        }
                    };
                    self.slate.collab?.send(delPkg);
                    self.slate.birdsEye?.nodeDeleted(delPkg);
                });
                self.end();
            }
        });
    }
    end(hasMarker = true) {
        const self = this;
        if (self.marker !== null || !hasMarker) {
            self.marker?.remove();
            self.resizer?.remove();
            self.marker = null;
            self.slate.enable();
            // self.slate.keyboard && self.slate.keyboard.end();
            self.hideIcons();
            self.selectedNodes.forEach((n)=>{
                n.unmark();
            });
            window.removeEventListener("beforeunload", self._enableOnRefresh);
        }
        if (self._init) self._init.innerHTML = "[multi-select]";
    }
    endSelection() {
        const self = this;
        self.selRect?.remove();
        self.showIcons();
        self.slate.options.allowDrag = true;
        self.slate.onSelectionStart = null;
        (0, _utilsDefault.default).removeEvent(self.slate.canvas.get(), "mousemove", self._move.bind(self));
    }
    xy(e) {
        const self = this;
        const mp = (0, _utilsDefault.default).mousePos(e);
        const off = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        const _x = mp.x + self.slate.options.viewPort.left - off.left;
        const _y = mp.y + self.slate.options.viewPort.top - off.top;
        const z = self.slate.options.viewPort.zoom.r;
        return {
            x: _x / z,
            y: _y / z
        };
    }
    _move(e) {
        const self = this;
        if (!self.slate.draggingNode) {
            const p = self.xy(e);
            const height = p.y - self.oy;
            const width = p.x - self.ox;
            if (height > 0) self.selRect.attr({
                height
            });
            else self.selRect.attr({
                y: p.y,
                height: self.oy - p.y
            });
            if (width > 0) self.selRect.attr({
                width
            });
            else self.selRect.attr({
                x: p.x,
                width: self.ox - p.x
            });
        }
    }
    showGroup(groupId) {
        const self = this;
        self.selectedNodes = self.slate.nodes.allNodes.filter((n)=>n.options.groupId === groupId);
        if (self.prepSelectedNodes()) {
            self.refreshMarker();
            self.showIcons();
        }
    }
    refreshMarker() {
        const self = this;
        self.marker?.remove();
        self.resizer?.remove();
        self.iconBg?.remove();
        self.selectedNodes.forEach((n)=>{
            n.unmark();
        });
        const z = self.slate.options.viewPort.zoom.r;
        const orient = self.slate.getOrientation(self.selectedNodes);
        let w = orient.width / z;
        let h = orient.height / z;
        if (w < self.minSize) w = self.minSize;
        if (h < self.minSize) h = self.minSize;
        self.marker = self.slate.paper.rect(orient.left / z, orient.top / z, w, h).attr({
            "stroke-dasharray": "-",
            fill: "#f8f8f8",
            opacity: 0.3
        });
        self.marker.toBack();
        self.slate?.grid.toBack();
        self.slate?.canvas.bgToBack();
        self.origPos = self.marker.getBBox();
        // self.resizer
        const _nx = self.origPos.x + self.origPos.width;
        const _ny = self.origPos.y + self.origPos.height;
        self.resizer = self.slate.paper.resize().transform([
            "t",
            _nx - 5,
            ",",
            _ny - 5,
            "r95 s1.5,1.5"
        ].join()).attr({
            fill: "#fff",
            stroke: "#000"
        });
        self.resizer.toFront();
        self.resizer.mouseover((e)=>{
            self.resizer.attr(self.attrs.mouseOver);
            (0, _utilsDefault.default).stopEvent(e);
        }) // self._resizeHover.bind(self));
        ;
        self.resizer.mouseout((e)=>{
            self.resizer.attr(self.attrs.mouseOut);
            (0, _utilsDefault.default).stopEvent(e);
        }) // self._resizeHover.bind(self));
        ;
        // self.resizer.unmouseover(self._resizeHover.bind(self));
        self.marker.drag(self.markerEvents.move, self.markerEvents.init, self.markerEvents.up);
        self.resizer.drag(self.resizeEvents.move, self.resizeEvents.init, self.resizeEvents.up);
        if (self.asIndiv) self.selectedNodes.forEach((n)=>{
            n.mark();
        });
    }
    prepSelectedNodes() {
        const self = this;
        // select relevant connections
        if (self.selectedNodes.length > 1) {
            const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
            self.relationshipsToTranslate = _associations.relationshipsToTranslate;
            self.relationshipsToRefresh = _associations.relationshipsToRefresh;
            self.refreshMarker();
            self.endSelection();
            // unmark all and remove connectors
            self.slate.nodes.closeAllMenus({
                nodes: self.selectedNodes
            });
        } else if (self.selectedNodes.length === 1) {
            self.selectedNodes[0].menu.show();
            self.slate.enable();
            self.endSelection();
            self.end();
            return false;
        } else {
            self.slate.enable();
            self.endSelection();
            self.end();
            return true;
        }
        return false;
    }
    _mouseUp(e) {
        const self = this;
        if (self._init) self._init.innerHTML = "[multi-select]";
        this._select(e);
    }
    _select() {
        const self = this;
        const sr = self.selRect.getBBox();
        if (sr) {
            const withinBox = self.slate.nodes.allNodes.filter((n)=>{
                const inRange = n.options.xPos + n.options.width > sr.x && n.options.xPos < sr.x + sr.width && n.options.yPos + n.options.height > sr.y && n.options.yPos < sr.y + sr.height;
                return inRange && !n.options.isLocked;
            });
            // add any groupIds
            const groupIds = (0, _lodashUniqDefault.default)(withinBox.map((n)=>n.options.groupId)).filter((g)=>!!g);
            const alreadySelectedIds = withinBox.map((n)=>n.options.id);
            self.selectedNodes = self.slate.nodes.allNodes.filter((n)=>alreadySelectedIds.includes(n.options.id) || groupIds.includes(n.options.groupId));
            self.prepSelectedNodes();
        }
    }
    static hideConnections(connections) {
        connections.forEach((c)=>{
            c.line.hide();
        });
    }
    static showConnections(connections) {
        connections.forEach((c)=>{
            c.line.show();
        });
    }
    broadcastMove() {
        const self = this;
        const pkg = {
            type: "onNodesMove",
            data: self.slate.nodes.nodeMovePackage({
                nodes: self.selectedNodes,
                relationships: self.relationshipsToTranslate.concat(self.relationshipsToRefresh)
            })
        };
        self.slate.collab?.send(pkg);
        self.slate.birdsEye?.nodeChanged(pkg);
    }
}
exports.default = multiSelection;

},{"lodash.uniq":"iDalh","lodash.clonedeep":"i3u1q","lodash.omit":"82TGT","../helpers/utils":"8QI6M","../helpers/refreshRelationships":"1UeYf","../index":"8lqZg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bRqCq":[function(require,module,exports) {
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _slate = require("../core/slate");
var _slateDefault = parcelHelpers.interopDefault(_slate);
class birdsEye {
    constructor(slate){
        this.slate = slate;
        this.be = null;
        this.corner = null;
        this.handle = null;
        this.orx = null;
        this.sp = null;
        this.options = {
            size: 200,
            onHandleMove: null
        };
        this.parentDimen = null;
        this.lastX = null;
        this.lastY = null;
        this.wpadding = null;
        this.hpadding = null;
    }
    setBe() {
        if (this.be) this.be.style.left = `${this.parentDimen.width - this.options.size}px`;
        if (this.be) this.be.style.top = "-2px";
    }
    _hideText() {
        this.corner.nodes.allNodes.forEach((node)=>{
            node.text.hide();
        });
    }
    _wireHandle() {
        const self = this;
        let start = {};
        const init = function hnd() {
            self.handle.ox = this.attr("x");
            self.handle.oy = this.attr("y");
            start = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
            self.slate.toggleFilters(true);
        };
        const move = function mv(x, y) {
            const _zr = self.corner.options.viewPort.originalWidth / self.sp;
            x += x / _zr - x;
            y += y / _zr - y;
            const _mx = self.handle.ox + x;
            const _my = self.handle.oy + y;
            self.handle.attr({
                x: _mx,
                y: _my
            });
            const bb = self.handle.getBBox();
            const _cx = bb.x * self.slate.options.viewPort.zoom.r;
            const _cy = bb.y * self.slate.options.viewPort.zoom.r;
            self.options.onHandleMove?.apply(self, [
                _cx,
                _cy
            ]);
            self.slate.canvas.move({
                x: _cx,
                y: _cy,
                dur: 0,
                isAbsolute: true
            });
            self.lastX = bb.x;
            self.lastY = bb.y;
        };
        const up = ()=>{
            self.refresh();
            const end = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
            self.slate.canvas.broadcast({
                x: start.left - end.left,
                y: start.top - end.top
            });
            self.slate.toggleFilters(false);
        };
        self.handle.drag(move, init, up);
    }
    show(_options) {
        const self = this;
        Object.assign(self.options, _options);
        const c = self.slate.options.container;
        self.parentDimen = (0, _utilsDefault.default).getDimensions(c);
        self.be = document.createElement("div");
        self.be.setAttribute("id", `slatebirdsEye_${self.slate.options.id}`);
        self.be.setAttribute("class", "slatebirdsEye");
        self.be.style.position = "absolute";
        self.be.style.height = `${self.options.size}px`;
        self.be.style.width = `${self.options.size}px`;
        self.be.style.border = "2px inset #333";
        self.be.style.backgroundColor = "#fff";
        c.appendChild(self.be);
        self.setBe();
        async function load() {
            self.corner = await new (0, _slateDefault.default)({
                container: `slatebirdsEye_${self.slate.options.id}`,
                viewPort: {
                    allowDrag: false
                },
                allowCollaboration: false,
                showZoom: false,
                showUndoRedo: false,
                showMultiSelect: false,
                showbirdsEye: false,
                showLocks: false,
                imageFolder: "",
                isbirdsEye: true
            }, {
                onNodeDragged () {
                    self.slate.nodes.copyNodePositions(self.corner.nodes.allNodes);
                }
            }).init();
            self.refresh();
            (0, _utilsDefault.default).addEvent(window, "resize", ()=>{
                const cx = self.slate.options.container;
                self.parentDimen = (0, _utilsDefault.default).getDimensions(cx);
                self.setBe();
            });
        }
        load();
    }
    enabled() {
        return this.corner !== null;
    }
    enable() {
        if (!this.corner) this.show();
        this.be.style.display = "block";
    }
    disable() {
        this.be.style.display = "none";
    }
    relationshipsChanged(pkg) {
        if (this.corner) switch(pkg.type){
            case "removeRelationship":
                this.corner.nodes.removeRelationship(pkg.data);
                break;
            case "addRelationship":
                var __pkg = JSON.parse(JSON.stringify(pkg));
                Object.assign(__pkg.data, {
                    options: {
                        lineWidth: 1
                    }
                });
                // data: { id: this.slate.options.id, relationships: rels} };
                this.corner.nodes.addRelationship(__pkg.data);
                break;
            default:
                break;
        }
    }
    nodeChanged(pkg) {
        if (this.corner) {
            if (pkg.type === "onNodesMove") this.corner.nodes.moveNodes(pkg, {
                useMainCanvas: true
            });
            else {
                const _node = this.corner.nodes.one(pkg.data.id);
                if (_node) {
                    const useMainCanvas = true;
                    switch(pkg.type){
                        case "onNodeShapeChanged":
                            _node.shapes.set(pkg.data);
                            break;
                        case "onNodeTextChanged":
                            _node.editor.set(pkg.data.text, pkg.data.fontSize, pkg.data.fontFamily, pkg.data.fontColor, pkg.data.textXAlign, pkg.data.textYAlign);
                            break;
                        case "onNodeColorChanged":
                            _node.colorPicker.set(pkg.data);
                            break;
                        case "onNodeImageChanged":
                            _node.images.set(pkg.data.img, pkg.data.w, pkg.data.h, useMainCanvas);
                            this.refresh();
                            break;
                        case "onNodeResized":
                            Object.assign(_node.options, pkg.data);
                            _node.vect.attr({
                                path: pkg.data.vectorPath
                            });
                            if (_node.vect.pattern) _node.images.imageSizeCorrection();
                            this.refresh();
                            break;
                        case "onNodeRotated":
                            {
                                pkg.data.associations.forEach((association)=>{
                                    const currentAssociation = _node.relationships.associations.find((ass)=>ass.child.options.id === association.childId && ass.parent.options.id === association.parentId);
                                    if (currentAssociation) currentAssociation.line.attr({
                                        path: association.linePath
                                    });
                                });
                                Object.assign(_node.options, (0, _lodashOmitDefault.default)(pkg.data, "associations"));
                                const tempPath = this.slate.paper.path(_node.vect.attr("path"));
                                tempPath.remove();
                                _node.rotate.applyImageRotation();
                                this.refresh();
                                break;
                            }
                        case "onNodeToFront":
                            _node.vect.toFront();
                            break;
                        case "onNodeToBack":
                            _node.vect.toBack();
                            break;
                        case "onNodeLocked":
                            _node.options.allowDrag = false;
                            break;
                        case "onNodeUnlocked":
                            _node.options.allowDrag = true;
                            break;
                        case "changeLineColor":
                            _node.lineOptions.set(pkg.data);
                            break;
                        default:
                            break;
                    }
                }
            }
        }
    }
    nodeDeleted(pkg) {
        if (this.corner) {
            const _node = this.corner.nodes.one(pkg.data.id);
            _node?.del();
        }
    }
    nodeDetatched(pkg) {
        if (this.corner) {
            const _node = this.corner.nodes.one(pkg.data.id);
            _node?.relationships.detatch();
        }
    }
    reload(json) {
        this.handle?.remove();
        this.corner.loadJSON(json);
        this.refresh(true);
    }
    refresh(blnNoAdditions) {
        if (this.corner) {
            const c = this.slate.options.container;
            this.parentDimen = (0, _utilsDefault.default).getDimensions(c);
            this.handle?.remove();
            if (blnNoAdditions === true) {
                this.corner.canvas.move({
                    x: this.slate.options.viewPort.left,
                    y: this.slate.options.viewPort.top,
                    dur: 0,
                    isAbsolute: true
                });
                const useMainCanvas = true;
                this.corner.nodes.copyNodePositions(this.slate.nodes.allNodes, useMainCanvas);
            } else {
                const _export = this.slate.exportDifference(this.corner, 1) // line width override
                ;
                this.corner.loadJSON(_export, true, true, true, true);
            }
            this.orx = this.slate.getOrientation();
            if (this.slate.options.viewPort.left < this.orx.left) this.wpadding = this.slate.options.viewPort.left - this.orx.left;
            else this.wpadding = this.slate.options.viewPort.left - this.orx.left + (this.parentDimen.width - this.orx.width);
            this.hpadding = this.slate.options.viewPort.top - this.orx.top;
            const _pw = Math.max(Math.abs(this.wpadding), this.orx.width < this.parentDimen.width ? this.parentDimen.width - this.orx.width : 0);
            const _ph = Math.max(Math.abs(this.hpadding), this.orx.height < this.parentDimen.height ? this.parentDimen.height - this.orx.height : 0);
            const wp = (this.orx.width + _pw) / this.options.size * this.slate.options.viewPort.width;
            const hp = (this.orx.height + _ph) / this.options.size * this.slate.options.viewPort.height;
            this.sp = Math.max(wp, hp);
            const _r = Math.max(this.slate.options.viewPort.width, this.slate.options.viewPort.height) / this.sp;
            const l = (this.orx.left + (this.wpadding < 0 ? this.wpadding : 0)) * _r - 5;
            const t = (this.orx.top + (this.hpadding < 0 ? this.hpadding : 0)) * _r - 5;
            this.corner.zoom(0, 0, this.sp, this.sp, true);
            this.corner.options.viewPort.zoom.r = this.corner.options.viewPort.originalWidth / this.sp;
            // this.corner.zoom();
            this.corner.canvas.move({
                x: l,
                y: t,
                dur: 0,
                isAbsolute: true
            });
            this.corner.disable();
            const _ix = this.slate.options.viewPort.left / this.slate.options.viewPort.zoom.r;
            const _iy = this.slate.options.viewPort.top / this.slate.options.viewPort.zoom.r;
            const _w = this.parentDimen.width / this.slate.options.viewPort.zoom.r;
            const _h = this.parentDimen.height / this.slate.options.viewPort.zoom.r;
            this.handle = this.corner.paper.rect(_ix, _iy, _w, _h).attr({
                stroke: "#000",
                "stroke-width": 2,
                fill: "#FFEB3A",
                "fill-opacity": ".5"
            });
            this._hideText();
            this._wireHandle();
        }
    }
}
exports.default = birdsEye;

},{"lodash.omit":"82TGT","../helpers/utils":"8QI6M","../core/slate":"khicH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9OwD":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wheelGestures = require("wheel-gestures");
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class inertia {
    constructor(slate){
        this.slate = slate;
        this.scale = 1;
        this.wheelEnd = null;
        this.xyOffset = null;
        if (slate.options.viewPort.useInertiaScrolling) this._init();
    }
    setScale(val) {
        this.scale = val;
    }
    _init() {
        const self = this;
        const wheelGestures = (0, _wheelGestures.WheelGestures)({
            momentum: true
        });
        // find and observe the element the user can interact with
        wheelGestures.observe(self.slate.canvas.internal);
        // function scale() {
        //   window.requestAnimationFrame(() => {
        //     const style = { transform: `scale(${self.scale})` } //, "transform-origin": `${self.slate.options.viewPort.left}px ${self.slate.options.viewPort.top}px` };
        //     console.log("ws is now", self.xyOffset);
        //     self.slate.canvas.internal.style["transform-origin"] = `${self.slate.options.viewPort.left + self.xyOffset.x}px ${self.slate.options.viewPort.top + self.xyOffset.y}px`;
        //     self.slate.canvas.internal.style.transform = `scale(${self.slate.options.viewPort.zoom.r})`; // = style;
        //   })
        // }
        // add your event callback
        let start = {};
        wheelGestures.on("wheel", (e)=>{
            if (self.slate.options.allowDrag) {
                if (e.event.ctrlKey) ;
                else {
                    const deltaX = e.event.deltaX * 0.8 // .5 is the modifier to slow self down a bit
                    ;
                    const deltaY = e.event.deltaY * 0.8;
                    if (e.isStart) {
                        start = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
                        // hide filters during dragging
                        self.slate.toggleFilters(true);
                    }
                    self.slate.canvas.move({
                        x: deltaX,
                        y: deltaY,
                        dur: 0,
                        isAbsolute: false
                    });
                    if (e.isEnding) {
                        const end = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
                        self.slate.birdsEye?.refresh(true);
                        self.slate.canvas.broadcast({
                            x: start.left - end.left,
                            y: start.top - end.top
                        });
                        // show filters after dragging
                        self.slate.toggleFilters(false);
                    }
                }
            }
        });
    }
}
exports.default = inertia;

},{"wheel-gestures":"9N55x","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9N55x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WheelGestures", ()=>WheelGestures);
parcelHelpers.export(exports, "absMax", ()=>absMax);
parcelHelpers.export(exports, "addVectors", ()=>addVectors);
parcelHelpers.export(exports, "average", ()=>average);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "configDefaults", ()=>configDefaults);
parcelHelpers.export(exports, "deepFreeze", ()=>deepFreeze);
parcelHelpers.export(exports, "lastOf", ()=>lastOf);
parcelHelpers.export(exports, "projection", ()=>projection);
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var DECAY = 0.996;
/**
 * movement projection based on velocity
 * @param velocityPxMs
 * @param decay
 */ var projection = function projection(velocityPxMs, decay) {
    if (decay === void 0) decay = DECAY;
    return velocityPxMs * decay / (1 - decay);
};
function lastOf(array) {
    return array[array.length - 1];
}
function average(numbers) {
    return numbers.reduce(function(a, b) {
        return a + b;
    }) / numbers.length;
}
var clamp = function clamp(value, min, max) {
    return Math.min(Math.max(min, value), max);
};
function addVectors(v1, v2) {
    if (v1.length !== v2.length) throw new Error("vectors must be same length");
    return v1.map(function(val, i) {
        return val + v2[i];
    });
}
function absMax(numbers) {
    return Math.max.apply(Math, numbers.map(Math.abs));
} // eslint-disable-next-line @typescript-eslint/ban-types
function deepFreeze(o) {
    Object.freeze(o);
    Object.values(o).forEach(function(value) {
        if (value !== null && typeof value === "object" && !Object.isFrozen(value)) deepFreeze(value);
    });
    return o;
}
function EventBus() {
    var listeners = {};
    function on(type, listener) {
        listeners[type] = (listeners[type] || []).concat(listener);
        return function() {
            return off(type, listener);
        };
    }
    function off(type, listener) {
        listeners[type] = (listeners[type] || []).filter(function(l) {
            return l !== listener;
        });
    }
    function dispatch(type, data) {
        if (!(type in listeners)) return;
        listeners[type].forEach(function(l) {
            return l(data);
        });
    }
    return deepFreeze({
        on: on,
        off: off,
        dispatch: dispatch
    });
}
function WheelTargetObserver(eventListener) {
    var targets = []; // add event listener to target element
    var observe = function observe(target) {
        target.addEventListener("wheel", eventListener, {
            passive: false
        });
        targets.push(target);
        return function() {
            return unobserve(target);
        };
    }; /// remove event listener from target element
    var unobserve = function unobserve(target) {
        target.removeEventListener("wheel", eventListener);
        targets = targets.filter(function(t) {
            return t !== target;
        });
    }; // stops watching all of its target elements for visibility changes.
    var disconnect = function disconnect() {
        targets.forEach(unobserve);
    };
    return deepFreeze({
        observe: observe,
        unobserve: unobserve,
        disconnect: disconnect
    });
}
var LINE_HEIGHT = 18;
var PAGE_HEIGHT = typeof window !== "undefined" && window.innerHeight || 800;
var DELTA_MODE_UNIT = [
    1,
    LINE_HEIGHT,
    PAGE_HEIGHT
];
function normalizeWheel(e) {
    var deltaX = e.deltaX * DELTA_MODE_UNIT[e.deltaMode];
    var deltaY = e.deltaY * DELTA_MODE_UNIT[e.deltaMode];
    var deltaZ = (e.deltaZ || 0) * DELTA_MODE_UNIT[e.deltaMode];
    return {
        timeStamp: e.timeStamp,
        axisDelta: [
            deltaX,
            deltaY,
            deltaZ
        ]
    };
}
var reverseAll = [
    -1,
    -1,
    -1
];
function reverseAxisDeltaSign(wheel, reverseSign) {
    if (!reverseSign) return wheel;
    var multipliers = reverseSign === true ? reverseAll : reverseSign.map(function(shouldReverse) {
        return shouldReverse ? -1 : 1;
    });
    return _extends({}, wheel, {
        axisDelta: wheel.axisDelta.map(function(delta, i) {
            return delta * multipliers[i];
        })
    });
}
var DELTA_MAX_ABS = 700;
var clampAxisDelta = function clampAxisDelta(wheel) {
    return _extends({}, wheel, {
        axisDelta: wheel.axisDelta.map(function(delta) {
            return clamp(delta, -DELTA_MAX_ABS, DELTA_MAX_ABS);
        })
    });
};
var __DEV__ = true;
var ACC_FACTOR_MIN = 0.6;
var ACC_FACTOR_MAX = 0.96;
var WHEELEVENTS_TO_MERGE = 2;
var WHEELEVENTS_TO_ANALAZE = 5;
var configDefaults = /*#__PURE__*/ deepFreeze({
    preventWheelAction: true,
    reverseSign: [
        true,
        true,
        false
    ]
});
var WILL_END_TIMEOUT_DEFAULT = 400;
function createWheelGesturesState() {
    return {
        isStarted: false,
        isStartPublished: false,
        isMomentum: false,
        startTime: 0,
        lastAbsDelta: Infinity,
        axisMovement: [
            0,
            0,
            0
        ],
        axisVelocity: [
            0,
            0,
            0
        ],
        accelerationFactors: [],
        scrollPoints: [],
        scrollPointsToMerge: [],
        willEndTimeout: WILL_END_TIMEOUT_DEFAULT
    };
}
function WheelGestures(optionsParam) {
    if (optionsParam === void 0) optionsParam = {};
    var _EventBus = EventBus(), on = _EventBus.on, off = _EventBus.off, dispatch = _EventBus.dispatch;
    var config = configDefaults;
    var state = createWheelGesturesState();
    var currentEvent;
    var negativeZeroFingerUpSpecialEvent = false;
    var prevWheelEventState;
    var feedWheel = function feedWheel(wheelEvents) {
        if (Array.isArray(wheelEvents)) wheelEvents.forEach(function(wheelEvent) {
            return processWheelEventData(wheelEvent);
        });
        else processWheelEventData(wheelEvents);
    };
    var updateOptions = function updateOptions(newOptions) {
        if (newOptions === void 0) newOptions = {};
        if (Object.values(newOptions).some(function(option) {
            return option === undefined || option === null;
        })) {
            __DEV__ && console.error("updateOptions ignored! undefined & null options not allowed");
            return config;
        }
        return config = deepFreeze(_extends({}, configDefaults, config, newOptions));
    };
    var publishWheel = function publishWheel(additionalData) {
        var wheelEventState = _extends({
            event: currentEvent,
            isStart: false,
            isEnding: false,
            isMomentumCancel: false,
            isMomentum: state.isMomentum,
            axisDelta: [
                0,
                0,
                0
            ],
            axisVelocity: state.axisVelocity,
            axisMovement: state.axisMovement,
            get axisMovementProjection () {
                return addVectors(wheelEventState.axisMovement, wheelEventState.axisVelocity.map(function(velocity) {
                    return projection(velocity);
                }));
            }
        }, additionalData);
        dispatch("wheel", _extends({}, wheelEventState, {
            previous: prevWheelEventState
        })); // keep reference without previous, otherwise we would create a long chain
        prevWheelEventState = wheelEventState;
    }; // should prevent when there is mainly movement on the desired axis
    var shouldPreventDefault = function shouldPreventDefault(deltaMaxAbs, axisDelta) {
        var _config = config, preventWheelAction = _config.preventWheelAction;
        var deltaX = axisDelta[0], deltaY = axisDelta[1], deltaZ = axisDelta[2];
        if (typeof preventWheelAction === "boolean") return preventWheelAction;
        switch(preventWheelAction){
            case "x":
                return Math.abs(deltaX) >= deltaMaxAbs;
            case "y":
                return Math.abs(deltaY) >= deltaMaxAbs;
            case "z":
                return Math.abs(deltaZ) >= deltaMaxAbs;
            default:
                __DEV__ && console.warn("unsupported preventWheelAction value: " + preventWheelAction, "warn");
                return false;
        }
    };
    var processWheelEventData = function processWheelEventData(wheelEvent) {
        var _clampAxisDelta = clampAxisDelta(reverseAxisDeltaSign(normalizeWheel(wheelEvent), config.reverseSign)), axisDelta = _clampAxisDelta.axisDelta, timeStamp = _clampAxisDelta.timeStamp;
        var deltaMaxAbs = absMax(axisDelta);
        if (wheelEvent.preventDefault && shouldPreventDefault(deltaMaxAbs, axisDelta)) wheelEvent.preventDefault();
        if (!state.isStarted) start();
        else if (state.isMomentum && deltaMaxAbs > Math.max(2, state.lastAbsDelta * 2)) {
            end(true);
            start();
        } // special finger up event on windows + blink
        if (deltaMaxAbs === 0 && Object.is && Object.is(wheelEvent.deltaX, -0)) {
            negativeZeroFingerUpSpecialEvent = true; // return -> zero delta event should not influence velocity
            return;
        }
        currentEvent = wheelEvent;
        state.axisMovement = addVectors(state.axisMovement, axisDelta);
        state.lastAbsDelta = deltaMaxAbs;
        state.scrollPointsToMerge.push({
            axisDelta: axisDelta,
            timeStamp: timeStamp
        });
        mergeScrollPointsCalcVelocity(); // only wheel event (move) and not start/end get the delta values
        publishWheel({
            axisDelta: axisDelta,
            isStart: !state.isStartPublished
        }); // state.isMomentum ? MOMENTUM_WHEEL : WHEEL, { axisDelta })
        // publish start after velocity etc. have been updated
        state.isStartPublished = true; // calc debounced end function, to recognize end of wheel event stream
        willEnd();
    };
    var mergeScrollPointsCalcVelocity = function mergeScrollPointsCalcVelocity() {
        if (state.scrollPointsToMerge.length === WHEELEVENTS_TO_MERGE) {
            state.scrollPoints.unshift({
                axisDeltaSum: state.scrollPointsToMerge.map(function(b) {
                    return b.axisDelta;
                }).reduce(addVectors),
                timeStamp: average(state.scrollPointsToMerge.map(function(b) {
                    return b.timeStamp;
                }))
            }); // only update velocity after a merged scrollpoint was generated
            updateVelocity(); // reset toMerge array
            state.scrollPointsToMerge.length = 0; // after calculation of velocity only keep the most recent merged scrollPoint
            state.scrollPoints.length = 1;
            if (!state.isMomentum) detectMomentum();
        } else if (!state.isStartPublished) updateStartVelocity();
    };
    var updateStartVelocity = function updateStartVelocity() {
        state.axisVelocity = lastOf(state.scrollPointsToMerge).axisDelta.map(function(d) {
            return d / state.willEndTimeout;
        });
    };
    var updateVelocity = function updateVelocity() {
        // need to have two recent points to calc velocity
        var _state$scrollPoints = state.scrollPoints, latestScrollPoint = _state$scrollPoints[0], prevScrollPoint = _state$scrollPoints[1];
        if (!prevScrollPoint || !latestScrollPoint) return;
         // time delta
        var deltaTime = latestScrollPoint.timeStamp - prevScrollPoint.timeStamp;
        if (deltaTime <= 0) {
            __DEV__ && console.warn("invalid deltaTime");
            return;
        } // calc the velocity per axes
        var velocity = latestScrollPoint.axisDeltaSum.map(function(d) {
            return d / deltaTime;
        }); // calc the acceleration factor per axis
        var accelerationFactor = velocity.map(function(v, i) {
            return v / (state.axisVelocity[i] || 1);
        });
        state.axisVelocity = velocity;
        state.accelerationFactors.push(accelerationFactor);
        updateWillEndTimeout(deltaTime);
    };
    var updateWillEndTimeout = function updateWillEndTimeout(deltaTime) {
        // use current time between events rounded up and increased by a bit as timeout
        var newTimeout = Math.ceil(deltaTime / 10) * 12; // double the timeout, when momentum was not detected yet
        if (!state.isMomentum) newTimeout = Math.max(100, newTimeout * 2);
        state.willEndTimeout = Math.min(1000, Math.round(newTimeout));
    };
    var accelerationFactorInMomentumRange = function accelerationFactorInMomentumRange(accFactor) {
        // when main axis is the the other one and there is no movement/change on the current one
        if (accFactor === 0) return true;
        return accFactor <= ACC_FACTOR_MAX && accFactor >= ACC_FACTOR_MIN;
    };
    var detectMomentum = function detectMomentum() {
        if (state.accelerationFactors.length >= WHEELEVENTS_TO_ANALAZE) {
            if (negativeZeroFingerUpSpecialEvent) {
                negativeZeroFingerUpSpecialEvent = false;
                if (absMax(state.axisVelocity) >= 0.2) {
                    recognizedMomentum();
                    return;
                }
            }
            var recentAccelerationFactors = state.accelerationFactors.slice(WHEELEVENTS_TO_ANALAZE * -1); // check recent acceleration / deceleration factors
            // all recent need to match, if any did not match
            var detectedMomentum = recentAccelerationFactors.every(function(accFac) {
                // when both axis decelerate exactly in the same rate it is very likely caused by momentum
                var sameAccFac = !!accFac.reduce(function(f1, f2) {
                    return f1 && f1 < 1 && f1 === f2 ? 1 : 0;
                }); // check if acceleration factor is within momentum range
                var bothAreInRangeOrZero = accFac.filter(accelerationFactorInMomentumRange).length === accFac.length; // one the requirements must be fulfilled
                return sameAccFac || bothAreInRangeOrZero;
            });
            if (detectedMomentum) recognizedMomentum();
             // only keep the most recent events
            state.accelerationFactors = recentAccelerationFactors;
        }
    };
    var recognizedMomentum = function recognizedMomentum() {
        state.isMomentum = true;
    };
    var start = function start() {
        state = createWheelGesturesState();
        state.isStarted = true;
        state.startTime = Date.now();
        prevWheelEventState = undefined;
        negativeZeroFingerUpSpecialEvent = false;
    };
    var willEnd = function() {
        var willEndId;
        return function() {
            clearTimeout(willEndId);
            willEndId = setTimeout(end, state.willEndTimeout);
        };
    }();
    var end = function end(isMomentumCancel) {
        if (isMomentumCancel === void 0) isMomentumCancel = false;
        if (!state.isStarted) return;
        if (state.isMomentum && isMomentumCancel) publishWheel({
            isEnding: true,
            isMomentumCancel: true
        });
        else publishWheel({
            isEnding: true
        });
        state.isMomentum = false;
        state.isStarted = false;
    };
    var _WheelTargetObserver = WheelTargetObserver(feedWheel), observe = _WheelTargetObserver.observe, unobserve = _WheelTargetObserver.unobserve, disconnect = _WheelTargetObserver.disconnect;
    updateOptions(optionsParam);
    return deepFreeze({
        on: on,
        off: off,
        observe: observe,
        unobserve: unobserve,
        disconnect: disconnect,
        feedWheel: feedWheel,
        updateOptions: updateOptions
    });
}
exports.default = WheelGestures;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2xnBR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class controller {
    constructor(slate){
        this.slate = slate;
    }
    static perform(pkg, node, op, cb) {
        const det = op.split("@");
        let dur = pkg.defaultDuration || 300;
        const param = det[1];
        switch(det[0]){
            case "zoom":
                dur = det.length > 2 ? parseFloat(det[2], 10) : pkg.defaultDuration;
                node.zoom(param, dur, cb);
                break;
            case "position":
                {
                    const ease = det.length > 2 ? det[2] : pkg.defaultEasing;
                    dur = det.length > 3 ? parseFloat(det[3], 10) : pkg.defaultDuration;
                    node.position(param, cb, ease, dur);
                    break;
                }
            default:
                break;
        }
    }
    scaleToFitNodes(_opts) {
        const opts = {
            nodes: null,
            dur: 0,
            cb: null
        };
        Object.assign(opts, _opts);
        const orient = this.slate.getOrientation(opts.nodes);
        const d = (0, _utilsDefault.default).getDimensions(this.slate.options.container);
        const r = this.slate.options.viewPort.zoom.r || 1;
        const widthZoomPercent = parseInt(d.width / (orient.width / r) * 100, 10) // division by r converts it back from the scaled version
        ;
        const heightZoomPercent = parseInt(d.height / (orient.height / r) * 100, 10);
        // zoom canvas
        this.slate.canvas.zoom({
            dur: opts.dur,
            callbacks: {
                after () {
                    if (opts.cb) opts.cb();
                }
            },
            easing: "easeFromTo",
            zoomPercent: Math.min(widthZoomPercent, heightZoomPercent)
        });
    }
    // useful for centering the canvas on a collection of nodes
    centerOnNodes(_opts) {
        const self = this;
        const opts = {
            nodes: null,
            dur: 500,
            cb: null
        };
        Object.assign(opts, _opts);
        const orient = self.slate.getOrientation(opts.nodes);
        const d = (0, _utilsDefault.default).getDimensions(self.slate.options.container);
        const cw = d.width;
        const ch = d.height;
        const nw = orient.width;
        const nh = orient.height;
        // get upper left coords
        const x = orient.left - (cw / 2 - nw / 2);
        const y = orient.top - (ch / 2 - nh / 2);
        self.slate.canvas.move({
            x,
            y,
            isAbsolute: true,
            dur: opts.dur,
            easing: "swingFromTo",
            callbacks: {
                after () {
                    setTimeout(()=>{
                        self.slate.birdseye?.refresh(true);
                    }, 100);
                    if (opts.cb) opts.cb();
                }
            }
        });
    }
    // useful for centering the canvas by comparing the viewport's previous width/height to its current width/height
    center(_opts) {
        const self = this;
        const opts = {
            previousWindowSize: {},
            dur: 500,
            cb: null
        };
        Object.assign(opts, _opts);
        const ws = (0, _utilsDefault.default).windowSize();
        this.slate.canvas.move({
            x: (ws.width - opts.previousWindowSize.w) / 2 * -1,
            y: (ws.height - opts.previousWindowSize.h) / 2 * -1,
            duration: opts.dur,
            isAbsolute: false,
            easing: "swingFromTo",
            callbacks: {
                after: ()=>{
                    self.slate.birdseye?.refresh(true);
                    if (opts.cb) opts.cb();
                }
            }
        });
        return ws;
    }
    // experimental
    bop(opts) {
        const dur = opts && opts.dur && opts.dur !== 0 ? opts.dur : 300;
        const locale = "center";
        const ease = "easeTo";
        const presentNodes = _.map(this.slate.nodes.allNodes, (a)=>({
                name: a.options.name,
                operations: [
                    `position@${locale}@${ease}@${dur}`
                ]
            }));
        this.slate.controller.present({
            nodes: presentNodes,
            // eslint-disable-next-line no-unused-vars
            nodeChanged: (node)=>{},
            // eslint-disable-next-line no-unused-vars
            opChanged: (op)=>{},
            complete: ()=>{},
            sync: {
                zoom: true,
                position: true
            }
        });
    }
    // expiremental
    shakeNodes() {
        const self = this;
        let s = 0;
        function move() {
            s += 1;
            const mPkg = {
                dur: 500,
                moves: [
                    {
                        id: "*",
                        x: s % 2 === 0 ? 20 : -20,
                        y: s % 2 === 0 ? -20 : -20
                    }
                ]
            };
            const pkg = self.slate.nodes.nodeMovePackage(mPkg);
            self.slate.nodes.moveNodes(pkg, {
                animate: true,
                cb: ()=>{
                    setTimeout(()=>{
                        move();
                    }, 4000);
                }
            });
        }
        move();
    }
    pulse(opts) {
        let cycles = 0;
        let dur = 10000 // slow
        ;
        let czp;
        let zp;
        function calc() {
            czp = this.slate.options.viewPort.zoom.r * 100;
            zp = {
                in: czp + 5,
                out: czp - 5
            } // nuance;
            ;
            if (opts) {
                switch(opts.speed){
                    case "fast":
                        dur = 3000;
                        break;
                    default:
                        break;
                }
                switch(opts.subtlety){
                    case "trump":
                        zp = {
                            in: czp + 60,
                            out: czp - 60
                        };
                        break;
                    default:
                        break;
                }
            }
        }
        function run(zpp, cb) {
            this.slate.canvas.zoom({
                dur,
                callbacks: {
                    after () {
                        if (cb) cb();
                    }
                },
                easing: "easeFromTo",
                zoomPercent: zpp
            });
        }
        function cycle() {
            run(zp.in, ()=>{
                run(zp.out, ()=>{
                    cycles += 1;
                    if (opts && opts.cycle && cycles >= opts.cycle) {
                        if (opts.cb) opts.cb();
                    } else cycle();
                });
            });
        }
        if (opts && opts.center) this.scaleToFitAndCenter(()=>{
            calc();
            cycle();
        });
        else {
            calc();
            cycle();
        }
    }
    scaleToFitAndCenter(cb, dur) {
        this.slate.controller.scaleToFitNodes({
            dur: dur != null ? dur : 0,
            cb: ()=>{
                this.centerOnNodes({
                    dur: 0
                });
                if (cb) cb();
            }
        });
    }
    present(pkg) {
        const self = this;
        let currentOperations = [];
        let n = null;
        function next() {
            if (currentOperations.length === 0) {
                if (pkg.nodes.length > 0) {
                    const node = pkg.nodes.shift();
                    n = this.slate.nodes.allNodes.find((nx)=>nx.options.name === node.name);
                    currentOperations = node.operations;
                    if (pkg.nodeChanged) pkg.nodeChanged(node);
                }
            }
            if (currentOperations.length > 0) {
                const op = currentOperations.shift();
                if (pkg.opChanged) pkg.opChanged(op);
                controller.perform(pkg, n, op, (p)=>{
                    const sync = pkg.sync !== undefined ? pkg.sync[p.operation] : false;
                    switch(p.operation){
                        case "zoom":
                            if (sync) this.slate.collab?.send({
                                type: "onZoom",
                                data: {
                                    id: p.id,
                                    zoomLevel: p.zoomLevel
                                }
                            });
                            break;
                        case "position":
                            if (sync) this.slate.collab?.send({
                                type: "onNodePositioned",
                                data: {
                                    id: p.id,
                                    location: p.location,
                                    easing: p.easing
                                }
                            });
                            break;
                        default:
                            break;
                    }
                    next();
                });
            } else if (pkg.complete) pkg.complete();
        }
        next();
    }
}
exports.default = controller;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6TbYF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class zoomSlider {
    constructor(slate){
        const self = this;
        self.slate = slate;
        self.slider = null;
        self.sliderId = `sb-zoom-slider-${(0, _utilsDefault.default).guid().substring(8)}`;
    }
    setValue(val) {
        if (this.slider) this.slider.setValue(val);
    }
    hide() {
    // this.slider.style.display = 'none'
    }
    show(_options) {
        const self = this;
        // console.log(
        //   'showing zoom',
        //   self.slate.isReadOnly(),
        //   self.slate.isCommentOnly()
        // )
        if (!self.slate.isReadOnly() && !self.slate.isCommentOnly()) {
            self.hide();
            const options = {
                height: 320,
                width: 28,
                offset: {
                    left: 39,
                    top: 85
                },
                slider: {
                    height: 300,
                    min: 6000,
                    max: 200000,
                    set: 5000
                }
            };
            Object.assign(options, _options);
            const c = self.slate.options.container;
            const scx = document.createElement("div");
            scx.setAttribute("id", `slateSlider_${self.slate.options.id}`);
            scx.style.position = "absolute";
            scx.style.height = `${options.height}px`;
            scx.style.width = `${options.width}px`;
            scx.style.left = `${options.offset.left}px`;
            scx.style.top = `${options.offset.top}px`;
            scx.style.borderRadius = "7px";
            scx.style.border = "1px solid #ccc";
            scx.style.backgroundColor = "#fff";
            c.appendChild(scx);
            self.slider = document.createElement("input");
            self.slider.setAttribute("orient", "vertical");
            self.slider.setAttribute("type", "range");
            self.slider.setAttribute("min", "6000");
            self.slider.setAttribute("step", "50");
            self.slider.setAttribute("max", "200000");
            self.slider.setAttribute("value", self.slate.options.viewPort.zoom.w || 50000);
            self.slider.setAttribute("id", self.sliderId);
            self.slider.style["writing-mode"] = "bt-lr";
            self.slider.style["-webkit-appearance"] = "slider-vertical";
            self.slider.style.width = `20px`;
            self.slider.style.height = `${options.height - 5}px`;
            self.slider.style.padding = `0 5px`;
            self.slider.style.transform = `rotate(180deg)`;
            self.slider.addEventListener("input", (e)=>{
                const val = parseFloat(e.target.value);
                self.set(val);
                self.slate.birdsEye?.refresh(true);
            });
            self.slider.addEventListener("change", (e)=>{
                const val = parseFloat(e.target.value);
                self.set(val);
                self.slate.collab?.send({
                    type: "onZoom",
                    data: {
                        zoomLevel: val
                    }
                });
            });
            scx.appendChild(self.slider);
        }
    }
    set(val) {
        const self = this;
        if (self.slider) self.slider.value = val;
        if (self.slate.canvas.resize(val) || !self.slate.canvas.completeInit) {
            self.slate.zoom(0, 0, val, val, false);
            const z = self.slate.options.viewPort.zoom;
            self.slate.options.viewPort.width = z.w;
            self.slate.options.viewPort.height = z.h;
            self.slate.options.viewPort.left = z.l;
            self.slate.options.viewPort.top = z.t;
        }
    }
}
exports.default = zoomSlider;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"78ZfO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class undoRedo {
    constructor(slate){
        this.slate = slate;
        this.stateSlate = null;
        this.actions = [];
        this.actionIndex = -1;
        this.toolbar = [];
    }
    setVisibility() {
        const self1 = this;
        if (self1.toolbar.length) {
            self1.toolbar[0].data({
                disabled: false
            });
            self1.toolbar[1].data({
                disabled: false
            });
            if (!this.actions[this.actionIndex - 1]) {
                self1.toolbar[0].attr({
                    "fill-opacity": "0.3"
                });
                self1.toolbar[0].data({
                    disabled: true
                });
            } else self1.toolbar[0].attr({
                "fill-opacity": "1.0"
            });
            if (!this.actions[this.actionIndex + 1]) {
                self1.toolbar[1].attr({
                    "fill-opacity": "0.3"
                });
                self1.toolbar[1].data({
                    disabled: true
                });
            } else self1.toolbar[1].attr({
                "fill-opacity": "1.0"
            });
        }
    }
    run() {
        const state = this.actions[this.actionIndex];
        this.slate.loadJSON(state);
        this.slate.birdsEye?.reload(state);
        const pkg = {
            type: "onSaveRequested"
        };
        if (self.slate.events?.onSlateChanged) self.slate.events.onSlateChanged.apply(self, [
            {
                type: "custom",
                slate: this.slate,
                pkg
            }
        ]);
    // this.slate.collaboration?.onCollaboration({
    //   type: 'custom',
    //   slate: this.slate,
    //   pkg,
    // })
    }
    undo() {
        if (this.actions[this.actionIndex - 1]) {
            this.actionIndex -= 1;
            this.setVisibility();
            this.run();
        } else this.setVisibility();
    }
    redo() {
        if (this.actions[this.actionIndex + 1]) {
            this.actionIndex += 1;
            this.setVisibility();
            this.run();
        } else this.setVisibility();
    }
    hide() {
        if ((0, _utilsDefault.default).el("slateUndoRedo") !== null) try {
            this.slate.options.container.removeChild((0, _utilsDefault.default).el("slateUndoRedo"));
        } catch (err) {}
    }
    show(_options) {
        const self1 = this;
        self1.hide();
        const options = {
            height: 80,
            width: 130,
            offset: {
                left: 10,
                top: 8
            }
        };
        Object.assign(options, _options);
        const c = self1.slate.options.container;
        const scx = document.createElement("div");
        scx.setAttribute("id", "slateUndoRedo");
        scx.style.position = "absolute";
        scx.style.height = `${options.height}px`;
        scx.style.width = `${options.width}px`;
        scx.style.left = `${options.offset.left}px`;
        scx.style.top = `${options.offset.top}px`;
        c.appendChild(scx);
        const x = options.offset.left;
        const y = options.offset.top + 30;
        options.paper = (0, _raphaelSvg.Raphael)("slateUndoRedo", options.width, options.height);
        self1.toolbar = [
            options.paper.undo().data({
                msg: "Undo",
                width: 50,
                height: 22
            }).attr({
                fill: "#fff",
                cursor: "pointer"
            }).attr({
                fill: "#333",
                stroke: "#fff"
            }).transform([
                "t",
                x,
                ",",
                y,
                "s",
                "1.5",
                "1.5"
            ].join()),
            options.paper.redo().data({
                msg: "Redo",
                width: 50,
                height: 22
            }).attr({
                fill: "#fff",
                cursor: "pointer"
            }).attr({
                fill: "#333",
                stroke: "#fff"
            }).transform([
                "t",
                x + 50,
                ",",
                y,
                "s",
                "-1.5",
                "1.5"
            ].join())
        ];
        self1.toolbar.forEach((toolbarElem)=>{
            toolbarElem.mouseover(function m(e) {
                (0, _utilsDefault.default).stopEvent(e);
                self1.slate.multiSelection?.hide();
                // $(e.target).style.cursor = "pointer";
                if (!this.data("disabled")) {
                    self1.slate.glow(this);
                    const text = this.data("msg");
                    self1.slate.addtip(this.tooltip({
                        type: "text",
                        msg: text
                    }, this.data("width"), this.data("height")));
                }
            });
            toolbarElem.mouseout(function m(e) {
                (0, _utilsDefault.default).stopEvent(e);
                self1.slate.multiSelection?.show();
                self1.slate.unglow();
                this.untooltip();
            });
        });
        self1.toolbar[0].mousedown(function m(e) {
            (0, _utilsDefault.default).stopEvent(e);
            self1.slate.unglow();
            if (!this.data("disabled")) self1.undo();
        });
        self1.toolbar[1].mousedown(function m(e) {
            (0, _utilsDefault.default).stopEvent(e);
            self1.slate.unglow();
            if (!this.data("disabled")) self1.redo();
        });
        // set the buttons both to be disabled
        self1.setVisibility();
        // register the initial state
        setTimeout(()=>{
            self1.snap(true);
        }, 500);
    }
    snap(init) {
        const self1 = this;
        self1.actionIndex += 1;
        if (self1.actionIndex !== self1.actions.length) // work has bene performed, so abandon the forked record
        self1.actions.splice(self1.actionIndex);
        const exp = self1.slate.exportJSON();
        self1.actions.push(exp);
        clearTimeout(self1.saveSnapshot);
        self1.saveSnapshot = setTimeout(async ()=>{
            if (self1.slate.events.onTakeSnapshot) await self1.slate.events.onTakeSnapshot({
                slateId: self1.slate.options.id,
                snapshot: exp
            });
        }, 3000) // once the slate settles for 3 secs, take a snapshot
        ;
        if (!init) self1.setVisibility();
    }
}
exports.default = undoRedo;

},{"../helpers/utils":"8QI6M","../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ixIFt":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class grid {
    constructor(slate){
        this.slate = slate;
        this._grid = null;
        if (this.slate.options.viewPort.showGrid) this.show();
    // produce the required grid patterns
    // <defs>
    //   <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
    //     <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" stroke-width="0.5"/>
    //   </pattern>
    //   <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
    //     <rect width="100" height="100" fill="url(#smallGrid)"/>
    //     <path d="M 100 0 L 0 0 0 100" fill="none" stroke="gray" stroke-width="1"/>
    //   </pattern>
    // </defs>`;
    }
    setGrid() {
        const gbg = this.slate.options.containerStyle.backgroundColor;
        const gridColor = (0, _utilsDefault.default).whiteOrBlack(gbg);
        if (!this.slate.options.viewPort.gridSize) this.slate.options.viewPort.gridSize = 50;
        const { gridSize } = this.slate.options.viewPort;
        this.slate.paper.def({
            tag: "pattern",
            id: "sbSmallGrid",
            height: gridSize,
            width: gridSize,
            patternUnits: "userSpaceOnUse",
            inside: [
                {
                    type: "path",
                    attrs: {
                        d: `M ${gridSize} 0 L 0 0 0 ${gridSize}`,
                        fill: "none",
                        stroke: gridColor,
                        "stroke-width": "0.5"
                    }
                }
            ]
        });
        this.slate.paper.def({
            tag: "pattern",
            id: "sbGrid",
            height: gridSize * 10,
            width: gridSize * 10,
            patternUnits: "userSpaceOnUse",
            inside: [
                {
                    type: "rect",
                    attrs: {
                        width: gridSize * 10,
                        height: gridSize * 10,
                        fill: "url(#sbSmallGrid)"
                    }
                },
                {
                    type: "path",
                    attrs: {
                        d: `M ${gridSize * 10} 0 L 0 0 0 ${gridSize * 10}`,
                        fill: "none",
                        stroke: gridColor,
                        "stroke-width": "0.5"
                    }
                }
            ]
        });
    }
    show() {
        const self = this;
        this.setGrid();
        self._grid = self.slate.paper.rect(0, 0, self.slate.options.viewPort.width, self.slate.options.viewPort.height).attr({
            fill: "url(#sbGrid)"
        }).toBack();
        self.slate.canvas.bgToBack();
    }
    toBack() {
        this._grid?.toBack();
    }
    destroy() {
        this._grid?.remove();
    }
}
exports.default = grid;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g3tty":[function(require,module,exports) {
/* eslint-disable new-cap */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class comments {
    constructor(slate){
        this.slate = slate;
        this.engaged = false;
    }
    engage() {
        const self = this;
        if (!self.engaged) {
            const comment = `M 14.4761 0 H 3.102 C 1.3888 0 0 1.3888 0 3.102 V 8.5307 c 0 1.7132 1.3888 3.102 3.102 3.102 H 9.8297 l 2.803 4.2412 l 0.9018 -4.2412 h 0.9418 c 1.7132 0 3.102 -1.3888 3.102 -3.102 V 3.102 C 17.5781 1.3888 16.1893 0 14.4761 0 z`;
            const svg = self.slate.canvas.internal.querySelector("svg");
            svg.addEventListener("mousedown", (e)=>{
                const mp = (0, _utilsDefault.default).mousePos(e);
                const x = mp.x + self.slate.options.viewPort.left;
                const y = mp.y + self.slate.options.viewPort.top;
                const tpath = (0, _utilsDefault.default)._transformPath(comment, `T${x},${y}s2,2`);
                const pbox = (0, _utilsDefault.default).getBBox({
                    path: tpath
                });
                const commentNodeOpts = {
                    text: "",
                    xPos: x,
                    yPos: y,
                    height: pbox.height,
                    width: pbox.width,
                    vectorPath: tpath,
                    allowMenu: false,
                    allowDrag: true,
                    opacity: 1,
                    borderOpacity: 1,
                    textOpacity: 1
                };
                const commentNode = new (0, _nodeDefault.default)(commentNodeOpts);
                self.slate.nodes.add(commentNode);
            });
            self.engaged = true;
        }
    }
}
exports.default = comments;

},{"../helpers/utils":"8QI6M","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fRVV4":[function(require,module,exports) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class keyboard {
    constructor(slate){
        const self1 = this;
        if (!slate.options.isbirdsEye) {
            self1.slate = slate;
            self1.bindGlobalUp = self1.keyUp.bind(self1);
            self1.bindGlobalDown = self1.keyDown.bind(self1);
            self1.span = 0;
            self1.bindGlobal();
        }
    }
    bindGlobal() {
        const self1 = this;
        (0, _utilsDefault.default).addEvent(document, "keydown", self1.bindGlobalDown);
        (0, _utilsDefault.default).addEvent(document, "keyup", self1.bindGlobalUp);
    }
    unbindGlobal() {
        const self1 = this;
        (0, _utilsDefault.default).removeEvent(document, "keydown", self1.bindGlobalDown);
        (0, _utilsDefault.default).removeEvent(document, "keyup", self1.bindGlobalUp);
    }
    key(e, blnKeyDown) {
        const self1 = this;
        const node = self1.slate.nodes.allNodes.find((n)=>n.menu.isOpen());
        const key = (0, _utilsDefault.default).getKey(e);
        switch(key){
            case 91:
            case 17:
                self1.slate.isCtrl = blnKeyDown;
                break;
            case 16:
                self1.slate.isShift = blnKeyDown;
                break;
            case 18:
                self1.slate.isAlt = blnKeyDown;
                break;
            default:
                break;
        }
        if (node) switch(key){
            case 37:
            case 38:
            case 39:
            case 40:
                if (blnKeyDown) {
                    if (self1.slate.options.viewPort.zoom.r >= 1) self1.span += 1;
                    else if (self1.slate.options.viewPort.zoom.r <= 0.5) self1.span += 5;
                    else self1.span += 2;
                    node.relationships._initDrag(self1, e);
                    if (key === 37) // left
                    node.relationships.enactMove(-self1.span, 0, true);
                    else if (key === 38) // up
                    node.relationships.enactMove(0, -self1.span, true);
                    else if (key === 39) {
                        // right
                        if (self1.slate.isCtrl) node.connectors.addNode(true);
                        else node.relationships.enactMove(self1.span, 0, true);
                    } else if (key === 40) // down
                    node.relationships.enactMove(0, self1.span, true);
                    node.relationships.showMenu();
                } else {
                    self1.span = 0;
                    node.relationships.finishDrag(true);
                }
                break;
            default:
                break;
        }
    }
    keyUp(e) {
        this.key(e, false);
        this.keyboardActive = false;
    }
    keyDown(e) {
        this.key(e, true);
        this.keyboardActive = true;
        // always have an escape hatch
        setTimeout(()=>{
            if (self.slate) {
                self.slate.isCtrl = false;
                self.slate.isShift = false;
                self.slate.isAlt = false;
            }
        }, 5000);
    }
}
exports.default = keyboard;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"JAVXJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class filters {
    constructor(slate){
        this.slate = slate;
        this.exposeDefaults();
    }
    addDeps(deps) {
        const self = this;
        deps.forEach((d)=>{
            const depDef = {
                id: (0, _utilsDefault.default).guid().substring(10),
                tag: d.type,
                ...d.attrs,
                inside: []
            };
            d.nested.forEach((n)=>{
                depDef.inside.push({
                    type: n.type,
                    attrs: n.attrs
                });
            });
            self.slate.paper.def(depDef);
        });
    }
    add(filter, isDefault) {
        const self = this;
        const filterDef = {
            id: filter.id || (0, _utilsDefault.default).guid().substring(10),
            tag: "filter",
            filterUnits: "userSpaceOnUse",
            ...filter.attrs,
            inside: []
        };
        filter.filters.forEach((ff)=>{
            if (ff.nested) filterDef.inside.push({
                type: ff.type,
                nested: ff.nested
            });
            else filterDef.inside.push({
                type: ff.type,
                attrs: ff.attrs
            });
        });
        self.slate.paper.def(filterDef);
        if (!isDefault) {
            if (!self.slate.customFilters) self.slate.customFilters = [];
            self.slate.customFilters.push(filterDef);
        }
        return filter.id;
    }
    remove(id) {
        const self = this;
        self.slate?.filters.splice(self.slate?.filters.findIndex((f)=>f.id === id));
        return true;
    }
    // <feGaussianBlur in="SourceAlpha" stdDeviation="3"/> <\!-- stdDeviation is how much to blur -->
    // <feOffset dx="2" dy="2" result="offsetblur"/> <\!-- how much to offset -->
    // <feComponentTransfer>
    //   <feFuncA type="linear" slope="0.5"/> <\!-- slope is the opacity of the shadow -->
    // </feComponentTransfer>
    // <feMerge>
    //   <feMergeNode/> <\!-- this contains the offset blurred image -->
    //   <feMergeNode in="SourceGraphic"/> <\!-- this contains the element that the filter is applied to -->
    // </feMerge>
    exposeDefaults() {
        const self = this;
        self.availableFilters = {
            embossed: {
                types: [
                    "vect",
                    "line",
                    "image",
                    "text"
                ],
                filters: [
                    {
                        type: "feGaussianBlur",
                        attrs: {
                            stdDeviation: "1.5",
                            in: "SourceAlpha"
                        }
                    },
                    {
                        type: "feOffset",
                        attrs: {
                            dx: "1",
                            dy: "1",
                            result: "offsetblur"
                        }
                    },
                    {
                        type: "feComponentTransfer",
                        nested: [
                            {
                                type: "feFuncA",
                                attrs: {
                                    type: "linear",
                                    slope: "10"
                                }
                            }
                        ]
                    },
                    {
                        type: "feMerge",
                        nested: [
                            {
                                type: "feMergeNode",
                                attrs: {}
                            },
                            {
                                type: "feMergeNode",
                                attrs: {
                                    in: "SourceGraphic"
                                }
                            }
                        ]
                    }
                ]
            },
            dropShadow: {
                levers: {
                    feDropShadow: {
                        stdDeviation: {
                            label: "distance",
                            default: 1.5,
                            range: [
                                1,
                                10
                            ]
                        },
                        dx: {
                            label: "x-displacement",
                            default: 5,
                            range: [
                                1,
                                50
                            ]
                        },
                        dy: {
                            label: "y-displacement",
                            default: 5,
                            range: [
                                1,
                                50
                            ]
                        }
                    }
                },
                types: [
                    "vect",
                    "line",
                    "image",
                    "text"
                ],
                filters: [
                    {
                        type: "feGaussianBlur",
                        attrs: {
                            stdDeviation: "3",
                            in: "SourceAlpha"
                        }
                    },
                    {
                        type: "feOffset",
                        attrs: {
                            dx: "5",
                            dy: "5",
                            result: "offsetblur"
                        }
                    },
                    {
                        type: "feComponentTransfer",
                        nested: [
                            {
                                type: "feFuncA",
                                attrs: {
                                    type: "linear",
                                    slope: "0.8"
                                }
                            }
                        ]
                    },
                    {
                        type: "feMerge",
                        nested: [
                            {
                                type: "feMergeNode",
                                attrs: {}
                            },
                            {
                                type: "feMergeNode",
                                attrs: {
                                    in: "SourceGraphic"
                                }
                            }
                        ]
                    }
                ]
            },
            postItNote: {
                types: [
                    "vect",
                    "line",
                    "image",
                    "text"
                ],
                filters: [
                    {
                        type: "feGaussianBlur",
                        attrs: {
                            stdDeviation: "2",
                            in: "SourceAlpha"
                        }
                    },
                    {
                        type: "feOffset",
                        attrs: {
                            dx: "0",
                            dy: "4",
                            result: "offsetblur"
                        }
                    },
                    {
                        type: "feComponentTransfer",
                        nested: [
                            {
                                type: "feFuncA",
                                attrs: {
                                    type: "linear",
                                    slope: "0.5"
                                }
                            }
                        ]
                    },
                    {
                        type: "feMerge",
                        nested: [
                            {
                                type: "feMergeNode",
                                attrs: {}
                            },
                            {
                                type: "feMergeNode",
                                attrs: {
                                    in: "SourceGraphic"
                                }
                            }
                        ]
                    }
                ]
            },
            tattered: {
                levers: {
                    feDisplacementMap: {
                        scale: {
                            label: "torn",
                            default: "10",
                            range: [
                                2,
                                50
                            ]
                        }
                    }
                },
                types: [
                    "vect",
                    "line",
                    "image",
                    "text"
                ],
                filters: [
                    {
                        type: "feTurbulence",
                        attrs: {
                            type: "turbulence",
                            baseFrequency: ".05 .05",
                            numOctaves: "05",
                            seed: "2",
                            stitchTiles: "noStitch",
                            result: "turbulence"
                        }
                    },
                    {
                        type: "feDisplacementMap",
                        attrs: {
                            in: "SourceGraphic",
                            in2: "turbulence",
                            scale: "10",
                            xChannelSelector: "R",
                            yChannelSelector: "B",
                            result: "displacementMap"
                        }
                    }
                ]
            },
            blur: {
                levers: {
                    feGaussianBlur: {
                        stdDeviation: {
                            label: "displacement",
                            default: 2,
                            range: [
                                1,
                                10
                            ]
                        }
                    }
                },
                types: [
                    "vect",
                    "line",
                    "image"
                ],
                filters: [
                    {
                        type: "feGaussianBlur",
                        attrs: {
                            stdDeviation: "2",
                            in: "SourceGraphic",
                            edgeMode: "none"
                        }
                    }
                ]
            },
            outline: {
                levers: {
                    feMorphology: {
                        radius: {
                            label: "cutout",
                            default: "1",
                            range: [
                                1,
                                10
                            ]
                        }
                    }
                },
                types: [
                    "text",
                    "line"
                ],
                filters: [
                    {
                        type: "feMorphology",
                        attrs: {
                            operator: "dilate",
                            radius: "1",
                            in: "SourceGraphic",
                            result: "thickness"
                        }
                    },
                    {
                        type: "feComposite",
                        attrs: {
                            operator: "out",
                            in: "thickness",
                            in2: "SourceGraphic"
                        }
                    }
                ]
            },
            pixelate: {
                levers: {
                    feImage: {
                        width: {
                            label: "width",
                            default: "8",
                            range: [
                                1,
                                30
                            ]
                        },
                        height: {
                            label: "height",
                            default: "8",
                            range: [
                                1,
                                30
                            ]
                        }
                    }
                },
                types: [
                    "image"
                ],
                filters: [
                    // https://stackoverflow.com/questions/37451189/can-one-pixelate-images-with-an-svg-filter
                    {
                        type: "feGaussianBlur",
                        attrs: {
                            stdDeviation: "2",
                            in: "SourceGraphic",
                            result: "smoothed"
                        }
                    },
                    {
                        type: "feImage",
                        attrs: {
                            width: "8",
                            height: "8",
                            "xlink:href": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAWSURBVAgdY1ywgOEDAwKxgJhIgFQ+AP/vCNK2s+8LAAAAAElFTkSuQmCC",
                            result: "displacement-map"
                        }
                    },
                    {
                        type: "feTile",
                        attrs: {
                            in: "displacement-map",
                            result: "pixelate-map"
                        }
                    },
                    {
                        type: "feDisplacementMap",
                        attrs: {
                            in: "smoothed",
                            in2: "pixelate-map",
                            xChannelSelector: "R",
                            yChannelSelector: "G",
                            scale: "30",
                            result: "pre-final"
                        }
                    },
                    {
                        type: "feComposite",
                        attrs: {
                            operator: "in",
                            in2: "SourceGraphic"
                        }
                    }
                ]
            },
            posterize: {
                levers: {},
                types: [
                    "image"
                ],
                filters: [
                    {
                        type: "feComponentTransfer",
                        nested: {
                            feFuncR: {
                                type: "discrete",
                                tableValues: ".25 .4 .5 .75 1"
                            },
                            feFuncG: {
                                type: "discrete",
                                tableValues: ".25 .4 .5 .75 1"
                            },
                            feFuncB: {
                                type: "discrete",
                                tableValues: ".25 .4 .5 .75 1"
                            }
                        }
                    }
                ]
            },
            sketchy: {
                types: [
                    "vect",
                    "line",
                    "text",
                    "image"
                ],
                filters: [
                    {
                        type: "feTurbulence",
                        attrs: {
                            baseFrequency: "0.01",
                            numOctaves: 2,
                            result: "turbulence"
                        }
                    },
                    {
                        type: "feDisplacementMap",
                        attrs: {
                            in2: "turbulence",
                            in: "SourceGraphic",
                            scale: 15,
                            xChannelSelector: "R",
                            yChannelSelector: "G"
                        }
                    }
                ]
            },
            pencil: {
                // https://heredragonsabound.blogspot.com/2020/02/creating-pencil-effect-in-svg.html
                levers: {},
                types: [
                    "vect",
                    "line",
                    "text",
                    "image"
                ],
                filters: [
                    {
                        type: "feTurbulence",
                        attrs: {
                            type: "fractalNoise",
                            baseFrequency: "0.03",
                            numOctaves: "3",
                            seed: "1",
                            result: "f1"
                        }
                    },
                    {
                        type: "feDisplacementMap",
                        attrs: {
                            xChannelSelector: "R",
                            yChannelSelector: "G",
                            scale: "5",
                            in: "SourceGraphic",
                            in2: "f1",
                            result: "f4"
                        }
                    },
                    {
                        type: "feTurbulence",
                        attrs: {
                            type: "fractalNoise",
                            baseFrequency: "0.03",
                            numOctaves: "3",
                            seed: "10",
                            result: "f2"
                        }
                    },
                    {
                        type: "feDisplacementMap",
                        attrs: {
                            xChannelSelector: "R",
                            yChannelSelector: "G",
                            scale: "5",
                            in: "SourceGraphic",
                            in2: "f2",
                            result: "f5"
                        }
                    },
                    {
                        type: "feTurbulence",
                        attrs: {
                            type: "fractalNoise",
                            baseFrequency: "1.2",
                            numOctaves: "2",
                            seed: "100",
                            result: "f3"
                        }
                    },
                    {
                        type: "feDisplacementMap",
                        attrs: {
                            xChannelSelector: "R",
                            yChannelSelector: "G",
                            scale: "3",
                            in: "SourceGraphic",
                            in2: "f3",
                            result: "f6"
                        }
                    }
                ]
            }
        };
    }
} // <filter id="f1" x="0" y="0" width="200%" height="200%">
 //   <feOffset result="offOut" in="SourceGraphic" dx="20" dy="20" />
 //   <feBlend in="SourceGraphic" in2="offOut" mode="normal" />
 // </filter>
 // <feBlend>
 // <feColorMatrix>
 // <feComponentTransfer>
 // <feComposite>
 // <feConvolveMatrix>
 // <feDiffuseLighting>
 // <feDisplacementMap>
 // <feDropShadow>
 // <feFlood>
 // <feGaussianBlur>
 // <feImage>
 // <feMerge>
 // <feMorphology>
 // <feOffset>
 // <feSpecularLighting>
 // <feTile>
 // <feTurbulence></feTurbulence>
 // https://github.com/svgdotjs/svg.filter
 // <filter id="displacementFilter">
 //   <feTurbulence type="turbulence" baseFrequency="0.05" numOctaves="5" seed="2" result="turbulence"/>
 //   <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="2"/>
 // </filter>
exports.default = filters;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8dkR":[function(require,module,exports) {
var _indexJs = require("../../index.js");
(0, _indexJs.Slatebox).base.registerPlugin({
    name: "attempt",
    opts: {},
    plugin: class extends (0, _indexJs.Slatebox).node {
        doAttempt() {
            console.log("HELLO NODE do I have inherited properties? ", this.disable);
        }
    }
});

},{"../../index.js":"8lqZg"}],"evEf8":[function(require,module,exports) {
var _indexJs = require("../../index.js");
(0, _indexJs.Slatebox).base.registerPlugin({
    name: "attempt",
    opts: {},
    plugin: class extends (0, _indexJs.Slatebox).slate {
        doSecond() {
            console.log("SLATE hello do I have inherited properties? ", this);
        }
    }
});

},{"../../index.js":"8lqZg"}]},["knIEI","620jy"], "620jy", "parcelRequire561b")

</script>
  </body>
</html>
