<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div style="width: 100%; height: 800px; border: 1px solid red" id="slateCanvas"></div>
    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"3czh9":[function(require,module,exports) {
"use strict";
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "51221d3ac2cb24fb";
function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {
            };
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return {
        s: function s() {
            it = it.call(o);
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally{
                if (didErr) throw err;
            }
        }
    };
}
function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function accept(fn) {
            this._acceptCallbacks.push(fn || function() {
            });
        },
        dispose: function dispose(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';
    var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // $FlowFixMe
    ws.onmessage = function(event) {
        checkedAssets = {
        };
        acceptedAssets = {
        };
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            var assets = data.assets.filter(function(asset) {
                return asset.envHash === HMR_ENV_HASH;
            }); // Handle HMR Update
            var handled = assets.every(function(asset) {
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                assets.forEach(function(asset) {
                    hmrApply(module.bundle.root, asset);
                });
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else window.location.reload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            var _iterator = _createForOfIteratorHelper(data.diagnostics.ansi), _step;
            try {
                for(_iterator.s(); !(_step = _iterator.n()).done;){
                    var ansiDiagnostic = _step.value;
                    var stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                    console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
                }
            } catch (err) {
                _iterator.e(err);
            } finally{
                _iterator.f();
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn('[parcel] 🚨 Connection to the HMR server was lost');
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log('[parcel] ✨ Error resolved');
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    var errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    var _iterator2 = _createForOfIteratorHelper(diagnostics), _step2;
    try {
        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
            var diagnostic = _step2.value;
            var stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
            errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>").concat(stack, "</pre>\n        <div>\n          ").concat(diagnostic.hints.map(function(hint) {
                return '<div>💡 ' + hint + '</div>';
            }).join(''), "\n        </div>\n        ").concat(diagnostic.documentation ? "<div>\uD83D\uDCDD <a style=\"color: violet\" href=\"".concat(diagnostic.documentation, "\" target=\"_blank\">Learn more</a></div>") : '', "\n      </div>\n    ");
        }
    } catch (err) {
        _iterator2.e(err);
    } finally{
        _iterator2.f();
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(window.location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        var deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                var oldDeps = modules[asset.id][1];
                for(var dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    var id = oldDeps[dep];
                    var parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            var fn = new Function('require', 'module', 'exports', asset.output);
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    var modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        var deps = modules[id1][1];
        var orphans = [];
        for(var dep in deps){
            var parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach(function(id) {
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    var parents = getParents(module.bundle.root, id);
    var accepted = false;
    while(parents.length > 0){
        var v = parents.shift();
        var a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            var p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push.apply(parents, _toConsumableArray(p));
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {
    };
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"620jy":[function(require,module,exports) {
var _indexJs = require("./index.js");
var _attemptJs = require("./plugins/node/attempt.js");
var _secondJs = require("./plugins/slate/second.js");
const s = new _indexJs.Slatebox.slate({
    name: 'New Slate',
    description: '',
    defaultLineColor: '#333',
    container: 'slateCanvas',
    instance: '',
    basedOnThemeId: '',
    syncWithTheme: false,
    viewPort: {
        useInertiaScrolling: true,
        showGrid: false,
        snapToObjects: true,
        gridSize: 50,
        width: 50000,
        height: 50000,
        left: 25000,
        top: 25000
    },
    enabled: true,
    allowDrag: true,
    showbirdsEye: true,
    sizeOfbirdsEye: 150,
    showMultiSelect: true,
    showZoom: true,
    showUndoRedo: true,
    showStatus: true,
    showLocks: true,
    mindMapMode: true,
    isPublic: true,
    isUnlisted: false,
    autoEnableDefaultFilters: true,
    followMe: false,
    containerStyle: {
        backgroundColor: '',
        backgroundImage: '',
        backgroundSize: '',
        backgroundEffect: '',
        backgroundColorAsGradient: true,
        backgroundGradientType: 'radial',
        backgroundGradientColors: [
            '#fff',
            '#333'
        ],
        backgroundGradientStrategy: 'shades'
    }
}, {
    onConfirmRequested: async (title, msg, cb)=>{
    // implement confirmation dialog
    },
    onTakeSnapshot: async (opts)=>{
    // implement slate snapshot
    },
    onTextPaneRequested: (node, cb)=>{
    // implement text pane
    },
    onLineMenuRequested: (node, association, cb)=>{
    // implement line menu request
    },
    onMenuRequested: (node, cb)=>{
    // implement menu request
    },
    onBase64ImageRequested: (imgUrl, imageType, cb)=>{
    // implement base64 image request
    },
    // onOptimizeSVG: (svg, cb) => {
    //   // implement SVG optimization
    // },
    isReadOnly: ()=>{
        // is the slate read only for this user?
        return false;
    },
    isCommentOnly: ()=>{
        // does the user have comment only access to this slate?
        return false;
    },
    canRemoveComments: ()=>{
    // can the user remove comments?
    },
    onThemeRequired: (opts, cb)=>{
    // expirmental: provide a them in the cb
    }
}, {
    allow: true,
    localizedOnly: false,
    onCollaboration: async function(opts) {
        switch(opts.type){
            case 'process':
                break;
            case 'custom':
                switch(opts.pkg.type){
                    case 'onSaveRequested':
                        if (opts.pkg._id) break;
                        break;
                }
        }
    }
}).init();
//this is a new slate
// s.shareId = 'test'
// const defaultNodeOpts = {
//   name: 'MASTER_NODE',
//   text: 'Welcome to Slatebox!',
//   xPos: 5500,
//   yPos: 5300,
//   height: 100,
//   width: 175,
//   vectorPath: 'roundedrectangle',
//   backgroundColor: '90-#031634-#2D579A', //blue default
//   foregroundColor: '#fff',
//   lineColor: '#333',
//   lineWidth: 5,
//   allowDrag: true,
// }
// const n = new Slatebox.node(defaultNodeOpts)
// s.nodes.add(n)
const nodes = [
    new _indexJs.Slatebox.node({
        id: 'first_node',
        name: 'first_node',
        text: 'drag me',
        xPos: 25110,
        yPos: 25120,
        height: 60,
        width: 120,
        vectorPath: 'roundedrectangle',
        backgroundColor: '#24A8E0',
        lineColor: '#333',
        lineWidth: 5,
        allowMenu: false,
        link: {
            show: true,
            type: 'currentSlate',
            data: 'second_node'
        },
        filters: {
            vect: 'dropShadow'
        }
    }),
    new _indexJs.Slatebox.node({
        id: 'second_node',
        name: 'second_node',
        text: 'drag me',
        xPos: 25310,
        yPos: 25220,
        height: 60,
        width: 120,
        vectorPath: 'roundedrectangle',
        backgroundColor: '#24A8E0',
        lineColor: '#333',
        lineWidth: 5,
        allowMenu: false,
        link: {
            show: true,
            type: 'url',
            data: 'https://slatebox.com'
        }
    }), 
];
s.nodes.addRange(nodes);
nodes[0].relationships.addAssociation(nodes[1], {
    showChildArrow: true,
    showParentArrow: true
}) // setTimeout(() => {
 //   s.svg()
 // }, 1000)
 // console.log('node plugins ', n.plugins)
 // n.plugins.attempt.doAttempt()
 // s.plugins.attempt.doSecond()
;

},{"./index.js":"8lqZg","./plugins/node/attempt.js":"c8dkR","./plugins/slate/second.js":"evEf8"}],"8lqZg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Slatebox", ()=>Slatebox
);
/* eslint-disable import/prefer-default-export */ /* eslint-disable import/no-cycle */ var _slate = require("./core/slate");
var _slateDefault = parcelHelpers.interopDefault(_slate);
var _node = require("./core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
var _base = require("./core/base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _utils = require("./helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
const Slatebox = {
    slate: _slateDefault.default,
    node: _nodeDefault.default,
    base: _baseDefault.default,
    utils: _utilsDefault.default
};

},{"./core/slate":"khicH","./core/node":"bAVQb","./core/base":"cmkOb","./helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"khicH":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-template-curly-in-string */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ /* eslint-disable no-unused-expressions */ /* eslint-disable new-cap */ /* eslint-disable import/no-cycle */ var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _deepmerge = require("deepmerge");
var _deepmergeDefault = parcelHelpers.interopDefault(_deepmerge);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _canvas = require("../slate/canvas");
var _canvasDefault = parcelHelpers.interopDefault(_canvas);
var _collab = require("../slate/collab");
var _collabDefault = parcelHelpers.interopDefault(_collab);
var _nodeController = require("../slate/nodeController");
var _nodeControllerDefault = parcelHelpers.interopDefault(_nodeController);
var _multiSelection = require("../slate/multiSelection");
var _multiSelectionDefault = parcelHelpers.interopDefault(_multiSelection);
var _birdsEye = require("../slate/birdsEye");
var _birdsEyeDefault = parcelHelpers.interopDefault(_birdsEye);
var _inertia = require("../slate/inertia");
var _inertiaDefault = parcelHelpers.interopDefault(_inertia);
var _controller = require("../slate/controller");
var _controllerDefault = parcelHelpers.interopDefault(_controller);
var _zoomSlider = require("../slate/zoomSlider");
var _zoomSliderDefault = parcelHelpers.interopDefault(_zoomSlider);
var _undoRedo = require("../slate/undoRedo");
var _undoRedoDefault = parcelHelpers.interopDefault(_undoRedo);
var _grid = require("../slate/grid");
var _gridDefault = parcelHelpers.interopDefault(_grid);
var _comments = require("../slate/comments");
var _commentsDefault = parcelHelpers.interopDefault(_comments);
var _keyboard = require("../slate/keyboard");
var _keyboardDefault = parcelHelpers.interopDefault(_keyboard);
var _filters = require("../slate/filters");
var _filtersDefault = parcelHelpers.interopDefault(_filters);
var _base = require("./base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _node = require("./node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class slate extends _baseDefault.default {
    constructor(_options, events, collaboration){
        super(_options);
        this.options = {
            id: _options.id || _utilsDefault.default.guid(),
            container: '',
            instance: '',
            name: '',
            description: '',
            basedOnThemeId: '',
            syncWithTheme: false,
            containerStyle: {
                backgroundColor: 'transparent',
                backgroundImage: '',
                backgroundSize: '',
                backgroundEffect: '',
                backgroundColorAsGradient: null,
                backgroundGradientType: null,
                backgroundGradientColors: [],
                backgroundGradientStrategy: null
            },
            viewPort: {
                useInertiaScrolling: true,
                showGrid: false,
                snapToObjects: true,
                gridSize: 50,
                width: 50000,
                height: 50000,
                left: 5000,
                top: 5000
            },
            enabled: true,
            allowDrag: true,
            showbirdsEye: true,
            sizeOfbirdsEye: 200,
            showMultiSelect: true,
            showZoom: true,
            showUndoRedo: true,
            showStatus: true,
            showLocks: true,
            mindMapMode: true,
            isPublic: true,
            isUnlisted: false,
            autoEnableDefaultFilters: true,
            followMe: false
        };
        this.options = _deepmergeDefault.default(this.options, _options);
        this.events = events || {
            onNodeDragged: null,
            onCanvasClicked: null,
            onImagesRequested: null,
            onRequestSave: null,
            isReadOnly: null
        };
        this.collaboration = collaboration || {
            allow: true,
            localizedOnly: false,
            userIdOverride: null,
            onCollaboration: null
        };
        // console.log("SLATE - share details are", this.options.shareId, this.options.userId, this.options.orgId);
        // ensure container is always an object
        if (!_utilsDefault.default.isElement(this.options.container)) this.options.container = _utilsDefault.default.el(this.options.container);
        this.constants = {
            statusPanelAtRest: 33,
            statusPanelExpanded: 200
        };
        this.glows = [];
        this.tips = [];
        this.tempNodeId = _utilsDefault.default.guid();
        this.allLines = [];
    }
    init() {
        const self = this;
        // instantiate all the dependencies for the slate -- order here is importantish
        // (birdsEye, undoRedo, zoomSlider are used in canvas, and inertia uses canvas)
        self.nodes = new _nodeControllerDefault.default(self);
        self.collab = new _collabDefault.default(self);
        self.birdsEye = new _birdsEyeDefault.default(self);
        self.zoomSlider = new _zoomSliderDefault.default(self);
        if (!self.isReadOnly() && !self.isCommentOnly()) {
            self.undoRedo = new _undoRedoDefault.default(self);
            self.multiSelection = new _multiSelectionDefault.default(self);
        }
        self.controller = new _controllerDefault.default(self);
        self.filters = new _filtersDefault.default(self);
        self.canvas = new _canvasDefault.default(self);
        self.canvas.init();
        if (self.multiSelection) self.multiSelection.init();
        self.inertia = new _inertiaDefault.default(self);
        self.grid = new _gridDefault.default(self);
        self.comments = new _commentsDefault.default(self);
        self.keyboard = new _keyboardDefault.default(self);
        self.autoLoadFilters();
        if (self.options.onInitCompleted) self.options.onInitCompleted.apply(self);
        return self;
    }
    url(opt) {
        return this.options.ajax.rootUrl + this.options.ajax.urlFlavor + opt;
    }
    glow(obj) {
        this.glows.push(obj.glow());
    }
    unglow() {
        this.glows.forEach((glow)=>{
            glow.remove();
        });
        this.glows = [];
    }
    addtip(tip) {
        if (tip) this.tips.push(tip);
    }
    untooltip() {
        this.tips.forEach((tip)=>{
            tip && tip.remove();
        });
    }
    toggleFilters(blnHide, nodeId, esc) {
        // hide filters during dragging
        if (this.nodes.allNodes.length > 20) {
            this.nodes.allNodes.forEach((n)=>{
                if (!nodeId || n.options.id === nodeId) n.toggleFilters(blnHide);
            });
            this.allLines.filter((l)=>l.lineEffect
            ).forEach((c)=>{
                if (blnHide) c.line.attr('filter', '');
                else c.line.attr('filter', `url(#${c.lineEffect})`);
            });
            if (blnHide) this.canvas.hideBg();
            if (esc) setTimeout(()=>{
                this.toggleFilters(!blnHide);
                this.canvas.hideBg(1);
            }, 500);
        }
    }
    removeContextMenus() {
        const _cm = _utilsDefault.default.select('div.sb_cm');
        _cm.forEach((elem)=>{
            document.body.removeChild(elem);
        });
    }
    remove() {
        this.nodes.allNodes.forEach((nn)=>{
            nn.del();
        });
        this.paper.remove();
    // delete self;
    }
    zoom(x, y, w, h, fit) {
        this.nodes.closeAllLineOptions();
        this.paper.setViewBox(x, y, w, h, fit);
    }
    png(ropts, cb) {
        const self = this;
        self.svg({
            useDataImageUrls: true,
            backgroundOnly: ropts?.backgroundOnly
        }, (opts)=>{
            if (self.events.onCreateImage) self.events.onCreateImage({
                svg: opts.svg,
                orient: opts.orient,
                type: 'png'
            }, (err, base64)=>{
                if (err) console.error('Unable to create png server side', svg, err);
                else if (ropts?.base64) cb(base64);
                else {
                    const img = new Image();
                    img.src = base64;
                    img.onload = ()=>{
                        const cnvs = document.createElement('canvas');
                        cnvs.width = img.naturalWidth;
                        cnvs.height = img.naturalHeight;
                        const ctx = cnvs.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0);
                        const link = document.createElement('a');
                        link.setAttribute('download', `${(self.options.name || 'slate').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${self.options.id}.png`);
                        cnvs.toBlob((blob)=>{
                            link.href = URL.createObjectURL(blob);
                            const event = new MouseEvent('click');
                            link.dispatchEvent(event);
                            cb && cb();
                        });
                    };
                }
            });
            else {
                const cnvs = document.createElement('canvas');
                cnvs.width = opts.orient.width;
                cnvs.height = opts.orient.height;
                const blb = new Blob([
                    opts.svg
                ], {
                    type: 'image/svg+xml;charset=utf8'
                });
                const url = URL.createObjectURL(blb);
                if (ropts?.base64) cb(`url('${url}')`);
                else {
                    const ctx = cnvs.getContext('2d');
                    const img = document.createElement('img');
                    img.src = url;
                    img.onload = ()=>{
                        ctx.drawImage(img, 0, 0);
                        const imgsrc = cnvs.toDataURL('image/png');
                        const a = document.createElement('a');
                        a.download = `${(self.options.name || 'slate').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${self.options.id}.png`;
                        a.href = imgsrc;
                        a.click();
                        URL.revokeObjectURL(img.src);
                        cb && cb();
                    };
                    img.onerror = (err)=>{
                        console.log('error loading image', err);
                    };
                }
            }
        });
    }
    copy(opts) {
        const self = this;
        if (!self.copySlate) self.copySlate = new slate({
            container: opts.container,
            containerStyle: this.options.containerStyle,
            defaultLineColor: this.options.defaultLineColor,
            viewPort: this.options.viewPort,
            name: this.options.name,
            description: this.options.description,
            showbirdsEye: false,
            showMultiSelect: false,
            showUndoRedo: false,
            showZoom: false
        }).init();
        const _json = JSON.parse(this.exportJSON());
        _json.nodes.forEach((nde)=>{
            const _mpkg = opts.moves ? opts.moves.find((m)=>m.id === nde.options.id || m.id === '*'
            ) : null;
            if (_mpkg) {
                nde.options.xPos += _mpkg.x;
                nde.options.yPos += _mpkg.y;
                const _transforms = [
                    `t${_mpkg.x}, ${_mpkg.y}`
                ];
                nde.options.vectorPath = _getTransformedPathDefault.default(_nodeDefault.default.options.vectorPath, _transforms);
            }
        });
        self.copySlate.loadJSON(JSON.stringify(_json));
        self.copySlate.nodes.refreshAllRelationships();
        return self.copySlate;
    }
    svg(opts, cb) {
        const self = this;
        const _nodesToOrient = opts?.nodes ? self.nodes.allNodes.filter((n)=>opts?.nodes.indexOf(n.options.id) > -1
        ) : null;
        const _orient = self.getOrientation(_nodesToOrient, true);
        const _r = 1 // this.options.viewPort.zoom.r || 1;
        ;
        const _resizedSlate = JSON.parse(self.exportJSON());
        if (opts?.backgroundOnly) _resizedSlate.nodes = [];
        _resizedSlate.nodes.forEach((n)=>{
            const _ty = n.options.yPos * _r;
            const _tx = n.options.xPos * _r;
            const _width = n.options.width;
            const _height = n.options.height;
            n.options.yPos = _ty - _orient.top;
            n.options.xPos = _tx - _orient.left;
            n.options.width = _width * _r;
            n.options.height = _height * _r;
            if (n.options.rotate && n.options.rotate.point) {
                n.options.rotate.point.x = n.options.rotate.point.x * _r - _orient.left;
                n.options.rotate.point.y = n.options.rotate.point.y * _r - _orient.top;
            }
            const _updatedPath = _utilsDefault.default._transformPath(n.options.vectorPath, [
                'T',
                _orient.left / _r * -1,
                ',',
                _orient.top / _r * -1,
                's',
                ',',
                _r,
                ',',
                _r, 
            ].join(''));
            n.options.vectorPath = _updatedPath;
        });
        const _div = document.createElement('div');
        _div.setAttribute('id', 'tempSvgSlate');
        _div.style.width = `${_orient.width}px`;
        _div.style.height = `${_orient.height}px`;
        _div.style.visibility = 'hidden';
        document.body.appendChild(_div);
        const exportOptions = _deepmergeDefault.default(_resizedSlate.options, {
            container: 'tempSvgSlate',
            containerStyle: {
                backgroundColor: _resizedSlate.options.containerStyle.backgroundColor,
                backgroundColorAsGradient: _resizedSlate.options.containerStyle.backgroundColorAsGradient,
                backgroundGradientType: _resizedSlate.options.containerStyle.backgroundGradientType,
                backgroundGradientColors: _resizedSlate.options.containerStyle.backgroundGradientColors,
                backgroundGradientStrategy: _resizedSlate.options.containerStyle.backgroundGradientStrategy
            },
            defaultLineColor: _resizedSlate.options.defaultLineColor,
            viewPort: {
                allowDrag: false,
                originalWidth: _orient.width,
                width: _orient.width,
                height: _orient.height,
                left: 0,
                top: 0,
                zoom: {
                    w: _orient.width * 1.5,
                    h: _orient.height * 1.5
                },
                showGrid: false
            },
            name: _resizedSlate.options.name,
            description: _resizedSlate.options.description,
            showbirdsEye: false,
            showMultiSelect: false,
            showUndoRedo: false,
            showZoom: false,
            showLocks: false,
            isEmbedding: true
        });
        // we don't yet load the nodes by default even though they're passed in on the options below...
        const _exportCanvas = new slate(exportOptions).init();
        // ...that's done in the loadJSON...which seems weird
        _exportCanvas.loadJSON(JSON.stringify({
            options: exportOptions,
            nodes: _resizedSlate.nodes
        }), false, true);
        // events don't serialize, so add them explicitly
        _exportCanvas.events = self.events;
        _exportCanvas.nodes.refreshAllRelationships();
        // add the bgColor (this is done on html styling in slatebox proper view)
        let bg = null;
        if (_resizedSlate.options.containerStyle.backgroundImage) {
            const img = document.createElement('img');
            img.setAttribute('src', _resizedSlate.options.containerStyle.backgroundImage);
            img.style.visibility = 'hidden';
            document.body.appendChild(img);
            let bw = img.naturalWidth;
            let bh = img.naturalHeight;
            if (self.options.containerStyle.backgroundSize === 'cover') {
                const ratio = self.canvas.internal.parentElement.offsetWidth / bw;
                bw *= ratio;
                bh *= ratio;
            }
            img.remove();
            const iw = Math.max(bw, _orient.width);
            const ih = Math.max(bh, _orient.height);
            bg = _exportCanvas.paper.image(_resizedSlate.options.containerStyle.backgroundImage, 0, 0, iw, ih);
        } else bg = _exportCanvas.paper.rect(0, 0, _orient.width, _orient.height).attr({
            fill: _resizedSlate.options.containerStyle.backgroundColor,
            stroke: 'none'
        });
        bg.toBack();
        // the timeout is critical to ensure that the SVG canvas settles
        // and the url-fill images appear.
        setTimeout(async ()=>{
            _exportCanvas.canvas.rawSVG((svg)=>{
                if (!opts) {
                    // presume download if no opts are sent
                    const svgBlob = new Blob([
                        svg
                    ], {
                        type: 'image/svg+xml;charset=utf-8'
                    });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    const dl = document.createElement('a');
                    dl.href = svgUrl;
                    dl.download = `${(self.options.name || 'slate').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${self?.shareId}.svg`;
                    dl.click();
                    cb && cb();
                } else cb && cb({
                    svg,
                    orient: _orient
                });
                _div.remove();
            });
        }, 100);
    }
    autoLoadFilters() {
        const self = this;
        // if auto filter is on, then these filters become immediately availalbe in their default form
        if (self.options.autoEnableDefaultFilters && self.filters?.availableFilters) Object.keys(self.filters.availableFilters).forEach((type)=>{
            self.filters.add({
                id: type,
                filters: self.filters.availableFilters[type].filters
            }, true);
            if (self.filters.availableFilters[type].deps) self.filters.addDeps(self.filters.availableFilters[type].deps);
        });
    }
    loadJSON(_jsonSlate, blnPreserve, blnSkipZoom, useMainCanvas = false) {
        const self = this;
        if (blnPreserve === undefined) {
            self.paper && self.paper.clear();
            if (self.nodes) self.nodes.allNodes = [];
        }
        const loadedSlate = JSON.parse(_jsonSlate);
        Object.assign(self.options, loadedSlate.options);
        self.autoLoadFilters();
        // bgcolor set
        self.canvas?.refreshBackground();
        // grid
        if (self.options.viewPort.showGrid) self.grid?.show();
        else self.grid?.destroy();
        // zoom
        if (!blnSkipZoom) self.zoomSlider?.set(self.options.viewPort.zoom.w || 50000);
        // sort nodes by their last painted order to honor toBack/toFront
        loadedSlate.nodes.sort((n1, n2)=>{
            const i1 = loadedSlate.options.nodeOrder?.findIndex((n)=>n === n1.options.id
            );
            const i2 = loadedSlate.options.nodeOrder?.findIndex((n)=>n === n2.options.id
            );
            return i1 - i2;
        });
        const deferredRelationships = [];
        loadedSlate.nodes.forEach((n)=>{
            n.options.allowDrag = true // must default
            ;
            n.options.allowMenu = true;
            const _boundTo = new _nodeDefault.default(n.options);
            self.nodes.add(_boundTo, useMainCanvas);
            deferredRelationships.push({
                bt: _boundTo,
                json: n
            });
        });
        deferredRelationships.forEach((relationship)=>{
            const _bounded = relationship;
            _bounded.bt.addRelationships(_bounded.json);
        });
        if (self.options.showLocks) self.displayLocks();
        // refreshes all relationships
        self.nodes.allNodes.forEach((_node1)=>{
            _node1.relationships.updateAssociationsWith({
                activeNode: _node1.options.id,
                currentDx: 0,
                currentDy: 0
            });
        });
        self.nodes.refreshAllRelationships();
        // finally invoke toFront in order
        self.nodes.allNodes.forEach((n)=>n.toFront()
        );
        // always add style tag to the <defs> for font embedding
        self.paper.def({
            tag: 'style',
            type: 'text/css',
            id: `embeddedSBStyles_${self.options.id}`
        });
        self.paper.def({
            tag: 'path',
            id: `raphael-marker-classic`,
            'stroke-linecap': 'round',
            d: 'M5,0 0,2.5 5,5 3.5,3 3.5,2z'
        });
        self.loadAllFonts();
        if (!blnSkipZoom) self.controller.centerOnNodes({
            dur: 0
        });
    }
    loadAllFonts() {
        // load all fonts
        const fonts = _lodashUniqDefault.default(this.nodes.allNodes.map((n)=>n.options.fontFamily
        )).join('|');
        if (document.getElementById('googleFonts')) document.getElementById('googleFonts').setAttribute('href', `https://fonts.googleapis.com/css?family=${fonts}`);
        else {
            const sc = document.createElement('link');
            sc.setAttribute('src', 'https://fonts.googleapis.com/css?family=${fonts}');
            sc.setAttribute('id', 'googleFonts');
            sc.setAttribute('rel', 'stylesheet');
            sc.setAttribute('type', 'text/css');
            document.head.appendChild(sc);
        }
    }
    displayLocks() {
        this.nodes.allNodes.forEach((nd)=>{
            nd.initLock();
        });
    }
    hideLocks() {
        this.nodes.allNodes.forEach((nd)=>{
            nd.hideLock();
        });
    }
    isReadOnly() {
        return !this.events.isReadOnly || this.events.isReadOnly && this.events.isReadOnly();
    }
    isCommentOnly() {
        return !this.events.isCommentOnly || this.events.isCommentOnly && this.events.isCommentOnly();
    }
    canRemoveComments() {
        return !this.events.canRemoveComments || this.events.canRemoveComments && this.events.canRemoveComments();
    }
    // the granularity is at the level of the node...
    exportDifference(compare, lineWidthOverride) {
        const _difOpts = {
            ...this.options
        };
        delete _difOpts.container;
        // birdsEye specific -- if this is not here, then locks
        // show up on the birdsEye
        _difOpts.showLocks = compare.options.showLocks;
        const jsonSlate = {
            options: JSON.parse(JSON.stringify(_difOpts)),
            nodes: []
        };
        const tnid = this.tempNodeId;
        this.nodes.allNodes.forEach((nd)=>{
            let _exists = false;
            const pn = nd;
            if (pn.options.id !== tnid) {
                compare.nodes.allNodes.forEach((nodeInner)=>{
                    if (nodeInner.options.id === pn.options.id) _exists = true;
                });
                if (!_exists) jsonSlate.nodes.push(pn.serialize(lineWidthOverride));
            }
        });
        return JSON.stringify(jsonSlate);
    }
    exportJSON() {
        const _cont = this.options.container;
        const _pcont = this.collaboration.panelContainer || null;
        const _callbacks = this.collaboration.callbacks || null;
        const _opts = this.options;
        delete _opts.container;
        const jsonSlate = {
            options: JSON.parse(JSON.stringify(_opts)),
            nodes: []
        };
        this.options.container = _cont;
        this.collaboration.panelContainer = _pcont;
        this.collaboration.callbacks = _callbacks;
        delete jsonSlate.options.ajax;
        delete jsonSlate.options.container;
        const tnid = this.tempNodeId;
        this.nodes.allNodes.forEach((nd)=>{
            if (nd.options.id !== tnid) jsonSlate.nodes.push(nd.serialize());
        });
        jsonSlate.shareId = this.shareId;
        return JSON.stringify(jsonSlate);
    }
    snapshot() {
        const _snap = JSON.parse(this.exportJSON());
        _snap.nodes.allNodes = _snap.nodes;
        return _snap;
    }
    getOrientation(_nodesToOrient, _alwaysOne) {
        let orient = 'landscape';
        let sWidth = this.options.viewPort.width;
        let sHeight = this.options.viewPort.height;
        const bb = [];
        bb.left = 99999;
        bb.right = 0;
        bb.top = 99999;
        bb.bottom = 0;
        const an = _nodesToOrient || this.nodes.allNodes;
        if (an.length > 0) {
            for(let _px = 0; _px < an.length; _px += 1){
                const sbw = 10;
                const _bb = an[_px].vect.getBBox();
                const _r = _alwaysOne ? 1 : this.options.viewPort.zoom.r || 1;
                const x = _bb.x * _r;
                const y = _bb.y * _r;
                const w = _bb.width * _r;
                const h = _bb.height * _r;
                bb.left = Math.abs(Math.min(bb.left, x - sbw));
                bb.right = Math.abs(Math.max(bb.right, x + w + sbw));
                bb.top = Math.abs(Math.min(bb.top, y - sbw));
                bb.bottom = Math.abs(Math.max(bb.bottom, y + h + sbw));
            }
            sWidth = bb.right - bb.left;
            sHeight = bb.bottom - bb.top;
            if (sHeight > sWidth) orient = 'portrait';
        }
        return {
            orientation: orient,
            height: sHeight,
            width: sWidth,
            left: bb.left,
            top: bb.top
        };
    }
    resize(_size, dur, pad) {
        let _p = pad || 0;
        if (_p < 6) _p = 6;
        _size -= _p * 2 || 0;
        const orx = this.getOrientation();
        const wp = orx.width / _size * this.options.viewPort.width;
        const hp = orx.height / _size * this.options.viewPort.height;
        const sp = Math.max(wp, hp);
        const _r = Math.max(this.options.viewPort.width, this.options.viewPort.height) / sp;
        const l = orx.left * _r - _p;
        const t = orx.top * _r - _p;
        this.zoom(0, 0, sp, sp, true);
        this.options.viewPort.zoom = {
            w: sp,
            h: sp,
            l: parseInt(l * -1, 10),
            t: parseInt(t * -1, 10),
            r: this.options.viewPort.originalWidth / sp
        };
        this.canvas.move({
            x: l,
            y: t,
            dur,
            isAbsolute: true
        });
    }
    disable(exemptSlate, exemptNodes, full) {
        if (!exemptNodes) this.nodes.allNodes.forEach((nd)=>{
            nd.disable();
        });
        if (!exemptSlate) {
            this.options.enabled = false;
            this.options.allowDrag = false;
            if (full) {
                this.multiSelection?.hideIcons();
                this.undoRedo?.hide();
                this.birdsEye?.disable();
                this.zoomSlider?.hide();
            }
        }
    }
    enable(exemptSlate, exemptNodes) {
        if (!exemptNodes) this.nodes.allNodes.forEach((nd)=>{
            !nd.options.isLocked && nd.enable();
        });
        if (!exemptSlate) {
            this.options.enabled = true;
            this.options.allowDrag = true;
        }
    }
    reorderNodes() {
        // these ids will come out in the order that they are painted on the screen - toFront and toBack adjusts this, so we need
        // to always keep this hand so that when the slate is reloaded, it can order the nodes by these ids (which are going to be dif
        // from the saved JSON order of arrays)
        const ids = Array.from(this.canvas.internal.querySelector('svg').querySelectorAll('path')).map((a)=>a.getAttribute('rel')
        ).filter((r)=>!!r
        );
        // console.log("order of nodes", ids);
        this.options.nodeOrder = ids;
    }
    findChildren(nodeIds, allChildren = []) {
        const self = this;
        // get his node's children - then recursively call findChildren on that node
        const nodes = self.nodes.allNodes.filter((n)=>nodeIds.includes(n.options.id)
        );
        allChildren = allChildren.concat(nodes.map((n)=>n.options.id
        ));
        const children = [];
        nodes.forEach((n)=>{
            n.relationships.associations.filter((a)=>a.parent.options.id === n.options.id
            ).forEach((a)=>children.push(a.child.options.id)
            );
        });
        if (children.length) return self.findChildren(children, allChildren);
        return allChildren;
    }
    applyTheme(theme, syncWithTheme, revertTheme) {
        const self = this;
        if (!revertTheme) {
            self.options.basedOnThemeId = theme._id;
            self.options.syncWithTheme = syncWithTheme;
        } else {
            self.options.basedOnThemeId = null;
            self.options.syncWithTheme = null;
        }
        const nodeStyle = {
        };
        const currentNodesByColor = {
        };
        const totChildren = [];
        // first apply slate
        if (theme.containerStyle.backgroundImage) self.collab.invoke({
            type: 'onSlateBackgroundImageChanged',
            data: {
                bg: {
                    size: theme.containerStyle.backgroundSize,
                    url: theme.containerStyle.backgroundImage
                }
            }
        });
        else if (theme.containerStyle.backgroundEffect) self.collab.invoke({
            type: 'onSlateBackgroundEffectChanged',
            data: {
                effect: theme.containerStyle.backgroundEffect
            }
        });
        else self.collab.invoke({
            type: 'onSlateBackgroundColorChanged',
            data: {
                color: theme.containerStyle.backgroundColor,
                asGradient: theme.containerStyle.backgroundColorAsGradient,
                gradientType: theme.containerStyle.backgroundGradientType,
                gradientColors: theme.containerStyle.backgroundGradientColors,
                gradientStrategy: theme.containerStyle.backgroundGradientStrategy
            }
        });
        self.collab.invoke({
            type: 'onLineColorChanged',
            data: {
                color: theme.defaultLineColor
            }
        });
        function applyStyle(id) {
            const allKeys = Object.keys(theme.styles);
            const lastStyle = theme.styles[allKeys[allKeys.length - 1]];
            const styleBase = theme.styles[nodeStyle[id]] || lastStyle;
            // borders
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderWidth',
                    val: styleBase.borderWidth
                }
            });
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderColor',
                    val: styleBase.borderColor
                }
            });
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderOpacity',
                    val: styleBase.borderOpacity
                }
            });
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderStyle',
                    val: styleBase.borderStyle
                }
            });
            // shape
            if (styleBase.vectorPath && syncWithTheme) // const node = self.nodes.one(id);
            // const sendPath = utils._transformPath(styleBase.vectorPath, `T${node.options.xPos},${node.options.xPos}`);
            self.collab.invoke({
                type: 'onNodeShapeChanged',
                data: {
                    id,
                    shape: styleBase.vectorPath
                }
            });
            // text
            self.collab.invoke({
                type: 'onNodeTextChanged',
                data: {
                    id,
                    fontSize: styleBase.fontSize,
                    fontFamily: styleBase.fontFamily,
                    fontColor: styleBase.foregroundColor,
                    textOpacity: styleBase.textOpacity
                }
            });
            // effects
            self.collab.invoke({
                type: 'onNodeEffectChanged',
                data: {
                    id,
                    filter: {
                        apply: 'text',
                        id: styleBase.filters.text
                    }
                }
            });
            // background color
            self.collab.invoke({
                type: 'onNodeColorChanged',
                data: {
                    id,
                    opacity: styleBase.opacity,
                    color: styleBase.backgroundColor
                }
            });
            // effects
            self.collab.invoke({
                type: 'onNodeEffectChanged',
                data: {
                    id,
                    filter: {
                        apply: 'vect',
                        id: styleBase.filters.vect
                    }
                }
            });
            // lines
            const styleNode = self.nodes.one(id);
            // console.log("node is ", id, node);
            styleNode.relationships.associations.forEach((a, ind)=>{
                self.collab.invoke({
                    type: 'onLineColorChanged',
                    data: {
                        id,
                        color: styleBase.lineColor
                    }
                });
                self.collab.invoke({
                    type: 'onLinePropertiesChanged',
                    data: {
                        id,
                        prop: 'lineOpacity',
                        val: styleBase.lineOpacity,
                        associationId: a.id,
                        index: ind
                    }
                });
                self.collab.invoke({
                    type: 'onLinePropertiesChanged',
                    data: {
                        id,
                        prop: 'lineEffect',
                        val: styleBase.lineEffect,
                        associationId: a.id,
                        index: ind
                    }
                });
                self.collab.invoke({
                    type: 'onLinePropertiesChanged',
                    data: {
                        id,
                        prop: 'lineWidth',
                        val: styleBase.lineWidth,
                        associationId: a.id,
                        index: ind
                    }
                });
            });
        }
        self.nodes.allNodes.forEach((nd)=>{
            if (self.options.mindMapMode || syncWithTheme) {
                const children = self.findChildren([
                    nd.options.id
                ]);
                totChildren.push(children);
            } else {
                if (!currentNodesByColor[nd.options.backgroundColor]) currentNodesByColor[nd.options.backgroundColor] = [];
                currentNodesByColor[nd.options.backgroundColor].push(nd.options.id);
            }
        });
        if (self.options.mindMapMode || syncWithTheme) {
            totChildren.sort((a, b)=>a.length - b.length
            );
            totChildren.forEach((t)=>{
                t.forEach((n, ind)=>{
                    nodeStyle[n] = ind === 0 ? `parent` : `child_${ind}`;
                });
            });
        } else {
            const colorsByUsage = Object.keys(currentNodesByColor).sort((a, b)=>currentNodesByColor[b].length - currentNodesByColor[a].length
            );
            let styleIndex = -1;
            colorsByUsage.forEach((c, index)=>{
                if (Object.keys(theme.styles).length < index) styleIndex = -1;
                styleIndex += 1;
                currentNodesByColor[c].forEach((id)=>{
                    nodeStyle[id] = styleIndex === 0 ? `parent` : `child_${styleIndex}`;
                });
            });
        }
        Object.keys(nodeStyle).forEach((id)=>{
            applyStyle(id);
        });
    }
}
exports.default = slate;

},{"lodash.uniq":"iDalh","deepmerge":"ck1Q2","../helpers/utils":"8QI6M","../helpers/getTransformedPath":"6wubb","../slate/canvas":"kpLaV","../slate/collab":"eYgJm","../slate/nodeController":"6wl7A","../slate/multiSelection":"kpcw7","../slate/birdsEye":"bRqCq","../slate/inertia":"l9OwD","../slate/controller":"2xnBR","../slate/zoomSlider":"6TbYF","../slate/undoRedo":"78ZfO","../slate/grid":"ixIFt","../slate/comments":"g3tty","../slate/keyboard":"fRVV4","../slate/filters":"JAVXJ","./base":"cmkOb","./node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDalh":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var funcTag = '[object Function]', genTag = '[object GeneratorFunction]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) return baseFindIndex(array, baseIsNaN, fromIndex);
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {
    }
    return result;
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var splice = arrayProto.splice;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, 'Map'), Set = getNative(root, 'Set'), nativeCreate = getNative(Object, 'create');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {
    };
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length)this.add(values[index]);
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */ function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) return setToArray(set);
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
    } else seen = iteratee ? [] : result;
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) continue outer;
            }
            if (iteratee) seen.push(computed);
            result.push(value);
        } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) seen.push(computed);
            result.push(value);
        }
    }
    return result;
}
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */ var createSet = !(Set && 1 / setToArray(new Set([
    ,
    -0
]))[1] == INFINITY) ? noop : function(values) {
    return new Set(values);
};
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e1) {
        }
    }
    return '';
}
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */ function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */ function noop() {
// No operation performed.
}
module.exports = uniq;

},{}],"ck1Q2":[function(require,module,exports) {
'use strict';
var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
    return !!value && typeof value === 'object';
}
function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 60103;
function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {
    };
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) return deepmerge;
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return target.propertyIsEnumerable(symbol);
    }) : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    } catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
     && Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
    ;
}
function mergeObject(target, source, options) {
    var destination = {
    };
    if (options.isMergeableObject(target)) getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
    getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) return;
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        else destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    });
    return destination;
}
function deepmerge(target, source, options) {
    options = options || {
    };
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) return cloneUnlessOtherwiseSpecified(source, options);
    else if (sourceIsArray) return options.arrayMerge(target, source, options);
    else return mergeObject(target, source, options);
}
deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) throw new Error('first argument should be an array');
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
    }, {
    });
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;

},{}],"8QI6M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ /* eslint-disable no-param-reassign */ /* eslint-disable no-return-assign */ var _raphaelSvg = require("../deps/raphael/raphael.svg");
class utils {
    static easing = {
        elastic (pos) {
            return -1 * 4 ** (-8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
        },
        swingFromTo (pos) {
            let s = 1.70158;
            return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
        },
        swingFrom (pos) {
            const s = 1.70158;
            return pos * pos * ((s + 1) * pos - s);
        },
        swingTo (pos) {
            const s = 1.70158;
            return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
        },
        bounce (pos) {
            if (pos < 1 / 2.75) return 7.5625 * pos * pos;
            if (pos < 2 / 2.75) return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
            if (pos < 2.5 / 2.75) return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
            return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
        },
        bouncePast (pos) {
            if (pos < 1 / 2.75) return 7.5625 * pos * pos;
            if (pos < 2 / 2.75) return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
            if (pos < 2.5 / 2.75) return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
            return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
        },
        easeFromTo (pos) {
            if ((pos /= 0.5) < 1) return 0.5 * pos ** 4;
            return -0.5 * ((pos -= 2) * pos ** 3 - 2);
        },
        easeFrom (pos) {
            return pos ** 4;
        },
        easeTo (pos) {
            return pos ** 0.25;
        },
        none (pos) {
            return -Math.cos(pos * Math.PI) / 2 + 0.5;
        }
    };
    static availColors = [
        {
            hex: '000000',
            to: '575757',
            fore: 'fff'
        },
        {
            hex: 'FFFFFF',
            to: 'd9d9d9',
            fore: '000'
        },
        {
            hex: 'FF0000',
            to: 'a31616',
            fore: '000'
        },
        {
            hex: 'C3FF68',
            to: 'afff68',
            fore: '000'
        },
        {
            hex: '0B486B',
            to: '3B88B5',
            fore: 'fff'
        },
        {
            hex: 'FBB829',
            to: 'cd900e',
            fore: '000'
        },
        {
            hex: 'BFF202',
            to: 'D1F940',
            fore: '000'
        },
        {
            hex: 'FF0066',
            to: 'aa1d55',
            fore: '000'
        },
        {
            hex: '800F25',
            to: '3d0812',
            fore: 'fff'
        },
        {
            hex: 'A40802',
            to: 'd70b03',
            fore: 'fff'
        },
        {
            hex: 'FF5EAA',
            to: 'cf5d93',
            fore: '000'
        },
        {
            hex: '740062',
            to: 'D962C6',
            fore: 'fff'
        },
        {
            hex: 'FF4242',
            to: 'A61515',
            fore: 'fff'
        },
        {
            hex: 'D15C57',
            to: '9D5C58',
            fore: '000'
        },
        {
            hex: 'FCFBE3',
            to: 'c9c56f',
            fore: '000'
        },
        {
            hex: 'FF9900',
            to: 'c98826',
            fore: '000'
        },
        {
            hex: '369001',
            to: '9CEE6C',
            fore: '000'
        },
        {
            hex: '9E906E',
            to: '675324',
            fore: 'fff'
        },
        {
            hex: 'F3D915',
            to: 'F9EA7C',
            fore: '000'
        },
        {
            hex: '031634',
            to: '2D579A',
            fore: 'fff'
        },
        {
            hex: '556270',
            to: '7b92ab',
            fore: 'fff'
        },
        {
            hex: '1693A5',
            to: '23aad6',
            fore: 'fff'
        },
        {
            hex: 'ADD8C7',
            to: '59a989',
            fore: '000'
        },
        {
            special: {
                // line options display only colors; node menu displays colors and transparent button
                color: {
                    hex: '8D5800',
                    to: 'EB9605'
                },
                other: {
                    transparent: true
                }
            }
        }, 
    ];
    static polygonCache = {
    };
    static async pause(millis) {
        return new Promise((resolve)=>{
            window.setTimeout(()=>{
                resolve();
            }, millis);
        });
    }
    static windowSize() {
        let w = 0;
        let h = 0;
        // IE
        if (!window.innerWidth) {
            // strict mode
            if (!(document.documentElement.clientWidth == 0)) {
                w = document.documentElement.clientWidth;
                h = document.documentElement.clientHeight;
            } else {
                w = document.body.clientWidth;
                h = document.body.clientHeight;
            }
        } else {
            w = window.innerWidth;
            h = window.innerHeight;
        }
        return {
            width: w,
            height: h
        };
    }
    static isElement(o) {
        return typeof HTMLElement === 'object' ? o instanceof HTMLElement // DOM2
         : typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';
    }
    // convenience
    static el(id) {
        if (id.indexOf('#') > -1 || id.indexOf('.') > -1) return document.querySelector(id);
        return document.getElementById(id);
    }
    // let arr = select("elem.className");
    static select(query) {
        const els = [];
        const index = query.indexOf('.');
        if (index !== -1) {
            const tag = query.slice(0, index) || '*';
            const klass = query.slice(index + 1, query.length);
            const all = document.getElementsByTagName(tag);
            for(let d = 0; d < all.length; d += 1){
                const elem = all[d];
                if (elem.className && elem.className.indexOf(klass) !== -1) els.push(elem);
            }
        }
        return els;
    }
    static getKey(e) {
        let keyCode = 0;
        try {
            keyCode = e.keyCode;
        } catch (Err) {
            keyCode = e.which;
        }
        return keyCode;
    }
    // fix event inconsistencies across browsers
    static stopEvent(e) {
        e = e || window.event;
        if (e.preventDefault) {
            e.stopPropagation();
            e.preventDefault();
        } else {
            e.returnValue = false;
            e.cancelBubble = true;
        }
        return false;
    }
    static toShortDateString(jsonDate) {
        let date = jsonDate;
        try {
            const d = new Date(parseInt(jsonDate.substr(6), 10));
            date = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        } catch (Err) {
        }
        return date;
    }
    static addEvent(obj, type, fn) {
        obj.addEventListener(type, fn);
    }
    static removeEvent(obj, type, fn) {
        obj.removeEventListener(type, fn);
    }
    // push an event listener into existing array of listeners
    static bind(to, evt, fn) {
        to[evt] = to[evt] || [];
        to[evt].push(fn);
    }
    static imageExists(u, cb, id) {
        const iid = `temp_${utils.guid()}`;
        const img = document.body.appendChild(document.createElement('img'));
        img.style.position = 'absolute';
        img.style.top = '-10000px';
        img.style.left = '-10000px';
        img.setAttribute('src', u);
        img.setAttribute('id', iid);
        this.addEvent(img, 'load', function(e) {
            const d = getDimensions(img);
            document.body.removeChild(img);
            cb.apply(this, [
                true,
                d.width,
                d.height,
                id
            ]);
        });
        this.addEvent(img, 'error', function(e) {
            document.body.removeChild(img);
            cb.apply(this, [
                false,
                0,
                0,
                id
            ]);
        });
    }
    static ajax(u, f, d, v, x, h) {
        x = this.ActiveXObject;
        // the guid is essential to break the cache because ie8< seems to want to cache this. argh.
        u = [
            u,
            u.indexOf('?') === -1 ? '?' : '&',
            `guid=${utils.guid()}`
        ].join('');
        x = new (x || XMLHttpRequest)('Microsoft.XMLHTTP');
        const vx = d ? v || 'POST' : v || 'GET';
        x.open(vx, u, 1);
        x.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        h.forEach((hElem)=>{
            x.setRequestHeader(hElem.n, hElem.v);
        });
        x.onreadystatechange = ()=>{
            // eslint-disable-next-line no-unused-expressions
            x.readyState > 3 && f && f(x.responseText, x);
        };
        x.send(d);
    }
    static hasClass(el, className) {
        if (el.classList) el.classList.contains(className);
        else new RegExp(`(^| )${className}( |$)`, 'gi').test(el.className);
    }
    static addClass(el, className) {
        if (el.classList) el.classList.add(className);
        else el.className += ` ${className}`;
    }
    static S4() {
        // eslint-disable-next-line no-bitwise
        return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
    }
    static guid() {
        return this.S4() + this.S4() + this.S4();
    }
    static getJSON(url, callback) {
        const id = this.S4() + this.S4();
        let script = document.createElement('script');
        const token = `__jsonp${id}`;
        // callback should be a global function
        window[token] = callback;
        // url should have "?" parameter which is to be replaced with a global callback name
        script.src = url.replace(/\?(&|$)/, `__jsonp${id}$1`);
        // clean up on load: remove script tag, null script variable and delete global callback function
        script.onload = ()=>{
            script = null;
        };
        document.getElementsByTagName('head')[0].appendChild(script);
    }
    static getBBox(opts) {
        const cont = document.createElement('div');
        cont.setAttribute('id', 'hiddenPaper');
        cont.style.display = 'none';
        document.body.appendChild(cont);
        const pp = new _raphaelSvg.Raphael(cont);
        const bb = pp.path(opts.path).getBBox();
        document.body.removeChild(cont);
        return bb;
    }
    static positionedOffset(obj) {
        let curleft = 0;
        let curtop = 0;
        if (obj.offsetParent) do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        // eslint-disable-next-line no-cond-assign
        }while (obj = obj.offsetParent)
        return {
            left: curleft,
            top: curtop
        };
    }
    static getDimensions(ele) {
        let width = 0;
        let height = 0;
        if (typeof ele.clip !== 'undefined') {
            width = ele.clip.width;
            height = ele.clip.height;
        } else if (ele.style?.pixelWidth) {
            width = ele.style.pixelWidth;
            height = ele.style.pixelHeight;
        } else {
            width = ele.offsetWidth;
            height = ele.offsetHeight;
        }
        return {
            width,
            height
        };
    }
    static mousePos(e) {
        let mouseX = null;
        let mouseY = null;
        const allTouches = [];
        if (e.targetTouches) {
            if (e.targetTouches.length) {
                const t = e.targetTouches[0];
                mouseX = t.clientX;
                mouseY = t.clientY;
                e.targetTouches.forEach((tx)=>{
                    allTouches.push({
                        x: e.targetTouches[tx].clientX,
                        y: e.targetTouches[tx].clientY
                    });
                });
            }
        } else {
            mouseX = e.pageX;
            mouseY = e.pageY;
        }
        return {
            x: mouseX,
            y: mouseY,
            allTouches
        };
    }
    static centerAndScalePathToFitContainer(opts) {
        // scale and transform the path to fit the box...
        // first get the bbox of the untouched path
        let bb = this.getBBox({
            path: opts.path
        });
        // calculate the scale of the path
        const scale = opts.scaleSize / Math.max(bb.width, bb.height);
        // scale the untouched path
        let newPath = this._transformPath(opts.path, [
            's',
            scale,
            ',',
            scale
        ].join(''));
        // go get the bbox of the scaled path
        bb = this.getBBox({
            path: newPath
        });
        // finally, move the scaled vector to the centered x,y coords
        // of the enclosed box
        const tp = [
            'T',
            bb.x * -1 + (opts.containerSize - bb.width) / 2,
            ',',
            bb.y * -1 + (opts.containerSize - bb.height) / 2, 
        ].join('');
        newPath = this._transformPath(newPath, tp);
        return {
            path: newPath,
            width: bb.width,
            height: bb.height
        };
    }
    static buildStyle(_styles) {
        let _str = '';
        Object.keys(_styles).forEach((k)=>{
            _str += `${k}:${_styles[k]};`;
        });
        return _str;
    }
    static whiteOrBlack(hex) {
        return _raphaelSvg.Raphael.rgb2hsb(hex).b < 0.4 ? '#fff' : '#000';
    }
    static _transformPath(original, transform) {
        const rpath = _raphaelSvg.Raphael.transformPath(original, transform).toString();
        return rpath;
    }
    static transformPath(_node, _transformation) {
        const _path = _raphaelSvg.Raphael.transformPath(_node.vect.attr('path').toString(), _transformation).toString();
        _node.options.vectorPath = _path;
        _node.vect.transform('');
        _node.vect.attr({
            path: _node.options.vectorPath
        });
        const bb = _node.vect.getBBox();
        const rotationContext = {
            point: {
                x: bb.cx,
                y: bb.cy
            }
        };
        Object.assign(_node.options.rotate, rotationContext);
        const transformString = _node.getTransformString();
        _node.vect.transform(transformString);
        _node.text.transform('');
        // xPos and yPos are updated in the setPosition in Slatebox.node.js
        _node.text.attr(_node.textCoords({
            x: _node.options.xPos,
            y: _node.options.yPos
        }));
        _node.text.transform(transformString);
    }
    static htmlToElement(html) {
        const template = document.createElement('template');
        html = html.trim();
        template.innerHTML = html;
        return template.content.firstChild;
    }
    static toDataUrl = (url)=>fetch(url, {
            mode: 'cors'
        }).then((response)=>response.blob()
        ).then((blob)=>new Promise((resolve, reject)=>{
                const reader = new FileReader();
                reader.onloadend = ()=>resolve(reader.result)
                ;
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            })
        )
    ;
}
exports.default = utils;

},{"../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jK21R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Raphael", ()=>Raphael
);
/* eslint-disable */ var _eveJs = require("../eve.js");
var _raphaelCoreJs = require("./raphael.core.js");
const Raphael = function() {
    const has = 'hasOwnProperty';
    const Str = String;
    const toFloat = parseFloat;
    const toInt = parseInt;
    const math = Math;
    const mmax = math.max;
    const { abs  } = math;
    const { pow  } = math;
    const separator = /[, ]+/;
    const E = '';
    const S = ' ';
    const xlink = 'http://www.w3.org/1999/xlink';
    const markers = {
        block: 'M5,0 0,2.5 5,5z',
        classic: 'M5,0 0,2.5 5,5 3.5,3 3.5,2z',
        diamond: 'M2.5,0 5,2.5 2.5,5 0,2.5z',
        open: 'M6,1 1,3.5 6,6',
        oval: 'M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z'
    };
    const markerCounter = {
    };
    var $ = function(el, attr) {
        if (attr) {
            if (typeof el === 'string') el = $(el);
            for(const key in attr)if (attr[has](key)) {
                if (key.substring(0, 6) == 'xlink:') el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                else el.setAttribute(key, Str(attr[key]));
            }
        } else {
            el = _raphaelCoreJs.R._g.doc.createElementNS('http://www.w3.org/2000/svg', el);
            el.style && (el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)');
        }
        return el;
    };
    const addGradientFill = function(element, gradient) {
        let type = 'linear';
        let id = element.id + gradient;
        let fx = 0.5;
        let fy = 0.5;
        const o = element.node;
        const SVG = element.paper;
        const s = o.style;
        let el = _raphaelCoreJs.R._g.doc.getElementById(id);
        if (!el) {
            gradient = Str(gradient).replace(_raphaelCoreJs.R._radial_gradient, (all, _fx, _fy)=>{
                type = 'radial';
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    const dir = (fy > 0.5) * 2 - (1)(fx - 0.5) ** 2 + (fy - 0.5) ** 2 > 0.25 && (fy = math.sqrt(0.25 - (fx - 0.5) ** 2) * dir + 0.5) && fy != 0.5 && (fy = fy.toFixed(5) - 0.00001 * dir);
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == 'linear') {
                let angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) return null;
                var vector = [
                    0,
                    0,
                    math.cos(_raphaelCoreJs.R.rad(angle)),
                    math.sin(_raphaelCoreJs.R.rad(angle))
                ];
                const max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            const dots = _raphaelCoreJs.R._parseDots(gradient);
            if (!dots) return null;
            id = id.replace(/[\(\)\s,\xb0#]/g, '_');
            if (element.gradient && id != element.gradient.id) {
                SVG.defs.removeChild(element.gradient);
                delete element.gradient;
            }
            if (!element.gradient) {
                el = $(`${type}Gradient`, {
                    id
                });
                element.gradient = el;
                $(el, type == 'radial' ? {
                    fx,
                    fy
                } : {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3],
                    gradientTransform: element.matrix.invert()
                });
                SVG.defs.appendChild(el);
                for(let i = 0, ii = dots.length; i < ii; i++)el.appendChild($('stop', {
                    offset: dots[i].offset ? dots[i].offset : i ? '100%' : '0%',
                    'stop-color': dots[i].color || '#fff',
                    'stop-opacity': isFinite(dots[i].opacity) ? dots[i].opacity : 1
                }));
            }
        }
        $(o, {
            fill: fillurl(id),
            opacity: 1,
            'fill-opacity': 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
    };
    const isIE9or10 = function() {
        const mode = document.documentMode;
        return mode && (mode === 9 || mode === 10);
    };
    var fillurl = function(id) {
        // SLATEBOX - always make the fillurl relative to the page, makes svg exports work
        return `url('#${id}')`;
    // if (isIE9or10()) {
    //     return "url('#" + id + "')";
    // }
    // var location = document.location;
    // var locationString = (
    //     location.protocol + '//' +
    //     location.host +
    //     location.pathname +
    //     location.search
    // );
    // return "url('" + locationString + "#" + id + "')";
    };
    // SLATEBOX - edit for image filling (not tiling patterns) of path elements
    const updatePosition = function(o) {
        if (!o.data('relativeFill')) {
            const bbox = o.getBBox(1);
            $(o.pattern, {
                patternTransform: `${o.matrix.invert()} translate(${bbox.x},${bbox.y})`
            });
        }
    };
    const addArrow = function(o, value, isEnd) {
        if (o.type == 'path') {
            const values = Str(value).toLowerCase().split('-');
            const p = o.paper;
            const se = isEnd ? 'end' : 'start';
            const { node  } = o;
            const { attrs  } = o;
            const stroke = attrs['stroke-width'];
            let i = values.length;
            let type = 'classic';
            let from;
            let to;
            let dx;
            let refX;
            let attr;
            let w = 3;
            let h = 3;
            let t = 5;
            while(i--)switch(values[i]){
                case 'block':
                case 'classic':
                case 'oval':
                case 'diamond':
                case 'open':
                case 'none':
                    type = values[i];
                    break;
                case 'wide':
                    h = 5;
                    break;
                case 'narrow':
                    h = 2;
                    break;
                case 'long':
                    w = 5;
                    break;
                case 'short':
                    w = 2;
                    break;
            }
            if (type == 'open') {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: 'none',
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: 'none'
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else o._.arrows = {
            };
            if (type != 'none') {
                const pathId = `raphael-marker-${type}`;
                const markerId = `raphael-marker-${se}${type}${w}${h}-obj${o.id}`;
                // SLATEBOX - addition to make sure arrows show in svg extract
                if (!_raphaelCoreJs.R._g.doc.getElementById(pathId) || _raphaelCoreJs.R._g.doc.getElementById(pathId) && getComputedStyle(_raphaelCoreJs.R._g.doc.getElementById(pathId)).display === 'none') {
                    p.defs.appendChild($($('path'), {
                        'stroke-linecap': 'round',
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else markerCounter[pathId]++;
                let marker = _raphaelCoreJs.R._g.doc.getElementById(markerId);
                let use;
                if (!marker) {
                    marker = $($('marker'), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: 'auto',
                        refX,
                        refY: h / 2
                    });
                    use = $($('use'), {
                        'xlink:href': `#${pathId}`,
                        transform: `${isEnd ? `rotate(180 ${w / 2} ${h / 2}) ` : E}scale(${w / t},${h / t})`,
                        'stroke-width': (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName('use')[0];
                }
                $(use, attr);
                const delta = dx * (type != 'diamond' && type != 'oval');
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = _raphaelCoreJs.R.getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = _raphaelCoreJs.R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {
                };
                attr[`marker-${se}`] = `url(#${markerId})`;
                if (to || from) attr.d = _raphaelCoreJs.R.getSubpath(attrs.path, from, to);
                $(node, attr);
                o._.arrows[`${se}Path`] = pathId;
                o._.arrows[`${se}Marker`] = markerId;
                o._.arrows[`${se}dx`] = delta;
                o._.arrows[`${se}Type`] = type;
                o._.arrows[`${se}String`] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = _raphaelCoreJs.R.getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = _raphaelCoreJs.R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[`${se}Path`] && $(node, {
                    d: _raphaelCoreJs.R.getSubpath(attrs.path, from, to)
                });
                delete o._.arrows[`${se}Path`];
                delete o._.arrows[`${se}Marker`];
                delete o._.arrows[`${se}dx`];
                delete o._.arrows[`${se}Type`];
                delete o._.arrows[`${se}String`];
            }
            for(attr in markerCounter)if (markerCounter[has](attr) && !markerCounter[attr]) {
                const item = _raphaelCoreJs.R._g.doc.getElementById(attr);
                item && item.parentNode.removeChild(item);
            }
        }
    };
    const dasharray = {
        '-': [
            3,
            1
        ],
        '.': [
            1,
            1
        ],
        '-.': [
            3,
            1,
            1,
            1
        ],
        '-..': [
            3,
            1,
            1,
            1,
            1,
            1
        ],
        '. ': [
            1,
            3
        ],
        '- ': [
            4,
            3
        ],
        '--': [
            8,
            3
        ],
        '- .': [
            4,
            3,
            1,
            3
        ],
        '--.': [
            8,
            3,
            1,
            3
        ],
        '--..': [
            8,
            3,
            1,
            3,
            1,
            3
        ]
    };
    const addDashes = function(o, value, params) {
        value = dasharray[Str(value).toLowerCase()];
        if (value) {
            const width = o.attrs['stroke-width'] || '1';
            const butt = {
                round: width,
                square: width,
                butt: 0
            }[o.attrs['stroke-linecap'] || params['stroke-linecap']] || 0;
            const dashes = [];
            let i = value.length;
            while(i--)dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
            $(o.node, {
                'stroke-dasharray': dashes.join(',')
            });
        } else $(o.node, {
            'stroke-dasharray': 'none'
        });
    };
    const setFillAndStroke = function(o, params) {
        const { node  } = o;
        const { attrs  } = o;
        const vis = node.style.visibility;
        node.style.visibility = 'hidden';
        for(let att in params)if (params[has](att)) {
            if (!_raphaelCoreJs.R._availableAttrs[has](att)) continue;
            let value = params[att];
            attrs[att] = value;
            switch(att){
                case 'blur':
                    o.blur(value);
                    break;
                case 'title':
                    var title = node.getElementsByTagName('title');
                    // Use the existing <title>.
                    if (title.length && (title = title[0])) title.firstChild.nodeValue = value;
                    else {
                        title = $('title');
                        const val = _raphaelCoreJs.R._g.doc.createTextNode(value);
                        title.appendChild(val);
                        node.appendChild(title);
                    }
                    break;
                case 'href':
                case 'target':
                    var pn = node.parentNode;
                    if (pn.tagName.toLowerCase() != 'a') {
                        const hl = $('a');
                        pn.insertBefore(hl, node);
                        hl.appendChild(node);
                        pn = hl;
                    }
                    if (att == 'target') pn.setAttributeNS(xlink, 'show', value == 'blank' ? 'new' : value);
                    else pn.setAttributeNS(xlink, att, value);
                    break;
                case 'cursor':
                    node.style.cursor = value;
                    break;
                case 'transform':
                    o.transform(value);
                    break;
                case 'arrow-start':
                    addArrow(o, value);
                    break;
                case 'arrow-end':
                    addArrow(o, value, 1);
                    break;
                case 'clip-rect':
                    var rect = Str(value).split(separator);
                    if (rect.length == 4) {
                        o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                        var el = $('clipPath');
                        const rc = $('rect');
                        el.id = _raphaelCoreJs.R.createUUID();
                        $(rc, {
                            x: rect[0],
                            y: rect[1],
                            width: rect[2],
                            height: rect[3]
                        });
                        el.appendChild(rc);
                        o.paper.defs.appendChild(el);
                        $(node, {
                            'clip-path': `url(#${el.id})`
                        });
                        o.clip = rc;
                    }
                    if (!value) {
                        const path = node.getAttribute('clip-path');
                        if (path) {
                            const clip = _raphaelCoreJs.R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                            clip && clip.parentNode.removeChild(clip);
                            $(node, {
                                'clip-path': E
                            });
                            delete o.clip;
                        }
                    }
                    break;
                case 'path':
                    // SLATEBOX - changed "$(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});"
                    // to $(node, {d: value ? attrs.path = value : "M0,0"}); in the line below -->
                    if (o.type == 'path') {
                        $(node, {
                            d: value ? attrs.path = value : 'M0,0'
                        }) // <--
                        ;
                        o._.dirty = 1;
                        if (o._.arrows) {
                            'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                            'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                    }
                    break;
                case 'width':
                    node.setAttribute(att, value);
                    o._.dirty = 1;
                    if (attrs.fx) {
                        att = 'x';
                        value = attrs.x;
                    } else break;
                case 'x':
                    if (attrs.fx) value = -attrs.x - (attrs.width || 0);
                case 'rx':
                    if (att == 'rx' && o.type == 'rect') break;
                case 'cx':
                    node.setAttribute(att, value);
                    o.pattern && updatePosition(o);
                    o._.dirty = 1;
                    break;
                case 'height':
                    node.setAttribute(att, value);
                    o._.dirty = 1;
                    if (attrs.fy) {
                        att = 'y';
                        value = attrs.y;
                    } else break;
                case 'y':
                    if (attrs.fy) value = -attrs.y - (attrs.height || 0);
                case 'ry':
                    if (att == 'ry' && o.type == 'rect') break;
                case 'cy':
                    node.setAttribute(att, value);
                    o.pattern && updatePosition(o);
                    o._.dirty = 1;
                    break;
                case 'r':
                    if (o.type == 'rect') $(node, {
                        rx: value,
                        ry: value
                    });
                    else node.setAttribute(att, value);
                    o._.dirty = 1;
                    break;
                case 'src':
                    if (o.type == 'image') node.setAttributeNS(xlink, 'href', value);
                    break;
                case 'stroke-width':
                    if (o._.sx != 1 || o._.sy != 1) value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                    node.setAttribute(att, value);
                    if (attrs['stroke-dasharray']) addDashes(o, attrs['stroke-dasharray'], params);
                    if (o._.arrows) {
                        'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                        'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                    }
                    break;
                case 'stroke-dasharray':
                    addDashes(o, value, params);
                    break;
                case 'fill':
                    // SLATEBOX a few edits for image filling (not tiling patterns) of path elements
                    var relativeFill = o.data('relativeFill');
                    var isURL = Str(value).match(_raphaelCoreJs.R._ISURL);
                    if (isURL) {
                        if (value.indexOf('(#') > -1) // internal reference
                        $(node, {
                            fill: value
                        });
                        else {
                            // image, external
                            el = $('pattern');
                            var ig = $('image');
                            el.id = _raphaelCoreJs.R.createUUID();
                            $(el, {
                                x: 0,
                                y: 0,
                                patternUnits: relativeFill ? 'objectBoundingBox' : 'userSpaceOnUse',
                                height: 1,
                                width: 1
                            });
                            $(ig, {
                                x: 0,
                                y: 0,
                                'xlink:href': isURL[1]
                            });
                            el.appendChild(ig);
                            (function(el) {
                                _raphaelCoreJs.R._preload(isURL[1], function() {
                                    const w = this.offsetWidth;
                                    const h = this.offsetHeight;
                                    const tempPath = o.paper.path(o.attr('path'));
                                    const bbox = tempPath.getBBox();
                                    $(el, {
                                        width: relativeFill ? 1 : w,
                                        height: relativeFill ? 1 : h
                                    });
                                    // SLATEBOX - image fixes for FF/safari
                                    $(ig, {
                                        width: relativeFill ? o.imageOrigWidth || bbox.width : w,
                                        height: relativeFill ? o.imageOrigHeight || bbox.height : h
                                    });
                                    delete o.imageOrigHeight;
                                    delete o.imageOrigWidth;
                                    tempPath.remove();
                                // end image fixes for SB
                                });
                            })(el);
                            o.paper.defs.appendChild(el);
                            $(node, {
                                fill: `url(#${el.id})`
                            });
                            o.pattern = el;
                            o.pattern && updatePosition(o);
                        }
                        break;
                    }
                    var clr = _raphaelCoreJs.R.getRGB(value);
                    if (!clr.error) {
                        delete params.gradient;
                        delete attrs.gradient;
                        !_raphaelCoreJs.R.is(attrs.opacity, 'undefined') && _raphaelCoreJs.R.is(params.opacity, 'undefined') && $(node, {
                            opacity: attrs.opacity
                        });
                        !_raphaelCoreJs.R.is(attrs['fill-opacity'], 'undefined') && _raphaelCoreJs.R.is(params['fill-opacity'], 'undefined') && $(node, {
                            'fill-opacity': attrs['fill-opacity']
                        });
                    } else if ((o.type == 'circle' || o.type == 'ellipse' || Str(value).charAt() != 'r') && addGradientFill(o, value)) {
                        if ('opacity' in attrs || 'fill-opacity' in attrs) {
                            var gradient = _raphaelCoreJs.R._g.doc.getElementById(node.getAttribute('fill').replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                var stops = gradient.getElementsByTagName('stop');
                                $(stops[stops.length - 1], {
                                    'stop-opacity': ('opacity' in attrs ? attrs.opacity : 1) * ('fill-opacity' in attrs ? attrs['fill-opacity'] : 1)
                                });
                            }
                        }
                        attrs.gradient = value;
                        attrs.fill = 'none';
                        break;
                    }
                    clr[has]('opacity') && $(node, {
                        'fill-opacity': clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                    });
                case 'stroke':
                    clr = _raphaelCoreJs.R.getRGB(value);
                    node.setAttribute(att, clr.hex);
                    att == 'stroke' && clr[has]('opacity') && $(node, {
                        'stroke-opacity': clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                    });
                    if (att == 'stroke' && o._.arrows) {
                        'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                        'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                    }
                    break;
                case 'gradient':
                    (o.type == 'circle' || o.type == 'ellipse' || Str(value).charAt() != 'r') && addGradientFill(o, value);
                    break;
                case 'opacity':
                    if (attrs.gradient && !attrs[has]('stroke-opacity')) $(node, {
                        'stroke-opacity': value > 1 ? value / 100 : value
                    });
                // fall
                case 'fill-opacity':
                    if (attrs.gradient) {
                        gradient = _raphaelCoreJs.R._g.doc.getElementById(node.getAttribute('fill').replace(/^url\(#|\)$/g, E));
                        if (gradient) {
                            stops = gradient.getElementsByTagName('stop');
                            $(stops[stops.length - 1], {
                                'stop-opacity': value
                            });
                        }
                        break;
                    }
                default:
                    att == 'font-size' && (value = `${toInt(value, 10)}px`);
                    var cssrule = att.replace(/(\-.)/g, (w)=>w.substring(1).toUpperCase()
                    );
                    node.style[cssrule] = value;
                    o._.dirty = 1;
                    node.setAttribute(att, value);
                    break;
            }
        }
        tuneText(o, params);
        node.style.visibility = vis;
    };
    const leading = 1.2;
    var tuneText = function(el, params) {
        if (el.type != 'text' || !(params[has]('text') || params[has]('font') || params[has]('font-size') || params[has]('x') || params[has]('y'))) return;
        const a = el.attrs;
        const { node  } = el;
        const fontSize = node.firstChild ? toInt(_raphaelCoreJs.R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue('font-size'), 10) : 10;
        if (params[has]('text')) {
            a.text = params.text;
            while(node.firstChild)node.removeChild(node.firstChild);
            const texts = Str(params.text).split('\n');
            var tspans = [];
            let tspan;
            for(var i = 0, ii = texts.length; i < ii; i++){
                tspan = $('tspan');
                i && $(tspan, {
                    dy: fontSize * leading,
                    x: a.x
                });
                tspan.appendChild(_raphaelCoreJs.R._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
        } else {
            tspans = node.getElementsByTagName('tspan');
            for(i = 0, ii = tspans.length; i < ii; i++)if (i) $(tspans[i], {
                dy: fontSize * leading,
                x: a.x
            });
            else $(tspans[0], {
                dy: 0
            });
        }
        $(node, {
            x: a.x,
            y: a.y
        });
        el._.dirty = 1;
        const bb = el._getBBox();
        const dif = a.y - (bb.y + bb.height / 2);
        dif && _raphaelCoreJs.R.is(dif, 'finite') && $(tspans[0], {
            dy: dif
        });
    };
    const getRealNode = function(node) {
        if (node.parentNode && node.parentNode.tagName.toLowerCase() === 'a') return node.parentNode;
        return node;
    };
    const Element = function(node, svg) {
        const X = 0;
        const Y = 0;
        /* \
       * Element.node
       [ property (object) ]
       **
       * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
       **
       * Note: Don’t mess with it.
       > Usage
       | // draw a circle at coordinate 10,10 with radius of 10
       | var c = paper.circle(10, 10, 10);
       | c.node.onclick = function () {
       |     c.attr("fill", "red");
       | };
      \ */ this[0] = this.node = node;
        /* \
       * Element.raphael
       [ property (object) ]
       **
       * Internal reference to @Raphael object. In case it is not available.
       > Usage
       | Raphael.el.red = function () {
       |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
       |     hsb.h = 1;
       |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
       | }
      \ */ node.raphael = true;
        /* \
       * Element.id
       [ property (number) ]
       **
       * Unique id of the element. Especially useful when you want to listen to events of the element,
       * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
      \ */ this.id = guid();
        node.raphaelid = this.id;
        /**
     * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements
     * @returns {string} id
     */ function guid() {
            return `0000${(Math.random() * 36 ** 5 << 0).toString(36)}`.slice(-5);
        }
        this.matrix = _raphaelCoreJs.R.matrix();
        this.realPath = null;
        /* \
       * Element.paper
       [ property (object) ]
       **
       * Internal reference to “paper” where object drawn. Mainly for use in plugins and element extensions.
       > Usage
       | Raphael.el.cross = function () {
       |     this.attr({fill: "red"});
       |     this.paper.path("M10,10L50,50M50,10L10,50")
       |         .attr({stroke: "red"});
       | }
      \ */ this.paper = svg;
        this.attrs = this.attrs || {
        };
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };
        !svg.bottom && (svg.bottom = this);
        /* \
       * Element.prev
       [ property (object) ]
       **
       * Reference to the previous element in the hierarchy.
      \ */ this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        /* \
       * Element.next
       [ property (object) ]
       **
       * Reference to the next element in the hierarchy.
      \ */ this.next = null;
    };
    const elproto = _raphaelCoreJs.R.el;
    Element.prototype = elproto;
    elproto.constructor = Element;
    _raphaelCoreJs.R._engine.path = function(pathString, SVG) {
        const el = $('path');
        SVG.canvas && SVG.canvas.appendChild(el);
        const p = new Element(el, SVG);
        p.type = 'path';
        setFillAndStroke(p, {
            fill: 'none',
            stroke: '#000',
            path: pathString
        });
        return p;
    };
    /* \
   * Element.rotate
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds rotation by given angle around given point to the list of
   * transformations of the element.
   > Parameters
   - deg (number) angle in degrees
   - cx (number) #optional x coordinate of the centre of rotation
   - cy (number) #optional y coordinate of the centre of rotation
   * If cx & cy aren’t specified centre of the shape is used as a point of rotation.
   = (object) @Element
  \ */ elproto.rotate = function(deg, cx, cy) {
        if (this.removed) return this;
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            const bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([
            [
                'r',
                deg,
                cx,
                cy
            ]
        ]));
        return this;
    };
    /* \
   * Element.scale
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds scale by given amount relative to given point to the list of
   * transformations of the element.
   > Parameters
   - sx (number) horisontal scale amount
   - sy (number) vertical scale amount
   - cx (number) #optional x coordinate of the centre of scale
   - cy (number) #optional y coordinate of the centre of scale
   * If cx & cy aren’t specified centre of the shape is used instead.
   = (object) @Element
  \ */ elproto.scale = function(sx, sy, cx, cy) {
        if (this.removed) return this;
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        sy == null && (sy = sx);
        cy == null && (cx = cy);
        if (cx == null || cy == null) var bbox = this.getBBox(1);
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([
            [
                's',
                sx,
                sy,
                cx,
                cy
            ]
        ]));
        return this;
    };
    /* \
   * Element.translate
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds translation by given amount to the list of transformations of the element.
   > Parameters
   - dx (number) horisontal shift
   - dy (number) vertical shift
   = (object) @Element
  \ */ elproto.translate = function(dx, dy) {
        if (this.removed) return this;
        dx = Str(dx).split(separator);
        if (dx.length - 1) dy = toFloat(dx[1]);
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([
            [
                't',
                dx,
                dy
            ]
        ]));
        return this;
    };
    /* \
   * Element.transform
   [ method ]
   **
   * Adds transformation to the element which is separate to other attributes,
   * i.e. translation doesn’t change `x` or `y` of the rectange. The format
   * of transformation string is similar to the path string syntax:
   | "t100,100r30,100,100s2,2,100,100r45s1.5"
   * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
   * scale and `m` is for matrix.
   *
   * There are also alternative “absolute” translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
   *
   * So, the example line above could be read like “translate by 100, 100; rotate 30° around 100, 100; scale twice around 100, 100;
   * rotate 45° around centre; scale 1.5 times relative to centre”. As you can see rotate and scale commands have origin
   * coordinates as optional parameters, the default is the centre point of the element.
   * Matrix accepts six parameters.
   > Usage
   | var el = paper.rect(10, 20, 300, 200);
   | // translate 100, 100, rotate 45°, translate -100, 0
   | el.transform("t100,100r45t-100,0");
   | // if you want you can append or prepend transformations
   | el.transform("...t50,50");
   | el.transform("s2...");
   | // or even wrap
   | el.transform("t50,50...t-50-50");
   | // to reset transformation call method with empty string
   | el.transform("");
   | // to get current value call it without parameters
   | console.log(el.transform());
   > Parameters
   - tstr (string) #optional transformation string
   * If tstr isn’t specified
   = (string) current transformation string
   * else
   = (object) @Element
  \ */ elproto.transform = function(tstr) {
        const { _  } = this;
        if (tstr == null) return _.transform;
        _raphaelCoreJs.R._extractTransform(this, tstr);
        this.clip && $(this.clip, {
            transform: this.matrix.invert()
        });
        this.pattern && updatePosition(this);
        this.node && $(this.node, {
            transform: this.matrix
        });
        if (_.sx != 1 || _.sy != 1) {
            const sw = this.attrs[has]('stroke-width') ? this.attrs['stroke-width'] : 1;
            this.attr({
                'stroke-width': sw
            });
        }
        return this;
    };
    /* \
   * Element.hide
   [ method ]
   **
   * Makes element invisible. See @Element.show.
   = (object) @Element
  \ */ elproto.hide = function() {
        if (!this.removed) this.node.style.display = 'none';
        return this;
    };
    /* \
   * Element.show
   [ method ]
   **
   * Makes element visible. See @Element.hide.
   = (object) @Element
  \ */ elproto.show = function() {
        if (!this.removed) this.node.style.display = '';
        return this;
    };
    /* \
   * Element.remove
   [ method ]
   **
   * Removes element from the paper.
  \ */ elproto.remove = function() {
        const node = getRealNode(this.node);
        if (this.removed || !node.parentNode) return;
        const { paper  } = this;
        paper.__set__ && paper.__set__.exclude(this);
        _eveJs.eve.unbind(`raphael.*.*.${this.id}`);
        if (this.gradient) paper.defs.removeChild(this.gradient);
        _raphaelCoreJs.R._tear(this, paper);
        node.parentNode.removeChild(node);
        // Remove custom data for element
        this.removeData();
        for(const i in this)this[i] = typeof this[i] === 'function' ? _raphaelCoreJs.R._removedFactory(i) : null;
        this.removed = true;
    };
    elproto._getBBox = function() {
        if (this.node.style.display == 'none') {
            this.show();
            var hide = true;
        }
        let canvasHidden = false;
        let containerStyle;
        if (this.paper.canvas.parentElement) containerStyle = this.paper.canvas.parentElement.style;
        else if (this.paper.canvas.parentNode) containerStyle = this.paper.canvas.parentNode.style;
        if (containerStyle && containerStyle.display == 'none') {
            canvasHidden = true;
            containerStyle.display = '';
        }
        let bbox = {
        };
        try {
            bbox = this.node.getBBox();
        } catch (e) {
            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
            bbox = {
                x: this.node.clientLeft,
                y: this.node.clientTop,
                width: this.node.clientWidth,
                height: this.node.clientHeight
            };
        } finally{
            bbox = bbox || {
            };
            if (canvasHidden) containerStyle.display = 'none';
        }
        hide && this.hide();
        return bbox;
    };
    /* \
   * Element.attr
   [ method ]
   **
   * Sets the attributes of the element.
   > Parameters
   - attrName (string) attribute’s name
   - value (string) value
   * or
   - params (object) object of name/value pairs
   * or
   - attrName (string) attribute’s name
   * or
   - attrNames (array) in this case method returns array of current values for given attribute names
   = (object) @Element if attrsName & value or params are passed in.
   = (...) value of the attribute if only attrsName is passed in.
   = (array) array of values of the attribute if attrsNames is passed in.
   = (object) object of attributes if nothing is passed in.
   > Possible parameters
   # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
   o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
   o clip-rect (string) comma or space separated values: x, y, width and height
   o cursor (string) CSS type of the cursor
   o cx (number) the x-axis coordinate of the center of the circle, or ellipse
   o cy (number) the y-axis coordinate of the center of the circle, or ellipse
   o fill (string) colour, gradient or image
   o fill-opacity (number)
   o font (string)
   o font-family (string)
   o font-size (number) font size in pixels
   o font-weight (string)
   o height (number)
   o href (string) URL, if specified element behaves as hyperlink
   o opacity (number)
   o path (string) SVG path string format
   o r (number) radius of the circle, ellipse or rounded corner on the rect
   o rx (number) horisontal radius of the ellipse
   o ry (number) vertical radius of the ellipse
   o src (string) image URL, only works for @Element.image element
   o stroke (string) stroke colour
   o stroke-dasharray (string) [“”, “none”, “`-`”, “`.`”, “`-.`”, “`-..`”, “`. `”, “`- `”, “`--`”, “`- .`”, “`--.`”, “`--..`”]
   o stroke-linecap (string) [“`butt`”, “`square`”, “`round`”]
   o stroke-linejoin (string) [“`bevel`”, “`round`”, “`miter`”]
   o stroke-miterlimit (number)
   o stroke-opacity (number)
   o stroke-width (number) stroke width in pixels, default is '1'
   o target (string) used with href
   o text (string) contents of the text element. Use `\n` for multiline text
   o text-anchor (string) [“`start`”, “`middle`”, “`end`”], default is “`middle`”
   o title (string) will create tooltip with a given text
   o transform (string) see @Element.transform
   o width (number)
   o x (number)
   o y (number)
   > Gradients
   * Linear gradient format: “`‹angle›-‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`90-#fff-#000`” – 90°
   * gradient from white to black or “`0-#fff-#f00:20-#000`” – 0° gradient from white via red (at 20%) to black.
   *
   * radial gradient: “`r[(‹fx›, ‹fy›)]‹colour›[-‹colour›[:‹offset›]]*-‹colour›`”, example: “`r#fff-#000`” –
   * gradient from white to black or “`r(0.25, 0.75)#fff-#000`” – gradient from white to black with focus point
   * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
   > Path String
   # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path’s data attribute’s format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphaël fully supports it.</p>
   > Colour Parsing
   # <ul>
   #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
   #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
   #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
   #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
   #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
   #     <li>rgba(•••, •••, •••, •••) — red, green and blue channels’ values: (“<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>”)</li>
   #     <li>rgba(•••%, •••%, •••%, •••%) — same as above, but in %: (“<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>”)</li>
   #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
   #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
   #     <li>hsba(•••, •••, •••, •••) — same as above, but with opacity</li>
   #     <li>hsl(•••, •••, •••) — almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
   #     <li>hsl(•••%, •••%, •••%) — same as above, but in %</li>
   #     <li>hsla(•••, •••, •••, •••) — same as above, but with opacity</li>
   #     <li>Optionally for hsb and hsl you could specify hue as a degree: “<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>” or, if you want to go fancy, “<code>hsl(240°,&nbsp;1,&nbsp;.5)</code>”</li>
   # </ul>
  \ */ elproto.attr = function(name, value) {
        if (this.removed) return this;
        if (name == null) {
            const res = {
            };
            for(const a in this.attrs)if (this.attrs[has](a)) res[a] = this.attrs[a];
            res.gradient && res.fill == 'none' && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && _raphaelCoreJs.R.is(name, 'string')) {
            if (name == 'fill' && this.attrs.fill == 'none' && this.attrs.gradient) return this.attrs.gradient;
            if (name == 'transform') return this._.transform;
            const names = name.split(separator);
            var out = {
            };
            for(var i = 0, ii = names.length; i < ii; i++){
                name = names[i];
                if (name in this.attrs) out[name] = this.attrs[name];
                else if (_raphaelCoreJs.R.is(this.paper.customAttributes[name], 'function')) out[name] = this.paper.customAttributes[name].def;
                else out[name] = _raphaelCoreJs.R._availableAttrs[name];
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && _raphaelCoreJs.R.is(name, 'array')) {
            out = {
            };
            for(i = 0, ii = name.length; i < ii; i++)out[name[i]] = this.attr(name[i]);
            return out;
        }
        if (value != null) {
            var params = {
            };
            params[name] = value;
        } else if (name != null && _raphaelCoreJs.R.is(name, 'object')) params = name;
        for(var key in params)_eveJs.eve(`raphael.attr.${key}.${this.id}`, this, params[key]);
        for(key in this.paper.customAttributes)if (this.paper.customAttributes[has](key) && params[has](key) && _raphaelCoreJs.R.is(this.paper.customAttributes[key], 'function')) {
            const par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for(const subkey in par)if (par[has](subkey)) params[subkey] = par[subkey];
        }
        setFillAndStroke(this, params);
        return this;
    };
    /* \
   * Element.toFront
   [ method ]
   **
   * Moves the element so it is the closest to the viewer’s eyes, on top of other elements.
   = (object) @Element
  \ */ elproto.toFront = function() {
        if (this.removed) return this;
        const node = getRealNode(this.node);
        node.parentNode.appendChild(node);
        const svg = this.paper;
        svg.top != this && _raphaelCoreJs.R._tofront(this, svg);
        return this;
    };
    /* \
   * Element.toBack
   [ method ]
   **
   * Moves the element so it is the furthest from the viewer’s eyes, behind other elements.
   = (object) @Element
  \ */ elproto.toBack = function() {
        if (this.removed) return this;
        const node = getRealNode(this.node);
        const { parentNode  } = node;
        parentNode.insertBefore(node, parentNode.firstChild);
        _raphaelCoreJs.R._toback(this, this.paper);
        const svg = this.paper;
        return this;
    };
    /* \
   * Element.insertAfter
   [ method ]
   **
   * Inserts current object after the given one.
   = (object) @Element
  \ */ elproto.insertAfter = function(element) {
        if (this.removed || !element) return this;
        const node = getRealNode(this.node);
        const afterNode = getRealNode(element.node || element[element.length - 1].node);
        if (afterNode.nextSibling) afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
        else afterNode.parentNode.appendChild(node);
        _raphaelCoreJs.R._insertafter(this, element, this.paper);
        return this;
    };
    /* \
   * Element.insertBefore
   [ method ]
   **
   * Inserts current object before the given one.
   = (object) @Element
  \ */ elproto.insertBefore = function(element) {
        if (this.removed || !element) return this;
        const node = getRealNode(this.node);
        const beforeNode = getRealNode(element.node || element[0].node);
        beforeNode.parentNode.insertBefore(node, beforeNode);
        _raphaelCoreJs.R._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function(size) {
        // Experimental. No Safari support. Use it on your own risk.
        const t = this;
        if (+size !== 0) {
            const fltr = $('filter');
            const blur = $('feGaussianBlur');
            t.attrs.blur = size;
            fltr.id = _raphaelCoreJs.R.createUUID();
            $(blur, {
                stdDeviation: +size || 1.5
            });
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {
                filter: `url(#${fltr.id})`
            });
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute('filter');
        }
        return t;
    };
    _raphaelCoreJs.R._engine.circle = function(svg, x, y, r) {
        const el = $('circle');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            cx: x,
            cy: y,
            r,
            fill: 'none',
            stroke: '#000'
        };
        res.type = 'circle';
        $(el, res.attrs);
        return res;
    };
    _raphaelCoreJs.R._engine.rect = function(svg, x, y, w, h, r) {
        const el = $('rect');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            width: w,
            height: h,
            rx: r || 0,
            ry: r || 0,
            fill: 'none',
            stroke: '#000'
        };
        res.type = 'rect';
        $(el, res.attrs);
        return res;
    };
    _raphaelCoreJs.R._engine.g = function(svg) {
        const el = $('g');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.type = 'g';
        res.canvas = res.node;
        // adding support for adding elements inside <g>
        const elements = [
            'circle',
            'rect',
            'ellipse',
            'image',
            'text',
            'g',
            'path'
        ];
        elements.forEach((element)=>{
            res[element] = function() {
                const args = [
                    res
                ];
                for(let i = 0; i < arguments.length; i++)args.push(arguments[i]);
                const out = _raphaelCoreJs.R._engine[element].apply(this, args);
                return out;
            };
        });
        $(el, res.attrs);
        return res;
    };
    _raphaelCoreJs.R._engine.def = function(def) {
        // SLATEBOX - add ability to programattically add defs
        // {
        //   type: "pattern",
        //   id: "smallGrid",
        //   height: 10,
        //   width: 10,
        //   patternUnits: "userSpaceOnUse",
        //   inside: {
        //     type: "path",
        //     attrs: {
        //       d: "M 10 0 L 0 0 0 10",
        //       fill: "none",
        //       stroke: "gray",
        //       "stroke-width": "0.5"
        //     }
        //   }
        // }
        /*
      <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
        <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" stroke-width="0.5"/>
      </pattern>
    */ const id = def.id || `raphael-def-${_raphaelCoreJs.R.createUUID()}`;
        // if exists, remove and rebuild
        const exists = Array.prototype.slice.call(this.defs.children).find((c)=>c.getAttribute('id') === id
        );
        exists && this.defs.removeChild(exists);
        const defOpts = {
            id
        };
        Object.assign(defOpts, {
            ...def
        });
        // no need to have inside=[object object] as it is used elsewhere below
        delete defOpts.inside;
        // if (def.height != null) defOpts.height = def.height;
        // if (def.width != null) defOpts.width = def.width;
        // switch (def.type) {
        //   case "pattern": {
        //     defOpts.patternUnits = def.patternUnits || "userSpaceOnUse";
        //     break;
        //   }
        //   case "filter": {
        //     if (def.x != null) defOpts.x = def.x;
        //     if (def.y != null) defOpts.y = def.y;
        //     break;
        //   }
        //   case "style": {
        //     defOpts.type = "text/css";
        //     break;
        //   }
        //   case "path": {
        //     Object.assign(defOpts, {...def});
        //     break;
        //   }
        // }
        // always rebuild
        const rDef = $($(def.tag || 'pattern'), defOpts);
        if (def.inside) def.inside.forEach((i)=>{
            const ins = $($(i.type), i.attrs || {
            });
            rDef.appendChild(ins);
            if (i.nested) {
                if (i.nested.forEach) i.nested.forEach((nx)=>{
                    const nest = $($(nx.type), nx.attrs || {
                    });
                    ins.appendChild(nest);
                });
                else Object.keys(i.nested).forEach((n)=>{
                    const nest = $($(n), i.nested[n] || {
                    });
                    ins.appendChild(nest);
                });
            }
        });
        this.defs.appendChild(rDef);
    };
    _raphaelCoreJs.R._engine.ellipse = function(svg, x, y, rx, ry) {
        const el = $('ellipse');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            cx: x,
            cy: y,
            rx,
            ry,
            fill: 'none',
            stroke: '#000'
        };
        res.type = 'ellipse';
        $(el, res.attrs);
        return res;
    };
    _raphaelCoreJs.R._engine.image = function(svg, src, x, y, w, h) {
        const el = $('image');
        $(el, {
            x,
            y,
            width: w,
            height: h,
            preserveAspectRatio: 'none'
        });
        el.setAttributeNS(xlink, 'href', src);
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            width: w,
            height: h,
            src
        };
        res.type = 'image';
        return res;
    };
    _raphaelCoreJs.R._engine.text = function(svg, x, y, text) {
        const el = $('text');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            'text-anchor': 'middle',
            text,
            'font-family': _raphaelCoreJs.R._availableAttrs['font-family'],
            'font-size': _raphaelCoreJs.R._availableAttrs['font-size'],
            stroke: 'none',
            fill: '#000'
        };
        res.type = 'text';
        setFillAndStroke(res, res.attrs);
        return res;
    };
    _raphaelCoreJs.R._engine.setSize = function(width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute('width', this.width);
        this.canvas.setAttribute('height', this.height);
        if (this._viewBox) this.setViewBox.apply(this, this._viewBox);
        return this;
    };
    _raphaelCoreJs.R._engine.create = function() {
        const con = _raphaelCoreJs.R._getContainer.apply(0, arguments);
        let container = con && con.container;
        let { x  } = con;
        let { y  } = con;
        let { width  } = con;
        let { height  } = con;
        if (!container) throw new Error('SVG container not found.');
        const cnvs = $('svg');
        const css = 'overflow:hidden;';
        let isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height,
            width,
            xmlns: 'http://www.w3.org/2000/svg'
        });
        if (container == 1) {
            cnvs.style.cssText = `${css}position:absolute;left:${x}px;top:${y}px`;
            _raphaelCoreJs.R._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = `${css}position:relative`;
            if (container.firstChild) container.insertBefore(cnvs, container.firstChild);
            else container.appendChild(cnvs);
        }
        container = new _raphaelCoreJs.R._Paper();
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function() {
        });
        container.renderfix();
        return container;
    };
    _raphaelCoreJs.R._engine.setViewBox = function(x, y, w, h, fit) {
        _eveJs.eve('raphael.setViewBox', this, this._viewBox, [
            x,
            y,
            w,
            h,
            fit
        ]);
        const paperSize = this.getSize();
        let size = mmax(w / paperSize.width, h / paperSize.height);
        let { top  } = this;
        const aspectRatio = fit ? 'xMidYMid meet' : 'xMinYMin';
        let vb;
        let sw;
        if (x == null) {
            if (this._vbSize) size = 1;
            delete this._vbSize;
            vb = `0 0 ${this.width}${S}${this.height}`;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while(size && top){
            sw = 'stroke-width' in top.attrs ? top.attrs['stroke-width'] : 1;
            top.attr({
                'stroke-width': sw
            });
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [
            x,
            y,
            w,
            h,
            !!fit
        ];
        return this;
    };
    /* \
   * Paper.renderfix
   [ method ]
   **
   * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent
   * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
   * This method fixes the issue.
   **
     Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
  \ */ _raphaelCoreJs.R.prototype.renderfix = function() {
        const cnvs = this.canvas;
        const s = cnvs.style;
        let pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        const left = -pos.e % 1;
        const top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = `${this._left}px`;
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = `${this._top}px`;
            }
        }
    };
    /* \
   * Paper.clear
   [ method ]
   **
   * Clears the paper, i.e. removes all the elements.
  \ */ _raphaelCoreJs.R.prototype.clear = function() {
        _raphaelCoreJs.R.eve('raphael.clear', this);
        const c = this.canvas;
        while(c.firstChild)c.removeChild(c.firstChild);
        this.bottom = this.top = null;
        c.appendChild(this.defs = $('defs'));
    };
    /* \
   * Paper.remove
   [ method ]
   **
   * Removes the paper from the DOM.
  \ */ _raphaelCoreJs.R.prototype.remove = function() {
        _eveJs.eve('raphael.remove', this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for(const i in this)this[i] = typeof this[i] === 'function' ? _raphaelCoreJs.R._removedFactory(i) : null;
    };
    const setproto = _raphaelCoreJs.R.st;
    for(const method in elproto)if (elproto[has](method) && !setproto[has](method)) setproto[method] = (function(methodname) {
        return function() {
            const arg = arguments;
            return this.forEach((el)=>{
                el[methodname].apply(el, arg);
            });
        };
    })(method);
    return _raphaelCoreJs.R;
}();

},{"../eve.js":"9FQ0M","./raphael.core.js":"5SUq7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9FQ0M":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eve", ()=>eve
);
const eve = function() {
    var version = "0.5.4", has = "hasOwnProperty", separator = /[\.\/]/, comaseparator = /\s*,\s*/, wildcard = "*", numsort = function(a, b) {
        return a - b;
    }, current_event, stop, events = {
        n: {
        }
    }, firstDefined = function() {
        for(var i = 0, ii = this.length; i < ii; i++){
            if (typeof this[i] != "undefined") return this[i];
        }
    }, lastDefined = function() {
        var i = this.length;
        while(--i){
            if (typeof this[i] != "undefined") return this[i];
        }
    }, objtos = Object.prototype.toString, Str = String, isArray = Array.isArray || function(ar) {
        return ar instanceof Array || objtos.call(ar) == "[object Array]";
    }, /*\
   * eve
   [ method ]

   * Fires event with given `name`, given scope and other parameters.

   - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
   - scope (object) context for the event handlers
   - varargs (...) the rest of arguments will be sent to event handlers

   = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
  \*/ eve1 = function(name, scope) {
        var oldstop = stop, args = Array.prototype.slice.call(arguments, 2), listeners = eve1.listeners(name), z = 0, l, indexed = [], queue = {
        }, out = [], ce = current_event;
        out.firstDefined = firstDefined;
        out.lastDefined = lastDefined;
        current_event = name;
        stop = 0;
        for(var i = 0, ii = listeners.length; i < ii; i++)if ("zIndex" in listeners[i]) {
            indexed.push(listeners[i].zIndex);
            if (listeners[i].zIndex < 0) queue[listeners[i].zIndex] = listeners[i];
        }
        indexed.sort(numsort);
        while(indexed[z] < 0){
            l = queue[indexed[z++]];
            out.push(l.apply(scope, args));
            if (stop) {
                stop = oldstop;
                return out;
            }
        }
        for(i = 0; i < ii; i++){
            l = listeners[i];
            if ("zIndex" in l) {
                if (l.zIndex == indexed[z]) {
                    out.push(l.apply(scope, args));
                    if (stop) break;
                    do {
                        z++;
                        l = queue[indexed[z]];
                        l && out.push(l.apply(scope, args));
                        if (stop) break;
                    }while (l)
                } else queue[l.zIndex] = l;
            } else {
                out.push(l.apply(scope, args));
                if (stop) break;
            }
        }
        stop = oldstop;
        current_event = ce;
        return out;
    };
    // Undocumented. Debug only.
    eve1._events = events;
    /*\
   * eve.listeners
   [ method ]

   * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

   - name (string) name of the event, dot (`.`) or slash (`/`) separated

   = (array) array of event handlers
  \*/ eve1.listeners = function(name) {
        var names = isArray(name) ? name : name.split(separator), e = events, item, items, k, i, ii, j, jj, nes, es = [
            e
        ], out = [];
        for(i = 0, ii = names.length; i < ii; i++){
            nes = [];
            for(j = 0, jj = es.length; j < jj; j++){
                e = es[j].n;
                items = [
                    e[names[i]],
                    e[wildcard]
                ];
                k = 2;
                while(k--){
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
   * eve.separator
   [ method ]

   * If for some reasons you don’t like default separators (`.` or `/`) you can specify yours
   * here. Be aware that if you pass a string longer than one character it will be treated as
   * a list of characters.

   - separator (string) new separator. Empty string resets to default: `.` or `/`.
  \*/ eve1.separator = function(sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else separator = /[\.\/]/;
    };
    /*\
   * eve.on
   [ method ]
   **
   * Binds given event handler with a given name. You can use wildcards “`*`” for the names:
   | eve.on("*.under.*", f);
   | eve("mouse.under.floor"); // triggers f
   * Use @eve to trigger the listener.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
   **
   - name (array) if you don’t want to use separators, you can use array of strings
   - f (function) event handler function
   **
   = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
   > Example:
   | eve.on("mouse", eatIt)(2);
   | eve.on("mouse", scream);
   | eve.on("mouse", catchIt)(1);
   * This will ensure that `catchIt` function will be called before `eatIt`.
   *
   * If you want to put your handler before non-indexed handlers, specify a negative value.
   * Note: I assume most of the time you don’t need to worry about z-index, but it’s nice to have this feature “just in case”.
  \*/ eve1.on = function(name1, f) {
        if (typeof f != "function") return function() {
        };
        var names1 = isArray(name1) ? isArray(name1[0]) ? name1 : [
            name1
        ] : Str(name1).split(comaseparator);
        for(var i1 = 0, ii1 = names1.length; i1 < ii1; i1++)(function(name) {
            var names = isArray(name) ? name : Str(name).split(separator), e = events, exist;
            for(var i = 0, ii = names.length; i < ii; i++){
                e = e.n;
                e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {
                    n: {
                    }
                });
            }
            e.f = e.f || [];
            for(i = 0, ii = e.f.length; i < ii; i++)if (e.f[i] == f) {
                exist = true;
                break;
            }
            !exist && e.f.push(f);
        })(names1[i1]);
        return function(zIndex) {
            if (+zIndex == +zIndex) f.zIndex = +zIndex;
        };
    };
    /*\
   * eve.f
   [ method ]
   **
   * Returns function that will fire given event with optional arguments.
   * Arguments that will be passed to the result function will be also
   * concated to the list of final arguments.
   | el.onclick = eve.f("click", 1, 2);
   | eve.on("click", function (a, b, c) {
   |     console.log(a, b, c); // 1, 2, [event object]
   | });
   - event (string) event name
   - varargs (…) and any other arguments
   = (function) possible event handler function
  \*/ eve1.f = function(event) {
        var attrs = [].slice.call(arguments, 1);
        return function() {
            eve1.apply(null, [
                event,
                null
            ].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
   * eve.stop
   [ method ]
   **
   * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
  \*/ eve1.stop = function() {
        stop = 1;
    };
    /*\
   * eve.nt
   [ method ]
   **
   * Could be used inside event handler to figure out actual name of the event.
   **
   - subname (string) #optional subname of the event
   **
   = (string) name of the event, if `subname` is not specified
   * or
   = (boolean) `true`, if current event’s name contains `subname`
  \*/ eve1.nt = function(subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        return cur;
    };
    /*\
   * eve.nts
   [ method ]
   **
   * Could be used inside event handler to figure out actual name of the event.
   **
   **
   = (array) names of the event
  \*/ eve1.nts = function() {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
   * eve.off
   [ method ]
   **
   * Removes given function from the list of event listeners assigned to given name.
   * If no arguments specified all the events will be cleared.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
  \*/ /*\
   * eve.unbind
   [ method ]
   **
   * See @eve.off
  \*/ eve1.off = eve1.unbind = function(name, f) {
        if (!name) {
            eve1._events = events = {
                n: {
                }
            };
            return;
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [
            name
        ] : Str(name).split(comaseparator);
        if (names.length > 1) {
            for(var i = 0, ii = names.length; i < ii; i++)eve1.off(names[i], f);
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e, key, splice, i, ii, j, jj, cur = [
            events
        ], inodes = [];
        for(i = 0, ii = names.length; i < ii; i++)for(j = 0; j < cur.length; j += splice.length - 2){
            splice = [
                j,
                1
            ];
            e = cur[j].n;
            if (names[i] != wildcard) {
                if (e[names[i]]) {
                    splice.push(e[names[i]]);
                    inodes.unshift({
                        n: e,
                        name: names[i]
                    });
                }
            } else {
                for(key in e)if (e[has](key)) {
                    splice.push(e[key]);
                    inodes.unshift({
                        n: e,
                        name: key
                    });
                }
            }
            cur.splice.apply(cur, splice);
        }
        for(i = 0, ii = cur.length; i < ii; i++){
            e = cur[i];
            while(e.n){
                if (f) {
                    if (e.f) {
                        for(j = 0, jj = e.f.length; j < jj; j++)if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for(key in e.n)if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for(j = 0, jj = funcs.length; j < jj; j++)if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for(key in e.n)if (e.n[has](key) && e.n[key].f) delete e.n[key].f;
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for(i = 0, ii = inodes.length; i < ii; i++){
            e = inodes[i];
            for(key in e.n[e.name].f)continue prune;
            for(key in e.n[e.name].n)continue prune;
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
   * eve.once
   [ method ]
   **
   * Binds given event handler with a given name to only run once then unbind itself.
   | eve.once("login", f);
   | eve("login"); // triggers f
   | eve("login"); // no listeners
   * Use @eve to trigger the listener.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
   **
   = (function) same return function as @eve.on
  \*/ eve1.once = function(name, f) {
        var f2 = function() {
            eve1.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve1.on(name, f2);
    };
    /*\
   * eve.version
   [ property (string) ]
   **
   * Current version of the library.
  \*/ eve1.version = version;
    eve1.toString = function() {
        return "You are running Eve " + version;
    };
    return eve1;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"5SUq7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "R", ()=>R
);
/* eslint-disable */ var _eveJs = require("../eve.js");
const R = function() {
    /* \
   * Raphael
   [ method ]
   **
   * Creates a canvas object on which to draw.
   * You must do this first, as all future calls to drawing methods
   * from this instance will be bound to this canvas.
   > Parameters
   **
   - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
   - width (number)
   - height (number)
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - x (number)
   - y (number)
   - width (number)
   - height (number)
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eve’s “DOMLoad” event. In this case method returns `undefined`.
   = (object) @Paper
   > Usage
   | // Each of the following examples create a canvas
   | // that is 320px wide by 200px high.
   | // Canvas is created at the viewport’s 10,50 coordinate.
   | var paper = Raphael(10, 50, 320, 200);
   | // Canvas is created at the top left corner of the #notepad element
   | // (or its top right corner in dir="rtl" elements)
   | var paper = Raphael(document.getElementById("notepad"), 320, 200);
   | // Same as above
   | var paper = Raphael("notepad", 320, 200);
   | // Image dump
   | var set = Raphael(["notepad", 320, 200, {
   |     type: "rect",
   |     x: 10,
   |     y: 10,
   |     width: 25,
   |     height: 25,
   |     stroke: "#f00"
   | }, {
   |     type: "text",
   |     x: 30,
   |     y: 40,
   |     text: "Dump"
   | }]);
  \ */ function R1(first) {
        if (R1.is(first, 'function')) return loaded1 ? first() : _eveJs.eve.on('raphael.DOMload', first);
        if (R1.is(first, array1)) return R1._engine.create[apply](R1, first.splice(0, 3 + R1.is(first[0], nu))).add(first);
        const args = Array.prototype.slice.call(arguments, 0);
        if (R1.is(args[args.length - 1], 'function')) {
            const f = args.pop();
            return loaded1 ? f.call(R1._engine.create[apply](R1, args)) : _eveJs.eve.on('raphael.DOMload', ()=>{
                f.call(R1._engine.create[apply](R1, args));
            });
        }
        return R1._engine.create[apply](R1, arguments);
    }
    R1.version = '2.2.0';
    R1.eve = _eveJs.eve;
    let loaded1;
    const separator = /[, ]+/;
    const elements = {
        circle: 1,
        rect: 1,
        path: 1,
        ellipse: 1,
        text: 1,
        image: 1
    };
    const formatrg = /\{(\d+)\}/g;
    const proto = 'prototype';
    const has = 'hasOwnProperty';
    const g1 = {
        doc: document,
        win: window
    };
    const oldRaphael = {
        was: Object.prototype[has].call(g1.win, 'Raphael'),
        is: g1.win.Raphael
    };
    const Paper = function() {
        /* \
       * Paper.ca
       [ property (object) ]
       **
       * Shortcut for @Paper.customAttributes
      \ */ /* \
       * Paper.customAttributes
       [ property (object) ]
       **
       * If you have a set of attributes that you would like to represent
       * as a function of some number you can do it easily with custom attributes:
       > Usage
       | paper.customAttributes.hue = function (num) {
       |     num = num % 1;
       |     return {fill: "hsb(" + num + ", 0.75, 1)"};
       | };
       | // Custom attribute “hue” will change fill
       | // to be given hue with fixed saturation and brightness.
       | // Now you can use it like this:
       | var c = paper.circle(10, 10, 10).attr({hue: .45});
       | // or even like this:
       | c.animate({hue: 1}, 1e3);
       |
       | // You could also create custom attribute
       | // with multiple parameters:
       | paper.customAttributes.hsb = function (h, s, b) {
       |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
       | };
       | c.attr({hsb: "0.5 .8 1"});
       | c.animate({hsb: [1, 0, 0.5]}, 1e3);
      \ */ this.ca = this.customAttributes = {
        };
    };
    let paperproto;
    const appendChild = 'appendChild';
    var apply = 'apply';
    const concat = 'concat';
    const supportsTouch = 'ontouchstart' in g1.win || g1.win.DocumentTouch && g1.doc instanceof DocumentTouch // taken from Modernizr touch test
    ;
    const E = '';
    const S1 = ' ';
    const Str = String;
    const split = 'split';
    const events1 = 'click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel'[split](S1);
    const touchMap = {
        mousedown: 'touchstart',
        mousemove: 'touchmove',
        mouseup: 'touchend'
    };
    const lowerCase = Str.prototype.toLowerCase;
    const math = Math;
    const mmax = math.max;
    const mmin = math.min;
    const { abs  } = math;
    const { pow  } = math;
    const { PI  } = math;
    var nu = 'number';
    const string1 = 'string';
    var array1 = 'array';
    const toString = 'toString';
    const fillString = 'fill';
    const objectToString = Object.prototype.toString;
    const paper1 = {
    };
    const push = 'push';
    const ISURL = R1._ISURL = /^url\(['"]?(.+?)['"]?\)$/i;
    const colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;
    const isnan = {
        NaN: 1,
        Infinity: 1,
        '-Infinity': 1
    };
    const bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/;
    const { round: round1  } = math;
    const setAttribute = 'setAttribute';
    const toFloat = parseFloat;
    const toInt = parseInt;
    const upperCase = Str.prototype.toUpperCase;
    const availableAttrs = R1._availableAttrs = {
        'arrow-end': 'none',
        'arrow-start': 'none',
        blur: 0,
        'clip-rect': '0 0 1e9 1e9',
        cursor: 'default',
        cx: 0,
        cy: 0,
        fill: '#fff',
        'fill-opacity': 1,
        font: '10px "Arial"',
        'font-family': '"Arial"',
        'font-size': '10',
        'font-style': 'normal',
        'font-weight': 400,
        gradient: 0,
        height: 0,
        href: 'http://raphaeljs.com/',
        'letter-spacing': 0,
        opacity: 1,
        path: 'M0,0',
        r: 0,
        rx: 0,
        ry: 0,
        src: '',
        stroke: '#000',
        'stroke-dasharray': '',
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'butt',
        'stroke-miterlimit': 0,
        'stroke-opacity': 1,
        'stroke-width': 1,
        target: '_blank',
        'text-anchor': 'middle',
        title: 'Raphael',
        transform: '',
        width: 0,
        x: 0,
        y: 0,
        class: '',
        filter: ''
    };
    const availableAnimAttrs = R1._availableAnimAttrs = {
        blur: nu,
        'clip-rect': 'csv',
        cx: nu,
        cy: nu,
        fill: 'colour',
        'fill-opacity': nu,
        'font-size': nu,
        height: nu,
        opacity: nu,
        path: 'path',
        r: nu,
        rx: nu,
        ry: nu,
        stroke: 'colour',
        'stroke-opacity': nu,
        'stroke-width': nu,
        transform: 'transform',
        width: nu,
        x: nu,
        y: nu
    };
    const whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g;
    const commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/;
    const hsrg = {
        hs: 1,
        rg: 1
    };
    const p2s = /,?([achlmqrstvxz]),?/gi;
    const pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi;
    const tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi;
    const pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi;
    const radial_gradient = R1._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/;
    const eldata = {
    };
    const sortByKey = function(a, b) {
        return a.key - b.key;
    };
    const sortByNumber = function(a, b) {
        return toFloat(a) - toFloat(b);
    };
    const fun = function() {
    };
    const pipe = function(x) {
        return x;
    };
    const rectPath = R1._rectPath = function(x, y, w, h, r) {
        if (r) return [
            [
                'M',
                x + r,
                y
            ],
            [
                'l',
                w - r * 2,
                0
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                r,
                r
            ],
            [
                'l',
                0,
                h - r * 2
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                -r,
                r
            ],
            [
                'l',
                r * 2 - w,
                0
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                -r,
                -r
            ],
            [
                'l',
                0,
                r * 2 - h
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                r,
                -r
            ],
            [
                'z'
            ], 
        ];
        return [
            [
                'M',
                x,
                y
            ],
            [
                'l',
                w,
                0
            ],
            [
                'l',
                0,
                h
            ],
            [
                'l',
                -w,
                0
            ],
            [
                'z'
            ]
        ];
    };
    const ellipsePath = function(x, y, rx, ry) {
        if (ry == null) ry = rx;
        return [
            [
                'M',
                x,
                y
            ],
            [
                'm',
                0,
                -ry
            ],
            [
                'a',
                rx,
                ry,
                0,
                1,
                1,
                0,
                2 * ry
            ],
            [
                'a',
                rx,
                ry,
                0,
                1,
                1,
                0,
                -2 * ry
            ],
            [
                'z'
            ], 
        ];
    };
    const getPath1 = R1._getPath = {
        path (el) {
            return el.attr('path');
        },
        circle (el) {
            const a = el.attrs;
            return ellipsePath(a.cx, a.cy, a.r);
        },
        ellipse (el) {
            const a = el.attrs;
            return ellipsePath(a.cx, a.cy, a.rx, a.ry);
        },
        rect (el) {
            const a = el.attrs;
            return rectPath(a.x, a.y, a.width, a.height, a.r);
        },
        image (el) {
            const a = el.attrs;
            return rectPath(a.x, a.y, a.width, a.height);
        },
        text (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        set (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        g (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    /* \
     * Raphael.mapPath
     [ method ]
     **
     * Transform the path string with given matrix.
     > Parameters
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \ */ const mapPath = R1.mapPath = function(path, matrix) {
        if (!matrix) return path;
        let x;
        let y;
        let i;
        let j;
        let ii;
        let jj;
        let pathi;
        path = path2curve(path);
        for(i = 0, ii = path.length; i < ii; i++){
            pathi = path[i];
            for(j = 1, jj = pathi.length; j < jj; j += 2){
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    };
    R1._g = g1;
    R1.type = 'SVG';
    R1.svg = true;
    R1._Paper = Paper;
    /* \
   * Raphael.fn
   [ property (object) ]
   **
   * You can add your own method to the canvas. For example if you want to draw a pie chart,
   * you can create your own pie chart function and ship it as a Raphaël plugin. To do this
   * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
   * Raphaël instance is created, otherwise it will take no effect. Please note that the
   * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
   * ensure any namespacing ensures proper context.
   > Usage
   | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
   |     return this.path( ... );
   | };
   | // or create namespace
   | Raphael.fn.mystuff = {
   |     arrow: function () {…},
   |     star: function () {…},
   |     // etc…
   | };
   | var paper = Raphael(10, 10, 630, 480);
   | // then use it
   | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
   | paper.mystuff.arrow();
   | paper.mystuff.star();
  \ */ R1.fn = paperproto = Paper.prototype = R1.prototype;
    R1._id = 0;
    /* \
   * Raphael.is
   [ method ]
   **
   * Handful of replacements for `typeof` operator.
   > Parameters
   - o (…) any object or primitive
   - type (string) name of the type, i.e. “string”, “function”, “number”, etc.
   = (boolean) is given value is of given type
  \ */ R1.is = function(o, type) {
        type = lowerCase.call(type);
        if (type == 'finite') return !isnan[has](+o);
        if (type == 'array') return o instanceof Array;
        return type == 'null' && o === null || type === typeof o && o !== null || type == 'object' && o === Object(o) || type == 'array' && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };
    function clone(obj) {
        if (typeof obj === 'function' || Object(obj) !== obj) return obj;
        const res = new obj.constructor();
        for(const key in obj)if (obj[has](key)) res[key] = clone(obj[key]);
        return res;
    }
    /* \
   * Raphael.angle
   [ method ]
   **
   * Returns angle between two or three points
   > Parameters
   - x1 (number) x coord of first point
   - y1 (number) y coord of first point
   - x2 (number) x coord of second point
   - y2 (number) y coord of second point
   - x3 (number) #optional x coord of third point
   - y3 (number) #optional y coord of third point
   = (number) angle in degrees.
  \ */ R1.angle = function(x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            const x = x1 - x2;
            const y = y1 - y2;
            if (!x && !y) return 0;
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        }
        return R1.angle(x1, y1, x3, y3) - R1.angle(x2, y2, x3, y3);
    };
    /* \
   * Raphael.rad
   [ method ]
   **
   * Transform angle to radians
   > Parameters
   - deg (number) angle in degrees
   = (number) angle in radians.
  \ */ R1.rad = function(deg) {
        return deg % 360 * PI / 180;
    };
    /* \
   * Raphael.deg
   [ method ]
   **
   * Transform angle to degrees
   > Parameters
   - rad (number) angle in radians
   = (number) angle in degrees.
  \ */ R1.deg = function(rad) {
        return Math.round(rad * 180 / PI % 360 * 1000) / 1000;
    };
    /* \
   * Raphael.snapTo
   [ method ]
   **
   * Snaps given value to given grid.
   > Parameters
   - values (array|number) given array of values or step of the grid
   - value (number) value to adjust
   - tolerance (number) #optional tolerance for snapping. Default is `10`.
   = (number) adjusted value.
  \ */ R1.snapTo = function(values, value, tolerance) {
        tolerance = R1.is(tolerance, 'finite') ? tolerance : 10;
        if (R1.is(values, array1)) {
            let i = values.length;
            while(i--)if (abs(values[i] - value) <= tolerance) return values[i];
        } else {
            values = +values;
            const rem = value % values;
            if (rem < tolerance) return value - rem;
            if (rem > values - tolerance) return value - rem + values;
        }
        return value;
    };
    /* \
   * Raphael.createUUID
   [ method ]
   **
   * Returns RFC4122, version 4 ID
  \ */ const createUUID = R1.createUUID = function(uuidRegEx, uuidReplacer) {
        return function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    }(/[xy]/g, (c)=>{
        const r = math.random() * 16 | 0;
        const v = c == 'x' ? r : r & 3 | 8;
        return v.toString(16);
    });
    /* \
   * Raphael.setWindow
   [ method ]
   **
   * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
   > Parameters
   - newwin (window) new window object
  \ */ R1.setWindow = function(newwin) {
        _eveJs.eve('raphael.setWindow', R1, g1.win, newwin);
        g1.win = newwin;
        g1.doc = g1.win.document;
        if (R1._engine.initWin) R1._engine.initWin(g1.win);
    };
    var toHex = function(color1) {
        const i = g1.doc.createElement('i');
        i.title = 'Rapha\xebl Colour Picker';
        i.style.display = 'none';
        g1.doc.body.appendChild(i);
        toHex = cacher('toHex', (color)=>{
            i.style.color = color;
            return g1.doc.defaultView.getComputedStyle(i, E).getPropertyValue('color');
        });
        return toHex(color1);
    };
    const hsbtoString = function() {
        return `hsb(${[
            this.h,
            this.s,
            this.b
        ]})`;
    };
    const hsltoString = function() {
        return `hsl(${[
            this.h,
            this.s,
            this.l
        ]})`;
    };
    const rgbtoString = function() {
        return this.hex;
    };
    const prepareRGB = function(r, g, b) {
        if (g == null && R1.is(r, 'object') && 'r' in r && 'g' in r && 'b' in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null && R1.is(r, string1)) {
            const clr = R1.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r > 1 || g > 1 || b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }
        return [
            r,
            g,
            b
        ];
    };
    const packageRGB = function(r, g, b, o) {
        r *= 255;
        g *= 255;
        b *= 255;
        const rgb = {
            r,
            g,
            b,
            hex: R1.rgb(r, g, b),
            toString: rgbtoString
        };
        R1.is(o, 'finite') && (rgb.opacity = o);
        return rgb;
    };
    /* \
   * Raphael.color
   [ method ]
   **
   * Parses the color string and returns object with all values for the given color.
   > Parameters
   - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
   = (object) Combined RGB & HSB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #••••••,
   o     error (boolean) `true` if string can’t be parsed,
   o     h (number) hue,
   o     s (number) saturation,
   o     v (number) value (brightness),
   o     l (number) lightness
   o }
  \ */ R1.color = function(clr) {
        let rgb;
        if (R1.is(clr, 'object') && 'h' in clr && 's' in clr && 'b' in clr) {
            rgb = R1.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R1.is(clr, 'object') && 'h' in clr && 's' in clr && 'l' in clr) {
            rgb = R1.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R1.is(clr, 'string')) clr = R1.getRGB(clr);
            if (R1.is(clr, 'object') && 'r' in clr && 'g' in clr && 'b' in clr) {
                rgb = R1.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R1.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {
                    hex: 'none'
                };
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /* \
   * Raphael.hsb2rgb
   [ method ]
   **
   * Converts HSB values to RGB object.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - v (number) value or brightness
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #••••••
   o }
  \ */ R1.hsb2rgb = function(h, s, v, o) {
        if (this.is(h, 'object') && 'h' in h && 's' in h && 'b' in h) {
            v = h.b;
            s = h.s;
            o = h.o;
            h = h.h;
        }
        h *= 360;
        let R2;
        let G;
        let B;
        let X;
        let C;
        h = h % 360 / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R2 = G = B = v - C;
        h = ~~h;
        R2 += [
            C,
            X,
            0,
            0,
            X,
            C
        ][h];
        G += [
            X,
            C,
            C,
            X,
            0,
            0
        ][h];
        B += [
            0,
            0,
            X,
            C,
            C,
            X
        ][h];
        return packageRGB(R2, G, B, o);
    };
    /* \
   * Raphael.hsl2rgb
   [ method ]
   **
   * Converts HSL values to RGB object.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - l (number) luminosity
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #••••••
   o }
  \ */ R1.hsl2rgb = function(h, s, l, o) {
        if (this.is(h, 'object') && 'h' in h && 's' in h && 'l' in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        let R3;
        let G;
        let B;
        let X;
        let C;
        h = h % 360 / 60;
        C = 2 * s * (l < 0.5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R3 = G = B = l - C / 2;
        h = ~~h;
        R3 += [
            C,
            X,
            0,
            0,
            X,
            C
        ][h];
        G += [
            X,
            C,
            C,
            X,
            0,
            0
        ][h];
        B += [
            0,
            0,
            X,
            C,
            C,
            X
        ][h];
        return packageRGB(R3, G, B, o);
    };
    /* \
   * Raphael.rgb2hsb
   [ method ]
   **
   * Converts RGB values to HSB object.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (object) HSB object in format:
   o {
   o     h (number) hue
   o     s (number) saturation
   o     b (number) brightness
   o }
  \ */ R1.rgb2hsb = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];
        let H;
        let S;
        let V;
        let C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {
            h: H,
            s: S,
            b: V,
            toString: hsbtoString
        };
    };
    /* \
   * Raphael.rgb2hsl
   [ method ]
   **
   * Converts RGB values to HSL object.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (object) HSL object in format:
   o {
   o     h (number) hue
   o     s (number) saturation
   o     l (number) luminosity
   o }
  \ */ R1.rgb2hsl = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];
        let H;
        let S;
        let L;
        let M;
        let m;
        let C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        L = (M + m) / 2;
        S = C == 0 ? 0 : L < 0.5 ? C / (2 * L) : C / (2 - 2 * L);
        return {
            h: H,
            s: S,
            l: L,
            toString: hsltoString
        };
    };
    R1._path2string = function() {
        // 2 decimal precision always...
        return this.map((t1)=>[
                t1[0],
                ...t1.slice(1).map((t)=>Math.round(t * 100) / 100
                ), 
            ]
        ).join(',').replace(p2s, '$1');
    };
    function repush(array, item) {
        for(let i = 0, ii = array.length; i < ii; i++)if (array[i] === item) return array.push(array.splice(i, 1)[0]);
    }
    const CACHE = R1.CACHE = {
    };
    function cacher(name, f, scope, postprocessor) {
        function newf() {
            const arg = Array.prototype.slice.call(arguments, 0);
            const args = arg.join('\u2400');
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1000 && delete cache[count.shift()];
            count.push(args);
            const cached = cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cached) : cached;
        }
        var cache = newf.cache = {
        };
        var count = newf.count = [];
        newf.clear = function() {
            cache = newf.cache = {
            };
            count = newf.count = [];
        };
        CACHE[name] = newf;
        return newf;
    }
    R1.clearCaches = function() {
        for(const key in CACHE){
            if (!CACHE.hasOwnProperty(key)) continue;
            CACHE[key].clear();
        }
    };
    const preload = R1._preload = function(src, f) {
        const img = g1.doc.createElement('img');
        img.style.cssText = 'position:absolute;left:-9999em;top:-9999em';
        img.onload = function() {
            f.call(this);
            this.onload = null;
            g1.doc.body.removeChild(this);
        };
        img.onerror = function() {
            g1.doc.body.removeChild(this);
        };
        g1.doc.body.appendChild(img);
        img.src = src;
    };
    function clrToString() {
        return this.hex;
    }
    /* \
   * Raphael.getRGB
   [ method ]
   **
   * Parses colour string as RGB object
   > Parameters
   - colour (string) colour string in one of formats:
   # <ul>
   #     <li>Colour name (“<code>red</code>”, “<code>green</code>”, “<code>cornflowerblue</code>”, etc)</li>
   #     <li>#••• — shortened HTML colour: (“<code>#000</code>”, “<code>#fc0</code>”, etc)</li>
   #     <li>#•••••• — full length HTML colour: (“<code>#000000</code>”, “<code>#bd2300</code>”)</li>
   #     <li>rgb(•••, •••, •••) — red, green and blue channels’ values: (“<code>rgb(200,&nbsp;100,&nbsp;0)</code>”)</li>
   #     <li>rgb(•••%, •••%, •••%) — same as above, but in %: (“<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>”)</li>
   #     <li>hsb(•••, •••, •••) — hue, saturation and brightness values: (“<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>”)</li>
   #     <li>hsb(•••%, •••%, •••%) — same as above, but in %</li>
   #     <li>hsl(•••, •••, •••) — same as hsb</li>
   #     <li>hsl(•••%, •••%, •••%) — same as hsb</li>
   # </ul>
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue
   o     hex (string) color in HTML/CSS format: #••••••,
   o     error (boolean) true if string can’t be parsed
   o }
  \ */ R1.getRGB = cacher('getRGB', (colour)=>{
        if (!colour || !!((colour = Str(colour)).indexOf('-') + 1)) return {
            r: -1,
            g: -1,
            b: -1,
            hex: 'none',
            error: 1,
            toString: clrToString
        };
        if (colour == 'none') return {
            r: -1,
            g: -1,
            b: -1,
            hex: 'none',
            toString: clrToString
        };
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == '#') && (colour = toHex(colour));
        let res;
        let red;
        let green;
        let blue;
        let opacity;
        let t;
        let values;
        let rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == '%' && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == '%' && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == '%' && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == 'rgba' && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == '%' && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == '%' && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == '%' && (blue *= 2.55);
                (values[0].slice(-3) == 'deg' || values[0].slice(-1) == '\xb0') && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == 'hsba' && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
                return R1.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == '%' && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == '%' && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == '%' && (blue *= 2.55);
                (values[0].slice(-3) == 'deg' || values[0].slice(-1) == '\xb0') && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == 'hsla' && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
                return R1.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {
                r: red,
                g: green,
                b: blue,
                toString: clrToString
            };
            rgb.hex = `#${(16777216 | blue | green << 8 | red << 16).toString(16).slice(1)}`;
            R1.is(opacity, 'finite') && (rgb.opacity = opacity);
            return rgb;
        }
        return {
            r: -1,
            g: -1,
            b: -1,
            hex: 'none',
            error: 1,
            toString: clrToString
        };
    }, R1);
    /* \
   * Raphael.hsb
   [ method ]
   **
   * Converts HSB values to hex representation of the colour.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - b (number) value or brightness
   = (string) hex representation of the colour.
  \ */ R1.hsb = cacher('hsb', (h, s, b)=>R1.hsb2rgb(h, s, b).hex
    );
    /* \
   * Raphael.hsl
   [ method ]
   **
   * Converts HSL values to hex representation of the colour.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - l (number) luminosity
   = (string) hex representation of the colour.
  \ */ R1.hsl = cacher('hsl', (h, s, l)=>R1.hsl2rgb(h, s, l).hex
    );
    /* \
   * Raphael.rgb
   [ method ]
   **
   * Converts RGB values to hex representation of the colour.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (string) hex representation of the colour.
  \ */ R1.rgb = cacher('rgb', (r, g, b)=>{
        function round(x) {
            return x + 0.5 | 0;
        }
        return `#${(16777216 | round(b) | round(g) << 8 | round(r) << 16).toString(16).slice(1)}`;
    });
    /* \
   * Raphael.getColor
   [ method ]
   **
   * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
   > Parameters
   - value (number) #optional brightness, default is `0.75`
   = (string) hex representation of the colour.
  \ */ R1.getColor = function(value) {
        const start = this.getColor.start = this.getColor.start || {
            h: 0,
            s: 1,
            b: value || 0.75
        };
        const rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += 0.075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= 0.2;
            start.s <= 0 && (this.getColor.start = {
                h: 0,
                s: 1,
                b: start.b
            });
        }
        return rgb.hex;
    };
    /* \
   * Raphael.getColor.reset
   [ method ]
   **
   * Resets spectrum position for @Raphael.getColor back to red.
  \ */ R1.getColor.reset = function() {
        delete this.start;
    };
    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        const d = [];
        for(let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2){
            const p = [
                {
                    x: +crp[i - 2],
                    y: +crp[i - 1]
                },
                {
                    x: +crp[i],
                    y: +crp[i + 1]
                },
                {
                    x: +crp[i + 2],
                    y: +crp[i + 3]
                },
                {
                    x: +crp[i + 4],
                    y: +crp[i + 5]
                }, 
            ];
            if (z) {
                if (!i) p[0] = {
                    x: +crp[iLen - 2],
                    y: +crp[iLen - 1]
                };
                else if (iLen - 4 == i) p[3] = {
                    x: +crp[0],
                    y: +crp[1]
                };
                else if (iLen - 2 == i) {
                    p[2] = {
                        x: +crp[0],
                        y: +crp[1]
                    };
                    p[3] = {
                        x: +crp[2],
                        y: +crp[3]
                    };
                }
            } else if (iLen - 4 == i) p[3] = p[2];
            else if (!i) p[0] = {
                x: +crp[i],
                y: +crp[i + 1]
            };
            d.push([
                'C',
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6 * p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y, 
            ]);
        }
        return d;
    }
    /* \
   * Raphael.parsePathString
   [ method ]
   **
   * Utility method
   **
   * Parses given path string into an array of arrays of path segments.
   > Parameters
   - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
   = (array) array of segments.
  \ */ R1.parsePathString = function(pathString) {
        if (!pathString) return null;
        const pth = paths(pathString);
        if (pth.arr) return pathClone(pth.arr);
        const paramCounts = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            r: 4,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        };
        let data = [];
        if (R1.is(pathString, array1) && R1.is(pathString[0], array1)) // rough assumption
        data = pathClone(pathString);
        if (!data.length) Str(pathString).replace(pathCommand, (a, b1, c)=>{
            const params = [];
            let name = b1.toLowerCase();
            c.replace(pathValues, (a, b)=>{
                b && params.push(+b);
            });
            if (name == 'm' && params.length > 2) {
                data.push([
                    b1
                ][concat](params.splice(0, 2)));
                name = 'l';
                b1 = b1 == 'm' ? 'l' : 'L';
            }
            if (name == 'r') data.push([
                b1
            ][concat](params));
            else while(params.length >= paramCounts[name]){
                data.push([
                    b1
                ][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) break;
            }
        });
        data.toString = R1._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /* \
   * Raphael.parseTransformString
   [ method ]
   **
   * Utility method
   **
   * Parses given path string into an array of transformations.
   > Parameters
   - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
   = (array) array of transformations.
  \ */ R1.parseTransformString = cacher('parseTransformString', (TString)=>{
        if (!TString) return null;
        const paramCounts = {
            r: 3,
            s: 4,
            t: 2,
            m: 6
        };
        let data = [];
        if (R1.is(TString, array1) && R1.is(TString[0], array1)) // rough assumption
        data = pathClone(TString);
        if (!data.length) Str(TString).replace(tCommand, (a, b2, c)=>{
            const params = [];
            const name = lowerCase.call(b2);
            c.replace(pathValues, (a, b)=>{
                b && params.push(+b);
            });
            data.push([
                b2
            ][concat](params));
        });
        data.toString = R1._path2string;
        return data;
    });
    // PATHS
    var paths = function(ps) {
        const p = paths.ps = paths.ps || {
        };
        if (p[ps]) p[ps].sleep = 100;
        else p[ps] = {
            sleep: 100
        };
        setTimeout(()=>{
            for(const key in p)if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    /* \
   * Raphael.findDotsAtSegment
   [ method ]
   **
   * Utility method
   **
   * Find dot coordinates on the given cubic bezier curve at the given t.
   > Parameters
   - p1x (number) x of the first point of the curve
   - p1y (number) y of the first point of the curve
   - c1x (number) x of the first anchor of the curve
   - c1y (number) y of the first anchor of the curve
   - c2x (number) x of the second anchor of the curve
   - c2y (number) y of the second anchor of the curve
   - p2x (number) x of the second point of the curve
   - p2y (number) y of the second point of the curve
   - t (number) position on the curve (0..1)
   = (object) point information in format:
   o {
   o     x: (number) x coordinate of the point
   o     y: (number) y coordinate of the point
   o     m: {
   o         x: (number) x coordinate of the left anchor
   o         y: (number) y coordinate of the left anchor
   o     }
   o     n: {
   o         x: (number) x coordinate of the right anchor
   o         y: (number) y coordinate of the right anchor
   o     }
   o     start: {
   o         x: (number) x coordinate of the start of the curve
   o         y: (number) y coordinate of the start of the curve
   o     }
   o     end: {
   o         x: (number) x coordinate of the end of the curve
   o         y: (number) y coordinate of the end of the curve
   o     }
   o     alpha: (number) angle of the curve derivative at the point
   o }
  \ */ R1.findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        const t1 = 1 - t;
        const t13 = t1 ** 3;
        const t12 = t1 ** 2;
        const t2 = t * t;
        const t3 = t2 * t;
        const x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
        const y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
        const mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
        const my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
        const nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
        const ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
        const ax = t1 * p1x + t * c1x;
        const ay = t1 * p1y + t * c1y;
        const cx = t1 * c2x + t * p2x;
        const cy = t1 * c2y + t * p2y;
        let alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x,
            y,
            m: {
                x: mx,
                y: my
            },
            n: {
                x: nx,
                y: ny
            },
            start: {
                x: ax,
                y: ay
            },
            end: {
                x: cx,
                y: cy
            },
            alpha
        };
    };
    /* \
   * Raphael.bezierBBox
   [ method ]
   **
   * Utility method
   **
   * Return bounding box of a given cubic bezier curve
   > Parameters
   - p1x (number) x of the first point of the curve
   - p1y (number) y of the first point of the curve
   - c1x (number) x of the first anchor of the curve
   - c1y (number) y of the first anchor of the curve
   - c2x (number) x of the second anchor of the curve
   - c2y (number) y of the second anchor of the curve
   - p2x (number) x of the second point of the curve
   - p2y (number) y of the second point of the curve
   * or
   - bez (array) array of six points for bezier curve
   = (object) point information in format:
   o {
   o     min: {
   o         x: (number) x coordinate of the left point
   o         y: (number) y coordinate of the top point
   o     }
   o     max: {
   o         x: (number) x coordinate of the right point
   o         y: (number) y coordinate of the bottom point
   o     }
   o }
  \ */ R1.bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R1.is(p1x, 'array')) p1x = [
            p1x,
            p1y,
            c1x,
            c1y,
            c2x,
            c2y,
            p2x,
            p2y
        ];
        const bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /* \
   * Raphael.isPointInsideBBox
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if given point is inside bounding boxes.
   > Parameters
   - bbox (string) bounding box
   - x (string) x coordinate of the point
   - y (string) y coordinate of the point
   = (boolean) `true` if point inside
  \ */ R1.isPointInsideBBox = function(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /* \
   * Raphael.isBBoxIntersect
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if two bounding boxes intersect
   > Parameters
   - bbox1 (string) first bounding box
   - bbox2 (string) second bounding box
   = (boolean) `true` if they intersect
  \ */ R1.isBBoxIntersect = function(bbox1, bbox2) {
        const i = R1.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y) || i(bbox2, bbox1.x2, bbox1.y) || i(bbox2, bbox1.x, bbox1.y2) || i(bbox2, bbox1.x2, bbox1.y2) || i(bbox1, bbox2.x, bbox2.y) || i(bbox1, bbox2.x2, bbox2.y) || i(bbox1, bbox2.x, bbox2.y2) || i(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        const t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
        const t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) z = 1;
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        const z2 = z / 2;
        const n = 12;
        const Tvalues = [
            -0.1252,
            0.1252,
            -0.3678,
            0.3678,
            -0.5873,
            0.5873,
            -0.7699,
            0.7699,
            -0.9041,
            0.9041,
            -0.9816,
            0.9816, 
        ];
        const Cvalues = [
            0.2491,
            0.2491,
            0.2335,
            0.2335,
            0.2032,
            0.2032,
            0.1601,
            0.1601,
            0.1069,
            0.1069,
            0.0472,
            0.0472, 
        ];
        let sum = 0;
        for(let i = 0; i < n; i++){
            const ct = z2 * Tvalues[i] + z2;
            const xbase = base3(ct, x1, x2, x3, x4);
            const ybase = base3(ct, y1, y2, y3, y4);
            const comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) return;
        const t = 1;
        let step = t / 2;
        let t2 = t - step;
        let l;
        const e = 0.01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while(abs(l - ll) > e){
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) return;
        const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
        const ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
        const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (!denominator) return;
        const px = nx / denominator;
        const py = ny / denominator;
        const px2 = +px.toFixed(2);
        const py2 = +py.toFixed(2);
        if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) return;
        return {
            x: px,
            y: py
        };
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        const bbox1 = R1.bezierBBox(bez1);
        const bbox2 = R1.bezierBBox(bez2);
        if (!R1.isBBoxIntersect(bbox1, bbox2)) return justCount ? 0 : [];
        const l1 = bezlen.apply(0, bez1);
        const l2 = bezlen.apply(0, bez2);
        const n1 = mmax(~~(l1 / 5), 1);
        const n2 = mmax(~~(l2 / 5), 1);
        const dots1 = [];
        const dots2 = [];
        const xy = {
        };
        let res = justCount ? 0 : [];
        for(var i = 0; i < n1 + 1; i++){
            var p = R1.findDotsAtSegment.apply(R1, bez1.concat(i / n1));
            dots1.push({
                x: p.x,
                y: p.y,
                t: i / n1
            });
        }
        for(i = 0; i < n2 + 1; i++){
            p = R1.findDotsAtSegment.apply(R1, bez2.concat(i / n2));
            dots2.push({
                x: p.x,
                y: p.y,
                t: i / n2
            });
        }
        for(i = 0; i < n1; i++)for(let j = 0; j < n2; j++){
            const di = dots1[i];
            const di1 = dots1[i + 1];
            const dj = dots2[j];
            const dj1 = dots2[j + 1];
            const ci = abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            const cj = abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            const is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
            if (is) {
                if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) continue;
                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                const t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
                const t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                    if (justCount) res++;
                    else res.push({
                        x: is.x,
                        y: is.y,
                        t1: mmin(t1, 1),
                        t2: mmin(t2, 1)
                    });
                }
            }
        }
        return res;
    }
    /* \
   * Raphael.pathIntersection
   [ method ]
   **
   * Utility method
   **
   * Finds intersections of two paths
   > Parameters
   - path1 (string) path string
   - path2 (string) path string
   = (array) dots of intersection
   o [
   o     {
   o         x: (number) x coordinate of the point
   o         y: (number) y coordinate of the point
   o         t1: (number) t value for segment of path1
   o         t2: (number) t value for segment of path2
   o         segment1: (number) order number for segment of path1
   o         segment2: (number) order number for segment of path2
   o         bez1: (array) eight coordinates representing beziér curve for the segment of path1
   o         bez2: (array) eight coordinates representing beziér curve for the segment of path2
   o     }
   o ]
  \ */ R1.pathIntersection = function(path1, path2) {
        return interPathHelper(path1, path2);
    };
    R1.pathIntersectionNumber = function(path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R1._path2curve(path1);
        path2 = R1._path2curve(path2);
        let x1;
        let y1;
        let x2;
        let y2;
        let x1m;
        let y1m;
        let x2m;
        let y2m;
        let bez1;
        let bez2;
        let res = justCount ? 0 : [];
        for(let i = 0, ii = path1.length; i < ii; i++){
            const pi = path1[i];
            if (pi[0] == 'M') {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == 'C') {
                    bez1 = [
                        x1,
                        y1
                    ].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [
                        x1,
                        y1,
                        x1,
                        y1,
                        x1m,
                        y1m,
                        x1m,
                        y1m
                    ];
                    x1 = x1m;
                    y1 = y1m;
                }
                for(let j = 0, jj = path2.length; j < jj; j++){
                    const pj = path2[j];
                    if (pj[0] == 'M') {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == 'C') {
                            bez2 = [
                                x2,
                                y2
                            ].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [
                                x2,
                                y2,
                                x2,
                                y2,
                                x2m,
                                y2m,
                                x2m,
                                y2m
                            ];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        const intr = interHelper(bez1, bez2, justCount);
                        if (justCount) res += intr;
                        else {
                            for(let k = 0, kk = intr.length; k < kk; k++){
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /* \
   * Raphael.isPointInsidePath
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if given point is inside a given closed path.
   > Parameters
   - path (string) path string
   - x (number) x of the point
   - y (number) y of the point
   = (boolean) true, if point is inside the path
  \ */ R1.isPointInsidePath = function(path, x, y) {
        const bbox = R1.pathBBox(path);
        return R1.isPointInsideBBox(bbox, x, y) && interPathHelper(path, [
            [
                'M',
                x,
                y
            ],
            [
                'H',
                bbox.x2 + 10
            ], 
        ], 1) % 2 == 1;
    };
    R1._removedFactory = function(methodname) {
        return function() {
            _eveJs.eve('raphael.log', null, `Rapha\xebl: you are calling to method \u201c${methodname}\u201d of removed object`, methodname);
        };
    };
    /* \
   * Raphael.pathBBox
   [ method ]
   **
   * Utility method
   **
   * Return bounding box of a given path
   > Parameters
   - path (string) path string
   = (object) bounding box
   o {
   o     x: (number) x coordinate of the left top point of the box
   o     y: (number) y coordinate of the left top point of the box
   o     x2: (number) x coordinate of the right bottom point of the box
   o     y2: (number) y coordinate of the right bottom point of the box
   o     width: (number) width of the box
   o     height: (number) height of the box
   o     cx: (number) x coordinate of the center of the box
   o     cy: (number) y coordinate of the center of the box
   o }
  \ */ const pathDimensions = R1.pathBBox = function(path) {
        const pth = paths(path);
        if (pth.bbox) return clone(pth.bbox);
        if (!path) return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            x2: 0,
            y2: 0
        };
        path = path2curve(path);
        let x = 0;
        let y = 0;
        let X = [];
        let Y = [];
        let p;
        for(let i = 0, ii = path.length; i < ii; i++){
            p = path[i];
            if (p[0] == 'M') {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                const dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        const xmin = mmin[apply](0, X);
        const ymin = mmin[apply](0, Y);
        const xmax = mmax[apply](0, X);
        const ymax = mmax[apply](0, Y);
        const width = xmax - xmin;
        const height = ymax - ymin;
        const bb = {
            x: xmin,
            y: ymin,
            x2: xmax,
            y2: ymax,
            width,
            height,
            cx: xmin + width / 2,
            cy: ymin + height / 2
        };
        pth.bbox = clone(bb);
        return bb;
    };
    var pathClone = function(pathArray) {
        // var res = clone(pathArray);
        // Array.slice() is faster then clone(pathArray).
        const res = pathArray.slice(0);
        for(let i = 0, ii = pathArray.length; i < ii; ++i)res[i] = pathArray[i].slice(0);
        res.toString = R1._path2string;
        return res;
    };
    const pathToRelative = R1._pathToRelative = function(pathArray) {
        const pth = paths(pathArray);
        if (pth.rel) return pathClone(pth.rel);
        if (!R1.is(pathArray, array1) || !R1.is(pathArray && pathArray[0], array1)) // rough assumption
        pathArray = R1.parsePathString(pathArray);
        const res = [];
        let x = 0;
        let y = 0;
        let mx = 0;
        let my = 0;
        let start = 0;
        if (pathArray[0][0] == 'M') {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push([
                'M',
                x,
                y
            ]);
        }
        for(let i = start, ii = pathArray.length; i < ii; i++){
            let r = res[i] = [];
            const pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch(r[0]){
                    case 'a':
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case 'v':
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case 'm':
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for(let j = 1, jj = pa.length; j < jj; j++)r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                }
            } else {
                r = res[i] = [];
                if (pa[0] == 'm') {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for(let k = 0, kk = pa.length; k < kk; k++)res[i][k] = pa[k];
            }
            const len = res[i].length;
            switch(res[i][0]){
                case 'z':
                    x = mx;
                    y = my;
                    break;
                case 'h':
                    x += +res[i][len - 1];
                    break;
                case 'v':
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = R1._path2string;
        pth.rel = pathClone(res);
        return res;
    };
    const pathToAbsolute = R1._pathToAbsolute = function(pathArray) {
        // return pathArray;
        const pth = paths(pathArray);
        if (pth.abs) return pathClone(pth.abs);
        if (!R1.is(pathArray, array1) || !R1.is(pathArray && pathArray[0], array1)) // rough assumption
        pathArray = R1.parsePathString(pathArray);
        if (!pathArray || !pathArray.length) return [
            [
                'M',
                0,
                0
            ]
        ];
        let res = [];
        let x = 0;
        let y = 0;
        let mx = 0;
        let my = 0;
        let start = 0;
        if (pathArray[0][0] == 'M') {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = [
                'M',
                x,
                y
            ];
        }
        const crz = pathArray.length == 3 && pathArray[0][0] == 'M' && pathArray[1][0].toUpperCase() == 'R' && pathArray[2][0].toUpperCase() == 'Z';
        for(var r, pa, i = start, ii = pathArray.length; i < ii; i++){
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch(r[0]){
                    case 'A':
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case 'V':
                        r[1] = +pa[1] + y;
                        break;
                    case 'H':
                        r[1] = +pa[1] + x;
                        break;
                    case 'R':
                        var dots = [
                            x,
                            y
                        ][concat](pa.slice(1));
                        for(var j = 2, jj = dots.length; j < jj; j++){
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case 'M':
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for(j = 1, jj = pa.length; j < jj; j++)r[j] = +pa[j] + (j % 2 ? x : y);
                }
            } else if (pa[0] == 'R') {
                dots = [
                    x,
                    y
                ][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = [
                    'R'
                ][concat](pa.slice(-2));
            } else for(let k = 0, kk = pa.length; k < kk; k++)r[k] = pa[k];
            switch(r[0]){
                case 'Z':
                    x = mx;
                    y = my;
                    break;
                case 'H':
                    x = r[1];
                    break;
                case 'V':
                    y = r[1];
                    break;
                case 'M':
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = R1._path2string;
        pth.abs = pathClone(res);
        return res;
    };
    const l2c = function(x1, y1, x2, y2) {
        return [
            x1,
            y1,
            x2,
            y2,
            x2,
            y2
        ];
    };
    const q2c = function(x1, y1, ax, ay, x2, y2) {
        const _13 = 1 / 3;
        const _23 = 2 / 3;
        return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2, 
        ];
    };
    var a2c = function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        const _120 = PI * 120 / 180;
        const rad1 = PI / 180 * (+angle || 0);
        let res = [];
        let xy;
        const rotate = cacher('a2c.rotate', (x, y, rad)=>{
            const X = x * math.cos(rad) - y * math.sin(rad);
            const Y = x * math.sin(rad) + y * math.cos(rad);
            return {
                x: X,
                y: Y
            };
        });
        if (!recursive) {
            xy = rotate(x1, y1, -rad1);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad1);
            x2 = xy.x;
            y2 = xy.y;
            const cos = math.cos(PI / 180 * angle);
            const sin = math.sin(PI / 180 * angle);
            const x = (x1 - x2) / 2;
            const y = (y1 - y2) / 2;
            let h = x * x / (rx * rx) + y * y / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            const rx2 = rx * rx;
            const ry2 = ry * ry;
            const k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
            var cx = k * rx * y / ry + (x1 + x2) / 2;
            var cy = k * -ry * x / rx + (y1 + y2) / 2;
            var f1 = math.asin(((y1 - cy) / ry).toFixed(9));
            var f2 = math.asin(((y2 - cy) / ry).toFixed(9));
            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) f1 -= PI * 2;
            if (!sweep_flag && f2 > f1) f2 -= PI * 2;
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        let df = f2 - f1;
        if (abs(df) > _120) {
            const f2old = f2;
            const x2old = x2;
            const y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
                f2,
                f2old,
                cx,
                cy, 
            ]);
        }
        df = f2 - f1;
        const c1 = math.cos(f1);
        const s1 = math.sin(f1);
        const c2 = math.cos(f2);
        const s2 = math.sin(f2);
        const t = math.tan(df / 4);
        const hx = 4 / 3 * rx * t;
        const hy = 4 / 3 * ry * t;
        const m1 = [
            x1,
            y1
        ];
        const m2 = [
            x1 + hx * s1,
            y1 - hy * c1
        ];
        const m3 = [
            x2 + hx * s2,
            y2 - hy * c2
        ];
        const m4 = [
            x2,
            y2
        ];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) return [
            m2,
            m3,
            m4
        ][concat](res);
        res = [
            m2,
            m3,
            m4
        ][concat](res).join()[split](',');
        const newres = [];
        for(let i = 0, ii = res.length; i < ii; i++)newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad1).y : rotate(res[i], res[i + 1], rad1).x;
        return newres;
    };
    const findDotAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        const t1 = 1 - t;
        return {
            x: t1 ** 3 * p1x + t1 ** 2 * 3 * t * c1x + t1 * 3 * t * t * c2x + t ** 3 * p2x,
            y: t1 ** 3 * p1y + t1 ** 2 * 3 * t * c1y + t1 * 3 * t * t * c2y + t ** 3 * p2y
        };
    };
    var curveDim = cacher('curveDim', (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y)=>{
        let a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x);
        let b = 2 * (c1x - p1x) - 2 * (c2x - c1x);
        let c = p1x - c1x;
        let t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
        let t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
        const y = [
            p1y,
            p2y
        ];
        const x = [
            p1x,
            p2x
        ];
        let dot;
        abs(t1) > '1e12' && (t1 = 0.5);
        abs(t2) > '1e12' && (t2 = 0.5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
        c = p1y - c1y;
        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
        abs(t1) > '1e12' && (t1 = 0.5);
        abs(t2) > '1e12' && (t2 = 0.5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        return {
            min: {
                x: mmin[apply](0, x),
                y: mmin[apply](0, y)
            },
            max: {
                x: mmax[apply](0, x),
                y: mmax[apply](0, y)
            }
        };
    });
    var path2curve = R1._path2curve = cacher('path2curve', (path1, path21)=>{
        const pth = !path21 && paths(path1);
        if (!path21 && pth.curve) return pathClone(pth.curve);
        const p = pathToAbsolute(path1);
        const p2 = path21 && pathToAbsolute(path21);
        const attrs = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        };
        const attrs2 = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        };
        const processPath = function(path, d, pcom) {
            let nx;
            let ny;
            const tq = {
                T: 1,
                Q: 1
            };
            if (!path) return [
                'C',
                d.x,
                d.y,
                d.x,
                d.y,
                d.x,
                d.y
            ];
            !(path[0] in tq) && (d.qx = d.qy = null);
            switch(path[0]){
                case 'M':
                    d.X = path[1];
                    d.Y = path[2];
                    break;
                case 'A':
                    path = [
                        'C'
                    ][concat](a2c[apply](0, [
                        d.x,
                        d.y
                    ][concat](path.slice(1))));
                    break;
                case 'S':
                    if (pcom == 'C' || pcom == 'S') {
                        // In "S" case we have to take into account, if the previous command is C/S.
                        nx = d.x * 2 - d.bx // And reflect the previous
                        ;
                        ny = d.y * 2 - d.by // command's control point relative to the current point.
                        ;
                    } else {
                        // or some else or nothing
                        nx = d.x;
                        ny = d.y;
                    }
                    path = [
                        'C',
                        nx,
                        ny
                    ][concat](path.slice(1));
                    break;
                case 'T':
                    if (pcom == 'Q' || pcom == 'T') {
                        // In "T" case we have to take into account, if the previous command is Q/T.
                        d.qx = d.x * 2 - d.qx // And make a reflection similar
                        ;
                        d.qy = d.y * 2 - d.qy // to case "S".
                        ;
                    } else {
                        // or something else or nothing
                        d.qx = d.x;
                        d.qy = d.y;
                    }
                    path = [
                        'C'
                    ][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                    break;
                case 'Q':
                    d.qx = path[1];
                    d.qy = path[2];
                    path = [
                        'C'
                    ][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                    break;
                case 'L':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, path[1], path[2]));
                    break;
                case 'H':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, path[1], d.y));
                    break;
                case 'V':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, d.x, path[1]));
                    break;
                case 'Z':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, d.X, d.Y));
                    break;
            }
            return path;
        };
        const fixArc = function(pp, i) {
            if (pp[i].length > 7) {
                pp[i].shift();
                const pi = pp[i];
                while(pi.length){
                    pcoms1[i] = 'A' // if created multiple C:s, their original seg is saved
                    ;
                    p2 && (pcoms2[i] = 'A') // the same as above
                    ;
                    pp.splice(i++, 0, [
                        'C'
                    ][concat](pi.splice(0, 6)));
                }
                pp.splice(i, 1);
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        const fixM = function(path1, path2, a1, a2, i) {
            if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
                path2.splice(i, 0, [
                    'M',
                    a2.x,
                    a2.y
                ]);
                a1.bx = 0;
                a1.by = 0;
                a1.x = path1[i][1];
                a1.y = path1[i][2];
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        var pcoms1 = [] // path commands of original path p
        ;
        var pcoms2 = [] // path commands of original path p2
        ;
        let pfirst = '' // temporary holder for original path command
        ;
        let pcom1 = '' // holder for previous path command of original path
        ;
        for(var i2 = 0, ii = mmax(p.length, p2 && p2.length || 0); i2 < ii; i2++){
            p[i2] && (pfirst = p[i2][0]) // save current path command
            ;
            if (pfirst != 'C') {
                // C is not saved yet, because it may be result of conversion
                pcoms1[i2] = pfirst // Save current path command
                ;
                i2 && (pcom1 = pcoms1[i2 - 1]) // Get previous path command pcom
                ;
            }
            p[i2] = processPath(p[i2], attrs, pcom1) // Previous path command is inputted to processPath
            ;
            if (pcoms1[i2] != 'A' && pfirst == 'C') pcoms1[i2] = 'C' // A is the only command
            ;
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path
            fixArc(p, i2) // fixArc adds also the right amount of A:s to pcoms1
            ;
            if (p2) {
                // the same procedures is done to p2
                p2[i2] && (pfirst = p2[i2][0]);
                if (pfirst != 'C') {
                    pcoms2[i2] = pfirst;
                    i2 && (pcom1 = pcoms2[i2 - 1]);
                }
                p2[i2] = processPath(p2[i2], attrs2, pcom1);
                if (pcoms2[i2] != 'A' && pfirst == 'C') pcoms2[i2] = 'C';
                fixArc(p2, i2);
            }
            fixM(p, p2, attrs, attrs2, i2);
            fixM(p2, p, attrs2, attrs, i2);
            const seg = p[i2];
            const seg2 = p2 && p2[i2];
            const seglen = seg.length;
            const seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) pth.curve = pathClone(p);
        return p2 ? [
            p,
            p2
        ] : p;
    }, null, pathClone);
    const parseDots = R1._parseDots = cacher('parseDots', (gradient)=>{
        const dots = [];
        for(var i = 0, ii = gradient.length; i < ii; i++){
            const dot = {
            };
            const par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
            dot.color = R1.getRGB(par[1]);
            if (dot.color.error) return null;
            dot.opacity = dot.color.opacity;
            dot.color = dot.color.hex;
            par[2] && (dot.offset = `${par[2]}%`);
            dots.push(dot);
        }
        for(i = 1, ii = dots.length - 1; i < ii; i++)if (!dots[i].offset) {
            let start = toFloat(dots[i - 1].offset || 0);
            let end = 0;
            for(var j = i + 1; j < ii; j++)if (dots[j].offset) {
                end = dots[j].offset;
                break;
            }
            if (!end) {
                end = 100;
                j = ii;
            }
            end = toFloat(end);
            const d = (end - start) / (j - i + 1);
            for(; i < j; i++){
                start += d;
                dots[i].offset = `${start}%`;
            }
        }
        return dots;
    });
    const tear = R1._tear = function(el, paper) {
        el == paper.top && (paper.top = el.prev);
        el == paper.bottom && (paper.bottom = el.next);
        el.next && (el.next.prev = el.prev);
        el.prev && (el.prev.next = el.next);
    };
    const tofront = R1._tofront = function(el, paper) {
        if (paper.top === el) return;
        tear(el, paper);
        el.next = null;
        el.prev = paper.top;
        paper.top.next = el;
        paper.top = el;
    };
    const toback = R1._toback = function(el, paper) {
        if (paper.bottom === el) return;
        tear(el, paper);
        el.next = paper.bottom;
        el.prev = null;
        paper.bottom.prev = el;
        paper.bottom = el;
    };
    const insertafter = R1._insertafter = function(el, el2, paper) {
        tear(el, paper);
        el2 == paper.top && (paper.top = el);
        el2.next && (el2.next.prev = el);
        el.next = el2.next;
        el.prev = el2;
        el2.next = el;
    };
    const insertbefore = R1._insertbefore = function(el, el2, paper) {
        tear(el, paper);
        el2 == paper.bottom && (paper.bottom = el);
        el2.prev && (el2.prev.next = el);
        el.prev = el2.prev;
        el2.prev = el;
        el.next = el2;
    };
    /* \
     * Raphael.toMatrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix of transformations applied to a given path
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (object) @Matrix
    \ */ const toMatrix = R1.toMatrix = function(path, transform) {
        const bb = pathDimensions(path);
        const el = {
            _: {
                transform: E
            },
            getBBox () {
                return bb;
            }
        };
        extractTransform(el, transform);
        return el.matrix;
    };
    /* \
     * Raphael.transformPath
     [ method ]
     **
     * Utility method
     **
     * Returns path transformed by a given transformation
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (string) path
    \ */ const transformPath = R1.transformPath = function(path, transform) {
        return mapPath(path, toMatrix(path, transform));
    };
    var extractTransform = R1._extractTransform = function(el, tstr) {
        if (tstr == null) return el._.transform;
        tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
        const tdata = R1.parseTransformString(tstr);
        let deg = 0;
        let dx = 0;
        let dy = 0;
        let sx = 1;
        let sy = 1;
        const { _  } = el;
        const m = new Matrix();
        _.transform = tdata || [];
        if (tdata) for(let i = 0, ii = tdata.length; i < ii; i++){
            const t = tdata[i];
            const tlen = t.length;
            const command = Str(t[0]).toLowerCase();
            const absolute = t[0] != command;
            const inver = absolute ? m.invert() : 0;
            var x1;
            var y1;
            var x2;
            var y2;
            var bb;
            if (command == 't' && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else m.translate(t[1], t[2]);
            } else if (command == 'r') {
                if (tlen == 2) {
                    bb = bb || el.getBBox(1);
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    deg += t[1];
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else m.rotate(t[1], t[2], t[3]);
                    deg += t[1];
                }
            } else if (command == 's') {
                if (tlen == 2 || tlen == 3) {
                    bb = bb || el.getBBox(1);
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    sx *= t[1];
                    sy *= t[tlen - 1];
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else m.scale(t[1], t[2], t[3], t[4]);
                    sx *= t[1];
                    sy *= t[2];
                }
            } else if (command == 'm' && tlen == 7) m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            _.dirtyT = 1;
            el.matrix = m;
        }
        /* \
       * Element.matrix
       [ property (object) ]
       **
       * Keeps @Matrix object, which represents element transformation
      \ */ el.matrix = m;
        _.sx = sx;
        _.sy = sy;
        _.deg = deg;
        _.dx = dx = m.e;
        _.dy = dy = m.f;
        if (sx == 1 && sy == 1 && !deg && _.bbox) {
            _.bbox.x += +dx;
            _.bbox.y += +dy;
        } else _.dirtyT = 1;
    };
    const getEmpty = function(item) {
        const l = item[0];
        switch(l.toLowerCase()){
            case 't':
                return [
                    l,
                    0,
                    0
                ];
            case 'm':
                return [
                    l,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0
                ];
            case 'r':
                if (item.length == 4) return [
                    l,
                    0,
                    item[2],
                    item[3]
                ];
                return [
                    l,
                    0
                ];
            case 's':
                if (item.length == 5) return [
                    l,
                    1,
                    1,
                    item[3],
                    item[4]
                ];
                if (item.length == 3) return [
                    l,
                    1,
                    1
                ];
                return [
                    l,
                    1
                ];
        }
    };
    const equaliseTransform = R1._equaliseTransform = function(t1, t2) {
        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
        t1 = R1.parseTransformString(t1) || [];
        t2 = R1.parseTransformString(t2) || [];
        const maxlength = mmax(t1.length, t2.length);
        const from = [];
        const to = [];
        let i = 0;
        let j;
        let jj;
        let tt1;
        let tt2;
        for(; i < maxlength; i++){
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == 'r' && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == 's' && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) return;
            from[i] = [];
            to[i] = [];
            for(j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++){
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from,
            to
        };
    };
    R1._getContainer = function(x, y, w, h) {
        let container;
        container = h == null && !R1.is(x, 'object') ? g1.doc.getElementById(x) : x;
        if (container == null) return;
        if (container.tagName) {
            if (y == null) return {
                container,
                width: container.style.pixelWidth || container.offsetWidth,
                height: container.style.pixelHeight || container.offsetHeight
            };
            return {
                container,
                width: y,
                height: w
            };
        }
        return {
            container: 1,
            x,
            y,
            width: w,
            height: h
        };
    };
    /* \
   * Raphael.pathToRelative
   [ method ]
   **
   * Utility method
   **
   * Converts path to relative form
   > Parameters
   - pathString (string|array) path string or array of segments
   = (array) array of segments.
  \ */ R1.pathToRelative = pathToRelative;
    R1._engine = {
    };
    /* \
   * Raphael.path2curve
   [ method ]
   **
   * Utility method
   **
   * Converts path to a new path where all segments are cubic bezier curves.
   > Parameters
   - pathString (string|array) path string or array of segments
   = (array) array of segments.
  \ */ R1.path2curve = path2curve;
    /* \
   * Raphael.matrix
   [ method ]
   **
   * Utility method
   **
   * Returns matrix based on given parameters.
   > Parameters
   - a (number)
   - b (number)
   - c (number)
   - d (number)
   - e (number)
   - f (number)
   = (object) @Matrix
  \ */ R1.matrix = function(a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function(matrixproto) {
        /* \
     * Matrix.add
     [ method ]
     **
     * Adds given matrix to existing one.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     or
     - matrix (object) @Matrix
    \ */ matrixproto.add = function(a, b, c, d, e, f) {
            const out = [
                [],
                [],
                []
            ];
            const m = [
                [
                    this.a,
                    this.c,
                    this.e
                ],
                [
                    this.b,
                    this.d,
                    this.f
                ],
                [
                    0,
                    0,
                    1
                ], 
            ];
            let matrix = [
                [
                    a,
                    c,
                    e
                ],
                [
                    b,
                    d,
                    f
                ],
                [
                    0,
                    0,
                    1
                ], 
            ];
            let x;
            let y;
            let z;
            let res;
            if (a && a instanceof Matrix) matrix = [
                [
                    a.a,
                    a.c,
                    a.e
                ],
                [
                    a.b,
                    a.d,
                    a.f
                ],
                [
                    0,
                    0,
                    1
                ], 
            ];
            for(x = 0; x < 3; x++)for(y = 0; y < 3; y++){
                res = 0;
                for(z = 0; z < 3; z++)res += m[x][z] * matrix[z][y];
                out[x][y] = res;
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /* \
     * Matrix.invert
     [ method ]
     **
     * Returns inverted version of the matrix
     = (object) @Matrix
    \ */ matrixproto.invert = function() {
            const me = this;
            const x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /* \
     * Matrix.clone
     [ method ]
     **
     * Returns copy of the matrix
     = (object) @Matrix
    \ */ matrixproto.clone = function() {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /* \
     * Matrix.translate
     [ method ]
     **
     * Translate the matrix
     > Parameters
     - x (number)
     - y (number)
    \ */ matrixproto.translate = function(x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /* \
     * Matrix.scale
     [ method ]
     **
     * Scales the matrix
     > Parameters
     - x (number)
     - y (number) #optional
     - cx (number) #optional
     - cy (number) #optional
    \ */ matrixproto.scale = function(x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /* \
     * Matrix.rotate
     [ method ]
     **
     * Rotates the matrix
     > Parameters
     - a (number)
     - x (number)
     - y (number)
    \ */ matrixproto.rotate = function(a, x, y) {
            a = R1.rad(a);
            x = x || 0;
            y = y || 0;
            const cos = +math.cos(a).toFixed(9);
            const sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /* \
     * Matrix.x
     [ method ]
     **
     * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
     > Parameters
     - x (number)
     - y (number)
     = (number) x
    \ */ matrixproto.x = function(x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /* \
     * Matrix.y
     [ method ]
     **
     * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
     > Parameters
     - x (number)
     - y (number)
     = (number) y
    \ */ matrixproto.y = function(x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function(i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function() {
            return R1.svg ? `matrix(${[
                this.get(0),
                this.get(1),
                this.get(2),
                this.get(3),
                this.get(4),
                this.get(5), 
            ].join()})` : [
                this.get(0),
                this.get(2),
                this.get(1),
                this.get(3),
                0,
                0
            ].join();
        };
        matrixproto.toFilter = function() {
            return `progid:DXImageTransform.Microsoft.Matrix(M11=${this.get(0)}, M12=${this.get(2)}, M21=${this.get(1)}, M22=${this.get(3)}, Dx=${this.get(4)}, Dy=${this.get(5)}, sizingmethod='auto expand')`;
        };
        matrixproto.offset = function() {
            return [
                this.e.toFixed(4),
                this.f.toFixed(4)
            ];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            const mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /* \
     * Matrix.split
     [ method ]
     **
     * Splits matrix into primitive transformations
     = (object) in format:
     o dx (number) translation by x
     o dy (number) translation by y
     o scalex (number) scale by x
     o scaley (number) scale by y
     o shear (number) shear
     o rotate (number) rotation in deg
     o isSimple (boolean) could it be represented via simple transformations
    \ */ matrixproto.split = function() {
            const out = {
            };
            // translation
            out.dx = this.e;
            out.dy = this.f;
            // scale and shear
            const row = [
                [
                    this.a,
                    this.c
                ],
                [
                    this.b,
                    this.d
                ], 
            ];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);
            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [
                row[1][0] - row[0][0] * out.shear,
                row[1][1] - row[0][1] * out.shear, 
            ];
            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;
            // rotation
            const sin = -row[0][1];
            const cos = row[1][1];
            if (cos < 0) {
                out.rotate = R1.deg(math.acos(cos));
                if (sin < 0) out.rotate = 360 - out.rotate;
            } else out.rotate = R1.deg(math.asin(sin));
            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /* \
     * Matrix.toTransformString
     [ method ]
     **
     * Return transform string that represents given matrix
     = (string) transform string
    \ */ matrixproto.toTransformString = function(shorter) {
            const s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return (s.dx || s.dy ? `t${[
                    s.dx,
                    s.dy
                ]}` : E) + (s.scalex != 1 || s.scaley != 1 ? `s${[
                    s.scalex,
                    s.scaley,
                    0,
                    0
                ]}` : E) + (s.rotate ? `r${[
                    s.rotate,
                    0,
                    0
                ]}` : E);
            }
            return `m${[
                this.get(0),
                this.get(1),
                this.get(2),
                this.get(3),
                this.get(4),
                this.get(5), 
            ]}`;
        };
    })(Matrix.prototype);
    const preventDefault = function() {
        this.returnValue = false;
    };
    const preventTouch = function() {
        return this.originalEvent.preventDefault();
    };
    const stopPropagation = function() {
        this.cancelBubble = true;
    };
    const stopTouch = function() {
        return this.originalEvent.stopPropagation();
    };
    const getEventPosition = function(e) {
        const scrollY = g1.doc.documentElement.scrollTop || g1.doc.body.scrollTop;
        const scrollX = g1.doc.documentElement.scrollLeft || g1.doc.body.scrollLeft;
        return {
            x: e.clientX + scrollX,
            y: e.clientY + scrollY
        };
    };
    const addEvent = function() {
        if (g1.doc.addEventListener) return function(obj, type, fn, element) {
            const f = function(e) {
                const pos = getEventPosition(e);
                return fn.call(element, e, pos.x, pos.y);
            };
            obj.addEventListener(type, f, false);
            if (supportsTouch && touchMap[type]) {
                var _f = function(e) {
                    const pos = getEventPosition(e);
                    const olde = e;
                    for(let i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++)if (e.targetTouches[i].target == obj) {
                        e = e.targetTouches[i];
                        e.originalEvent = olde;
                        e.preventDefault = preventTouch;
                        e.stopPropagation = stopTouch;
                        break;
                    }
                    return fn.call(element, e, pos.x, pos.y);
                };
                obj.addEventListener(touchMap[type], _f, false);
            }
            return function() {
                obj.removeEventListener(type, f, false);
                if (supportsTouch && touchMap[type]) obj.removeEventListener(touchMap[type], _f, false);
                return true;
            };
        };
        if (g1.doc.attachEvent) return function(obj, type, fn, element) {
            const f = function(e) {
                e = e || g1.win.event;
                const scrollY = g1.doc.documentElement.scrollTop || g1.doc.body.scrollTop;
                const scrollX = g1.doc.documentElement.scrollLeft || g1.doc.body.scrollLeft;
                const x = e.clientX + scrollX;
                const y = e.clientY + scrollY;
                e.preventDefault = e.preventDefault || preventDefault;
                e.stopPropagation = e.stopPropagation || stopPropagation;
                return fn.call(element, e, x, y);
            };
            obj.attachEvent(`on${type}`, f);
            const detacher = function() {
                obj.detachEvent(`on${type}`, f);
                return true;
            };
            return detacher;
        };
    }();
    let drag = [];
    const dragMove = function(e) {
        let x = e.clientX;
        let y = e.clientY;
        const scrollY = g1.doc.documentElement.scrollTop || g1.doc.body.scrollTop;
        const scrollX = g1.doc.documentElement.scrollLeft || g1.doc.body.scrollLeft;
        let dragi;
        let j = drag.length;
        while(j--){
            dragi = drag[j];
            if (supportsTouch && e.touches) {
                let i = e.touches.length;
                var touch;
                while(i--){
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else e.preventDefault();
            const { node  } = dragi.el;
            var o;
            const next = node.nextSibling;
            const parent = node.parentNode;
            const { display  } = node.style;
            g1.win.opera && parent.removeChild(node);
            node.style.display = 'none';
            o = dragi.el.paper.getElementByPoint(x, y);
            node.style.display = display;
            g1.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
            o && _eveJs.eve(`raphael.drag.over.${dragi.el.id}`, dragi.el, o);
            x += scrollX;
            y += scrollY;
            _eveJs.eve(`raphael.drag.move.${dragi.el.id}`, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
        }
    };
    var dragUp = function(e) {
        R1.unmousemove(dragMove).unmouseup(dragUp);
        let i = drag.length;
        let dragi;
        while(i--){
            dragi = drag[i];
            dragi.el._drag = {
            };
            _eveJs.eve(`raphael.drag.end.${dragi.el.id}`, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    };
    /* \
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is useful when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldn’t affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \ */ const elproto = R1.el = {
    };
    /* \
   * Element.click
   [ method ]
   **
   * Adds event handler for click for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unclick
   [ method ]
   **
   * Removes event handler for click for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.dblclick
   [ method ]
   **
   * Adds event handler for double click for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.undblclick
   [ method ]
   **
   * Removes event handler for double click for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mousedown
   [ method ]
   **
   * Adds event handler for mousedown for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmousedown
   [ method ]
   **
   * Removes event handler for mousedown for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mousemove
   [ method ]
   **
   * Adds event handler for mousemove for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmousemove
   [ method ]
   **
   * Removes event handler for mousemove for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseout
   [ method ]
   **
   * Adds event handler for mouseout for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseout
   [ method ]
   **
   * Removes event handler for mouseout for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseover
   [ method ]
   **
   * Adds event handler for mouseover for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseover
   [ method ]
   **
   * Removes event handler for mouseover for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseup
   [ method ]
   **
   * Adds event handler for mouseup for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseup
   [ method ]
   **
   * Removes event handler for mouseup for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchstart
   [ method ]
   **
   * Adds event handler for touchstart for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchstart
   [ method ]
   **
   * Removes event handler for touchstart for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchmove
   [ method ]
   **
   * Adds event handler for touchmove for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchmove
   [ method ]
   **
   * Removes event handler for touchmove for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchend
   [ method ]
   **
   * Adds event handler for touchend for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchend
   [ method ]
   **
   * Removes event handler for touchend for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchcancel
   [ method ]
   **
   * Adds event handler for touchcancel for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchcancel
   [ method ]
   **
   * Removes event handler for touchcancel for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ for(let i1 = events1.length; i1--;)(function(eventName) {
        R1[eventName] = elproto[eventName] = function(fn, scope) {
            if (R1.is(fn, 'function')) {
                this.events = this.events || [];
                this.events.push({
                    name: eventName,
                    f: fn,
                    unbind: addEvent(this.shape || this.node || g1.doc, eventName, fn, scope || this)
                });
            }
            return this;
        };
        R1[`un${eventName}`] = elproto[`un${eventName}`] = function(fn) {
            const events = this.events || [];
            let l = events.length;
            while(l--)if (events[l].name == eventName && (R1.is(fn, 'undefined') || events[l].f == fn)) {
                events[l].unbind();
                events.splice(l, 1);
                !events.length && delete this.events;
            }
            return this;
        };
    })(events1[i1]);
    /* \
   * Element.data
   [ method ]
   **
   * Adds or retrieves given value associated with given key.
   **
   * See also @Element.removeData
   > Parameters
   - key (string) key to store data
   - value (any) #optional value to store
   = (object) @Element
   * or, if value is not specified:
   = (any) value
   * or, if key and value are not specified:
   = (object) Key/value pairs for all the data associated with the element.
   > Usage
   | for (var i = 0, i < 5, i++) {
   |     paper.circle(10 + 15 * i, 10, 10)
   |          .attr({fill: "#000"})
   |          .data("i", i)
   |          .click(function () {
   |             alert(this.data("i"));
   |          });
   | }
  \ */ elproto.data = function(key, value) {
        const data = eldata[this.id] = eldata[this.id] || {
        };
        if (arguments.length == 0) return data;
        if (arguments.length == 1) {
            if (R1.is(key, 'object')) {
                for(const i in key)if (key[has](i)) this.data(i, key[i]);
                return this;
            }
            _eveJs.eve(`raphael.data.get.${this.id}`, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        _eveJs.eve(`raphael.data.set.${this.id}`, this, value, key);
        return this;
    };
    /* \
   * Element.removeData
   [ method ]
   **
   * Removes value associated with an element by given key.
   * If key is not provided, removes all the data of the element.
   > Parameters
   - key (string) #optional key
   = (object) @Element
  \ */ elproto.removeData = function(key) {
        if (key == null) eldata[this.id] = {
        };
        else eldata[this.id] && delete eldata[this.id][key];
        return this;
    };
    /* \
    * Element.getData
    [ method ]
    **
    * Retrieves the element data
    = (object) data
  \ */ elproto.getData = function() {
        return clone(eldata[this.id] || {
        });
    };
    /* \
   * Element.hover
   [ method ]
   **
   * Adds event handlers for hover for the element.
   > Parameters
   - f_in (function) handler for hover in
   - f_out (function) handler for hover out
   - icontext (object) #optional context for hover in handler
   - ocontext (object) #optional context for hover out handler
   = (object) @Element
  \ */ elproto.hover = function(f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /* \
   * Element.unhover
   [ method ]
   **
   * Removes event handlers for hover for the element.
   > Parameters
   - f_in (function) handler for hover in
   - f_out (function) handler for hover out
   = (object) @Element
  \ */ elproto.unhover = function(f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    const draggable = [];
    /* \
   * Element.drag
   [ method ]
   **
   * Adds event handlers for drag of the element.
   > Parameters
   - onmove (function) handler for moving
   - onstart (function) handler for drag start
   - onend (function) handler for drag end
   - mcontext (object) #optional context for moving handler
   - scontext (object) #optional context for drag start handler
   - econtext (object) #optional context for drag end handler
   * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,
   * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
   * `drag.over.<id>` will be fired as well.
   *
   * Start event and start handler will be called in specified context or in context of the element with following parameters:
   o x (number) x position of the mouse
   o y (number) y position of the mouse
   o event (object) DOM event object
   * Move event and move handler will be called in specified context or in context of the element with following parameters:
   o dx (number) shift by x from the start point
   o dy (number) shift by y from the start point
   o x (number) x position of the mouse
   o y (number) y position of the mouse
   o event (object) DOM event object
   * End event and end handler will be called in specified context or in context of the element with following parameters:
   o event (object) DOM event object
   = (object) @Element
  \ */ elproto.drag = function(onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            let x = e.clientX;
            let y = e.clientY;
            const scrollY = g1.doc.documentElement.scrollTop || g1.doc.body.scrollTop;
            const scrollX = g1.doc.documentElement.scrollLeft || g1.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                let i = e.touches.length;
                let touch;
                while(i--){
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R1.mousemove(dragMove).mouseup(dragUp);
            drag.push({
                el: this,
                move_scope,
                start_scope,
                end_scope
            });
            onstart && _eveJs.eve.on(`raphael.drag.start.${this.id}`, onstart);
            onmove && _eveJs.eve.on(`raphael.drag.move.${this.id}`, onmove);
            onend && _eveJs.eve.on(`raphael.drag.end.${this.id}`, onend);
            _eveJs.eve(`raphael.drag.start.${this.id}`, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this.start = start // SLATEBOX - makes text draggable
        ;
        this._drag = {
        };
        draggable.push({
            el: this,
            start
        });
        this.mousedown(start);
        return this;
    };
    /* \
   * Element.onDragOver
   [ method ]
   **
   * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
   > Parameters
   - f (function) handler for event, first argument would be the element you are dragging over
  \ */ elproto.onDragOver = function(f) {
        f ? _eveJs.eve.on(`raphael.drag.over.${this.id}`, f) : _eveJs.eve.unbind(`raphael.drag.over.${this.id}`);
    };
    /* \
   * Element.undrag
   [ method ]
   **
   * Removes all drag event handlers from given element.
  \ */ elproto.undrag = function() {
        let i = draggable.length;
        while(i--)if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            _eveJs.eve.unbind(`raphael.drag.*.${this.id}`);
        }
        !draggable.length && R1.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    /* \
   * Paper.circle
   [ method ]
   **
   * Draws a circle.
   **
   > Parameters
   **
   - x (number) x coordinate of the centre
   - y (number) y coordinate of the centre
   - r (number) radius
   = (object) Raphaël element object with type “circle”
   **
   > Usage
   | var c = paper.circle(50, 50, 40);
  \ */ paperproto.circle = function(x, y, r) {
        const out = R1._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.rect
   [ method ]
   *
   * Draws a rectangle.
   **
   > Parameters
   **
   - x (number) x coordinate of the top left corner
   - y (number) y coordinate of the top left corner
   - width (number) width
   - height (number) height
   - r (number) #optional radius for rounded corners, default is 0
   = (object) Raphaël element object with type “rect”
   **
   > Usage
   | // regular rectangle
   | var c = paper.rect(10, 10, 50, 50);
   | // rectangle with rounded corners
   | var c = paper.rect(40, 40, 50, 50, 10);
  \ */ paperproto.rect = function(x, y, w, h, r) {
        const out = R1._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
     * Paper.g
     [ method ]
     *
     * Draws a svg group (g) element.
     **
    \ */ paperproto.g = function() {
        const out = R1._engine.g(this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
     * Paper.def
     [ method ]
     *
     * Adds a <def>
     **
    \ */ paperproto.def = function(def) {
        R1._engine.def.call(this, def);
    };
    /* \
   * Paper.ellipse
   [ method ]
   **
   * Draws an ellipse.
   **
   > Parameters
   **
   - x (number) x coordinate of the centre
   - y (number) y coordinate of the centre
   - rx (number) horizontal radius
   - ry (number) vertical radius
   = (object) Raphaël element object with type “ellipse”
   **
   > Usage
   | var c = paper.ellipse(50, 50, 40, 20);
  \ */ paperproto.ellipse = function(x, y, rx, ry) {
        const out = R1._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.path
   [ method ]
   **
   * Creates a path element by given path data string.
   > Parameters
   - pathString (string) #optional path string in SVG format.
   * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
   | "M10,20L30,40"
   * Here we can see two commands: “M”, with arguments `(10, 20)` and “L” with arguments `(30, 40)`. Upper case letter mean command is absolute, lower case—relative.
   *
   # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
   # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
   # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
   # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
   # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
   # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
   # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
   # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
   # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
   # <tr><td>Q</td><td>quadratic Bézier curveto</td><td>(x1 y1 x y)+</td></tr>
   # <tr><td>T</td><td>smooth quadratic Bézier curveto</td><td>(x y)+</td></tr>
   # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
   # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmull–Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
   * * “Catmull-Rom curveto” is a not standard SVG command and added in 2.0 to make life easier.
   * Note: there is a special case when path consist of just three commands: “M10,10R…z”. In this case path will smoothly connects to its beginning.
   > Usage
   | var c = paper.path("M10 10L90 90");
   | // draw a diagonal line:
   | // move to 10,10, line to 90,90
   * For example of path strings, check out these icons: http://raphaeljs.com/icons/
  \ */ paperproto.path = function(pathString) {
        pathString && !R1.is(pathString, string1) && !R1.is(pathString[0], array1) && (pathString += E);
        const out = R1._engine.path(R1.format[apply](R1, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.image
   [ method ]
   **
   * Embeds an image into the surface.
   **
   > Parameters
   **
   - src (string) URI of the source image
   - x (number) x coordinate position
   - y (number) y coordinate position
   - width (number) width of the image
   - height (number) height of the image
   = (object) Raphaël element object with type “image”
   **
   > Usage
   | var c = paper.image("apple.png", 10, 10, 80, 80);
  \ */ paperproto.image = function(src, x, y, w, h) {
        const out = R1._engine.image(this, src || 'about:blank', x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.text
   [ method ]
   **
   * Draws a text string. If you need line breaks, put “\n” in the string.
   **
   > Parameters
   **
   - x (number) x coordinate position
   - y (number) y coordinate position
   - text (string) The text string to draw
   = (object) Raphaël element object with type “text”
   **
   > Usage
   | var t = paper.text(50, 50, "Raphaël\nkicks\nbutt!");
  \ */ paperproto.text = function(x, y, text) {
        const out = R1._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.set
   [ method ]
   **
   * Creates array-like object to keep and operate several elements at once.
   * Warning: it doesn’t create any elements for itself in the page, it just groups existing elements.
   * Sets act as pseudo elements — all methods available to an element can be used on a set.
   = (object) array-like object that represents set of elements
   **
   > Usage
   | var st = paper.set();
   | st.push(
   |     paper.circle(10, 10, 5),
   |     paper.circle(30, 10, 5)
   | );
   | st.attr({fill: "red"}); // changes the fill of both circles
  \ */ paperproto.set = function(itemsArray) {
        !R1.is(itemsArray, 'array') && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        const out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out.paper = this;
        out.type = 'set';
        return out;
    };
    /* \
   * Paper.setStart
   [ method ]
   **
   * Creates @Paper.set. All elements that will be created after calling this method and before calling
   * @Paper.setFinish will be added to the set.
   **
   > Usage
   | paper.setStart();
   | paper.circle(10, 10, 5),
   | paper.circle(30, 10, 5)
   | var st = paper.setFinish();
   | st.attr({fill: "red"}); // changes the fill of both circles
  \ */ paperproto.setStart = function(set) {
        this.__set__ = set || this.set();
    };
    /* \
   * Paper.setFinish
   [ method ]
   **
   * See @Paper.setStart. This method finishes catching and returns resulting set.
   **
   = (object) set
  \ */ paperproto.setFinish = function(set) {
        const out = this.__set__;
        delete this.__set__;
        return out;
    };
    /* \
   * Paper.getSize
   [ method ]
   **
   * Obtains current paper actual size.
   **
   = (object)
   \ */ paperproto.getSize = function() {
        const container = this.canvas.parentNode;
        return {
            width: container.offsetWidth,
            height: container.offsetHeight
        };
    };
    /* \
   * Paper.setSize
   [ method ]
   **
   * If you need to change dimensions of the canvas call this method
   **
   > Parameters
   **
   - width (number) new width of the canvas
   - height (number) new height of the canvas
  \ */ paperproto.setSize = function(width, height) {
        return R1._engine.setSize.call(this, width, height);
    };
    /* \
   * Paper.setViewBox
   [ method ]
   **
   * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
   * specifying new boundaries.
   **
   > Parameters
   **
   - x (number) new x position, default is `0`
   - y (number) new y position, default is `0`
   - w (number) new width of the canvas
   - h (number) new height of the canvas
   - fit (boolean) `true` if you want graphics to fit into new boundary box
  \ */ paperproto.setViewBox = function(x, y, w, h, fit) {
        return R1._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /* \
   * Paper.top
   [ property ]
   **
   * Points to the topmost element on the paper
  \ */ /* \
   * Paper.bottom
   [ property ]
   **
   * Points to the bottom element on the paper
  \ */ paperproto.top = paperproto.bottom = null;
    /* \
   * Paper.raphael
   [ property ]
   **
   * Points to the @Raphael object/function
  \ */ paperproto.raphael = R1;
    const getOffset = function(elem) {
        const box = elem.getBoundingClientRect();
        const doc = elem.ownerDocument;
        const { body  } = doc;
        const docElem = doc.documentElement;
        const clientTop = docElem.clientTop || body.clientTop || 0;
        const clientLeft = docElem.clientLeft || body.clientLeft || 0;
        const top = box.top + (g1.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop;
        const left = box.left + (g1.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /* \
   * Paper.getElementByPoint
   [ method ]
   **
   * Returns you topmost element under given point.
   **
   = (object) Raphaël element object
   > Parameters
   **
   - x (number) x coordinate from the top left corner of the window
   - y (number) y coordinate from the top left corner of the window
   > Usage
   | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
  \ */ paperproto.getElementByPoint = function(x, y) {
        const paper = this;
        const svg = paper.canvas;
        let target = g1.doc.elementFromPoint(x, y);
        if (g1.win.opera && target.tagName == 'svg') {
            const so = getOffset(svg);
            const sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            const hits = svg.getIntersectionList(sr, null);
            if (hits.length) target = hits[hits.length - 1];
        }
        if (!target) return null;
        while(target.parentNode && target != svg.parentNode && !target.raphael)target = target.parentNode;
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };
    /* \
   * Paper.getElementsByBBox
   [ method ]
   **
   * Returns set of elements that have an intersecting bounding box
   **
   > Parameters
   **
   - bbox (object) bbox to check with
   = (object) @Set
   \ */ paperproto.getElementsByBBox = function(bbox) {
        const set = this.set();
        this.forEach((el)=>{
            if (R1.isBBoxIntersect(el.getBBox(), bbox)) set.push(el);
        });
        return set;
    };
    /* \
   * Paper.getById
   [ method ]
   **
   * Returns you element by its internal ID.
   **
   > Parameters
   **
   - id (number) id
   = (object) Raphaël element object
  \ */ paperproto.getById = function(id) {
        let bot = this.bottom;
        while(bot){
            if (bot.id == id) return bot;
            bot = bot.next;
        }
        return null;
    };
    /* \
   * Paper.forEach
   [ method ]
   **
   * Executes given function for each element on the paper
   *
   * If callback function returns `false` it will stop loop running.
   **
   > Parameters
   **
   - callback (function) function to run
   - thisArg (object) context object for the callback
   = (object) Paper object
   > Usage
   | paper.forEach(function (el) {
   |     el.attr({ stroke: "blue" });
   | });
  \ */ paperproto.forEach = function(callback, thisArg) {
        let bot = this.bottom;
        while(bot){
            if (callback.call(thisArg, bot) === false) return this;
            bot = bot.next;
        }
        return this;
    };
    /* \
   * Paper.getElementsByPoint
   [ method ]
   **
   * Returns set of elements that have common point inside
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (object) @Set
  \ */ paperproto.getElementsByPoint = function(x, y) {
        const set = this.set();
        this.forEach((el)=>{
            if (el.isPointInside(x, y)) set.push(el);
        });
        return set;
    };
    function x_y() {
        return this.x + S1 + this.y;
    }
    function x_y_w_h() {
        return `${this.x + S1 + this.y + S1 + this.width} \xd7 ${this.height}`;
    }
    /* \
   * Element.isPointInside
   [ method ]
   **
   * Determine if given point is inside this element’s shape
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (boolean) `true` if point inside the shape
  \ */ elproto.isPointInside = function(x, y) {
        let rp = this.realPath = getPath1[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) rp = R1.transformPath(rp, this.attr('transform'));
        return R1.isPointInsidePath(rp, x, y);
    };
    /* \
   * Element.getBBox
   [ method ]
   **
   * Return bounding box for a given element
   **
   > Parameters
   **
   - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
   = (object) Bounding box object:
   o {
   o     x: (number) top left corner x
   o     y: (number) top left corner y
   o     x2: (number) bottom right corner x
   o     y2: (number) bottom right corner y
   o     width: (number) width
   o     height: (number) height
   o }
  \ */ elproto.getBBox = function(isWithoutTransform) {
        if (this.removed) return {
        };
        const { _  } = this;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath1[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath1[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /* \
   * Element.clone
   [ method ]
   **
   = (object) clone of a given element
   **
  \ */ elproto.clone = function() {
        if (this.removed) return null;
        const out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Element.glow
   [ method ]
   **
   * Return set of elements that create glow-like effect around given element. See @Paper.set.
   *
   * Note: Glow is not connected to the element. If you change element attributes it won’t adjust itself.
   **
   > Parameters
   **
   - glow (object) #optional parameters object with all properties optional:
   o {
   o     width (number) size of the glow, default is `10`
   o     fill (boolean) will it be filled, default is `false`
   o     opacity (number) opacity, default is `0.5`
   o     offsetx (number) horizontal offset, default is `0`
   o     offsety (number) vertical offset, default is `0`
   o     color (string) glow colour, default is `black`
   o }
   = (object) @Paper.set of elements that represents glow
  \ */ elproto.glow = function(glow) {
        if (this.type == 'text') return null;
        glow = glow || {
        };
        const s = {
            width: (glow.width || 10) + (+this.attr('stroke-width') || 1),
            fill: glow.fill || false,
            opacity: glow.opacity == null ? 0.5 : glow.opacity,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || '#000'
        };
        const c = s.width / 2;
        const r = this.paper;
        const out = r.set();
        let path = this.realPath || getPath1[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for(let i = 1; i < c + 1; i++)out.push(r.path(path).attr({
            stroke: s.color,
            fill: s.fill ? s.color : 'none',
            'stroke-linejoin': 'round',
            'stroke-linecap': 'round',
            'stroke-width': +(s.width / c * i).toFixed(3),
            opacity: +(s.opacity / c).toFixed(3)
        }));
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    const curveslengths = {
    };
    const getPointAtSegmentLength = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        return R1.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
    };
    const getLengthFactory = function(istotal, subpath) {
        return function(path, length, onlystart) {
            path = path2curve(path);
            let x;
            let y;
            let p;
            let l;
            let sp = '';
            const subpaths = {
            };
            let point;
            let len = 0;
            for(let i = 0, ii = path.length; i < ii; i++){
                p = path[i];
                if (p[0] == 'M') {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += [
                                `C${point.start.x}`,
                                point.start.y,
                                point.m.x,
                                point.m.y,
                                point.x,
                                point.y, 
                            ];
                            if (onlystart) return sp;
                            subpaths.start = sp;
                            sp = [
                                `M${point.x}`,
                                `${point.y}C${point.n.x}`,
                                point.n.y,
                                point.end.x,
                                point.end.y,
                                p[5],
                                p[6], 
                            ].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {
                                x: point.x,
                                y: point.y,
                                alpha: point.alpha
                            };
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R1.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {
                x: point.x,
                y: point.y,
                alpha: point.alpha
            });
            return point;
        };
    };
    const getTotalLength = getLengthFactory(1);
    const getPointAtLength = getLengthFactory();
    const getSubpathsAtLength = getLengthFactory(0, 1);
    /* \
   * Raphael.getTotalLength
   [ method ]
   **
   * Returns length of the given path in pixels.
   **
   > Parameters
   **
   - path (string) SVG path string.
   **
   = (number) length.
  \ */ R1.getTotalLength = getTotalLength;
    /* \
   * Raphael.getPointAtLength
   [ method ]
   **
   * Return coordinates of the point located at the given length on the given path.
   **
   > Parameters
   **
   - path (string) SVG path string
   - length (number)
   **
   = (object) representation of the point:
   o {
   o     x: (number) x coordinate
   o     y: (number) y coordinate
   o     alpha: (number) angle of derivative
   o }
  \ */ R1.getPointAtLength = getPointAtLength;
    /* \
   * Raphael.getSubpath
   [ method ]
   **
   * Return subpath of a given path from given length to given length.
   **
   > Parameters
   **
   - path (string) SVG path string
   - from (number) position of the start of the segment
   - to (number) position of the end of the segment
   **
   = (string) pathstring for the segment
  \ */ R1.getSubpath = function(path, from, to) {
        if (this.getTotalLength(path) - to < 0.000001) return getSubpathsAtLength(path, from).end;
        const a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /* \
   * Element.getTotalLength
   [ method ]
   **
   * Returns length of the path in pixels. Only works for element of “path” type.
   = (number) length.
  \ */ elproto.getTotalLength = function() {
        const path = this.getPath();
        if (!path) return;
        if (this.node.getTotalLength) return this.node.getTotalLength();
        return getTotalLength(path);
    };
    /* \
   * Element.getPointAtLength
   [ method ]
   **
   * Return coordinates of the point located at the given length on the given path. Only works for element of “path” type.
   **
   > Parameters
   **
   - length (number)
   **
   = (object) representation of the point:
   o {
   o     x: (number) x coordinate
   o     y: (number) y coordinate
   o     alpha: (number) angle of derivative
   o }
  \ */ elproto.getPointAtLength = function(length) {
        const path = this.getPath();
        if (!path) return;
        return getPointAtLength(path, length);
    };
    /* \
   * Element.getPath
   [ method ]
   **
   * Returns path of the element. Only works for elements of “path” type and simple elements like circle.
   = (object) path
   **
  \ */ elproto.getPath = function() {
        let path;
        const getPath = R1._getPath[this.type];
        if (this.type == 'text' || this.type == 'set') return;
        if (getPath) path = getPath(this);
        return path;
    };
    /* \
   * Element.getSubpath
   [ method ]
   **
   * Return subpath of a given element from given length to given length. Only works for element of “path” type.
   **
   > Parameters
   **
   - from (number) position of the start of the segment
   - to (number) position of the end of the segment
   **
   = (string) pathstring for the segment
  \ */ elproto.getSubpath = function(from, to) {
        const path = this.getPath();
        if (!path) return;
        return R1.getSubpath(path, from, to);
    };
    /* \
   * Raphael.easing_formulas
   [ property ]
   **
   * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
   # <ul>
   #     <li>“linear”</li>
   #     <li>“&lt;” or “easeIn” or “ease-in”</li>
   #     <li>“>” or “easeOut” or “ease-out”</li>
   #     <li>“&lt;>” or “easeInOut” or “ease-in-out”</li>
   #     <li>“backIn” or “back-in”</li>
   #     <li>“backOut” or “back-out”</li>
   #     <li>“elastic”</li>
   #     <li>“bounce”</li>
   # </ul>
   # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
  \ */ const ef = R1.easing_formulas = {
        linear (n) {
            return n;
        },
        '<': function(n) {
            return n ** 1.7;
        },
        '>': function(n) {
            return n ** 0.48;
        },
        '<>': function(n) {
            const q = 0.48 - n / 1.04;
            const Q = math.sqrt(0.1734 + q * q);
            const x = Q - q;
            const X = abs(x) ** (1 / 3) * (x < 0 ? -1 : 1);
            const y = -Q - q;
            const Y = abs(y) ** (1 / 3) * (y < 0 ? -1 : 1);
            const t = X + Y + 0.5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn (n) {
            const s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut (n) {
            n -= 1;
            const s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic (n) {
            if (n == !!n) return n;
            return 2 ** (-10 * n) * math.sin((n - 0.075) * (2 * PI) / 0.3) + 1;
        },
        bounce (n) {
            const s = 7.5625;
            const p = 2.75;
            let l;
            if (n < 1 / p) l = s * n * n;
            else if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + 0.75;
            } else if (n < 2.5 / p) {
                n -= 2.25 / p;
                l = s * n * n + 0.9375;
            } else {
                n -= 2.625 / p;
                l = s * n * n + 0.984375;
            }
            return l;
        }
    };
    ef.easeIn = ef['ease-in'] = ef['<'];
    ef.easeOut = ef['ease-out'] = ef['>'];
    ef.easeInOut = ef['ease-in-out'] = ef['<>'];
    ef['back-in'] = ef.backIn;
    ef['back-out'] = ef.backOut;
    const animationElements = [];
    const requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        setTimeout(callback, 16);
    };
    var animation = function() {
        const Now = +new Date();
        let l = 0;
        for(; l < animationElements.length; l++){
            const e = animationElements[l];
            if (e.el.removed || e.paused) continue;
            let time = Now - e.start;
            var { ms  } = e;
            const { easing  } = e;
            var { from  } = e;
            var { diff  } = e;
            const { to  } = e;
            const { t  } = e;
            const that1 = e.el;
            const set = {
            };
            var now;
            const init = {
            };
            var key;
            if (e.initstatus) {
                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                e.status = e.initstatus;
                delete e.initstatus;
                e.stop && animationElements.splice(l--, 1);
            } else e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
            if (time < 0) continue;
            if (time < ms) {
                var pos = easing(time / ms);
                for(var attr in from)if (from[has](attr)) {
                    switch(availableAnimAttrs[attr]){
                        case nu:
                            now = +from[attr] + pos * ms * diff[attr];
                            break;
                        case 'colour':
                            now = `rgb(${[
                                upto255(round1(from[attr].r + pos * ms * diff[attr].r)),
                                upto255(round1(from[attr].g + pos * ms * diff[attr].g)),
                                upto255(round1(from[attr].b + pos * ms * diff[attr].b)), 
                            ].join(',')})`;
                            break;
                        case 'path':
                            now = [];
                            for(var i = 0, ii = from[attr].length; i < ii; i++){
                                now[i] = [
                                    from[attr][i][0]
                                ];
                                for(var j = 1, jj = from[attr][i].length; j < jj; j++)now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                now[i] = now[i].join(S1);
                            }
                            now = now.join(S1);
                            break;
                        case 'transform':
                            if (diff[attr].real) {
                                now = [];
                                for(i = 0, ii = from[attr].length; i < ii; i++){
                                    now[i] = [
                                        from[attr][i][0]
                                    ];
                                    for(j = 1, jj = from[attr][i].length; j < jj; j++)now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                }
                            } else {
                                const get = function(i) {
                                    return +from[attr][i] + pos * ms * diff[attr][i];
                                };
                                // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                now = [
                                    [
                                        'm',
                                        get(0),
                                        get(1),
                                        get(2),
                                        get(3),
                                        get(4),
                                        get(5)
                                    ]
                                ];
                            }
                            break;
                        case 'csv':
                            if (attr == 'clip-rect') {
                                now = [];
                                i = 4;
                                while(i--)now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                            }
                            break;
                        default:
                            var from2 = [][concat](from[attr]);
                            now = [];
                            i = that1.paper.customAttributes[attr].length;
                            while(i--)now[i] = +from2[i] + pos * ms * diff[attr][i];
                            break;
                    }
                    set[attr] = now;
                }
                that1.attr(set);
                (function(id, that, anim) {
                    setTimeout(()=>{
                        _eveJs.eve(`raphael.anim.frame.${id}`, that, anim);
                    });
                })(that1.id, that1, e.anim);
            } else {
                (function(f, el, a) {
                    setTimeout(()=>{
                        _eveJs.eve(`raphael.anim.frame.${el.id}`, el, a);
                        _eveJs.eve(`raphael.anim.finish.${el.id}`, el, a);
                        R1.is(f, 'function') && f.call(el);
                    });
                })(e.callback, that1, e.anim);
                that1.attr(to);
                animationElements.splice(l--, 1);
                if (e.repeat > 1 && !e.next) {
                    for(key in to)if (to[has](key)) init[key] = e.totalOrigin[key];
                    e.el.attr(init);
                    runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                }
                if (e.next && !e.stop) runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
            }
        }
        animationElements.length && requestAnimFrame(animation);
    };
    var upto255 = function(color) {
        return color > 255 ? 255 : color < 0 ? 0 : color;
    };
    /* \
   * Element.animateWith
   [ method ]
   **
   * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
   **
   > Parameters
   **
   - el (object) element to sync with
   - anim (object) animation to sync with
   - params (object) #optional final attributes for the element, see also @Element.attr
   - ms (number) #optional number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   * or
   - element (object) element to sync with
   - anim (object) animation to sync with
   - animation (object) #optional animation object, see @Raphael.animation
   **
   = (object) original element
  \ */ elproto.animateWith = function(el, anim, params, ms, easing, callback) {
        const element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        const a = params instanceof Animation ? params : R1.animation(params, ms, easing, callback);
        let x;
        let y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for(let i = 0, ii = animationElements.length; i < ii; i++)if (animationElements[i].anim == anim && animationElements[i].el == el) {
            animationElements[ii - 1].start = animationElements[i].start;
            break;
        }
        return element;
    //
    //
    // var a = params ? R.animation(params, ms, easing, callback) : anim,
    //     status = element.status(anim);
    // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t2, p1x, p1y, p2x, p2y, duration) {
        const cx = 3 * p1x;
        const bx = 3 * (p2x - p1x) - cx;
        const ax = 1 - cx - bx;
        const cy = 3 * p1y;
        const by = 3 * (p2y - p1y) - cy;
        const ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            const t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            let t0;
            let t1;
            let t2;
            let x2;
            let d2;
            let i;
            for(t2 = x, i = 0; i < 8; i++){
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) return t2;
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 0.000001) break;
                t2 -= x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) return t0;
            if (t2 > t1) return t1;
            while(t0 < t1){
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) return t2;
                if (x > x2) t0 = t2;
                else t1 = t2;
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t2, 1 / (200 * duration));
    }
    elproto.onAnimation = function(f) {
        f ? _eveJs.eve.on(`raphael.anim.frame.${this.id}`, f) : _eveJs.eve.unbind(`raphael.anim.frame.${this.id}`);
        return this;
    };
    function Animation(anim, ms) {
        const percents = [];
        const newAnim = {
        };
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for(const attr in anim)if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /* \
   * Animation.delay
   [ method ]
   **
   * Creates a copy of existing animation object with given delay.
   **
   > Parameters
   **
   - delay (number) number of ms to pass between animation start and actual animation
   **
   = (object) new altered Animation object
   | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
   | circle1.animate(anim); // run the given animation immediately
   | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
  \ */ Animation.prototype.delay = function(delay) {
        const a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /* \
   * Animation.repeat
   [ method ]
   **
   * Creates a copy of existing animation object with given repetition.
   **
   > Parameters
   **
   - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
   **
   = (object) new altered Animation object
  \ */ Animation.prototype.repeat = function(times) {
        const a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        let params;
        let isInAnim;
        let isInAnimSet;
        const percents = [];
        let next;
        let prev;
        let timestamp;
        let { ms  } = anim;
        const from = {
        };
        const to = {
        };
        const diff = {
        };
        if (status) for(i = 0, ii = animationElements.length; i < ii; i++){
            var e = animationElements[i];
            if (e.el.id == element.id && e.anim == anim) {
                if (e.percent != percent) {
                    animationElements.splice(i, 1);
                    isInAnimSet = 1;
                } else isInAnim = e;
                element.attr(e.totalOrigin);
                break;
            }
        }
        else status = +to // NaN
        ;
        for(var i = 0, ii = anim.percents.length; i < ii; i++){
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) element.attr(anim.anim[anim.percents[i]]);
        }
        if (!params) return;
        if (!isInAnim) {
            for(const attr in params)if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    from[attr] == null && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch(availableAnimAttrs[attr]){
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case 'colour':
                            from[attr] = R1.getRGB(from[attr]);
                            var toColour = R1.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case 'path':
                            var pathes = path2curve(from[attr], to[attr]);
                            var toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for(i = 0, ii = from[attr].length; i < ii; i++){
                                diff[attr][i] = [
                                    0
                                ];
                                for(var j = 1, jj = from[attr][i].length; j < jj; j++)diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                            }
                            break;
                        case 'transform':
                            var { _  } = element;
                            var eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for(i = 0, ii = from[attr].length; i < ii; i++){
                                    diff[attr][i] = [
                                        from[attr][i][0]
                                    ];
                                    for(j = 1, jj = from[attr][i].length; j < jj; j++)diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                }
                            } else {
                                const m = element.matrix || new Matrix();
                                const to2 = {
                                    _: {
                                        transform: _.transform
                                    },
                                    getBBox () {
                                        return element.getBBox(1);
                                    }
                                };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms, 
                                ];
                            // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                            // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                            // extractTransform(to2, to[attr]);
                            // diff[attr] = [
                            //     (to2._.sx - _.sx) / ms,
                            //     (to2._.sy - _.sy) / ms,
                            //     (to2._.deg - _.deg) / ms,
                            //     (to2._.dx - _.dx) / ms,
                            //     (to2._.dy - _.dy) / ms
                            // ];
                            }
                            break;
                        case 'csv':
                            var values = Str(params[attr])[split](separator);
                            var from2 = Str(from[attr])[split](separator);
                            if (attr == 'clip-rect') {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while(i--)diff[attr][i] = (values[i] - from[attr][i]) / ms;
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while(i--)diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            break;
                    }
                }
            }
            const { easing  } = params;
            let easyeasy = R1.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    const curve = easyeasy;
                    easyeasy = function(t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else easyeasy = pipe;
            }
            timestamp = params.start || anim.start || +new Date();
            e = {
                anim,
                percent,
                timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms,
                easing: easyeasy,
                from,
                diff,
                to,
                el: element,
                callback: params.callback,
                prev,
                next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date() - ms * status;
                if (animationElements.length == 1) return animation();
            }
            if (isInAnimSet) e.start = new Date() - e.ms * status;
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date() - isInAnim.ms * status;
        }
        _eveJs.eve(`raphael.anim.start.${element.id}`, element, anim);
    }
    /* \
   * Raphael.animation
   [ method ]
   **
   * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
   * See also @Animation.delay and @Animation.repeat methods.
   **
   > Parameters
   **
   - params (object) final attributes for the element, see also @Element.attr
   - ms (number) number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   **
   = (object) @Animation
  \ */ R1.animation = function(params, ms, easing, callback) {
        if (params instanceof Animation) return params;
        if (R1.is(easing, 'function') || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        const p = {
        };
        let json;
        let attr;
        for(attr in params)if (params[has](attr) && toFloat(attr) != attr && `${toFloat(attr)}%` != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            // if percent-like syntax is used and end-of-all animation callback used
            if (callback) {
                // find the last one
                let lastKey = 0;
                for(const i in params){
                    const percent = toInt(i);
                    if (params[has](i) && percent > lastKey) lastKey = percent;
                }
                lastKey += '%';
                // if already defined callback in the last keyframe, skip
                !params[lastKey].callback && (params[lastKey].callback = callback);
            }
            return new Animation(params, ms);
        }
        easing && (p.easing = easing);
        callback && (p.callback = callback);
        return new Animation({
            100: p
        }, ms);
    };
    /* \
   * Element.animate
   [ method ]
   **
   * Creates and starts animation for given element.
   **
   > Parameters
   **
   - params (object) final attributes for the element, see also @Element.attr
   - ms (number) number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   * or
   - animation (object) animation object, see @Raphael.animation
   **
   = (object) original element
  \ */ elproto.animate = function(params, ms, easing, callback) {
        const element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        const anim = params instanceof Animation ? params : R1.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /* \
   * Element.setTime
   [ method ]
   **
   * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
   **
   > Parameters
   **
   - anim (object) animation object
   - value (number) number of milliseconds from the beginning of the animation
   **
   = (object) original element if `value` is specified
   * Note, that during animation following events are triggered:
   *
   * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
  \ */ elproto.setTime = function(anim, value) {
        if (anim && value != null) this.status(anim, mmin(value, anim.ms) / anim.ms);
        return this;
    };
    /* \
   * Element.status
   [ method ]
   **
   * Gets or sets the status of animation of the element.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   - value (number) #optional 0 – 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
   **
   = (number) status
   * or
   = (array) status if `anim` is not specified. Array of objects in format:
   o {
   o     anim: (object) animation object
   o     status: (number) status
   o }
   * or
   = (object) original element if `value` is specified
  \ */ elproto.status = function(anim, value) {
        const out = [];
        let i = 0;
        let len;
        let e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        }
        len = animationElements.length;
        for(; i < len; i++){
            e = animationElements[i];
            if (e.el.id == this.id && (!anim || e.anim == anim)) {
                if (anim) return e.status;
                out.push({
                    anim: e.anim,
                    status: e.status
                });
            }
        }
        if (anim) return 0;
        return out;
    };
    /* \
   * Element.pause
   [ method ]
   **
   * Stops animation of the element with ability to resume it later on.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.pause = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (_eveJs.eve(`raphael.anim.pause.${this.id}`, this, animationElements[i].anim) !== false) animationElements[i].paused = true;
        }
        return this;
    };
    /* \
   * Element.resume
   [ method ]
   **
   * Resumes animation if it was paused with @Element.pause method.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.resume = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            const e = animationElements[i];
            if (_eveJs.eve(`raphael.anim.resume.${this.id}`, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /* \
   * Element.stop
   [ method ]
   **
   * Stops animation of the element.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.stop = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if (_eveJs.eve(`raphael.anim.stop.${this.id}`, this, animationElements[i].anim) !== false) animationElements.splice(i--, 1);
        }
        return this;
    };
    function stopAnimation(paper) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.paper == paper) animationElements.splice(i--, 1);
    }
    _eveJs.eve.on('raphael.remove', stopAnimation);
    _eveJs.eve.on('raphael.clear', stopAnimation);
    elproto.toString = function() {
        return 'Rapha\xebl\u2019s object';
    };
    // Set
    var Set = function(items) {
        this.items = [];
        this.length = 0;
        this.type = 'set';
        if (items) {
            for(let i = 0, ii = items.length; i < ii; i++)if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                this[this.items.length] = this.items[this.items.length] = items[i];
                this.length++;
            }
        }
    };
    const setproto = Set.prototype;
    /* \
   * Set.push
   [ method ]
   **
   * Adds each argument to the current set.
   = (object) original element
  \ */ setproto.push = function() {
        let item;
        let len;
        for(let i = 0, ii = arguments.length; i < ii; i++){
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /* \
   * Set.pop
   [ method ]
   **
   * Removes last element and returns it.
   = (object) element
  \ */ setproto.pop = function() {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /* \
   * Set.forEach
   [ method ]
   **
   * Executes given function for each element in the set.
   *
   * If function returns `false` it will stop loop running.
   **
   > Parameters
   **
   - callback (function) function to run
   - thisArg (object) context object for the callback
   = (object) Set object
  \ */ setproto.forEach = function(callback, thisArg) {
        for(let i = 0, ii = this.items.length; i < ii; i++){
            if (callback.call(thisArg, this.items[i], i) === false) return this;
        }
        return this;
    };
    for(const method in elproto)if (elproto[has](method)) setproto[method] = (function(methodname) {
        return function() {
            const arg = arguments;
            return this.forEach((el)=>{
                el[methodname][apply](el, arg);
            });
        };
    })(method);
    setproto.attr = function(name, value) {
        if (name && R1.is(name, array1) && R1.is(name[0], 'object')) for(let j = 0, jj = name.length; j < jj; j++)this.items[j].attr(name[j]);
        else for(let i = 0, ii = this.items.length; i < ii; i++)this.items[i].attr(name, value);
        return this;
    };
    /* \
   * Set.clear
   [ method ]
   **
   * Removes all elements from the set
  \ */ setproto.clear = function() {
        while(this.length)this.pop();
    };
    /* \
   * Set.splice
   [ method ]
   **
   * Removes given element from the set
   **
   > Parameters
   **
   - index (number) position of the deletion
   - count (number) number of element to remove
   - insertion… (object) #optional elements to insert
   = (object) set elements that were deleted
  \ */ setproto.splice = function(index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        const tail = [];
        const todel = [];
        const args = [];
        let i;
        for(i = 2; i < arguments.length; i++)args.push(arguments[i]);
        for(i = 0; i < count; i++)todel.push(this[index + i]);
        for(; i < this.length - index; i++)tail.push(this[index + i]);
        const arglen = args.length;
        for(i = 0; i < arglen + tail.length; i++)this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        i = this.items.length = this.length -= count - arglen;
        while(this[i])delete this[i++];
        return new Set(todel);
    };
    /* \
   * Set.exclude
   [ method ]
   **
   * Removes given element from the set
   **
   > Parameters
   **
   - element (object) element to remove
   = (boolean) `true` if object was found & removed from the set
  \ */ setproto.exclude = function(el) {
        for(let i = 0, ii = this.length; i < ii; i++)if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function(params, ms, easing, callback) {
        (R1.is(easing, 'function') || !easing) && (callback = easing || null);
        let len = this.items.length;
        let i = len;
        let item;
        const set = this;
        let collector;
        if (!len) return this;
        callback && (collector = function() {
            !--len && callback.call(set);
        });
        easing = R1.is(easing, string1) ? easing : collector;
        const anim = R1.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while(i--){
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            this.items[i] && !this.items[i].removed || len--;
        }
        return this;
    };
    setproto.insertAfter = function(el) {
        let i = this.items.length;
        while(i--)this.items[i].insertAfter(el);
        return this;
    };
    setproto.getBBox = function() {
        let x = [];
        let y = [];
        let x2 = [];
        let y2 = [];
        for(let i = this.items.length; i--;)if (!this.items[i].removed) {
            const box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x,
            y,
            x2,
            y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function(s) {
        s = this.paper.set();
        for(let i = 0, ii = this.items.length; i < ii; i++)s.push(this.items[i].clone());
        return s;
    };
    setproto.toString = function() {
        return 'Rapha\xebl\u2018s set';
    };
    setproto.glow = function(glowConfig) {
        const ret = this.paper.set();
        this.forEach((shape, index)=>{
            const g = shape.glow(glowConfig);
            if (g != null) g.forEach((shape2, index2)=>{
                ret.push(shape2);
            });
        });
        return ret;
    };
    /* \
   * Set.isPointInside
   [ method ]
   **
   * Determine if given point is inside this set’s elements
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (boolean) `true` if point is inside any of the set's elements
   \ */ setproto.isPointInside = function(x, y) {
        let isPointInside = false;
        this.forEach((el)=>{
            if (el.isPointInside(x, y)) {
                isPointInside = true;
                return false // stop loop
                ;
            }
        });
        return isPointInside;
    };
    /* \
   * Raphael.registerFont
   [ method ]
   **
   * Adds given font to the registered set of fonts for Raphaël. Should be used as an internal call from within Cufón’s font file.
   * Returns original parameter, so it could be used with chaining.
   # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufón and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
   **
   > Parameters
   **
   - font (object) the font to register
   = (object) the font you passed in
   > Usage
   | Cufon.registerFont(Raphael.registerFont({…}));
  \ */ R1.registerFont = function(font) {
        if (!font.face) return font;
        this.fonts = this.fonts || {
        };
        const fontcopy = {
            w: font.w,
            face: {
            },
            glyphs: {
            }
        };
        const family = font.face['font-family'];
        for(const prop in font.face)if (font.face[has](prop)) fontcopy.face[prop] = font.face[prop];
        if (this.fonts[family]) this.fonts[family].push(fontcopy);
        else this.fonts[family] = [
            fontcopy
        ];
        if (!font.svg) {
            fontcopy.face['units-per-em'] = toInt(font.face['units-per-em'], 10);
            for(const glyph in font.glyphs)if (font.glyphs[has](glyph)) {
                const path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {
                    },
                    d: path.d && `M${path.d.replace(/[mlcxtrv]/g, (command)=>({
                            l: 'L',
                            c: 'C',
                            x: 'z',
                            t: 'm',
                            r: 'l',
                            v: 'c'
                        })[command] || 'M'
                    )}z`
                };
                if (path.k) {
                    for(const k in path.k)if (path[has](k)) fontcopy.glyphs[glyph].k[k] = path.k[k];
                }
            }
        }
        return font;
    };
    /* \
   * Paper.getFont
   [ method ]
   **
   * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like “Myriad” for “Myriad Pro”.
   **
   > Parameters
   **
   - family (string) font family name or any word from it
   - weight (string) #optional font weight
   - style (string) #optional font style
   - stretch (string) #optional font stretch
   = (object) the font object
   > Usage
   | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
  \ */ paperproto.getFont = function(family, weight, style, stretch) {
        stretch = stretch || 'normal';
        style = style || 'normal';
        weight = +weight || ({
            normal: 400,
            bold: 700,
            lighter: 300,
            bolder: 800
        })[weight] || 400;
        if (!R1.fonts) return;
        let font = R1.fonts[family];
        if (!font) {
            const name = new RegExp(`(^|\\s)${family.replace(/[^\w\d\s+!~.:_-]/g, E)}(\\s|$)`, 'i');
            for(const fontName in R1.fonts)if (R1.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R1.fonts[fontName];
                    break;
                }
            }
        }
        let thefont;
        if (font) for(let i = 0, ii = font.length; i < ii; i++){
            thefont = font[i];
            if (thefont.face['font-weight'] == weight && (thefont.face['font-style'] == style || !thefont.face['font-style']) && thefont.face['font-stretch'] == stretch) break;
        }
        return thefont;
    };
    /* \
   * Paper.print
   [ method ]
   **
   * Creates path that represent given text written using given font at given position with given size.
   * Result of the method is path element that contains whole text as a separate path.
   **
   > Parameters
   **
   - x (number) x position of the text
   - y (number) y position of the text
   - string (string) text to print
   - font (object) font object, see @Paper.getFont
   - size (number) #optional size of the font, default is `16`
   - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
   - letter_spacing (number) #optional number in range `-1..1`, default is `0`
   - line_spacing (number) #optional number in range `1..3`, default is `1`
   = (object) resulting path element, which consist of all letters
   > Usage
   | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
  \ */ paperproto.print = function(x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || 'middle' // baseline|middle
        ;
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        const letters = Str(string)[split](E);
        let shift = 0;
        let notfirst = 0;
        let path = E;
        let scale;
        R1.is(font, 'string') && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face['units-per-em'];
            const bb = font.face.bbox[split](separator);
            const top = +bb[0];
            const lineHeight = bb[3] - bb[1];
            let shifty = 0;
            const height = +bb[1] + (origin == 'baseline' ? lineHeight + +font.face.descent : lineHeight / 2);
            for(let i = 0, ii = letters.length; i < ii; i++){
                if (letters[i] == '\n') {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    const prev = notfirst && font.glyphs[letters[i - 1]] || {
                    };
                    var curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) path += R1.transformPath(curr.d, [
                    't',
                    shift * scale,
                    shifty * scale,
                    's',
                    scale,
                    scale,
                    top,
                    height,
                    't',
                    (x - top) / scale,
                    (y - height) / scale, 
                ]);
            }
        }
        return this.path(path).attr({
            fill: '#000',
            stroke: 'none'
        });
    };
    /* \
   * Paper.add
   [ method ]
   **
   * Imports elements in JSON array in format `{type: type, <attributes>}`
   **
   > Parameters
   **
   - json (array)
   = (object) resulting set of imported elements
   > Usage
   | paper.add([
   |     {
   |         type: "circle",
   |         cx: 10,
   |         cy: 10,
   |         r: 5
   |     },
   |     {
   |         type: "rect",
   |         x: 10,
   |         y: 10,
   |         width: 10,
   |         height: 10,
   |         fill: "#fc0"
   |     }
   | ]);
  \ */ paperproto.add = function(json) {
        if (R1.is(json, 'array')) {
            var res = this.set();
            let i = 0;
            const ii = json.length;
            let j;
            for(; i < ii; i++){
                j = json[i] || {
                };
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };
    /* \
   * Raphael.format
   [ method ]
   **
   * Simple format function. Replaces construction of type “`{<number>}`” to the corresponding argument.
   **
   > Parameters
   **
   - token (string) string to format
   - … (string) rest of arguments will be treated as parameters for replacement
   = (string) formated string
   > Usage
   | var x = 10,
   |     y = 20,
   |     width = 40,
   |     height = 50;
   | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
   | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
  \ */ R1.format = function(token, params) {
        const args = R1.is(params, array1) ? [
            0
        ][concat](params) : arguments;
        token && R1.is(token, string1) && args.length - 1 && (token = token.replace(formatrg, (str, i)=>args[++i] == null ? E : args[i]
        ));
        return token || E;
    };
    /* \
   * Raphael.fullfill
   [ method ]
   **
   * A little bit more advanced format function than @Raphael.format. Replaces construction of type “`{<name>}`” to the corresponding argument.
   **
   > Parameters
   **
   - token (string) string to format
   - json (object) object which properties will be used as a replacement
   = (string) formated string
   > Usage
   | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
   | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
   |     x: 10,
   |     y: 20,
   |     dim: {
   |         width: 40,
   |         height: 50,
   |         "negative width": -40
   |     }
   | }));
  \ */ R1.fullfill = (function() {
        const tokenRegex = /\{([^\}]+)\}/g;
        const objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g // matches .xxxxx or ["xxxxx"] to run over object properties
        ;
        const replacer = function(all, key, obj) {
            let res = obj;
            key.replace(objNotationRegex, (all, name, quote, quotedName, isFunc)=>{
                name = name || quotedName;
                if (res) {
                    if (name in res) res = res[name];
                    typeof res === 'function' && isFunc && (res = res());
                }
            });
            res = `${res == null || res == obj ? all : res}`;
            return res;
        };
        return function(str, obj) {
            return String(str).replace(tokenRegex, (all, key)=>replacer(all, key, obj)
            );
        };
    })();
    /* \
   * Raphael.ninja
   [ method ]
   **
   * If you want to leave no trace of Raphaël (Well, Raphaël creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
   * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
   **
   = (object) Raphael object
   > Usage
   | (function (local_raphael) {
   |     var paper = local_raphael(10, 10, 320, 200);
   |     …
   | })(Raphael.ninja());
  \ */ R1.ninja = function() {
        if (oldRaphael.was) g1.win.Raphael = oldRaphael.is;
        else {
            // IE8 raises an error when deleting window property
            window.Raphael = undefined;
            try {
                delete window.Raphael;
            } catch (e) {
            }
        }
        return R1;
    };
    /* \
   * Raphael.st
   [ property (object) ]
   **
   * You can add your own method to elements and sets. It is wise to add a set method for each element method
   * you added, so you will be able to call the same method on sets too.
   **
   * See also @Raphael.el.
   > Usage
   | Raphael.el.red = function () {
   |     this.attr({fill: "#f00"});
   | };
   | Raphael.st.red = function () {
   |     this.forEach(function (el) {
   |         el.red();
   |     });
   | };
   | // then use it
   | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
  \ */ R1.st = setproto;
    _eveJs.eve.on('raphael.DOMload', ()=>{
        loaded1 = true;
    });
    (function(doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener) {
            doc.addEventListener(loaded, f = function() {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = 'complete';
            }, false);
            doc.readyState = 'loading';
        }
        function isLoaded() {
            /in/.test(doc && doc.readyState) ? setTimeout(isLoaded, 9) : R1.eve('raphael.DOMload');
        }
        isLoaded();
    })(document, 'DOMContentLoaded');
    return R1;
}();

},{"../eve.js":"9FQ0M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6wubb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _utils = require("./utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
function getTransformedPath(originalPath, transforms) {
    let transformsArray = transforms;
    let transformedPath = originalPath;
    if (!transforms.find && typeof transforms === 'string') transformsArray = [
        transforms
    ];
    // NOTE: it's safer to apply transforms one by one because this transform string `T${_x * percent}, ${_y * percent}, s${_width/150 * percent}, ${_height/100 * percent}, ${_x}, ${_y}`
    //      would be applied incorrectly - element would be translated using the center of scaling ${_x}, ${_y} which seems to be a bug in raphael.js
    transformsArray.forEach((transform)=>{
        transformedPath = _utilsDefault.default._transformPath(transformedPath, transform).toString();
    });
    return transformedPath;
}
exports.default = getTransformedPath;

},{"./utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpLaV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
var _raphaelFnShapes = require("../deps/raphael/raphael.fn.shapes");
var _raphaelElExtensions = require("../deps/raphael/raphael.el.extensions");
var _embedGoogleFonts = require("../helpers/embedGoogleFonts");
var _embedGoogleFontsDefault = parcelHelpers.interopDefault(_embedGoogleFonts);
var _emile = require("../deps/emile");
class canvas {
    constructor(slate){
        const self = this;
        self.slate = slate;
        let c = slate.options.container;
        if (typeof c === 'string') c = _utilsDefault.default.el(c);
        if (c === undefined || c === null) throw new Error('You must provide a container to initiate the canvas!');
        // customize raphael -- modifies global Raphael for all other imports
        _raphaelFnShapes.shapes(_raphaelSvg.Raphael);
        _raphaelElExtensions.extensions(_raphaelSvg.Raphael);
        self.isDragging = false;
        self.slate.paper = null;
        self.internal = null;
        self.status = null;
        self.imageFolder = null;
        self.dken = null;
        self.eve = {
            init: [
                'onmousedown',
                'ontouchstart'
            ],
            drag: [
                'onmousemove',
                'ontouchmove'
            ],
            up: [
                'onmouseup',
                'ontouchend',
                'onmouseout'
            ],
            gest: [
                'ongesturestart',
                'ongesturechange',
                'ongestureend'
            ]
        };
    }
    init() {
        const self = this;
        const imageFolder = self.slate.options.imageFolder || '/images/';
        const c = self.slate.options.container;
        const { slate  } = self;
        self.Canvas = {
            objInitPos: {
            },
            objInitialMousePos: {
                x: 0,
                y: 0
            },
            initDrag (e) {
                if (slate.isCtrl) slate.multiSelection?.start();
                if (slate.options.allowDrag) {
                    self.isDragging = true;
                    slate.multiSelection?.end();
                    slate.nodes?.closeAllMenus();
                    const m = _utilsDefault.default.mousePos(e);
                    self.Canvas.objInitPos = _utilsDefault.default.positionedOffset(self.internal);
                    const offsets = _utilsDefault.default.positionedOffset(slate.options.container);
                    self.Canvas.objInitialMousePos = {
                        x: m.x + offsets.left,
                        y: m.y + offsets.top
                    };
                    const xy = self.cp(e);
                    if (self.status) self.status.innerHTML = `${Math.abs(xy.x)}, ${Math.abs(xy.y)}`;
                    if (slate.options.showStatus) {
                        if (self.status) self.status.style.display = 'block';
                        slate.multiSelection?.hide();
                    }
                    self.internal.style.cursor = `url(${imageFolder}closedhand.cur), default`;
                    if (m.allTouches) slate.options.lastTouches = m.allTouches;
                    if (slate.removeContextMenus) slate.removeContextMenus();
                    slate.draggingZoom = self.slate.options.viewPort.zoom;
                    // hide filters during dragging
                    slate.toggleFilters(true);
                    _utilsDefault.default.stopEvent(e);
                } else if (slate.onSelectionStart) slate.onSelectionStart.apply(self, [
                    e
                ]);
                else _utilsDefault.default.stopEvent(e);
            },
            setCursor () {
                if (self.isDragging) self.internal.style.cursor = `url(${imageFolder}closedhand.cur), default`;
                else self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
            },
            onDrag (e) {
                requestAnimationFrame(()=>{
                    // broadcast custom collab
                    const mp = _utilsDefault.default.mousePos(e);
                    const curPos = _utilsDefault.default.positionedOffset(self.internal);
                    mp.currentZoom = slate.options.viewPort.zoom.r;
                    mp.left = Math.abs(curPos.left);
                    mp.top = Math.abs(curPos.top);
                    slate.collab?.send({
                        type: 'onMouseMoved',
                        data: mp
                    });
                    if (self.isDragging && slate.options.allowDrag) {
                        const xy = self.cp(e);
                        if (xy.allTouches && xy.allTouches.length > 1) slate.options.lastTouches = xy.allTouches;
                        if (self.status) self.status.innerHTML = `${Math.abs(xy.x)}, ${Math.abs(xy.y)}`;
                        self.internal.style.left = `${xy.x}px`;
                        self.internal.style.top = `${xy.y}px`;
                    }
                });
            },
            endDrag (e) {
                if (self.isDragging && slate.options.allowDrag) {
                    self.isDragging = false;
                    self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
                    if (self.status) self.status.style.display = 'none';
                    slate.multiSelection?.show();
                    const xy = self.cp(e);
                    slate.draggingZoom = null;
                    self.endDrag(xy);
                    // show filters after dragging
                    slate.toggleFilters(false);
                }
            }
        };
        // wipe it clean
        if (!slate.options.preserve) c.innerHTML = '';
        if (self.slate.paper) self.slate.paper.clear();
        if (self.internal) c.removeChild(self.internal);
        // internal
        self.internal = document.createElement('div');
        self.internal.setAttribute('class', `slateboxInternal_${self.slate.options.id} sb_canvas`);
        // console.log("setting slate canvas", `slateboxInternal_${self.slate.options.id}`);
        const _w = slate.options.viewPort.width;
        const _h = slate.options.viewPort.height;
        const _l = slate.options.viewPort.left;
        const _t = slate.options.viewPort.top;
        self.internal.style.width = `${_w + 100000}px`;
        self.internal.style.height = `${_h + 100000}px`;
        self.internal.style.left = `${_l * -1}px`;
        self.internal.style.top = `${_t * -1}px`;
        self.internal.style.position = 'absolute';
        self.internal.style['-webkit-transform'] = `translateZ(0)`;
        self.internal.style.transform = `translateZ(0)` // `translate3d(0,0,0)`; //helps with GPU based rendering
        ;
        c.appendChild(self.internal);
        self.internal.addEventListener('mousedown', ()=>{
            self.slate?.events?.onCanvasClicked?.apply();
        });
        // status
        if (self.slate.options.showStatus) {
            self.status = document.createElement('div');
            self.status.style.position = 'absolute';
            self.status.style.height = '20px';
            self.status.style.left = '5px';
            self.status.style.color = '#000';
            self.status.style.fontSize = '10pt';
            self.status.style.fontFamily = 'trebuchet ms';
            self.status.style.top = '0px';
            self.status.style.display = 'none';
            self.status.style.padding = '5px';
            self.status.style.filter = 'alpha(opacity=80)';
            self.status.style.opacity = '.80';
            self.status.style.backgroundColor = '#ffff99';
            self.status.style.fontWeight = 'bold';
            c.appendChild(self.status);
        }
        // style container
        c.style.position = 'relative';
        c.style.overflow = 'hidden';
        // style internal
        self.internal.style.borderTop = `${slate.borderTop}px`;
        self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
        self.slate.paper = _raphaelSvg.Raphael(self.internal, _w, _h);
        self.refreshBackground();
        if (slate.options.allowDrag) self.wire();
        slate.options.viewPort.originalHeight = _h;
        slate.options.viewPort.originalWidth = _w;
        // set up initial zoom params
        self.resize(_w);
        // show zoom slider
        if (slate.options.showZoom) {
            if (slate.zoomSlider) slate.zoomSlider.show(slate.options.viewPort.width);
        }
        // show undo redo
        if (slate.options.showUndoRedo) {
            if (slate.undoRedo) slate.undoRedo.show();
        }
        // show birdsEye -- this is self referential on canvas in loadJSON inside slate, so this must be deferred until canvas constructor is done.
        if (slate.options.showbirdsEye) {
            if (slate.birdsEye.enabled()) slate.birdsEye.reload(slate.exportJSON());
            else slate.birdsEye.show({
                size: slate.options.sizeOfbirdsEye || 200,
                onHandleMove () {
                }
            });
        }
        // set up the shareable/branding if need be
        if (!slate.options.isbirdsEye && (slate.options.isSharing || slate.options.isEmbedding)) {
            const _btnSize = 25;
            const _scaleSize = _btnSize - 3;
            const _iframe = document.getElementById('snap_slate');
            const _parent = document.createElement('div');
            _parent.className = 'sb_parent_shareable';
            const _styles = _utilsDefault.default.buildStyle({
                height: _iframe ? `${_scaleSize + 8}px` : `${_scaleSize}px`
            });
            _parent.setAttribute('style', _styles);
            if (slate.options.isEmbedding && !slate.options.nobrand) {
                const _brand = document.createElement('a');
                _brand.className = 'sb_brand';
                _brand.setAttribute('href', 'https://slatebox.com');
                _brand.innerHTML = 'built with slatebox';
                _parent.appendChild(_brand);
            }
            if (!slate.options.isbirdsEye && slate.options.isSharing) {
                const _svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${_btnSize}" height="${_btnSize}"><path fill="#333" stroke="#000" d="{path}" stroke-dasharray="none" stroke-width="1" opacity="1" fill-opacity="1"></path></svg>`;
                [
                    'download',
                    'embed'
                ].forEach((e)=>{
                    const _btn = document.createElement('div');
                    _btn.className = 'sb_share';
                    _btn.setAttribute('data-action', e);
                    const _bstyles = _utilsDefault.default.buildStyle({
                        width: `${_btnSize}px`,
                        height: `${_btnSize}px`
                    });
                    _btn.setAttribute('style', _bstyles);
                    const _new = _utilsDefault.default.centerAndScalePathToFitContainer({
                        containerSize: _btnSize,
                        scaleSize: _scaleSize,
                        path: _sbIconsDefault.default.icons[e]
                    });
                    _btn.innerHTML = _svg.replace(/{path}/gi, _new.path);
                    _parent.appendChild(_btn);
                    _utilsDefault.default.addEvent(_btn, 'click', ()=>{
                        const _act = this.getAttribute('data-action');
                        switch(_act){
                            case 'embed':
                                {
                                    const _et = document.createElement('textarea');
                                    document.body.appendChild(_et);
                                    let _val = '';
                                    if (_iframe) _val = `<iframe id='sb_embed_${slate.options.id}' src='${window.location.href}' width='${_iframe.clientWidth}' height='${_iframe.clientHeight}' frameborder='0' scrolling='no'></iframe>`;
                                    else {
                                        const _ele = slate.options.container.parentElement;
                                        const _raw = _ele.innerHTML;
                                        const _split = _raw.split('<div class="slateboxInternal"');
                                        const _orig = `${_split[0]}<script>${_split[1].split('<script>')[1]}`;
                                        _val = `<div id="sb_embed_${slate.options.id}">${_orig}</div>`;
                                    }
                                    _et.value = _val;
                                    _et.select();
                                    document.execCommand('copy');
                                    document.body.removeChild(_et);
                                    const _note = document.createElement('div');
                                    _note.innerHTML = 'Copied!';
                                    _note.setAttribute('style', _utilsDefault.default.buildStyle({
                                        'font-size': '11pt',
                                        'text-align': 'center',
                                        padding: '4px',
                                        'margin-right': '-1px',
                                        width: '125px',
                                        height: '22px',
                                        position: 'absolute',
                                        right: 0,
                                        bottom: 0,
                                        'background-color': '#333',
                                        color: '#fff'
                                    }));
                                    _parent.appendChild(_note);
                                    window.setTimeout(()=>{
                                        _parent.removeChild(_note);
                                    }, 1500);
                                    break;
                                }
                            case 'download':
                                slate.png();
                                break;
                            default:
                                break;
                        }
                    });
                });
            }
            if (slate.options.isEmbedding && _parent.innerHTML !== '') c.appendChild(_parent);
        }
        self.windowSize = _utilsDefault.default.windowSize();
        self.containerOffset = _utilsDefault.default.positionedOffset(self.slate.options.container);
        _utilsDefault.default.addEvent(window, 'resize', ()=>{
            self.windowSize = _utilsDefault.default.windowSize();
            self.containerOffset = _utilsDefault.default.positionedOffset(self.slate.options.container);
            if (self.dken !== null) {
                self.dken.style.width = `${self.ws.width}px`;
                self.dken.style.height = `${self.ws.height}px`;
            }
        });
        setTimeout(()=>{
            self.slate.birdsEye?.setBe();
            self.slate.birdsEye?.refresh();
        // set init
        // self.Canvas.objInitPos = utils.positionedOffset(self.internal)
        // console.log('init mouse', self.Canvas.objInitPos)
        }, 500);
        // self.cp()
        // self.initDragDefaults()
        self.completeInit = true;
    }
    cp(e) {
        const m = e ? _utilsDefault.default.mousePos(e) : {
            x: 0,
            y: 0
        };
        let difX = this.Canvas.objInitPos.left + (m.x - this.Canvas.objInitialMousePos.x);
        let difY = this.Canvas.objInitPos.top + (m.y - this.Canvas.objInitialMousePos.y);
        return {
            x: difX,
            y: difY
        };
    }
    endDrag(coords) {
        this.slate.options.viewPort.left = Math.abs(coords.x);
        this.slate.options.viewPort.top = Math.abs(coords.y);
        this.internal.style.left = `${coords.x}px`;
        this.internal.style.top = `${coords.y}px`;
        const curPos = _utilsDefault.default.positionedOffset(this.internal);
        const moved = {
            x: this.Canvas.objInitPos.left - curPos.left,
            y: this.Canvas.objInitPos.top - curPos.top
        };
        this.slate.birdsEye?.refresh(true);
        if (this.slate.collaboration.allow) this.broadcast(moved);
    }
    broadcast(moved) {
        this.slate.collab?.send({
            type: 'onCanvasMove',
            data: {
                left: this.slate.options.viewPort.left,
                top: this.slate.options.viewPort.top,
                relative: moved,
                orient: this.slate.getOrientation()
            }
        });
    }
    zoom(_opts) {
        const self = this;
        const opts = {
            dur: 500,
            callbacks: {
                after: null,
                during: null
            },
            easing: 'easeFromTo',
            zoomPercent: 100
        };
        Object.assign(opts, _opts);
        self.slate.nodes.closeAllConnectors();
        const _startZoom = self.slate.options.viewPort.zoom.w || 50000;
        const _targetZoom = self.slate.options.viewPort.originalWidth * (100 / parseInt(opts.zoomPercent, 10));
        const _zoomDif = Math.abs(_targetZoom - _startZoom);
        opts.dur = !opts.dur && opts.dur !== 0 ? 500 : opts.dur;
        // eslint-disable-next-line no-undef
        emile(self.internal, 'padding:1px', {
            duration: opts.dur,
            before () {
                self.slate.options.allowDrag = false;
            },
            after () {
                self.slate.options.allowDrag = true;
                self.slate.zoomSlider.set(_targetZoom);
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.after?.apply(self.slate, [
                    _targetZoom
                ]);
            },
            during (pc) {
                const _val = _targetZoom > _startZoom ? _startZoom + _zoomDif * pc : _startZoom - _zoomDif * pc;
                self.slate.zoom(0, 0, _val, _val, false);
                self.slate.canvas.resize(_val);
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.during?.apply(pc);
            },
            easing: _utilsDefault.default.easing[opts.easing]
        });
    }
    move(_opts) {
        const self = this;
        const opts = {
            x: 0,
            y: 0,
            dur: 500,
            callbacks: {
                after: null,
                during: null
            },
            isAbsolute: true,
            easing: 'easeFromTo'
        };
        Object.assign(opts, _opts);
        let { x  } = opts;
        let { y  } = opts;
        if (opts.isAbsolute === false) {
            x = self.slate.options.viewPort.left + x;
            y = self.slate.options.viewPort.top + y;
        }
        self.slate.nodes.closeAllConnectors();
        if (opts.dur > 0) // eslint-disable-next-line no-undef
        emile(self.internal, `left:${x * -1}px;top:${y * -1}px`, {
            duration: opts.dur,
            before () {
                self.slate.options.allowDrag = false;
            },
            after () {
                self.slate.options.allowDrag = true;
                self.slate.options.viewPort.left = Math.abs(parseInt(self.internal.style.left.replace('px', ''), 10));
                self.slate.options.viewPort.top = Math.abs(parseInt(self.internal.style.top.replace('px', ''), 10));
                self.slate.birdsEye?.refresh(true);
                opts.callbacks.after?.apply(self.slate);
            },
            during (pc) {
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.during?.apply(pc);
            },
            easing: _utilsDefault.default.easing[opts.easing]
        });
        else window.requestAnimationFrame(()=>{
            self.internal.style.left = `${x * -1}px`;
            self.internal.style.top = `${y * -1}px`;
            self.slate.options.viewPort.left = Math.abs(x);
            self.slate.options.viewPort.top = Math.abs(y);
            opts.callbacks?.after?.apply(self.slate);
        });
    // }
    }
    resize(val) {
        const uval = parseInt(val, 10);
        const R = this.slate.options.viewPort.width / uval;
        const dimen = _utilsDefault.default.getDimensions(this.slate.options.container);
        let _top = this.slate.options.viewPort.top * -1 * R;
        let _left = this.slate.options.viewPort.left * -1 * R;
        const _centerY = (dimen.height / 2 * R - dimen.height / 2) * -1;
        const _centerX = (dimen.width / 2 * R - dimen.width / 2) * -1;
        _top += _centerY;
        _left += _centerX;
        const threshold = this.slate.options.viewPort.originalWidth - 1000;
        if (-_top > threshold || -_left > threshold) return false;
        this.internal.style.top = `${_top}px`;
        this.internal.style.left = `${_left}px`;
        this.slate.options.viewPort.zoom = {
            w: uval,
            h: uval,
            l: parseFloat(_left * -1),
            t: parseFloat(_top * -1),
            r: this.slate.options.viewPort.originalWidth / uval
        };
        return true;
    }
    clear() {
        this.slate.options.container.innerHTML = '';
        return this.slate._;
    }
    wire() {
        const self = this;
        self.eve.init.forEach((ee)=>{
            self.internal[ee] = self.Canvas.initDrag;
        });
        self.eve.drag.forEach((ee)=>{
            self.internal[ee] = self.Canvas.onDrag;
        });
        self.eve.up.forEach((ee)=>{
            self.internal[ee] = self.Canvas.endDrag;
        });
    }
    unwire() {
        const self = this;
        self.eve.init.forEach((ee)=>{
            self.internal[ee] = null;
        });
        self.eve.drag.forEach((ee)=>{
            self.internal[ee] = null;
        });
        self.eve.up.forEach((ee)=>{
            self.internal[ee] = null;
        });
    }
    rawSVG(cb) {
        const self = this;
        function finalize(svg) {
            if (self.slate.events.onOptimizeSVG) self.slate.events.onOptimizeSVG(svg, (err, optimized)=>{
                if (err) console.error('Unable to optimize slate svg export', err);
                else cb(optimized);
            });
            else cb(svg);
        }
        function extractImages(__svg) {
            let ssvg = __svg;
            const images = _lodashUniqDefault.default(self.slate.nodes.allNodes.map((n)=>n.options.image
            ).filter((f)=>!!f
            ));
            if (images.length > 0) images.forEach((i, ind)=>{
                if (self.slate.events.onBase64ImageRequested) {
                    // server side gen
                    let imageType = 'png';
                    if (i.indexOf('jpg')) imageType = 'jpeg';
                    else if (i.indexOf('gif')) imageType = 'gif';
                    self.slate.events.onBase64ImageRequested(i, imageType, (err, res)=>{
                        if (err) console.error('Unable to retrieve base64 from image', err);
                        else {
                            const ix = i.replace(/&/gi, '&amp;');
                            while(ssvg.indexOf(ix) > -1)ssvg = ssvg.replace(ix, res);
                        }
                        if (ind + 1 === images.length) finalize(ssvg);
                    });
                } else // client side only -- good luck with CORS - this method should be avoided
                _utilsDefault.default.toDataUrl(i).then((dataUrl)=>{
                    ssvg = ssvg.replace(new RegExp(i, 'gi'), dataUrl);
                }).catch((err)=>{
                    console.error('Unable to get image', err);
                }).finally(()=>{
                    if (ind + 1 === images.length) finalize(ssvg);
                });
            });
            else finalize(ssvg);
        }
        // always embed fonts and fix links -- a style node is always added in the init
        _embedGoogleFontsDefault.default({
            fonts: _lodashUniqDefault.default(self.slate.nodes.allNodes.map((n)=>n.options.fontFamily
            )),
            text: _lodashUniqDefault.default(self.slate.nodes.allNodes.flatMap((n)=>n.options.text.replace(/ /gi, '').split('')
            )).join('').trim(),
            styleNode: self.internal.querySelector('svg > defs > style')
        }).then(()=>{
            // need to swap out xlink:href with href for the blob to work w/ the pixelate (or other) filter
            let __svg = self.internal.innerHTML.replace(/xlink:href/gi, 'href');
            const slateBg = self.slate.options.containerStyle.backgroundImage;
            if (slateBg) {
                // server side gen
                let bgImageType = 'png';
                if (slateBg.indexOf('jpg')) bgImageType = 'jpeg';
                else if (slateBg.indexOf('gif')) bgImageType = 'gif';
                self.slate.events.onBase64ImageRequested(slateBg, bgImageType, (err, res)=>{
                    if (err) console.error('Unable to retrieve base64 from image', err);
                    else __svg = __svg.replace(slateBg, res);
                    extractImages(__svg);
                });
            } else extractImages(__svg);
        });
    }
    bgToBack() {
        this._bg?.toBack();
    }
    hideBg(t) {
        const self = this;
        const e = self.slate.options.containerStyle.backgroundEffect;
        self._bg?.remove();
        delete self._bg;
        if (e) {
            if (!self.slate.options.isbirdsEye) {
                clearTimeout(self.showBgTimeout);
                self.showBgTimeout = setTimeout(()=>{
                    const attrs = {
                        filter: `url(#${e})`
                    };
                    if (self.slate.filters.availableFilters[e]?.fill) attrs.fill = `url(#${self.slate.filters.availableFilters[e]?.fill})`;
                    self._bg = self.slate.paper.rect(0, 0, self.slate.options.viewPort.width, self.slate.options.viewPort.height).attr(attrs).toBack();
                }, t || 2500);
            }
        }
        self.refreshBackground();
    }
    refreshBackground() {
        const self = this;
        self.internal.style.backgroundColor = '';
        self.internal.parentElement.style.backgroundImage = '';
        self.internal.parentElement.style.backgroundSize = '';
        self.internal.parentElement.style.background = '';
        self.internal.style.backgroundSize = '';
        self.internal.style.backgroundPosition = '';
        if (self.slate.options.containerStyle.backgroundEffect) self.slate.options.containerStyle.backgroundColor = self.slate.filters.availableFilters[self.slate.options.containerStyle.backgroundEffect].backgroundColor;
        if (self.slate.options.containerStyle.backgroundImage) {
            self.slate.options.containerStyle.prevBackgroundColor = self.slate.options.containerStyle.backgroundColor;
            self.slate.options.containerStyle.backgroundColor = 'transparent';
            self.internal.parentElement.style.backgroundImage = `url('${self.slate.options.containerStyle.backgroundImage}')`;
            if (self.slate.options.containerStyle.backgroundSize) self.internal.parentElement.style.backgroundSize = self.slate.options.containerStyle.backgroundSize;
        }
        // show only on first load
        if (!self.initBg && self.slate.options.containerStyle.backgroundEffect) {
            self.initBg = true;
            self.hideBg(1);
        }
        switch(self.slate.options.containerStyle.backgroundColor){
            case 'transparent':
                if (!self.slate.options.isbirdsEye) {
                    if (self.slate.options.isEmbedding) self.internal.style.backgroundColor = '';
                    else if (!self.slate.options.containerStyle.backgroundImage) {
                        self.internal.style.backgroundImage = 'linear-gradient(45deg,rgba(13,26,43,0.1) 25%,transparent 25%,transparent 75%,rgba(13,26,43,0.1) 75%),linear-gradient(45deg,rgba(13,26,43,0.1) 25%,transparent 25%,transparent 75%,rgba(13,26,43,0.1) 75%)';
                        self.internal.style.backgroundSize = '12px 12px';
                        self.internal.style.backgroundPosition = '0 0,6px 6px';
                    }
                }
                break;
            default:
                if (self.slate.options.containerStyle.backgroundColorAsGradient) {
                    self.internal.style.backgroundColor = '';
                    const bgStyle = `${self.slate.options.containerStyle.backgroundGradientType}-gradient(${self.slate.options.containerStyle.backgroundGradientColors.join(',')})`;
                    self.internal.parentElement.style.background = bgStyle;
                } else self.internal.style.backgroundColor = self.slate.options.containerStyle.backgroundColor || '#fff';
                break;
        }
        self.slate.grid?.setGrid();
    }
    get() {
        return this.internal;
    }
    draggable() {
        return this.internal;
    }
}
exports.default = canvas;

},{"lodash.uniq":"iDalh","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","../deps/raphael/raphael.svg":"jK21R","../deps/raphael/raphael.fn.shapes":"k1q4m","../deps/raphael/raphael.el.extensions":"7Msrc","../helpers/embedGoogleFonts":"jW8Fw","../deps/emile":"dd61Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5LoVV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class sbIcons {
    static icons = {
        handle: 'M26.33,15.836l-3.893-1.545l3.136-7.9c0.28-0.705-0.064-1.505-0.771-1.785c-0.707-0.28-1.506,0.065-1.785,0.771l-3.136,7.9l-4.88-1.937l3.135-7.9c0.281-0.706-0.064-1.506-0.77-1.786c-0.706-0.279-1.506,0.065-1.785,0.771l-3.136,7.9L8.554,8.781l-1.614,4.066l2.15,0.854l-2.537,6.391c-0.61,1.54,0.143,3.283,1.683,3.895l1.626,0.646L8.985,26.84c-0.407,1.025,0.095,2.188,1.122,2.596l0.93,0.369c1.026,0.408,2.188-0.095,2.596-1.121l0.877-2.207l1.858,0.737c1.54,0.611,3.284-0.142,3.896-1.682l2.535-6.391l1.918,0.761L26.33,15.836z',
        editor: 'M25.31,2.872l-3.384-2.127c-0.854-0.536-1.979-0.278-2.517,0.576l-1.334,2.123l6.474,4.066l1.335-2.122C26.42,4.533,26.164,3.407,25.31,2.872zM6.555,21.786l6.474,4.066L23.581,9.054l-6.477-4.067L6.555,21.786zM5.566,26.952l-0.143,3.819l3.379-1.787l3.14-1.658l-6.246-3.925L5.566,26.952z',
        deleter: 'M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z',
        searcher: 'M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z',
        up: 'M1.67892,15.48059l23.55337,0l-11.37616,-13.92457l-12.17721,13.92457z',
        arrow: 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM13.665,25.725l-3.536-3.539l6.187-6.187l-6.187-6.187l3.536-3.536l9.724,9.723L13.665,25.725z',
        settings: 'M16.015,12.03c-2.156,0-3.903,1.747-3.903,3.903c0,2.155,1.747,3.903,3.903,3.903c0.494,0,0.962-0.102,1.397-0.27l0.836,1.285l1.359-0.885l-0.831-1.276c0.705-0.706,1.142-1.681,1.142-2.757C19.918,13.777,18.171,12.03,16.015,12.03zM16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM26.174,20.809c-0.241,0.504-0.513,0.99-0.826,1.45L22.19,21.58c-0.481,0.526-1.029,0.994-1.634,1.385l0.119,3.202c-0.507,0.23-1.028,0.421-1.569,0.57l-1.955-2.514c-0.372,0.051-0.75,0.086-1.136,0.086c-0.356,0-0.706-0.029-1.051-0.074l-1.945,2.5c-0.541-0.151-1.065-0.342-1.57-0.569l0.117-3.146c-0.634-0.398-1.208-0.88-1.712-1.427L6.78,22.251c-0.313-0.456-0.583-0.944-0.826-1.448l2.088-2.309c-0.226-0.703-0.354-1.451-0.385-2.223l-2.768-1.464c0.055-0.563,0.165-1.107,0.301-1.643l3.084-0.427c0.29-0.702,0.675-1.352,1.135-1.942L8.227,7.894c0.399-0.389,0.83-0.744,1.283-1.07l2.663,1.672c0.65-0.337,1.349-0.593,2.085-0.75l0.968-3.001c0.278-0.021,0.555-0.042,0.837-0.042c0.282,0,0.56,0.022,0.837,0.042l0.976,3.028c0.72,0.163,1.401,0.416,2.036,0.75l2.704-1.697c0.455,0.326,0.887,0.681,1.285,1.07l-1.216,2.986c0.428,0.564,0.793,1.181,1.068,1.845l3.185,0.441c0.135,0.535,0.247,1.081,0.302,1.643l-2.867,1.516c-0.034,0.726-0.15,1.43-0.355,2.1L26.174,20.809z',
        sliderHandle: 'M16,3.5c-4.142,0-7.5,3.358-7.5,7.5c0,4.143,7.5,18.121,7.5,18.121S23.5,15.143,23.5,11C23.5,6.858,20.143,3.5,16,3.5z M16,14.584z',
        speechbubble: 'M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z',
        link: 'M15.667,4.601c-1.684,1.685-2.34,3.985-2.025,6.173l3.122-3.122c0.004-0.005,0.014-0.008,0.016-0.012c0.21-0.403,0.464-0.789,0.802-1.126c1.774-1.776,4.651-1.775,6.428,0c1.775,1.773,1.777,4.652,0.002,6.429c-0.34,0.34-0.727,0.593-1.131,0.804c-0.004,0.002-0.006,0.006-0.01,0.01l-3.123,3.123c2.188,0.316,4.492-0.34,6.176-2.023c2.832-2.832,2.83-7.423,0-10.255C23.09,1.77,18.499,1.77,15.667,4.601zM14.557,22.067c-0.209,0.405-0.462,0.791-0.801,1.131c-1.775,1.774-4.656,1.774-6.431,0c-1.775-1.774-1.775-4.653,0-6.43c0.339-0.338,0.725-0.591,1.128-0.8c0.004-0.006,0.005-0.012,0.011-0.016l3.121-3.123c-2.187-0.316-4.489,0.342-6.172,2.024c-2.831,2.831-2.83,7.423,0,10.255c2.833,2.831,7.424,2.831,10.257,0c1.684-1.684,2.342-3.986,2.023-6.175l-3.125,3.123C14.565,22.063,14.561,22.065,14.557,22.067zM9.441,18.885l2.197,2.197c0.537,0.537,1.417,0.537,1.953,0l8.302-8.302c0.539-0.536,0.539-1.417,0.002-1.952l-2.199-2.197c-0.536-0.539-1.416-0.539-1.952-0.002l-8.302,8.303C8.904,17.469,8.904,18.349,9.441,18.885z',
        copy: 'M 20.48 7.28 H 9.92 c -0.968 0 -1.76 0.792 -1.76 1.76 v 12.32 h 1.76 V 9.04 h 10.56 V 7.28 z m 2.64 3.52 H 13.44 c -0.968 0 -1.76 0.792 -1.76 1.76 v 12.32 c 0 0.968 0.792 1.76 1.76 1.76 h 9.68 c 0.968 0 1.76 -0.792 1.76 -1.76 V 12.56 c 0 -0.968 -0.792 -1.76 -1.76 -1.76 z m 0 14.08 H 13.44 V 12.56 h 9.68 v 12.32 z',
        plus: 'M25.979,12.896 19.312,12.896 19.312,6.229 12.647,6.229 12.647,12.896 5.979,12.896 5.979,19.562 12.647,19.562 12.647,26.229 19.312,26.229 19.312,19.562 25.979,19.562z',
        minus: 'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z',
        arrowHead: 'M15.834,29.084 15.834,16.166 2.917,16.166 29.083,2.917z',
        undo: 'M12.981,9.073V6.817l-12.106,6.99l12.106,6.99v-2.422c3.285-0.002,9.052,0.28,9.052,2.269c0,2.78-6.023,4.263-6.023,4.263v2.132c0,0,13.53,0.463,13.53-9.823C29.54,9.134,17.952,8.831,12.981,9.073z',
        lockClosed: 'M24.875,15.334v-4.876c0-4.894-3.981-8.875-8.875-8.875s-8.875,3.981-8.875,8.875v4.876H5.042v15.083h21.916V15.334H24.875zM10.625,10.458c0-2.964,2.411-5.375,5.375-5.375s5.375,2.411,5.375,5.375v4.876h-10.75V10.458zM18.272,26.956h-4.545l1.222-3.667c-0.782-0.389-1.324-1.188-1.324-2.119c0-1.312,1.063-2.375,2.375-2.375s2.375,1.062,2.375,2.375c0,0.932-0.542,1.73-1.324,2.119L18.272,26.956z',
        lockOpen: 'M24.875,15.334v-4.876c0-4.894-3.981-8.875-8.875-8.875s-8.875,3.981-8.875,8.875v0.375h3.5v-0.375c0-2.964,2.411-5.375,5.375-5.375s5.375,2.411,5.375,5.375v4.876H5.042v15.083h21.916V15.334H24.875zM18.272,26.956h-4.545l1.222-3.667c-0.782-0.389-1.324-1.188-1.324-2.119c0-1.312,1.063-2.375,2.375-2.375s2.375,1.062,2.375,2.375c0,0.932-0.542,1.73-1.324,2.119L18.272,26.956z',
        download: 'M62.498910964222794,5C30.742627701282224,5,5,30.744805772836607,5,62.498910964222794C5,94.25519422716337,30.744805772836607,120,62.498910964222794,120C94.25519422716337,120,120,94.2551942271634,120,62.49891096422281C120,30.742627701282238,94.2551942271634,5.000000000000014,62.49891096422281,5.000000000000014C62.49891096422281,5.000000000000014,62.498910964222794,5,62.498910964222794,5M62.50108903577718,90.76374552548342C62.50108903577718,90.76374552548342,43.81105702759522,62.498910964222794,43.81105702759522,62.498910964222794C43.81105702759522,62.498910964222794,51.6085531922953,62.498910964222794,51.6085531922953,62.498910964222794C51.6085531922953,62.498910964222794,51.6085531922953,36.362052311596806,51.6085531922953,36.362052311596806C51.6085531922953,36.362052311596806,71.21119718176479,36.362052311596806,71.21119718176479,36.362052311596806C71.21119718176479,36.362052311596806,71.21119718176479,62.498910964222794,71.21119718176479,62.498910964222794C71.21119718176479,62.498910964222794,81.18676490085039,62.498910964222794,81.18676490085039,62.498910964222794C81.18676490085039,62.498910964222794,62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342C62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342',
        embed: 'M62.49999999999999,5C30.759999999999998,5,5,30.759999999999998,5,62.49999999999999C5,94.23999999999998,30.759999999999998,120,62.49999999999999,120C94.23999999999998,120,120,94.23999999999998,120,62.49999999999999C120,30.760000000000005,94.23999999999998,5,62.49999999999999,5C62.49999999999999,5,62.49999999999999,5,62.49999999999999,5M46.285,74.57499999999999C47.894999999999996,76.41499999999999,47.665,79.28999999999999,45.824999999999996,80.9C43.98499999999999,82.51000000000002,41.10999999999999,82.28,39.5,80.44C39.5,80.44,26.505,65.375,26.505,65.375C25.009999999999998,63.65,25.009999999999998,61.23499999999999,26.505,59.50999999999999C26.505,59.50999999999999,39.385,44.44499999999999,39.385,44.44499999999999C40.19,43.41,41.455,42.834999999999994,42.834999999999994,42.834999999999994C43.86999999999999,42.834999999999994,44.904999999999994,43.17999999999999,45.709999999999994,43.86999999999999C46.62999999999999,44.675,47.20499999999999,45.709999999999994,47.20499999999999,46.974999999999994C47.31999999999999,48.125,46.85999999999999,49.275,46.169999999999995,50.19499999999999C46.169999999999995,50.19499999999999,35.81999999999999,62.49999999999999,35.81999999999999,62.49999999999999C35.81999999999999,62.49999999999999,46.285,74.57499999999999,46.285,74.57499999999999C46.285,74.57499999999999,46.285,74.57499999999999,46.285,74.57499999999999M73.08,49.275C73.08,49.275,60.199999999999996,79.28999999999999,60.199999999999996,79.28999999999999C59.28,81.475,56.519999999999996,82.625,54.334999999999994,81.59C53.184999999999995,81.13,52.37999999999999,80.20999999999998,51.919999999999995,79.17500000000001C51.459999999999994,78.025,51.459999999999994,76.875,51.919999999999995,75.725C51.919999999999995,75.725,64.8,45.709999999999994,64.8,45.709999999999994C65.49,44.099999999999994,67.1,42.949999999999996,68.94,42.949999999999996C69.515,42.949999999999996,70.09,43.065,70.66499999999999,43.294999999999995C71.815,43.754999999999995,72.62,44.675,73.08,45.709999999999994C73.53999999999999,46.974999999999994,73.53999999999999,48.125,73.08,49.275C73.08,49.275,73.08,49.275,73.08,49.275M98.495,65.375C98.495,65.375,85.61499999999998,80.44,85.61499999999998,80.44C84.005,82.28,81.13,82.50999999999999,79.28999999999999,80.9C77.44999999999999,79.29000000000002,77.22,76.41499999999999,78.82999999999998,74.57499999999999C78.82999999999998,74.57499999999999,89.17999999999998,62.49999999999999,89.17999999999998,62.49999999999999C89.17999999999998,62.49999999999999,78.715,50.425,78.715,50.425C77.91,49.505,77.565,48.355,77.68,47.205C77.79499999999999,46.055,78.37,44.905,79.17500000000001,44.099999999999994C79.98000000000002,43.41,81.01499999999999,43.065,82.05000000000001,43.065C83.315,43.065,84.58000000000001,43.64,85.5,44.675C85.5,44.675,98.495,59.739999999999995,98.495,59.739999999999995C99.98999999999998,61.23499999999999,99.98999999999998,63.765,98.495,65.375C98.495,65.375,98.495,65.375,98.495,65.375',
        trash: 'M 13.56 8.28 h 5.28 v -1.54 c 0 -0.0581 -0.0229 -0.1144 -0.0642 -0.1558 c -0.0414 -0.0414 -0.0977 -0.0642 -0.1558 -0.0642 h -4.84 c -0.0581 0 -0.1144 0.0229 -0.1558 0.0642 c -0.0414 0.0414 -0.0642 0.0977 -0.0642 0.1558 v 1.54 z m 9.68 0.88 h -14.08 v 15.84 c 0 0.4858 0.3942 0.88 0.88 0.88 h 12.32 c 0.4858 0 0.88 -0.3942 0.88 -0.88 v -15.84 z m -8.8 3.08 c 0 -0.2429 -0.1971 -0.44 -0.44 -0.44 s -0.44 0.1971 -0.44 0.44 v 10.56 c 0 0.2429 0.1971 0.44 0.44 0.44 s 0.44 -0.1971 0.44 -0.44 v -10.56 z m 4.4 0 c 0 -0.2429 -0.1971 -0.44 -0.44 -0.44 s -0.44 0.1971 -0.44 0.44 v 10.56 c 0 0.2429 0.1971 0.44 0.44 0.44 s 0.44 -0.1971 0.44 -0.44 v -10.56 z m 7.04 -3.96 v 0.88 h -1.76 v 15.84 c 0 0.9724 -0.7876 1.76 -1.76 1.76 h -12.32 c -0.9724 0 -1.76 -0.7876 -1.76 -1.76 v -15.84 h -1.76 v -0.88 h 6.16 v -1.76 c 0 -0.4858 0.3942 -0.88 0.88 -0.88 h 5.28 c 0.4858 0 0.88 0.3942 0.88 0.88 v 1.76 h 6.16 z',
        resize: 'M24 10.999v-10.999h-11l3.379 3.379-13.001 13-3.378-3.378v10.999h11l-3.379-3.379 13.001-13z'
    };
}
exports.default = sbIcons;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1q4m":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shapes", ()=>shapes
);
/* eslint-disable */ var _sbIconsJs = require("../../helpers/sbIcons.js");
var _sbIconsJsDefault = parcelHelpers.interopDefault(_sbIconsJs);
const shapes = function(R) {
    const c = 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466z';
    const { icons  } = _sbIconsJsDefault.default;
    R.fn.handle = function(x, y) {
        return this.path(icons.handle + c);
    };
    R.fn.editor = function(x, y) {
        return this.path(icons.editor + c);
    };
    R.fn.deleter = function(x, y) {
        return this.path(icons.deleter + c);
    };
    R.fn.trash = function() {
        return this.path(icons.trash + c).attr({
            fill: '#000'
        });
    };
    R.fn.searcher = function(x, y) {
        return this.path(icons.searcher + c);
    };
    R.fn.plus = function(x, y) {
        return this.path(icons.plus + c);
    };
    R.fn.merge = function(x, y) {
        return this.path(icons.plus + c);
    };
    R.fn.copy = function(x, y) {
        return this.path(icons.copy + c);
    };
    R.fn.minus = function(x, y) {
        return this.path(icons.minus + c);
    };
    R.fn.link = function(x, y) {
        return this.path(icons.link + c);
    };
    R.fn.up = function(x, y) {
        return this.path(icons.up);
    };
    R.fn.down = function(x, y) {
        return this.path(icons.up).transform('r180');
    };
    R.fn.setting = function(x, y) {
        return this.path(icons.settings + c).transform('s,.9,.9');
    };
    R.fn.arrow = function() {
        return this.path(icons.arrow + c);
    };
    R.fn.arrowHead = function() {
        return this.path(icons.arrowHead).attr({
            fill: '#648CB2'
        }).transform('s0.7');
    };
    R.fn.linkArrow = function() {
        return this.path(icons.arrow + c).attr({
            fill: '#648CB2'
        });
    };
    R.fn.lockClosed = function() {
        return this.path(icons.lockClosed);
    };
    R.fn.lockOpen = function() {
        return this.path(icons.lockOpen);
    };
    R.fn.speechbubble = function(x, y, txt) {
        const _bubble = this.set();
        _bubble.push(this.path(icons.speechbubble).transform([
            't',
            x,
            ',',
            y
        ].join()).scale(6, 4).scale(-1, 1)).attr({
            fill: '#fff',
            stroke: '#000',
            'stroke-width': 3
        });
        _bubble.push(this.text(x + 10, y + 10, txt).attr({
            'font-size': 12
        }));
        return _bubble;
    };
    R.fn.undo = function(path) {
        return this.path(icons.undo);
    };
    R.fn.redo = function(path) {
        return this.path(icons.undo).transform('s-1,1');
    };
    R.fn.resize = function() {
        return this.path(`M24 10.999v-10.999h-11l3.379 3.379-13.001 13-3.378-3.378v10.999h11l-3.379-3.379 13.001-13z`);
    };
    R.fn.resizeLines = function() {
        return this.image('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAXCAYAAAAP6L+eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEBJREFUeNpiYKAuYAPijUD8n1aGVowaOmoo/QyNpYWh+UB8g1aGSowaOmroqKEEAE0MZaCVoQxEFH3e5BgKEGAAnnVBs4ro6nUAAAAASUVORK5CYII=', 0, 0, 22, 23);
    };
};

},{"../../helpers/sbIcons.js":"5LoVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Msrc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extensions", ()=>extensions
);
const extensions = function(R) {
    R.el.loop = function(_options) {
        const _self = this;
        const options = {
            pkg: [
                {
                    'stroke-width': 3
                },
                {
                    'stroke-width': 1
                }
            ],
            duration: 200,
            repeat: false
        };
        Object.assign(options, _options);
        function loop() {
            _self.animate(options.pkg[0], options.duration, ()=>{
                _self.animate(options.pkg[1], options.duration, ()=>{
                    if (options.repeat) loop();
                });
            });
        }
        loop();
        return _self;
    };
    R.el.tooltip = function(obj, w, h) {
        if (w === undefined) w = 80;
        if (h === undefined) h = 20;
        const _tt = this.paper.set();
        const pos = this.getBBox();
        if (obj.type === 'text') {
            // text tooltip
            _tt.push(this.paper.rect(pos.x, pos.y + h * -1 - 10, w, h, 5).attr({
                fill: '#fff'
            }));
            _tt.push(this.paper.text(pos.x + 5, pos.y - 20, '').attr({
                'text-anchor': 'start',
                stroke: '#fff',
                'font-size': 13,
                fill: '#fff'
            }));
        } else {
            // image tooltip
            const xpad = w * -1 - 5;
            _tt.push(this.paper.rect(pos.x + xpad, pos.y + h / 2 * -1, w, h, 15).attr({
                'stroke-width': 2,
                stroke: '#fff',
                'z-index': 9999
            }));
            _tt.push(this.paper.rect(pos.x + xpad, pos.y + (h / 2 - 45), w, 47, 15)).attr({
                'stroke-width': 2,
                fill: '90-#333-#000',
                'z-index': 9999
            });
            _tt.push(this.paper.text(pos.x + xpad + w / 2, pos.y + (h / 2 - 20), '').attr({
                'text-anchor': 'middle',
                stroke: '#fff',
                'font-weight': 'normal',
                'font-family': 'Verdana',
                'font-size': 11,
                'z-index': 999
            }));
        }
        const s = this;
        if (!s.removed) {
            s.tt = _tt;
            if (obj.type === 'text') s.tt[0].animate({
                stroke: '#000',
                fill: '#333'
            }, 200, ()=>{
                s.tt[1].attr({
                    text: obj.msg
                });
            });
            else s.tt[0].animate({
                stroke: '#000',
                fill: '#333'
            }, 200, ()=>{
                // s.tt[1].attr({  });
                s.tt[2].attr({
                    text: obj.msg
                });
            });
        }
        return s.tt;
    };
    R.el.untooltip = function() {
        this.tt && this.tt.remove();
        return this;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jW8Fw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const kCSSFontFacePattern = /(@font\-face {[\s\S]*?})/g;
const kCSSUrlPattern = /url\((https.+?)\)/;
function fontToDataURLViaBlob(fontUrl) {
    return fetch(fontUrl).then((fontResponse)=>fontResponse.blob()
    ).then((fontBlob)=>new Promise((resolve)=>{
            const reader = new FileReader();
            reader.onload = ()=>{
                resolve(reader.result);
            };
            reader.readAsDataURL(fontBlob);
        })
    );
}
function fontToDataURLViaBuffer(fontUrl) {
    return fetch(fontUrl).then((fontResponse)=>Promise.all([
            Promise.resolve(fontResponse.headers.get("content-type")),
            fontResponse.buffer(), 
        ])
    ).then((fontBuffer)=>{
        const b64 = fontBuffer[1].toString("base64");
        return `data:${fontBuffer[0]};base64,${b64}`;
    });
}
function embedFont(fontFace) {
    const fontUrlMatch = kCSSUrlPattern.exec(fontFace);
    let promise;
    if (typeof FileReader !== "undefined") promise = fontToDataURLViaBlob(fontUrlMatch[1]);
    else promise = fontToDataURLViaBuffer(fontUrlMatch[1]);
    return promise.then((dataURL)=>fontFace.replace(fontUrlMatch[1], dataURL)
    );
}
function embedGoogleFonts({ fonts , text , styleNode  }) {
    const snode = styleNode;
    const fontQuery = fonts.join("|").replace(/ /g, "+");
    const googleFontUrl = `https://fonts.googleapis.com/css?family=${fontQuery}&text=${text}`;
    if (fonts.length > 0) return fetch(googleFontUrl).then((cssResponse)=>cssResponse.text()
    ).then((cssText)=>{
        let fontFaces = kCSSFontFacePattern.exec(cssText);
        const embedFontPromises = [];
        while(fontFaces != null){
            embedFontPromises.push(embedFont(fontFaces[1]));
            fontFaces = kCSSFontFacePattern.exec(cssText);
        }
        return Promise.all(embedFontPromises);
    }).then((results)=>{
        snode.innerHTML += results.join("\n");
        return true;
    });
    return Promise.resolve(true);
}
exports.default = embedGoogleFonts;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dd61Y":[function(require,module,exports) {
(function(emile, container) {
    const parseEl = document.createElement('div');
    const props = "backgroundColor borderBottomColor borderBottomWidth borderLeftColor borderLeftWidth borderRightColor borderRightWidth borderSpacing borderTopColor borderTopWidth bottom color fontSize fontWeight height left letterSpacing lineHeight marginBottom marginLeft marginRight marginTop maxHeight maxWidth minHeight minWidth opacity outlineColor outlineOffset outlineWidth paddingBottom paddingLeft paddingRight paddingTop right textIndent top width wordSpacing zIndex".split(' ');
    function interpolate(source, target, pos) {
        return parseFloat(source + (target - source) * pos).toFixed(3);
    }
    function s(str, p, c) {
        return str.substr(p, c || 1);
    }
    function color(source, target, pos) {
        let i = 2;
        let j;
        let c;
        let tmp;
        const v = [];
        const r = [];
        while(j = 3, c = arguments[i - 1], i--)if (s(c, 0) == 'r') {
            c = c.match(/\d+/g);
            while(j--)v.push(~~c[j]);
        } else {
            if (c.length == 4) c = `#${s(c, 1)}${s(c, 1)}${s(c, 2)}${s(c, 2)}${s(c, 3)}${s(c, 3)}`;
            while(j--)v.push(parseInt(s(c, 1 + j * 2, 2), 16));
        }
        while(j--){
            tmp = ~~(v[j + 3] + (v[j] - v[j + 3]) * pos);
            r.push(tmp < 0 ? 0 : tmp > 255 ? 255 : tmp);
        }
        return `rgb(${r.join(',')})`;
    }
    function parse(prop) {
        const p = parseFloat(prop);
        const q = prop.replace(/^[\-\d\.]+/, '');
        return Number.isNaN(p) ? {
            v: q,
            f: color,
            u: ''
        } : {
            v: p,
            f: interpolate,
            u: q
        };
    }
    function normalize(style) {
        let css;
        const rules = {
        };
        let i = props.length;
        let v;
        parseEl.innerHTML = `<div style="${style}"></div>`;
        css = parseEl.childNodes[0].style;
        while(i--)if (v = css[props[i]]) rules[props[i]] = parse(v);
        return rules;
    }
    container[emile] = function(el, style, opts) {
        el = typeof el === 'string' ? document.getElementById(el) : el;
        opts = opts || {
        };
        const target = normalize(style);
        const comp = el.currentStyle ? el.currentStyle : getComputedStyle(el, null);
        let prop;
        const current = {
        };
        const start = +new Date();
        const dur = opts.duration || 200;
        const finish = start + dur;
        let interval;
        const easing = opts.easing || function(pos) {
            return -Math.cos(pos * Math.PI) / 2 + 0.5;
        };
        for(prop in target)current[prop] = parse(comp[prop]);
        interval = setInterval(function() {
            window.requestAnimationFrame(()=>{
                const time = +new Date();
                const pos = time > finish ? 1 : (time - start) / dur;
                for(prop in target){
                    const tv = opts.onMove ? opts.onMove(prop) : target[prop].f(current[prop].v, target[prop].v, easing(pos));
                    el.style[prop] = tv + target[prop].u;
                }
                if (time > finish) {
                    clearInterval(interval);
                    opts.after && opts.after();
                } else opts.during && opts.during.apply(this, [
                    (time - start) / dur
                ]);
            });
        }, 10);
    };
})('emile', window);

},{}],"eYgJm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class collab {
    constructor(slate){
        this.slate = slate;
        this.invoker = null;
        this.pc = slate.collaboration || {
        };
        if (!_utilsDefault.default.localRecipients) _utilsDefault.default.localRecipients = [];
        this.wire();
    }
    exe(pkg) {
        const self = this;
        self.invoke(pkg);
        self.send(pkg);
    }
    wire() {
        const self = this;
        function resetMultiSelect() {
            self.slate.multiSelection?.end();
        }
        self.invoker = {
            onZoom (pkg) {
                if (self.slate.options.followMe) {
                    resetMultiSelect();
                    const zoomPercent = self.slate.options.viewPort.originalWidth / pkg.data.zoomLevel * 100;
                    self.slate.canvas.zoom({
                        dur: pkg.data.duration || 500,
                        zoomPercent,
                        callbacks: {
                            during () {
                            // additional calcs
                            },
                            after () {
                            }
                        }
                    });
                }
            },
            onNodePositioned (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.position(pkg.data.location, ()=>{
                }, pkg.data.easing, pkg.data.duration || 500);
                self.closeNodeSpecifics(pkg);
            },
            onNodeLinkRemoved (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.links?.unset(false);
                self.closeNodeSpecifics(pkg);
            },
            onNodeLinkAdded (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.links?.set(pkg, false);
                self.closeNodeSpecifics(pkg);
            },
            onNodeUnlocked (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.options.allowDrag = true;
                cn.options.isLocked = false;
                cn.hideLock();
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeLocked (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.options.allowDrag = false;
                cn.options.isLocked = true;
                cn.showLock();
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeBehaviorChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                pkg.data.behaviorChanges.forEach((b)=>{
                    cn.options[b.name] = b.value;
                });
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeToBack (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.toBack();
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeToFront (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.toFront();
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeShapeChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.shapes.set(pkg.data);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeAdded (pkg) {
                resetMultiSelect();
                const blnPreserve = pkg.preserve !== undefined ? pkg.preserve : true;
                self.slate.loadJSON(pkg.data, blnPreserve, true);
            },
            onNodeImageChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.images.set(pkg.data.img, pkg.data.w, pkg.data.h);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeDeleted (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.del();
                self.slate.birdsEye?.nodeDeleted(pkg);
            },
            onNodeResized (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.hideOwnMenus();
                const opts = {
                    associations: pkg.data.associations,
                    animate: true
                };
                Object.assign(cn.options, _lodashOmitDefault.default(pkg.data, [
                    'associations',
                    'textPosition'
                ]));
                cn.resize.animateSet(pkg.data, opts);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeRotated (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                const cn = self.slate.nodes.one(pkg.data.id);
                // needs to be updated
                cn.options.textOffset = pkg.data.textOffset;
                cn.hideOwnMenus();
                const previousRotationAngle = cn.options.rotate.rotationAngle;
                const opts = {
                    associations: pkg.data.associations,
                    animate: true
                };
                Object.assign(cn.options, _lodashOmitDefault.default(pkg.data, 'associations'));
                cn.rotate.animateSet({
                    ...pkg.data,
                    rotationAngle: pkg.data.rotate.rotationAngle - previousRotationAngle
                }, opts);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeColorChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.colorPicker.set(pkg.data);
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeTextChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.editor.set(pkg.data.text, pkg.data.fontSize, pkg.data.fontFamily, pkg.data.fontColor, pkg.data.textOpacity, pkg.data.textXAlign, pkg.data.textYAlign, true);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.slate.loadAllFonts();
            },
            addRelationship (pkg) {
                resetMultiSelect();
                self.slate.nodes.addRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
            },
            removeRelationship (pkg) {
                resetMultiSelect();
                self.slate.nodes.removeRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
            },
            onNodesMove (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                self.slate.nodes.moveNodes(pkg, {
                    animate: true
                });
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeEffectChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.applyFilters(pkg.data.filter);
            },
            onNodeBorderPropertiesChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn.applyBorder(pkg.data);
            },
            onLinePropertiesChanged (pkg) {
                const upkg = pkg;
                self.slate.toggleFilters(true, null, true);
                if (!upkg.data.forEach) upkg.data = [
                    upkg.data
                ];
                upkg.data.forEach((p)=>{
                    const cn = self.slate.nodes.one(p.id);
                    Object.assign(cn.options, p.options);
                    cn.lineOptions.set(p);
                });
            },
            onFollowMeChanged (pkg) {
                self.slate.options.followMe = pkg.data?.followMe;
            },
            onCanvasMove (pkg) {
                if (self.slate.options.followMe) {
                    self.slate.toggleFilters(true, null, true);
                    const opts = {
                        x: pkg.data.left,
                        y: pkg.data.top,
                        dur: pkg.data.duration || 500,
                        callback: {
                            after () {
                                self.slate.birdsEye?.refresh(true);
                            }
                        },
                        isAbsolute: !pkg.isRelative
                    };
                    self.slate.canvas.move(opts);
                }
            },
            onSlateThemeChanged (pkg) {
                self.slate.options.themeId = pkg.data?.theme?._id;
                if (pkg.data?.theme) self.slate.applyTheme(pkg.data.theme, pkg.data.syncWithTheme);
            },
            onSlateBackgroundEffectChanged (pkg) {
                self.slate.options.containerStyle.backgroundEffect = pkg.data.effect;
                self.slate.canvas.hideBg(1);
            // self.slate.png({ backgroundOnly: true, base64: true }, (base64) => {
            //   self.slate.canvas.internal.style.background = base64;
            //   self.slate.canvas._bg?.remove();
            // });
            },
            onSlateBackgroundImageChanged (pkg) {
                if (pkg.data.bg) {
                    self.slate.options.containerStyle.backgroundImage = pkg.data.bg.url;
                    self.slate.options.containerStyle.backgroundSize = pkg.data.bg.size;
                } else {
                    const c = self.slate.options.containerStyle.prevBackgroundColor || '#fff';
                    self.slate.options.containerStyle.backgroundColor = c;
                    self.slate.options.containerStyle.backgroundImage = null;
                    self.slate.options.containerStyle.backgroundEffect = null;
                }
                self.slate.canvas.hideBg(1);
            },
            onSlateBackgroundColorChanged (pkg) {
                self.slate.options.containerStyle.backgroundColor = pkg.data.color;
                self.slate.options.containerStyle.backgroundColorAsGradient = pkg.data.asGradient;
                self.slate.options.containerStyle.backgroundGradientType = pkg.data.gradientType;
                self.slate.options.containerStyle.backgroundGradientColors = pkg.data.gradientColors;
                self.slate.options.containerStyle.backgroundGradientStrategy = pkg.data.gradientStrategy;
                self.slate.options.containerStyle.backgroundImage = null;
                self.slate.options.containerStyle.backgroundEffect = null;
                self.slate.canvas.hideBg(1);
            },
            onLineColorChanged (pkg) {
                self.slate.options.defaultLineColor = pkg.data.color;
                self.slate.nodes.allNodes.forEach((n)=>{
                    n.options.lineColor = pkg.data.color;
                    n.relationships.associations.forEach((a)=>{
                        a.lineColor = pkg.data.color;
                    });
                    n.relationships.refreshOwnRelationships();
                });
            },
            onSlateNameChanged (pkg) {
                self.slate.options.name = pkg.data.name;
            },
            onSlateDescriptionChanged (pkg) {
                self.slate.options.description = pkg.data.description;
            },
            onSlateShowGridChanged (pkg) {
                self.slate.options.viewPort.showGrid = pkg.data.showGrid;
                if (pkg.data.showGrid) self.slate.grid.show();
                else self.slate.grid.destroy();
            },
            onSlateMindMapModeChanged (pkg) {
                self.slate.options.mindMapMode = pkg.data.mindMapMode;
            },
            onSlateTemplateChanged (pkg) {
                self.slate.options.isTemplate = pkg.data.isTemplate;
            },
            onSlateSnapToObjectsChanged (pkg) {
                self.slate.options.viewPort.snapToObjects = pkg.data.snapToObjects;
            },
            onSlateFollowMeChanged (pkg) {
                self.slate.options.followMe = pkg.data.followMe;
            }
        } // this invoker
        ;
        if (self.pc.onCollaboration) self.pc.onCollaboration({
            type: 'init',
            slate: self.slate,
            cb (pkg) {
                self._process(pkg);
            }
        });
        if (self.pc.localizedOnly) _utilsDefault.default.localRecipients.push(self);
    }
    _process(pkg) {
        const self = this;
        if (_utilsDefault.default.localRecipients.length > 1) {
            let _time = 0;
            _utilsDefault.default.localRecipients.forEach((s)=>{
                _time += 10;
                ((rec, t)=>{
                    setTimeout(()=>{
                        rec.collab.invoke(pkg);
                    }, t);
                })(_utilsDefault.default.localRecipients[s], _time);
            });
        } else if (self.invoker[pkg.type]) self.invoker[pkg.type](pkg);
        else if (self.pc.onCollaboration) self.pc.onCollaboration({
            type: 'custom',
            slate: self.slate,
            pkg
        });
    }
    invoke(pkg) {
        const self = this;
        if (self.invoker[pkg.type]) self.invoker[pkg.type](pkg);
    }
    closeNodeSpecifics(pkg) {
        const self = this;
        const all = pkg.data.nodeOptions ? pkg.data.nodeOptions : [
            pkg.data
        ];
        all.forEach((n)=>{
            // close self node's marker if open
            const nx = self.slate.nodes.one(n.id);
            if (nx) {
                nx.menu?.hide();
                nx.connectors?.remove();
                nx.resize?.hide();
                nx.rotate?.hide();
                nx.relationships.associations.forEach((association)=>{
                    nx.lineOptions?.hide(association.id);
                });
            } else console.error('Unable to find node with id', n.id);
        });
        // remove any context menus
        self.slate.removeContextMenus();
        self.slate.untooltip();
    }
    send(pkg) {
        const self = this;
        if (pkg.type !== 'onMouseMoved') {
            if (self.slate.undoRedo && self.slate.options.showUndoRedo) self.slate.undoRedo.snap();
        }
        if (self.pc.allow) {
            if (self.slate.options?.onSlateChanged) self.slate.options.onSlateChanged.apply(self, [
                pkg
            ]);
            if (self.pc.onCollaboration) self.pc.onCollaboration({
                type: 'process',
                slate: self.slate,
                pkg
            });
        }
    }
}
exports.default = collab;

},{"lodash.omit":"82TGT","../helpers/utils":"8QI6M","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82TGT":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while(++index < length)result[index] = iteratee(array[index], index, array);
    return result;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) return baseFindIndex(array, baseIsNaN, fromIndex);
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {
    }
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Symbol = root.Symbol, getPrototype = overArg(Object.getPrototypeOf, Object), propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, 'Map'), nativeCreate = getNative(Object, 'create');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {
    };
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length)this.add(values[index]);
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */ function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) return result;
    if (iteratee) values = arrayMap(values, baseUnary(iteratee));
    if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
    }
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while(valuesIndex--){
                if (values[valuesIndex] === computed) continue outer;
            }
            result.push(value);
        } else if (!includes(values, computed, comparator)) result.push(value);
    }
    return result;
}
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
            else arrayPush(result, value);
        } else if (!isStrict) result[result.length] = value;
    }
    return result;
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeysIn(object) {
    if (!isObject(object)) return nativeKeysIn(object);
    var isProto = isPrototype(object), result = [];
    for(var key in object)if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
    return result;
}
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */ function basePick(object, props) {
    object = Object(object);
    return basePickBy(object, props, function(value, key) {
        return key in object;
    });
}
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */ function basePickBy(object, props, predicate) {
    var index = -1, length = props.length, result = {
    };
    while(++index < length){
        var key = props[index], value = object[key];
        if (predicate(value, key)) result[key] = value;
    }
    return result;
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while(object){
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
    }
    return result;
};
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function nativeKeysIn(object) {
    var result = [];
    if (object != null) for(var key in Object(object))result.push(key);
    return result;
}
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) return value;
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e1) {
        }
    }
    return '';
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */ function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */ var omit = baseRest(function(object, props) {
    if (object == null) return {
    };
    props = arrayMap(baseFlatten(props, 1), toKey);
    return basePick(object, baseDifference(getAllKeysIn(object), props));
});
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
module.exports = omit;

},{}],"bAVQb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-param-reassign */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-unused-expressions */ /* eslint-disable no-underscore-dangle */ var _base = require("./base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class node extends _baseDefault.default {
    constructor(options){
        super();
        this._lock = null;
        this._openLock = null;
        this.lm = null;
        this.options = {
            id: _utilsDefault.default.guid(),
            name: '',
            text: '',
            image: '',
            groupId: null,
            xPos: 0,
            yPos: 0,
            height: 10,
            width: 10,
            borderStyle: 'solid',
            borderWidth: 1,
            borderColor: '#000',
            borderOpacity: 1,
            lineColor: '#000000',
            lineOpacity: 1,
            lineEffect: '',
            lineWidth: 5,
            opacity: 1,
            textOpacity: 1,
            showDelete: true,
            showAddAndDeleteConditionally: false,
            showResize: true,
            showAdd: true,
            showRelationshipConnector: true,
            showRelationshipDelete: true,
            showRelationshipProperties: true,
            showRelationshipReassign: true,
            showRotate: true,
            showMenu: true,
            showColorTab: true,
            showTextTab: true,
            showShapeTab: true,
            showImageTab: true,
            showEffectTab: true,
            spaceBetweenNodesWhenAdding: 30,
            disableMenuAsTemplate: false,
            disableDrag: false,
            allowDrag: true,
            allowMenu: true,
            allowContext: true,
            allowResize: true,
            isLocked: false,
            isComment: false,
            backgroundColor: '90-#031634-#2D579A',
            foregroundColor: '#fff',
            fontSize: 18,
            fontFamily: 'Roboto',
            vectorPath: '',
            rotate: {
                rotationAngle: 0
            },
            textXAlign: 'middle',
            textYAlign: 'middle',
            link: {
                show: false,
                type: '',
                data: '',
                thumbnail: {
                    width: 175,
                    height: 175
                }
            },
            filters: {
                vect: null,
                text: null
            }
        };
        Object.assign(this.options, options);
        if (this.options.name === '') this.options.name = this.options.id;
        this.constants = {
            statusPanelAtRest: 33,
            statusPanelExpanded: 200
        };
    }
    // get vect() {
    //   return this.vect;
    // }
    // get text() {
    //   return this.text;
    // }
    // get link() {
    //   return this.link;
    // }
    // set vect(val) {
    //   this.vect = val;
    // }
    // set text(val) {
    //   this.text = val;
    // }
    // set link(val) {
    //   this.link = val;
    // }
    _url(opt) {
        return this.options.ajax.rootUrl + this.options.ajax.urlFlavor + opt;
    }
    del() {
        const _unlinkId = this.options.id;
        this.slate.nodes.closeAllMenus();
        this.slate.nodes.closeAllLineOptions();
        this.relationships.removeAll();
        this.slate.options.allowDrag = true;
        // unlink any links
        this.slate.nodes.allNodes.forEach((nd)=>{
            if (nd.options.link && nd.options.link.show && nd.options.link.data === _unlinkId) {
                Object.assign(nd.options.link, {
                    show: false,
                    type: '',
                    data: ''
                });
                nd.link.hide();
            }
        });
        this.slate.nodes.remove(this);
    }
    getTransformString(opts = {
    }) {
        const _transforms = [];
        let rotationTransform;
        if (opts.action === 'resize') {
            const resizeTransform = `s${opts.sx},${opts.sy}`;
            _transforms.push(resizeTransform);
        }
        if (opts.rotate) rotationTransform = `R${opts.rotate.rotationAngle}, ${opts.rotate.point.x}, ${opts.rotate.point.y}`;
        else if (this.options.rotate.rotationAngle) rotationTransform = `R${this.options.rotate.rotationAngle}, ${this.options.rotate.point.x - (opts.dx || 0)}, ${this.options.rotate.point.y - (opts.dy || 0)}`;
        if (rotationTransform) _transforms.push(rotationTransform);
        if (opts.action === 'translate') {
            const translationTransform = `T${opts.dx}, ${opts.dy}`;
            // console.log("node transform string ", translationTransform);
            _transforms.push(translationTransform);
        }
        return _transforms.join(' ');
    }
    rotateMoveVector({ dx , dy  }) {
        const _rotationAngle = -this.options.rotate.rotationAngle * Math.PI / 180 // conversion to radians
        ;
        return {
            dx: dx * Math.cos(_rotationAngle) - dy * Math.sin(_rotationAngle),
            dy: dx * Math.sin(_rotationAngle) + dy * Math.cos(_rotationAngle)
        };
    }
    translateWith({ dx , dy  }) {
        // need a rotateMoveVector for both the vect and the text
        const newMoveVector = this.rotateMoveVector({
            dx,
            dy
        });
        const translateContext = {
            action: 'translate',
            dx: newMoveVector.dx,
            dy: newMoveVector.dy
        };
        const transformString = this.getTransformString(translateContext);
        // during movement, the only thing that is updated is the transform property on
        // both the text and vect -- the actual attr update happens at the "up" in the
        // relationships.js module -- and the transform("") there causes these transient
        // transforms to be removed and replaced with the permanent attr updates.
        // note the "up" function there calls into the utils.transformPath on Slatebox.js
        // proper where the transform("") and the attr permanent record is done.
        this.vect.transform(transformString);
        this.text.transform(transformString);
        this.setPosition({
            x: this.vect.ox + dx,
            y: this.vect.oy + dy
        });
    }
    setPosition(p, blnKeepMenusOpen, activeNode, opts = {
    }) {
        this.options.xPos = p.x;
        this.options.yPos = p.y;
        const lc = this.linkCoords();
        // not setting the text attr here -- this is
        // this.text.attr(this.textCoords(p));
        // this.text.attr(this.textCoords({x: this.options.xPos, y: this.options.yPos = p.y });
        this.link.transform([
            't',
            lc.x,
            ',',
            lc.y,
            's',
            '.8',
            ',',
            '.8',
            'r',
            '180'
        ].join());
        // close all open menus
        if (blnKeepMenusOpen !== true) {
            this.slate.nodes.closeAllMenus({
                exception: activeNode
            });
            this.slate.nodes.closeAllLineOptions();
        }
    }
    setStartDrag() {
        this.slate.options.allowDrag = false;
        // this.slate.stopEditing();
        this.connectors && this.connectors.reset();
        this.context && this.context.remove();
    }
    setEndDrag() {
        if (this.slate && this.slate.options.enabled) // could be null in case of the tempNode
        this.slate.options.allowDrag = true;
        this.slate.displayLocks();
    }
    serialize(lineWidthOverride) {
        const self = this;
        const jsonNode = {
        };
        Object.assign(jsonNode, {
            options: self.options
        });
        jsonNode.relationships = {
            associations: []
        } // , children: []
        ;
        self.relationships.associations.forEach((association)=>{
            jsonNode.relationships.associations.push(self._bindRel(association, lineWidthOverride));
        });
        return jsonNode;
    }
    _bindRel(obj, lineWidthOverride) {
        return {
            childId: obj.child.options.id,
            parentId: obj.parent.options.id,
            isStraightLine: obj.blnStraight,
            lineColor: obj.lineColor,
            lineEffect: obj.lineEffect,
            lineOpacity: obj.lineOpacity,
            lineWidth: lineWidthOverride || obj.lineWidth
        };
    }
    addRelationships(json, cb) {
        // add parents
        const self = this;
        const _lines = [];
        if (json.relationships) // add associations
        {
            if (json.relationships && json.relationships.associations && json.relationships.associations.forEach) json.relationships.associations.forEach((association)=>{
                const _pr = association;
                let _pn = null;
                self.slate.nodes.allNodes.forEach((node1)=>{
                    if (node1.options.id === _pr.parentId && self.options.id !== node1.options.id) _pn = node1;
                });
                if (_pn) {
                    const _conn = _pn.relationships.addAssociation(self, _pr);
                    _lines.push(_conn.line);
                }
            });
        }
        cb?.apply(self, [
            _lines
        ]);
    }
    toFront() {
        this.relationships?.associations?.forEach((assoc)=>{
            assoc.line.toFront();
        });
        this.vect.toFront();
        this.text.toFront();
        this.link.toFront();
        this.slate?.grid.toBack();
        this.slate?.canvas.bgToBack();
        this.slate.reorderNodes();
    }
    toBack() {
        this.link.toBack();
        this.text.toBack();
        this.vect.toBack();
        this.relationships?.associations?.forEach((assoc)=>{
            assoc.line.toBack();
        });
        this.slate?.grid.toBack();
        this.slate?.canvas.bgToBack();
        this.slate.reorderNodes();
    }
    hide() {
        this.vect.hide();
        this.text.hide();
        this.options.link.show && this.link.hide();
    }
    show() {
        this.vect.show();
        this.text.show();
        this.options.link.show && this.link.show();
    }
    applyFilters(filter) {
        const self = this;
        if (filter) {
            // presumes that the filter has been added to the slate
            if (!self.options.filters[filter.apply]) self.options.filters[filter.apply] = {
            };
            self.options.filters[filter.apply] = filter.id;
        }
        Object.keys(self.options?.filters).forEach((key)=>{
            if (self[key]) {
                if (self.options.filters[key]) self[key].attr('filter', `url(#${self.options.filters[key]})`);
                else self[key].attr('filter', '');
            }
        });
    }
    toggleFilters(blnHide) {
        const self = this;
        Object.keys(self.options?.filters).forEach((key)=>{
            if (self[key]) {
                if (self.options.filters[key]) {
                    if (blnHide) self[key].attr('filter', '');
                    else self[key].attr('filter', `url(#${self.options.filters[key]})`);
                }
            }
        });
    }
    applyBorder(pkg) {
        // first update the border prop if used
        if (pkg) this.options[pkg.prop] = pkg.val;
        // next define the full suite
        const vectOpts = {
            stroke: this.options.borderColor,
            'stroke-dasharray': this.options.borderStyle || null,
            'stroke-width': this.options.borderWidth != null ? this.options.borderWidth : 1,
            'stroke-opacity': this.options.borderOpacity != null ? this.options.borderOpacity : 1,
            'stroke-linecap': 'round'
        };
        if (this.vect) this.vect.attr(vectOpts);
        return vectOpts;
    }
    // returns an invisible path with the correct position of a path being dragged. MAKE SURE TO REMOVE IT AFTER YOU ARE DONE WITH IT or there will be a growing number of invisible paths rendering the slate unusable
    getTempPathWithCorrectPositionFor({ pathElement , dx , dy , rotationAngle  }) {
        const tempPath = this.slate.paper.path(pathElement.attr('path').toString()).attr({
            opacity: 0
        });
        const _transforms = [];
        const bb = tempPath.getBBox();
        if (dx != null && dy != null) {
            if (this.options.rotate.rotationAngle) {
                const newMoveVector = this.rotateMoveVector({
                    dx,
                    dy
                });
                _transforms.push(`T${newMoveVector.dx},${newMoveVector.dy}`);
            } else _transforms.push(`T${dx},${dy}`);
        }
        if (rotationAngle != null) _transforms.push(`r${rotationAngle}, ${bb.cx}, ${bb.cy}`);
        else if (this.options.rotate.rotationAngle) _transforms.push(`r${this.options.rotate.rotationAngle}, ${this.options.rotate.point.x}, ${this.options.rotate.point.y}`);
        tempPath.transform('');
        const transformPath = _getTransformedPathDefault.default(tempPath.attr('path').toString(), _transforms);
        tempPath.attr({
            path: transformPath
        });
        return tempPath;
    }
    hideOwnMenus() {
        this.link.hide();
        this.menu.hide();
    // this._lock && this._lock.hide();
    // this._openLock && this._openLock.hide();
    }
    spin(opts) {
        let ii = 0;
        const _aa = opts && opts.angle || 280;
        const _dur = opts && opts.duration || 5000;
        function _spinner(_angle) {
            ii++;
            const _ra = ii % 2 === 0 ? this.options.rotate.rotationAngle - _angle : this.options.rotate.rotationAngle + _angle;
            const _rotate = {
                rotate: this.options.rotate,
                rotationAngle: _ra
            };
            this.rotate.animateSet(_rotate, {
                duration: _dur,
                cb: ()=>{
                    _spinner(_aa);
                }
            });
        }
        _spinner(_aa);
    }
    move(pkg) {
        const _mPkg = {
            dur: pkg.dur || 500,
            moves: [
                {
                    id: this.options.id,
                    x: pkg.x,
                    y: pkg.y
                }, 
            ]
        };
        const _pkg = this.slate.nodes.nodeMovePackage(_mPkg);
        this.slate.nodes.moveNodes(_pkg, {
            animate: true,
            cb: ()=>{
                pkg.cb && pkg.cb();
            }
        });
    }
    zoom(zoomPercent, duration, cb) {
        /*
    var _startZoom = this.slate.options.viewPort.zoom.w;
    var _targetZoom = this.slate.options.viewPort.originalWidth * (100 / parseInt(zoomPercent));
    var _zoomDif = Math.abs(_targetZoom - _startZoom);
    */ // UNTIL PAN AND ZOOM WORKS CORRECTLY, THIS WILL
        // ALWAYS BE A SIMPLE PROXY TO ZOOMING THE SLATE
        this.slate.canvas.zoom({
            dur: duration,
            zoomPercent,
            callbacks: {
                during (percentComplete, easing) {
                // additional calcs
                },
                after (zoomVal) {
                    cb && cb.apply(this, [
                        {
                            id: this.options.id,
                            operation: 'zoom',
                            zoomLevel: zoomVal
                        }, 
                    ]);
                }
            }
        });
    }
    position(location, cb, easing, dur) {
        const self = this;
        easing = easing || 'easeTo' // 'swingFromTo'
        ;
        dur = dur || 500;
        const _vpt = self.vect.getBBox();
        const zr = self.slate.options.viewPort.zoom.r;
        const d = _utilsDefault.default.getDimensions(self.slate.options.container);
        const cw = d.width;
        const ch = d.height;
        const nw = self.options.width * zr;
        const nh = self.options.height * zr;
        const pad = 10;
        // get upper left coords
        let _x = _vpt.x * zr;
        let _y = _vpt.y * zr;
        switch(location){
            case 'lowerright':
                _x = _x - (cw - nw) - pad;
                _y = _y - (ch - nh) - pad;
                break;
            case 'lowerleft':
                _x -= pad;
                _y = _y - (ch - nh) - pad;
                break;
            case 'upperright':
                _x = _x - (cw - nw) - pad;
                _y -= pad;
                break;
            case 'upperleft':
                _x -= pad;
                _y -= pad;
                break;
            default:
                // center
                _x -= cw / 2 - nw / 2;
                _y -= ch / 2 - nh / 2;
                break;
        }
        if (_x === self.slate.options.viewPort.left && _y === self.slate.options.viewPort.top) cb.apply();
        else self.slate.canvas.move({
            x: _x,
            y: _y,
            dur,
            callbacks: {
                after () {
                    cb?.apply(self, [
                        {
                            id: self.options.id,
                            operation: 'position',
                            location,
                            easing
                        }, 
                    ]);
                }
            },
            isAbsolute: true,
            easing
        });
    }
    toggleImage(opts) {
        if (this.options.vectorPath && this.options.remoteImage) {
            if (opts.active) {
                const _svgAsImage = this.options.remoteImage;
                this.hidden = {
                    vectorPath: this.options.vectorPath
                };
                this.shapes.set({
                    shape: 'rect',
                    keepResizerOpen: opts.keepResizerOpen
                });
                this.images.set(_svgAsImage, this.options.width, this.options.height, opts.keepResizerOpen);
                this.text && this.text.hide();
            } else if (this.hidden) {
                this.images.set('', this.options.width, this.options.height);
                this.customShapes.set(this.hidden.vectorPath);
                if (opts.width && opts.height) this.resize.set(opts.width, opts.height);
                this.text && this.text.show();
                this.relationships.showOwn();
                setTimeout(()=>{
                    this.menu.show();
                }, 100);
                delete this.hidden;
            }
        }
    }
    disable() {
        this.options.allowMenu = false;
        this.options.allowDrag = false;
        this.hideOwnMenus();
        if (this.slate.options.showLocks && this.options.isLocked) this.showLock();
    // this.relationships.unwireHoverEvents();
    }
    enable() {
        this.options.allowMenu = true // _prevAllowMenu || true;
        ;
        this.options.allowDrag = true // _prevAllowDrag || true;
        ;
        this.hideLock();
    // this.relationships.wireHoverEvents();
    }
    showLock() {
        const self = this;
        const _vpt = self.vect.getBBox();
        const r = self.slate.paper;
        if (!self._lock && self.slate.options.showLocks) {
            self._lock = r.lockClosed().transform([
                't',
                _vpt.x2 - 10,
                ',',
                _vpt.y2 - 10,
                's',
                0.9,
                0.9
            ].join()).attr({
                fill: '#fff',
                stroke: '#000'
            });
            self._lock.mouseover((e)=>{
                self.hideLock();
            });
        }
        return self._lock;
    }
    hideLock() {
        this.hideOpenLock();
        this._lock && this._lock.remove();
        this._lock = null;
        this.slate.unglow();
    }
    showOpenLock() {
        const self = this;
        const _vpt = this.vect.getBBox();
        const r = this.slate.paper;
        self._openLock = r.lockOpen().transform([
            't',
            _vpt.x2 - 10,
            ',',
            _vpt.y2 - 10,
            's',
            0.9,
            0.9
        ].join()).attr({
            fill: '#fff',
            stroke: '#000'
        });
        self._openLock.mouseover((e)=>{
            self._openLock.attr({
                'stroke-width': '2px',
                'stroke-color': '#000'
            });
            self._openLock.style.cursor = 'pointer';
        });
        self._openLock.mouseout(()=>{
            self.hideOpenLock();
            self.showLock();
        });
        self._openLock.mousedown(()=>{
            self.enable();
            self.options.isLocked = false;
            const pkg = {
                type: 'onNodeUnlocked',
                data: {
                    id: self.options.id
                }
            };
            self.context.broadcast(pkg);
        });
        return self._openLock;
    }
    hideOpenLock() {
        this._openLock && this._openLock.remove();
        this._openLock = null;
    }
    initLock() {
        if (this.vect && this.options.isLocked) this.showLock();
    }
    offset() {
        let _x = this.options.xPos - this.slate.options.viewPort.left;
        let _y = this.options.yPos - this.slate.options.viewPort.top;
        if (this.options.vectorPath === 'ellipse') {
            _x -= this.options.width / 2;
            _y -= this.options.height / 2;
        }
        return {
            x: _x,
            y: _y
        };
    }
    textCoords(opts = {
    }) {
        const _useX = opts.x || this.vect.ox || 0;
        const _useY = opts.y || this.vect.oy || 0;
        // these are the center defaults
        // start
        let _offsetX = this.options?.textOffset?.x || 0;
        // middle
        let _offsetY = this.options?.textOffset?.y || 0;
        const bbox = this.vect.getBBox();
        const _scale = 1;
        switch(this.options.textXAlign){
            case 'end':
                _offsetX = _offsetX * _scale + this.options.textOffset.width;
                break;
            case 'middle':
                _offsetX = _offsetX * _scale + this.options.textOffset.width / 2;
                break;
            default:
                break;
        }
        switch(this.options.textYAlign){
            case 'hanging':
                _offsetY = _offsetY * _scale - bbox.height / 2;
                break;
            case 'baseline':
                _offsetY = _offsetY * _scale + bbox.height / 2;
                break;
            default:
                break;
        }
        const tx = _useX + _offsetX;
        const ty = _useY + _offsetY;
        const _tc = {
            x: tx,
            y: ty
        };
        return _tc;
    }
    linkCoords() {
        let x = this.options.xPos - 20;
        let y = this.options.yPos + this.options.height / 2 - 22;
        if (this.vect.type !== 'rect') {
            y = this.options.yPos + this.options.height / 2 - 22;
            x = this.options.xPos - 20;
        }
        return {
            x,
            y
        };
    }
    _rotate(_opts) {
        const opts = {
            angle: 0,
            cb: null,
            dur: 0
        };
        Object.assign(opts, _opts);
        const ta = [
            'r',
            opts.angle
        ].join('');
        if (opts.dur === 0) {
            this.vect.transform(ta);
            this.text.transform(ta);
            if (this.options.link.show) this.link.transform(ta);
            opts.cb && opts.cb();
        } else {
            const lm = this.slate.paper.set();
            lm.push(this.vect);
            lm.push(this.text);
            if (this.options.link.show) lm.push(this.link);
            lm.animate({
                transform: ta
            }, opts.dur, '>', ()=>{
                opts.cb && opts.cb();
            });
        }
    }
}
exports.default = node;

},{"./base":"cmkOb","../helpers/getTransformedPath":"6wubb","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmkOb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable new-cap */ const availablePlugins = {
};
class base {
    constructor(initPayload){
        // register any plugins
        if (this.constructor.name !== 'plugin') this.registerPlugins(initPayload);
    }
    registerPlugins(initPayload) {
        const root = this.constructor.name;
        // console.log("registering plugins ", root, base.plugins, base.plugins[root]);
        if (availablePlugins[root]) availablePlugins[root].forEach((p)=>{
            const { name , plugin  } = p;
            if (!this.plugins) this.plugins = {
            };
            this.plugins[name] = new plugin(initPayload);
        });
    }
    static registerPlugin(details) {
        if (!details.name || !details.plugin) throw new Error('Plugins must provide a name and a plugin (class definition)');
        const root = Object.getPrototypeOf(details.plugin).name;
        // console.log("creating plugin root ", root);
        if (!availablePlugins[root]) availablePlugins[root] = [];
        availablePlugins[root] = [
            ...availablePlugins[root],
            details
        ];
    }
}
exports.default = base;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6wl7A":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable new-cap */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _getDepCoords = require("../helpers/getDepCoords");
var _getDepCoordsDefault = parcelHelpers.interopDefault(_getDepCoords);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _editor = require("../node/editor");
var _editorDefault = parcelHelpers.interopDefault(_editor);
var _relationships = require("../node/relationships");
var _relationshipsDefault = parcelHelpers.interopDefault(_relationships);
var _rotate = require("../node/rotate");
var _rotateDefault = parcelHelpers.interopDefault(_rotate);
var _menu = require("../node/menu");
var _menuDefault = parcelHelpers.interopDefault(_menu);
var _connectors = require("../node/connectors");
var _connectorsDefault = parcelHelpers.interopDefault(_connectors);
var _resize = require("../node/resize");
var _resizeDefault = parcelHelpers.interopDefault(_resize);
var _images = require("../node/images");
var _imagesDefault = parcelHelpers.interopDefault(_images);
var _shapes = require("../node/shapes");
var _shapesDefault = parcelHelpers.interopDefault(_shapes);
var _customShapes = require("../node/customShapes");
var _customShapesDefault = parcelHelpers.interopDefault(_customShapes);
var _colorPicker = require("../node/colorPicker");
var _colorPickerDefault = parcelHelpers.interopDefault(_colorPicker);
var _context = require("../node/context");
var _contextDefault = parcelHelpers.interopDefault(_context);
var _lineOptions = require("../node/lineOptions");
var _lineOptionsDefault = parcelHelpers.interopDefault(_lineOptions);
var _gridLines = require("../node/gridLines");
var _gridLinesDefault = parcelHelpers.interopDefault(_gridLines);
var _links = require("../node/links");
var _linksDefault = parcelHelpers.interopDefault(_links);
class nodeController {
    constructor(slate){
        this.slate = slate;
        this.ensureBe = null;
        this.allNodes = [];
    }
    _refreshBe() {
        const self = this;
        window.clearTimeout(self.ensureBe);
        self.ensureBe = window.setTimeout(()=>{
            self.slate.birdsEye?.refresh(false);
        }, 10);
    }
    _getParentChild(obj) {
        let _parent;
        let _child;
        this.allNodes.forEach((node)=>{
            if (node.options.id === obj.parent) _parent = node;
            else if (node.options.id === obj.child) _child = node;
        });
        return {
            p: _parent,
            c: _child
        };
    }
    static remove(a, obj) {
        return a.filter((ax)=>ax.options.id !== obj.options.id
        );
    }
    copyNodePositions(source, useMainCanvas = false) {
        const self = this;
        source.forEach((src)=>{
            // if (src.options.id !== self.tempNodeId) {
            let cn = self.allNodes.find((n)=>n.options.id === src.options.id
            );
            if (!cn) {
                self.add(src);
                cn = self.allNodes.find((n)=>n.options.id === src.options.id
                );
            }
            cn.setPosition({
                x: src.options.xPos,
                y: src.options.yPos
            });
            const opts = {
            };
            if (useMainCanvas) {
                const tempPath = self.slate.paper.path(cn.vect.attr('path')) // Meteor.currentSlate.paper
                ;
                opts.boundingClientRect = tempPath[0].getBoundingClientRect();
                tempPath.remove();
            }
            cn.rotate.applyImageRotation(opts);
        // }
        });
        _lodashInvokeDefault.default(self.allNodes.map((n)=>n.relationships
        ), 'refresh');
    }
    addRange(_nodes) {
        const self = this;
        _nodes.forEach((node)=>{
            self.add(node);
        });
        return self;
    }
    removeRange(_nodes) {
        const self = this;
        _nodes.forEach((node)=>{
            self.allNodes = nodeController.remove(self.allNodes, node);
        });
        return self;
    }
    add(_node, useMainCanvas) {
        _node.slate = this.slate // parent
        ;
        this.allNodes.push(_node);
        this.addToCanvas(_node, useMainCanvas);
    }
    remove(_node) {
        this.allNodes = nodeController.remove(this.allNodes, _node);
        _node.slate = null;
        this.removeFromCanvas(_node);
    }
    nodeMovePackage(opts = {
    }) {
        // if exporting a move package with moves applied (e.g., you're
        // planning on manipulating the slate programmatically and this is
        // not an export bound for collaboration (at first)) -- then we need
        // to apply the final results to a copy of the slate because they are need
        // for the calculations below, and those calcs are mutable, so they
        // cannot be applied to the current slate.
        let _use = this.slate;
        let _divCopy = null;
        if (opts && opts.moves) {
            _divCopy = document.createElement('div');
            const _did = `copy_${_utilsDefault.default.guid()}`;
            _divCopy.setAttribute('id', _did);
            _divCopy.setAttribute('style', `width:1px;height:1px;display:none;`);
            document.body.appendChild(_divCopy);
            _use = this.slate.copy({
                container: _did,
                moves: opts.moves
            });
        }
        const nds = opts?.nodes || _use.nodes.allNodes;
        const _ret = {
            dur: opts ? opts.dur : 300,
            easing: opts ? opts.easing : '>',
            textPositions: (()=>nds.map((node)=>({
                        id: node.options.id,
                        textPosition: {
                            x: node.text.attrs.x,
                            y: node.text.attrs.y,
                            transform: node.getTransformString()
                        }
                    })
                )
            )(),
            nodeOptions: nds.map((node)=>node.options
            ),
            associations: (()=>{
                const assoc = [];
                if (opts.relationships && opts.nodes) opts.relationships.forEach((a)=>{
                    assoc.push({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr('path').toString(),
                        id: a.line.id
                    });
                });
                else _use.nodes.allNodes.forEach((node)=>{
                    node.relationships.associations.forEach((a)=>{
                        assoc.push({
                            parentId: a.parent.options.id,
                            childId: a.child.options.id,
                            linePath: a.line.attr('path').toString(),
                            id: a.line.id
                        });
                    });
                });
                return _lodashUniqDefault.default(assoc, (a)=>a.id
                );
            })()
        };
        if (_divCopy) document.removeChild(_divCopy);
        return _ret;
    }
    moveNodes(pkg, options = {
    }) {
        this.closeAllLineOptions();
        this.closeAllMenus();
        // _node.hideOwnMenus();
        const allAssoc = [];
        this.allNodes.forEach((node)=>{
            node.relationships.associations.forEach((a)=>{
                allAssoc.push(a);
            });
        });
        const uniqAssoc = _lodashUniqDefault.default(allAssoc, (a)=>a.id
        );
        const p = pkg.data || pkg;
        const d = p.dur || 300 // Meteor.collabAnimationDuration ||
        ;
        const e = p.easing || '>';
        const { associations , nodeOptions , textPositions  } = p;
        let cntr = 0;
        function _potentiallyFinalize() {
            cntr += 1;
            if (cntr === nodeOptions.length && options.cb) {
                options.cb();
                delete options.cb;
            }
        }
        nodeOptions.forEach((opts)=>{
            const nodeObject = this.allNodes.find((node)=>node.options.id === opts.id
            );
            if (nodeObject) {
                Object.assign(nodeObject.options, opts);
                const dps = _getDepCoordsDefault.default({
                    x: opts.xPos,
                    y: opts.yPos
                }, nodeObject.options);
                const { lx , ty  } = dps;
                const currentTextPosition = textPositions.find((tp)=>tp.id === opts.id
                );
                if (options.animate) {
                    nodeObject.text.animate(currentTextPosition.textPosition, d, e);
                    nodeObject.link.animate({
                        x: lx,
                        y: ty
                    }, d, e);
                } else {
                    nodeObject.text.attr(currentTextPosition.textPosition);
                    nodeObject.link.attr({
                        x: lx,
                        y: ty
                    });
                }
                if (options.animate) {
                    if (nodeObject) nodeObject.vect.animate({
                        path: opts.vectorPath,
                        transform: nodeObject.getTransformString()
                    }, d, e, ()=>{
                        nodeObject.vect.attr({
                            path: opts.vectorPath
                        });
                        nodeObject.images.imageSizeCorrection();
                        _potentiallyFinalize();
                    });
                } else {
                    if (nodeObject) nodeObject.vect.attr({
                        path: opts.vectorPath
                    });
                    let rotationOptions = {
                    };
                    if (options.useMainCanvas) {
                        const tempPath = this.slate.paper.path(nodeObject.vect.attr('path')) // Meteor.currentSlate.paper.
                        ;
                        rotationOptions = {
                            boundingClientRect: tempPath[0].getBoundingClientRect()
                        };
                        tempPath.remove();
                    }
                    nodeObject.rotate.applyImageRotation(rotationOptions);
                    nodeObject.images.imageSizeCorrection();
                    _potentiallyFinalize();
                }
            }
        });
        associations.forEach((assoc)=>{
            const a = uniqAssoc.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId
            );
            if (options.animate) {
                if (a) a.line.animate({
                    path: assoc.linePath
                }, d, e, ()=>{
                    a.line.attr({
                        path: assoc.linePath
                    });
                    _potentiallyFinalize();
                });
            } else {
                if (a) a.line.attr({
                    path: assoc.linePath
                });
                _potentiallyFinalize();
            }
        });
        this.slate.birdsEye?.refresh(true);
    }
    getRelevantAssociationsWith(nodes) {
        const _relationshipsToTranslate = [];
        const _relationshipsToRefresh = [];
        nodes.forEach((node)=>{
            const otherSelectedNodes = nodes.filter((n)=>n.options.id !== node.options.id
            );
            node.relationships.associations.forEach((assoc)=>{
                if (otherSelectedNodes.map((n)=>n.relationships.associations
                ).some((associations)=>associations.find((a)=>a.id === assoc.id
                    )
                )) {
                    if (!_relationshipsToTranslate.some((r)=>r.id === assoc.id
                    )) _relationshipsToTranslate.push(assoc) // connections which move with both nodes
                    ;
                } else if (!_relationshipsToRefresh.some((r)=>r.id === assoc.id
                )) _relationshipsToRefresh.push(assoc) // connections which move on one end only
                ;
            });
        });
        return {
            relationshipsToRefresh: _relationshipsToRefresh,
            relationshipsToTranslate: _relationshipsToTranslate
        };
    }
    translateRelationships(relationships, { dx , dy  }) {
        relationships.forEach((r)=>{
            r.line.transform(`T${dx}, ${dy}`);
        });
    }
    saveRelationships(relationships, { dx , dy  }) {
        relationships.forEach((r)=>{
            const newLinePath = _utilsDefault.default._transformPath(r.line.attr('path').toString(), `T${dx},${dy}`).toString();
            r.line.attr({
                path: newLinePath
            });
            r.line.transform('');
        });
    }
    removeRelationship(rm) {
        const pc = this._getParentChild(rm);
        const _parent = pc.p;
        const _child = pc.c;
        if (_parent && _child) {
            // _parent.relationships.removeChild(_child);
            // _child.relationships.removeParent(_parent);
            _parent.relationships.removeAssociation(_child);
            _child.relationships.removeAssociation(_parent);
        }
    }
    refreshAllRelationships() {
        this.allNodes.forEach((node)=>{
            node.relationships.refreshOwnRelationships();
        });
    }
    addRelationship(add) {
        const pc = this._getParentChild(add);
        const _parent = pc.p;
        const _child = pc.c;
        if (_parent && _child) switch(add.type){
            case 'association':
                _parent.relationships.addAssociation(_child, add.options);
                break;
            default:
                break;
        }
    }
    closeAllLineOptions(exception) {
        this.allNodes.forEach((node)=>{
            node.relationships.associations.forEach((association)=>{
                if (association.id !== exception) node.lineOptions?.hide(association.id);
            });
        });
    }
    closeAllMenus({ exception , nodes  } = {
    }) {
        (nodes || this.allNodes).forEach((node)=>{
            if (node.options.id !== exception) {
                node.menu.hide();
                node.lineOptions?.hideAll();
                node.resize?.hide();
                node.rotate?.hide();
            }
        });
    }
    closeAllConnectors() {
        this.allNodes.forEach((node)=>{
            node.connectors?.remove();
            node.resize?.hide();
            node.rotate?.hide();
        });
    }
    one(id) {
        let cn = null;
        this.allNodes.forEach((node)=>{
            if (node.options.id === id) cn = node;
        });
        return cn;
    }
    removeFromCanvas(_node) {
        [
            'vect',
            'text',
            'link'
        ].forEach((tt)=>{
            _node[tt].remove();
        });
        this._refreshBe();
    }
    addToCanvas(_node, useMainCanvas) {
        _node.slate = this.slate;
        let vect = null;
        let link = null;
        const vectOpt = {
            fill: _node.options.backgroundColor || '#fff',
            'fill-opacity': _node.options.opacity != null ? _node.options.opacity : 1
        };
        Object.assign(vectOpt, _node.applyBorder());
        const _x = _node.options.xPos;
        const _y = _node.options.yPos;
        const paperToUse = this.slate.paper;
        const percent = 1;
        const _width = _node.options.width;
        const _height = _node.options.height;
        const _transforms = [
            `T${_x * percent}, ${_y * percent}`,
            `s${_width / 150 * percent}, ${_height / 100 * percent}, ${_x}, ${_y}`, 
        ];
        _node.options.isEllipse = _node.options.isEllipse || _node.options.vectorPath === 'ellipse';
        switch(_node.options.vectorPath){
            case 'ellipse':
                _node.options.vectorPath = _getTransformedPathDefault.default('M150,50 a75,50 0 1,1 0,-1 z', _transforms);
                break;
            case 'rectangle':
                _node.options.vectorPath = _getTransformedPathDefault.default('M1,1 h150 v100 h-150 v-100 z', _transforms);
                break;
            case 'roundedrectangle':
                _node.options.vectorPath = _getTransformedPathDefault.default('M1,1 h130 a10,10 0 0 1 10,10 v80 a10,10 0 0 1 -10,10 h-130 a10,10 0 0 1 -10,-10 v-80 a10,10 0 0 1 10,-10 z', _transforms);
                break;
            default:
                break;
        }
        if (_node.options.vectorPath === 'M2,12 L22,12') vectOpt['stroke-dasharray'] = '2px';
        vect = paperToUse.path(_node.options.vectorPath).attr(vectOpt);
        vect.node.style.cursor = 'pointer';
        // need to set in case toback or tofront is called and the load order changes in the context plugin
        vect.node.setAttribute('rel', _node.options.id);
        vect.data({
            id: _node.options.id
        });
        _node.vect = vect;
        // _node.vect.ox = _x;
        // _node.vect.oy = _y;
        // get the text coords before the transform is applied
        // var tc = _node.textCoords();
        _node.vect.transform(_node.getTransformString());
        // update xPos, yPos in case it is different than actual
        const bbox = vect.getBBox();
        _node.options.xPos = bbox.x;
        _node.options.yPos = bbox.y;
        const lc = _node.linkCoords();
        // apply the text coords prior to transform
        // text = paperToUse.text(tc.x, tc.y, (_node.options.text || '')).attr({ "font-size": _node.options.fontSize + "pt", fill: _node.options.foregroundColor || "#000" });
        link = paperToUse.linkArrow().transform([
            't',
            lc.x,
            ',',
            lc.y,
            's',
            '.8',
            ',',
            '.8',
            'r',
            '180'
        ].join()).attr({
            cursor: 'pointer'
        });
        // create and set editor
        _node.editor = new _editorDefault.default(this.slate, _node);
        _node.editor.set() // creates and sets the text
        ;
        _node.text.transform(_node.getTransformString());
        // set link
        _node.link = link;
        _node.both = new _node.slate.paper.set();
        _node.both.push(_node.vect);
        _node.both.push(_node.text);
        // relationships
        _node.relationships = new _relationshipsDefault.default(this.slate, _node);
        _node.relationships.wireDragEvents();
        // rotate
        _node.rotate = new _rotateDefault.default(this.slate, _node);
        // connectors
        _node.connectors = new _connectorsDefault.default(this.slate, _node);
        // menu
        _node.menu = new _menuDefault.default(this.slate, _node);
        // resizer
        _node.resize = new _resizeDefault.default(this.slate, _node);
        // images
        _node.images = new _imagesDefault.default(this.slate, _node);
        // context
        _node.context = new _contextDefault.default(this.slate, _node);
        // lineOptions
        _node.lineOptions = new _lineOptionsDefault.default(this.slate, _node);
        // shapes
        _node.shapes = new _shapesDefault.default(this.slate, _node);
        // customShapes
        _node.customShapes = new _customShapesDefault.default(this.slate, _node);
        // colorPicker
        _node.colorPicker = new _colorPickerDefault.default(this.slate, _node);
        // gridLines
        _node.gridLines = new _gridLinesDefault.default(this.slate, _node);
        //links
        _node.links = new _linksDefault.default(this.slate, _node);
        if (_node.options.image && !_node.options.imageOrigHeight) _node.options.imageOrigHeight = _node.options.height;
        if (_node.options.image && !_node.options.imageOrigWidth) _node.options.imageOrigWidth = _node.options.width;
        if (_node.options.image && _node.options.image !== '') _node.images.set(_node.options.image, _node.options.imageOrigWidth, _node.options.imageOrigHeight, useMainCanvas);
        if (!_node.options.link || !_node.options.link.show) _node.link.hide();
        // apply any node filters to vect and/or text
        _node.applyFilters();
        this._refreshBe();
        return vect;
    }
}
exports.default = nodeController;

},{"lodash.uniq":"iDalh","lodash.invoke":"6VYuy","../helpers/getTransformedPath":"6wubb","../helpers/getDepCoords":"hVTn1","../helpers/utils":"8QI6M","../node/editor":"klp05","../node/relationships":"8zQA0","../node/rotate":"6en3b","../node/menu":"91LgF","../node/connectors":"h710n","../node/resize":"4vYbQ","../node/images":"jLcMC","../node/shapes":"kA5hP","../node/customShapes":"edbtN","../node/colorPicker":"jJAST","../node/context":"185nI","../node/lineOptions":"c3gfk","../node/gridLines":"6cFRW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../node/links":"4BxQS"}],"6VYuy":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var FUNC_ERROR_TEXT = 'Expected a function';
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {
    }
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Symbol = root.Symbol, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, 'Map'), nativeCreate = getNative(Object, 'create');
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {
    };
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = isKey(path, object) ? [
        path
    ] : castPath(path);
    var index = 0, length = path.length;
    while(object != null && index < length)object = object[toKey(path[index++])];
    return index && index == length ? object : undefined;
}
/**
 * The base implementation of `_.invoke` without support for individual
 * method arguments.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} args The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 */ function baseInvoke(object, path, args) {
    if (!isKey(path, object)) {
        path = castPath(path);
        object = parent(object, path);
        path = last(path);
    }
    var func = object == null ? object : object[toKey(path)];
    return func == null ? undefined : apply(func, object, args);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */ function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) start = -start > length ? 0 : length + start;
    end = end > length ? length : end;
    if (end < 0) end += length;
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while(++index < length)result[index] = array[index + start];
    return result;
}
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') return value;
    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : '';
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (isArray(value)) return false;
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */ function parent(object, path) {
    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = memoize(function(string1) {
    string1 = toString(string1);
    var result = [];
    if (reLeadingDot.test(string1)) result.push('');
    string1.replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) return value;
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e1) {
        }
    }
    return '';
}
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */ function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : undefined;
}
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
}
// Assign cache to `_.memoize`.
memoize.Cache = MapCache;
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? '' : baseToString(value);
}
/**
 * Invokes the method at `path` of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
 *
 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
 * // => [2, 3]
 */ var invoke = baseRest(baseInvoke);
module.exports = invoke;

},{}],"hVTn1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getDepCoords(p, options) {
    let lx = p.x - 5;
    let tx = p.x + options.width / 2;
    let ty = p.y + options.height / 2;
    if (options.vectorPath === 'ellipse') {
        lx = p.cx - 5;
        tx = p.cx;
        ty = p.cy;
    }
    return {
        lx,
        tx,
        ty
    };
}
exports.default = getDepCoords;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klp05":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-param-reassign */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class editor {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    setTextOffset() {
        if (this.node.options.allowDrag) {
            this.node.options.textBounds = this.node.vect.getBBox();
            this.node.options.textOffset = {
                x: this.node.options.textBounds.cx - this.node.options.textBounds.width / 2 - this.node.options.xPos,
                y: this.node.options.textBounds.cy - this.node.options.yPos,
                width: this.node.options.textBounds.width,
                height: this.node.options.textBounds.height
            };
        }
    }
    set(t, s, f, c, opacity, ta, tb) {
        const tempShim = `§` // utils.guid().substring(3);
        ;
        if (!t && t !== '') t = this.node.options.text || tempShim;
        if (!s) s = this.node.options.fontSize || 12;
        if (opacity == null) opacity = this.node.options.textOpacity || 1;
        if (!f) f = this.node.options.fontFamily || 'Roboto';
        if (!c) c = this.node.options.foregroundColor || '#000';
        if (!ta) ta = this.node.options.textXAlign || 'middle';
        if (!tb) tb = this.node.options.textYAlign || 'middle';
        // ensure text is always legible if it is set to the same as background
        if (c === this.node.options.backgroundColor) c = _utilsDefault.default.whiteOrBlack(this.node.options.backgroundColor);
        this.node.options.text = t;
        this.node.options.fontSize = s;
        this.node.options.fontFamily = f;
        this.node.options.foregroundColor = c;
        this.node.options.textOpacity = opacity;
        this.node.options.textXAlign = ta;
        this.node.options.textYAlign = tb;
        let coords = null;
        this.setTextOffset();
        coords = this.node.textCoords();
        if (!this.node.text) this.node.text = this.slate.paper.text(this.node.options.xPos + coords.x, this.node.options.yPos + coords.y, t);
        coords = this.node.textCoords({
            x: this.node.options.xPos,
            y: this.node.options.yPos
        });
        this.node.text.attr(coords);
        this.node.text.attr({
            text: t
        });
        this.node.text.attr({
            'font-size': `${s}pt`
        });
        this.node.text.attr({
            'font-family': f
        });
        this.node.text.attr({
            fill: c
        });
        this.node.text.attr({
            'text-anchor': ta
        });
        this.node.text.attr({
            'text-baseline': tb
        });
        this.node.text.attr({
            'fill-opacity': opacity
        });
        this.node.text.attr({
            class: 'slatebox-text'
        });
        const noSelect = [
            '-webkit-user-select',
            '-moz-user-select',
            '-ms-user-select',
            'user-select', 
        ].map((sx)=>`${sx}: none;`
        ).join(' ');
        this.node.text.attr({
            style: noSelect
        });
        if (tempShim === t) {
            this.node.options.text = '';
            this.node.text.attr({
                text: ''
            });
        } else setTimeout(()=>{
            this.node.text.attr({
                text: t
            });
        }, 10);
    }
}
exports.default = editor;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8zQA0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _getHorizontalCurve = require("../helpers/getHorizontalCurve");
var _getHorizontalCurveDefault = parcelHelpers.interopDefault(_getHorizontalCurve);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class relationships {
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.PATH_COMPLEXITY_LIMIT = 100000;
        self.associations = [];
        self._isLastAlt = false;
        self._isLastShift = false;
        self.selectedNodes = [];
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self._dx = 0;
        self._dy = 0;
        self.collabSent = null;
        self.slate.draggingNode = false;
        self.ft = null;
        self.kdTree = null;
        self.gracefulClear = null;
        self.dragEvents = {
            move (dx, dy) {
                self.enactMove(dx, dy);
            },
            async up () {
                self.finishDrag(true);
            },
            dragger (x, y, e) {
                if (!self.slate.canvas.isDragging) {
                    self.node.toggleImage({
                        active: true
                    });
                    // self.slate.canvas._bg?.hide();
                    if (self.node.events?.onClick) self.node.events.onClick.apply(self, [
                        function() {
                            self._initDrag(self, e);
                        }, 
                    ]);
                    else self._initDrag(self, e);
                }
            }
        };
    }
    showMenu(e) {
        const self = this;
        self.slate.nodes.closeAllMenus({
            exception: self.node.options.id
        });
        self.slate.enable();
        if (self.node?.menu?.show && self.node.options.allowMenu && !self.node.menu.isOpen()) {
            if (self.node?.options.groupId) self.slate.multiSelection.showGroup(self.node?.options.groupId);
            self.node.menu.show();
        }
        _utilsDefault.default.stopEvent(e);
    }
    finishDrag(blnBroadcast) {
        const self = this;
        console.log('done dragging node', self.draggingNode);
        self.slate.draggingNode = false;
        self.selectedNodes.forEach((nd)=>{
            // the transformPath here converts the transient transforms that happened during the movement
            // to become permanent on the "attr" properties.
            _utilsDefault.default.transformPath(nd, `T${self._dx},${self._dy}`);
            nd.vect.currentDx = 0;
            nd.vect.currentDy = 0;
            nd.editor.setTextOffset();
        });
        _refreshRelationshipsDefault.default({
            relationships: self.relationshipsToRefresh,
            nodes: self.selectedNodes,
            dx: 0,
            dy: 0
        });
        self.slate.nodes.saveRelationships(self.relationshipsToTranslate, {
            dx: self._dx,
            dy: self._dy
        });
        if (blnBroadcast) {
            self.send({
                nodes: self.selectedNodes,
                relationships: self.relationshipsToRefresh.concat(self.relationshipsToTranslate)
            });
            self.selectedNodes.forEach((n)=>{
                n.relationships.showAll(true);
            });
            if (self.foreignPoints?.length > 0) {
                self.kdTree.dispose();
                delete self.foreignPoints;
                clearTimeout(self.gracefulClear);
                self.gracefulClear = setTimeout(()=>{
                    self.node.gridLines.clear();
                }, 200);
            }
        }
        // console.log("here we go", self.selectedNodes);
        // self.slate.canvas._bg?.show();
        self.slate.toggleFilters(false);
        self.showMenu();
    }
    enactMove(dx, dy, blnFinish) {
        const self = this;
        dx = Math.ceil(dx);
        dy = Math.ceil(dy);
        // adjust the dx and dy if snapping to grid
        // if (slate.options.viewPort.showGrid && slate.options.viewPort.snapToGrid) {
        //   let gridSize = slate.options.viewPort.gridSize || 10;
        //   dx = Math.round(dx / gridSize) * gridSize;
        //   dy = Math.round(dy / gridSize) * gridSize;
        // }
        const z = self.slate.options.viewPort.zoom.r;
        dx += dx / z - dx;
        dy += dy / z - dy;
        self.selectedNodes.forEach((nd, i)=>{
            nd.vect.currentDx = dx;
            nd.vect.currentDy = dy;
            nd.translateWith({
                dx,
                dy
            });
            // console.log("yPos ", i, node.options.yPos);
            // only snap and show guidelines for primary moving node, none of its children
            if (i === 0 && nd.options.id !== self.slate.tempNodeId) {
                // const nbb = node.vect.getBBox();
                const nearest = self.kdTree.knn([
                    nd.options.xPos,
                    nd.options.yPos
                ], 2) // , 1);
                ;
                nearest.forEach((n)=>{
                    ({ dx , dy  } = self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox));
                });
            }
        });
        self.slate.nodes.translateRelationships(self.relationshipsToTranslate, {
            dx,
            dy
        });
        _refreshRelationshipsDefault.default({
            relationships: self.relationshipsToRefresh,
            nodes: self.selectedNodes,
            dx,
            dy
        });
        self._dx = dx;
        self._dy = dy;
        if (blnFinish) self.finishDrag(false);
    }
    _broadcast(pkg) {
        this.slate.collab?.send(pkg);
    }
    _hitTest(mp) {
        const self = this;
        let overNode = null;
        const off = _utilsDefault.default.positionedOffset(self.slate.options.container);
        self.slate.nodes.allNodes.forEach((nd)=>{
            if (nd.options.id !== self.slate.tempNodeId && nd.options.id !== self.node.options.id && nd.options.allowContext && nd.options.allowResize) {
                const _bb = nd.vect.getBBox();
                const _zr = self.slate.options.viewPort.zoom.r;
                const xp = self.slate.options.viewPort.left + mp.x - off.left;
                const yp = self.slate.options.viewPort.top + mp.y - off.top;
                const c = {
                    x: xp + (xp / _zr - xp),
                    y: yp + (yp / _zr - yp)
                };
                if (c.x > _bb.x && c.x < _bb.x + _bb.width && c.y > _bb.y && c.y < _bb.y + _bb.height) overNode = nd;
            }
        });
        return overNode;
    }
    _remove(associations, type, obj) {
        const _na = [];
        const self = this;
        associations.forEach((association)=>{
            if (association[type].options.id === obj.options.id) self.removeRelationship(association);
            else _na.push(association);
        });
        return _na;
    }
    _initDrag(vect, e) {
        const self = this;
        self.selectedNodes = [];
        self.relationshipsToRefresh = [];
        self.relationshipsToTranslate = [];
        self.collabSent = false;
        self.slate.draggingNode = true;
        console.log('set dragging node', self.slate.draggingNode);
        self._dx = 0;
        self._dy = 0;
        self.slate.multiSelection?.end();
        if (self.slate.options.linking) self.slate.options.linking.onNode.apply(vect, [
            self
        ]);
        else if (self.node.options.allowDrag && !self.node.options.disableDrag) {
            self.selectedNodes = self.getSelectedNodes();
            const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
            self.relationshipsToTranslate = _associations.relationshipsToTranslate;
            self.relationshipsToRefresh = _associations.relationshipsToRefresh;
            self.selectedNodes.forEach((n)=>{
                n.setStartDrag();
                n.vect.ox = n.options.xPos;
                n.vect.oy = n.options.yPos;
            });
            const selectedIds = self.selectedNodes.map((n)=>n.options.id
            );
            self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>selectedIds.indexOf(n.options.id) === -1
            ).map((n)=>({
                    id: n.options.id,
                    bbox: n.vect.getBBox(),
                    point: [
                        n.options.xPos,
                        n.options.yPos
                    ]
                })
            );
            self.kdTree = _staticKdtreeDefault.default(self.foreignPoints.map((fp)=>fp.point
            ));
            self.conditionallyHideAll();
        } else _utilsDefault.default.stopEvent(e);
    }
    async initiateTempNode(e, _parent, _assocPkg) {
        const self = this;
        const mp = _utilsDefault.default.mousePos(e);
        const _slate = _parent.slate;
        const off = _utilsDefault.default.positionedOffset(_slate.options.container);
        const _zr = self.slate.options.viewPort.zoom.r;
        const xp = _slate.options.viewPort.left + mp.x - off.left;
        const yp = _slate.options.viewPort.top + mp.y - off.top;
        const _xPos = xp + (xp / _zr - xp);
        const _yPos = yp + (yp / _zr - yp);
        const _path = _utilsDefault.default._transformPath(_sbIconsDefault.default.icons.handle, `T${_xPos - 15}, ${_yPos - 15}`);
        const _tempNode = new _nodeDefault.default({
            id: self.slate.tempNodeId,
            xPos: _xPos,
            yPos: _yPos,
            lineColor: '#990000',
            backgroundColor: '#ffffff',
            vectorPath: _path,
            width: 30,
            height: 30
        });
        _slate.nodes.add(_tempNode, true);
        const _tempRelationship = _parent.relationships.addAssociation(_tempNode, _assocPkg, true);
        _tempRelationship.hoveredOver = null;
        _tempRelationship.lastHoveredOver = null;
        // initiates the drag
        _tempNode.vect.start(e) // , off.x, off.y);
        ;
        _slate.options.allowDrag = false;
        _tempNode.vect.mousemove((ex)=>{
            // is there a current hit?
            if (_tempRelationship.hoveredOver === null) {
                _tempRelationship.hoveredOver = self._hitTest(_utilsDefault.default.mousePos(ex));
                if (_tempRelationship.hoveredOver !== null) // yes, currently over a node -- scale it
                _tempRelationship.hoveredOver.vect.animate({
                    'stroke-width': 5
                }, 500, ()=>{
                    _tempRelationship.hoveredOver.vect.animate({
                        'stroke-width': self.node.options.borderWidth
                    }, 500, ()=>{
                        _tempRelationship.hoveredOver = null;
                    });
                });
            }
        });
        _tempNode.vect.mouseup((ex)=>{
            _parent.relationships.removeAssociation(_tempNode);
            _tempNode.slate.nodes.remove(_tempNode);
            const overNode = self._hitTest(_utilsDefault.default.mousePos(ex));
            if (overNode !== null) {
                // overNode.vect.transform("s1,1,");
                // check if overNode has any parents
                const _relevantAssociations = overNode.relationships.associations.filter((association)=>overNode.options.id === association.child.options.id
                );
                overNode.options.parents = _relevantAssociations.map((a)=>a.parent.options.id
                );
                // check if the two nodes are already associated -- multiple associations between two nodes are currently not supported
                const relevantAssociation = _parent.relationships.associations.find((association)=>association.child.options.id === overNode.options.id && association.parent.options.id === _parent.options.id || association.parent.options.id === overNode.options.id && association.child.options.id === _parent.options.id
                );
                if (!relevantAssociation) {
                    _parent.relationships.addAssociation(overNode, _assocPkg);
                    const _pkgx = {
                        type: 'addRelationship',
                        data: {
                            type: 'association',
                            parent: _parent.options.id,
                            child: overNode.options.id
                        }
                    };
                    self.slate.birdsEye?.relationshipsChanged(_pkgx);
                    self._broadcast(_pkgx);
                }
            }
            if (self.slate.options.enabled) _parent.slate.options.allowDrag = true;
        });
    }
    _visibility(action) {
        if (this.node.options.id !== this.slate.tempNodeId) for(let i = this.associations.length; i < this.associations.length; i += 1)this.associations[i].line[action]();
    }
    removeAll() {
        const self = this;
        self.associations.forEach((association)=>{
            association.child.relationships.removeAssociation(self.node) // .parent);
            ;
            association.parent.relationships.removeAssociation(self.node);
            self.removeRelationship(association);
        });
        self.associations = [];
    }
    removeAssociation(_node1) {
        this.associations = this._remove(this.associations, 'child', _node1);
        this.associations = this._remove(this.associations, 'parent', _node1);
        return this;
    }
    setKeys({ isShift , isAlt  }) {
        this._isLastShift = isShift;
        this._isLastAlt = isAlt;
    }
    addAssociation(_node2, assocPkg) {
        assocPkg = assocPkg || {
        };
        // make sure this doesn't already exist
        let _connection = this.associations.find((a)=>a.child.options.id === _node2.options.id
        );
        if (!_connection) {
            const _copts = {
                id: _utilsDefault.default.guid(),
                parent: this.node,
                child: _node2,
                lineColor: assocPkg.lineColor || this.node.options.lineColor,
                lineWidth: assocPkg.lineWidth || this.node.options.lineWidth,
                lineOpacity: assocPkg.lineOpacity || this.node.options.lineOpacity,
                lineEffect: assocPkg.lineEffect || this.node.options.lineEffect,
                blnStraight: assocPkg.isStraightLine || false,
                showParentArrow: assocPkg.showParentArrow,
                showChildArrow: assocPkg.showChildArrow
            };
            _connection = this.createNewRelationship(_copts);
            _connection.line.toBack();
            this.associations.push(_connection);
            _node2.relationships.associations.push(_connection);
            this.wireLineEvents(_connection);
        }
        _node2.slate.allLines.push(_connection) // helper for managing raw line attrs
        ;
        return _connection;
    }
    createNewRelationship(opts) {
        const { paper  } = this.slate;
        const association = {
            parent: null,
            child: null,
            lineColor: '#fff',
            lineOpacity: 1,
            lineEffect: '',
            lineWidth: 20,
            blnStraight: false,
            showParentArrow: false,
            showChildArrow: true
        };
        Object.assign(association, opts);
        const _attr = {
            stroke: association.lineColor,
            class: 'association',
            fill: 'none',
            'stroke-width': association.lineWidth,
            'fill-opacity': association.lineOpacity,
            filter: association.lineEffect ? `url(#${association.lineEffect})` : '',
            opacity: association.lineOpacity
        };
        // these two generic points will be adjusted after the line is created
        const origPoint = {
            x: 1,
            y: 1
        };
        const endPoint = {
            x: 200,
            y: 200
        };
        if (!association.line) Object.assign(association, {
            line: paper.path(_getHorizontalCurveDefault.default(origPoint, endPoint)).attr(_attr)
        });
        if (association.child && association.parent) _refreshRelationshipsDefault.default({
            relationships: [
                association
            ],
            nodes: [
                association.parent
            ]
        });
        return association;
    }
    removeRelationship(association) {
        const self = this;
        self.node.slate?.allLines.splice(self.slate?.allLines.findIndex((l)=>l.id === association.id
        ));
        association.line.remove();
    }
    wireLineEvents(c) {
        const self = this;
        if (self.node.options.allowMenu) {
            c.line.node.style.cursor = 'pointer';
            c.line.mousedown((e)=>{
                _utilsDefault.default.stopEvent(e);
                self.node.lineOptions.show(e, c);
            });
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
    }
    getSelectedNodes() {
        const self = this;
        self.selectedNodes = [];
        if (self.node.options.isLocked === false) {
            self.selectedNodes.push(self.node);
            this.syncAssociations(self.node, (c, a)=>{
                if (!self.selectedNodes.some((n)=>n.options.id === c.options.id
                ) && c.options.isLocked === false) self.selectedNodes.push(c);
            });
        }
        return self.selectedNodes;
    }
    syncAssociations(nd, cb) {
        const self = this;
        if (!self.slate.isCtrl || self.slate.isCtrl && self.slate.isShift) nd.relationships.associations.forEach((a)=>{
            if (a.child.options.id !== self.node.options.id && a.child.options.id !== nd.options.id) {
                if (cb) cb(a.child, a);
                if (self.slate.isCtrl && self.slate.isShift) self.syncAssociations(a.child, cb);
            }
        });
    }
    updateAssociationsWith(opts) {
        const conditionalSet = {
        };
        if (opts.conditional) {
            opts.conditional.forEach((setContext, i)=>{
                conditionalSet[i] = setContext;
            });
            delete opts.conditional;
        }
        this.associations.forEach((a)=>{
            Object.assign(a, opts);
            Object.keys(conditionalSet).forEach((sc)=>{
                const setContext = conditionalSet[sc];
                if (setContext.condition(a, setContext.data)) a[setContext.key] = setContext.getValue(a, setContext.data);
            });
        });
    }
    updateSingleAssociationWith(key, opts) {
        const association = this.associations.find(a, key);
        if (association) Object.assign(association, opts);
    }
    send(opts) {
        if (this.node.context && !this.node.context.isVisible() && this.node.options.allowDrag && !this.node.options.disableDrag) {
            const pkg = {
                type: 'onNodesMove'
            };
            if (opts.nodes && opts.relationships) pkg.data = this.slate.nodes.nodeMovePackage({
                nodes: opts.nodes,
                relationships: opts.relationships
            });
            else pkg.data = this.slate.nodes.nodeMovePackage();
            this.slate.collab?.send(pkg);
            this.slate.birdsEye?.nodeChanged(pkg);
            this.collabSent = true;
        }
    }
    conditionallyHideAll() {
        const self = this;
        if (self.node.options.id !== self.slate.tempNodeId) {
            const exceeds = self.node.options.vectorPath.length > self.PATH_COMPLEXITY_LIMIT;
            if (exceeds) self.hideAll(true);
            self.associations.forEach((a)=>{
                const cexceed = exceeds || a.child.options.vectorPath.length > self.PATH_COMPLEXITY_LIMIT;
                a.child.relationships.hideAll(cexceed);
            });
        }
    }
    hideAll(_blnOverride) {
        if (this.slate.isAlt && this.slate.isShift || _blnOverride) this._visibility('hide');
    }
    hideOwn() {
        this.associations.forEach((association)=>{
            association.line.hide();
        });
    }
    showOwn() {
        this.associations.forEach((association)=>{
            association.line.show();
        });
    }
    showAll(_blnOverride) {
        if (this._isLastAlt && this._isLastShift || _blnOverride) this._visibility('show');
    }
    refreshOwnRelationships() {
        _refreshRelationshipsDefault.default({
            relationships: this.associations,
            nodes: [
                this.node
            ]
        });
    }
    wireDragEvents() {
        const self = this;
        function showText() {
            self.slate.events?.onTextPaneRequested?.apply(this, [
                self.node,
                ()=>{
                }
            ]);
        }
        if (!self.slate.isReadOnly() && (!self.slate.isCommentOnly() || self.slate.isCommentOnly() && self.node.options.isComment)) {
            self.node.vect.drag(self.dragEvents.move, self.dragEvents.dragger, self.dragEvents.up);
            self.node.text.mousedown((e)=>{
                self.node.vect.start(e);
            });
            self.node.vect.dblclick(()=>{
                showText();
            });
            self.node.text.dblclick(()=>{
                showText();
            });
        }
    }
}
exports.default = relationships;

},{"static-kdtree":"i8GTt","../helpers/refreshRelationships":"1UeYf","../helpers/getHorizontalCurve":"dzUMr","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i8GTt":[function(require,module,exports) {
"use strict";
module.exports = createKDTree;
module.exports.deserialize = deserializeKDTree;
var ndarray = require("ndarray");
var ndselect = require("ndarray-select");
var pack = require("ndarray-pack");
var ops = require("ndarray-ops");
var ndscratch = require("ndarray-scratch");
var pool = require("typedarray-pool");
var inorderTree = require("inorder-tree-layout");
var bits = require("bit-twiddle");
var KDTHeap = require("./lib/heap.js");
function KDTree(points, ids, n, d) {
    this.points = points;
    this.ids = ids;
    this.dimension = d;
    this.length = n;
}
var proto = KDTree.prototype;
proto.serialize = function() {
    if (this.length > 0) return {
        p: Array.prototype.slice.call(this.points.data, 0, this.length * this.dimension),
        i: Array.prototype.slice.call(this.ids, 0, this.length)
    };
    else return {
        d: this.dimension
    };
};
//Range query
proto.range = function kdtRangeQuery(lo, hi, visit) {
    var n = this.length;
    if (n < 1) return;
    //Check degenerate case
    var d = this.dimension;
    for(var i = 0; i < d; ++i){
        if (hi[i] < lo[i]) return;
    }
    var points = this.points;
    var ids = this.ids;
    //Walk tree in level order, skipping subtrees which do not intersect range
    var visitRange = ndscratch.malloc([
        n,
        2,
        d
    ]);
    var visitIndex = pool.mallocInt32(n);
    var rangeData = visitRange.data;
    var pointData = points.data;
    var visitCount = 1;
    var visitTop = 0;
    var retval;
    visitIndex[0] = 0;
    pack(lo, visitRange.pick(0, 0));
    pack(hi, visitRange.pick(0, 1));
    while(visitTop < visitCount){
        var idx = visitIndex[visitTop];
        var k = bits.log2(idx + 1) % d;
        var loidx = visitRange.index(visitTop, 0, 0);
        var hiidx = visitRange.index(visitTop, 1, 0);
        var pidx = points.index(idx, 0);
        var visitPoint = true;
        for(var i = 0; i < d; ++i){
            var pc = pointData[pidx + i];
            if (pc < rangeData[loidx + i] || rangeData[hiidx + i] < pc) {
                visitPoint = false;
                break;
            }
        }
        if (visitPoint) {
            retval = visit(ids[idx]);
            if (retval !== undefined) break;
        }
        //Visit children
        var pk = pointData[pidx + k];
        var hk = rangeData[hiidx + k];
        var lk = rangeData[loidx + k];
        if (lk <= pk) {
            var left = 2 * idx + 1;
            if (left < n) {
                visitIndex[visitCount] = left;
                var y = visitRange.index(visitCount, 0, 0);
                for(var i = 0; i < d; ++i)rangeData[y + i] = rangeData[loidx + i];
                var z = visitRange.index(visitCount, 1, 0);
                for(var i = 0; i < d; ++i)rangeData[z + i] = rangeData[hiidx + i];
                rangeData[z + k] = Math.min(hk, pk);
                visitCount += 1;
            }
        }
        if (pk <= hk) {
            var right = 2 * (idx + 1);
            if (right < n) {
                visitIndex[visitCount] = right;
                var y = visitRange.index(visitCount, 0, 0);
                for(var i = 0; i < d; ++i)rangeData[y + i] = rangeData[loidx + i];
                var z = visitRange.index(visitCount, 1, 0);
                for(var i = 0; i < d; ++i)rangeData[z + i] = rangeData[hiidx + i];
                rangeData[y + k] = Math.max(lk, pk);
                visitCount += 1;
            }
        }
        //Increment pointer
        visitTop += 1;
    }
    ndscratch.free(visitRange);
    pool.free(visitIndex);
    return retval;
};
proto.rnn = function(point, radius, visit) {
    if (radius < 0) return;
    var n = this.length;
    if (n < 1) return;
    var d = this.dimension;
    var points = this.points;
    var ids = this.ids;
    //Walk tree in level order, skipping subtrees which do not intersect sphere
    var visitDistance = ndscratch.malloc([
        n,
        d
    ]);
    var visitIndex = pool.mallocInt32(n);
    var distanceData = visitDistance.data;
    var pointData = points.data;
    var visitCount = 1;
    var visitTop = 0;
    var r2 = radius * radius;
    var retval;
    //Initialize top of queue
    visitIndex[0] = 0;
    for(var i = 0; i < d; ++i)visitDistance.set(0, i, 0);
    //Walk over queue
    while(visitTop < visitCount){
        var idx = visitIndex[visitTop];
        var pidx = points.index(idx, 0);
        //Check if point in sphere
        var d2 = 0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 <= r2) {
            retval = visit(ids[idx]);
            if (retval !== undefined) break;
        }
        //Visit children
        var k = bits.log2(idx + 1) % d;
        var ds = 0;
        var didx = visitDistance.index(visitTop, 0);
        for(var i = 0; i < d; ++i)if (i !== k) ds += distanceData[didx + i];
        //Handle split axis
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = distanceData[didx + k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        if (d2l <= r2) {
            var left = 2 * idx + 1;
            if (left < n) {
                visitIndex[visitCount] = left;
                var y = visitDistance.index(visitCount, 0);
                for(var i = 0; i < d; ++i)distanceData[y + i] = distanceData[didx + i];
                distanceData[y + k] = lk;
                visitCount += 1;
            }
        }
        if (d2h <= r2) {
            var right = 2 * (idx + 1);
            if (right < n) {
                visitIndex[visitCount] = right;
                var y = visitDistance.index(visitCount, 0);
                for(var i = 0; i < d; ++i)distanceData[y + i] = distanceData[didx + i];
                distanceData[y + k] = hk;
                visitCount += 1;
            }
        }
        //Increment pointer
        visitTop += 1;
    }
    ndscratch.free(visitDistance);
    pool.free(visitIndex);
    return retval;
};
proto.nn = function(point, maxDistance) {
    var n = this.length;
    if (n < 1) return -1;
    if (typeof maxDistance === "number") {
        if (maxDistance < 0) return -1;
    } else maxDistance = Infinity;
    var d = this.dimension;
    var points = this.points;
    var pointData = points.data;
    var dataVector = pool.mallocFloat64(d);
    var toVisit = new KDTHeap(n, d + 1);
    var index = toVisit.index;
    var data = toVisit.data;
    index[0] = 0;
    for(var i = 0; i <= d; ++i)data[i] = 0;
    toVisit.count += 1;
    var nearest = -1;
    var nearestD = maxDistance;
    while(toVisit.count > 0){
        if (data[0] >= nearestD) break;
        var idx = index[0];
        var pidx = points.index(idx, 0);
        var d2 = 0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 < nearestD) {
            nearestD = d2;
            nearest = idx;
        }
        //Compute distance bounds for children
        var k = bits.log2(idx + 1) % d;
        var ds = 0;
        for(var i = 0; i < d; ++i){
            var dd = data[i + 1];
            if (i !== k) ds += dd;
            dataVector[i] = dd;
        }
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = dataVector[k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        toVisit.pop();
        if (d2l < nearestD) {
            var left = 2 * idx + 1;
            if (left < n) {
                var vcount = toVisit.count;
                index[vcount] = left;
                var vptr = vcount * (d + 1);
                data[vptr] = d2l;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = lk;
                toVisit.push();
            }
        }
        if (d2h < nearestD) {
            var right = 2 * (idx + 1);
            if (right < n) {
                var vcount = toVisit.count;
                index[vcount] = right;
                var vptr = vcount * (d + 1);
                data[vptr] = d2h;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = hk;
                toVisit.push();
            }
        }
    }
    pool.freeFloat64(dataVector);
    toVisit.dispose();
    if (nearest < 0) return -1;
    return this.ids[nearest];
};
proto.knn = function(point, maxPoints, maxDistance) {
    //Check degenerate cases
    if (typeof maxDistance === "number") {
        if (maxDistance < 0) return [];
    } else maxDistance = Infinity;
    var n = this.length;
    if (n < 1) return [];
    if (typeof maxPoints === "number") {
        if (maxPoints <= 0) return [];
        maxPoints = Math.min(maxPoints, n) | 0;
    } else maxPoints = n;
    var ids = this.ids;
    var d = this.dimension;
    var points = this.points;
    var pointData = points.data;
    var dataVector = pool.mallocFloat64(d);
    //List of closest points
    var closestPoints = new KDTHeap(maxPoints, 1);
    var cl_index = closestPoints.index;
    var cl_data = closestPoints.data;
    var toVisit = new KDTHeap(n, d + 1);
    var index = toVisit.index;
    var data = toVisit.data;
    index[0] = 0;
    for(var i = 0; i <= d; ++i)data[i] = 0;
    toVisit.count += 1;
    var nearest = -1;
    var nearestD = maxDistance;
    while(toVisit.count > 0){
        if (data[0] >= nearestD) break;
        var idx = index[0];
        var pidx = points.index(idx, 0);
        var d2 = 0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 < nearestD) {
            if (closestPoints.count >= maxPoints) closestPoints.pop();
            var pcount = closestPoints.count;
            cl_index[pcount] = idx;
            cl_data[pcount] = -d2;
            closestPoints.push();
            if (closestPoints.count >= maxPoints) nearestD = -cl_data[0];
        }
        //Compute distance bounds for children
        var k = bits.log2(idx + 1) % d;
        var ds = 0;
        for(var i = 0; i < d; ++i){
            var dd = data[i + 1];
            if (i !== k) ds += dd;
            dataVector[i] = dd;
        }
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = dataVector[k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        toVisit.pop();
        if (d2l < nearestD) {
            var left = 2 * idx + 1;
            if (left < n) {
                var vcount = toVisit.count;
                index[vcount] = left;
                var vptr = vcount * (d + 1);
                data[vptr] = d2l;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = lk;
                toVisit.push();
            }
        }
        if (d2h < nearestD) {
            var right = 2 * (idx + 1);
            if (right < n) {
                var vcount = toVisit.count;
                index[vcount] = right;
                var vptr = vcount * (d + 1);
                data[vptr] = d2h;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = hk;
                toVisit.push();
            }
        }
    }
    pool.freeFloat64(dataVector);
    toVisit.dispose();
    //Sort result
    var result = new Array(closestPoints.count);
    var ids = this.ids;
    for(var i = closestPoints.count - 1; i >= 0; --i){
        result[i] = ids[cl_index[0]];
        closestPoints.pop();
    }
    closestPoints.dispose();
    return result;
};
proto.dispose = function kdtDispose() {
    pool.free(this.points.data);
    pool.freeInt32(this.ids);
    this.points = null;
    this.ids = null;
    this.length = 0;
};
function Queue() {
    this.data = [];
    this.offset = 0;
}
Queue.prototype.size = function() {
    return this.data.length - this.offset;
};
Queue.prototype.push = function(item) {
    return this.data.push(item);
};
Queue.prototype.pop = function() {
    if (this.size() === 0) return undefined;
    var ret = this.data[this.offset];
    this.offset++;
    if (this.data.length > 1024 && this.offset * 2 > this.data.length) {
        this.data = this.data.slice(this.offset);
        this.offset = 0;
    }
    return ret;
};
function createKDTree(points) {
    var n, d, indexed;
    if (Array.isArray(points)) {
        n = points.length;
        if (n === 0) return new KDTree(null, null, 0, 0);
        d = points[0].length;
        indexed = ndarray(pool.mallocDouble(n * (d + 1)), [
            n,
            d + 1
        ]);
        pack(points, indexed.hi(n, d));
    } else {
        n = points.shape[0];
        d = points.shape[1];
        //Round up data type size
        var type = points.dtype;
        if (type === "int8" || type === "int16" || type === "int32") type = "int32";
        else if (type === "uint8" || type === "uint8_clamped" || type === "buffer" || type === "uint16" || type === "uint32") type = "uint32";
        else if (type === "float32") type = "float32";
        else type = "float64";
        indexed = ndarray(pool.malloc(n * (d + 1), type), [
            n,
            d + 1
        ]);
        ops.assign(indexed.hi(n, d), points);
    }
    for(var i = 0; i < n; ++i)indexed.set(i, d, i);
    var pointArray = ndscratch.malloc([
        n,
        d
    ], points.dtype);
    var indexArray = pool.mallocInt32(n);
    var pointer = 0;
    var pointData = pointArray.data;
    var arrayData = indexed.data;
    var l2_n = bits.log2(bits.nextPow2(n));
    var sel_cmp = ndselect.compile(indexed.order, true, indexed.dtype);
    //Walk tree in level order
    var toVisit = new Queue();
    toVisit.push(indexed);
    while(pointer < n){
        var head = toVisit.pop();
        var array = head;
        var nn = array.shape[0] | 0;
        //Find median
        if (nn > 1) {
            var k = bits.log2(pointer + 1) % d;
            var median;
            var n_2 = inorderTree.root(nn);
            median = sel_cmp(array, n_2, function(a, b) {
                return a.get(k) - b.get(k);
            });
            //Copy into new array
            var pptr = pointArray.index(pointer, 0);
            var mptr = median.offset;
            for(var i = 0; i < d; ++i)pointData[pptr++] = arrayData[mptr++];
            indexArray[pointer] = arrayData[mptr];
            pointer += 1;
            //Queue new items
            toVisit.push(array.hi(n_2));
            if (nn > 2) toVisit.push(array.lo(n_2 + 1));
        } else {
            //Copy into new array
            var mptr = array.offset;
            var pptr = pointArray.index(pointer, 0);
            for(var i = 0; i < d; ++i)pointData[pptr + i] = arrayData[mptr++];
            indexArray[pointer] = arrayData[mptr];
            pointer += 1;
        }
    }
    //Release indexed
    pool.free(indexed.data);
    return new KDTree(pointArray, indexArray, n, d);
}
function deserializeKDTree(data) {
    var points = data.p;
    var ids = data.i;
    if (points) {
        var nd = points.length;
        var pointArray = pool.mallocFloat64(nd);
        for(var i = 0; i < nd; ++i)pointArray[i] = points[i];
        var n = ids.length;
        var idArray = pool.mallocInt32(n);
        for(var i = 0; i < n; ++i)idArray[i] = ids[i];
        var d = nd / n | 0;
        return new KDTree(ndarray(pointArray, [
            n,
            d
        ]), idArray, n, d);
    } else return new KDTree(null, null, 0, data.d);
}

},{"ndarray":"1nDU8","ndarray-select":"6mCoB","ndarray-pack":"48txd","ndarray-ops":"kXyuI","ndarray-scratch":"7acsC","typedarray-pool":"1RryJ","inorder-tree-layout":"7V1A8","bit-twiddle":"9kWjw","./lib/heap.js":"epTUT"}],"1nDU8":[function(require,module,exports) {
var iota = require("iota-array");
var isBuffer = require("is-buffer");
var hasTypedArrays = typeof Float64Array !== "undefined";
function compare1st(a, b) {
    return a[0] - b[0];
}
function order() {
    var stride = this.stride;
    var terms = new Array(stride.length);
    var i;
    for(i = 0; i < terms.length; ++i)terms[i] = [
        Math.abs(stride[i]),
        i
    ];
    terms.sort(compare1st);
    var result = new Array(terms.length);
    for(i = 0; i < result.length; ++i)result[i] = terms[i][1];
    return result;
}
function compileConstructor(dtype, dimension) {
    var className = [
        "View",
        dimension,
        "d",
        dtype
    ].join("");
    if (dimension < 0) className = "View_Nil" + dtype;
    var useGetters = dtype === "generic";
    if (dimension === -1) {
        //Special case for trivial arrays
        var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
    } else if (dimension === 0) {
        //Special case for 0d arrays
        var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
    }
    var code = [
        "'use strict'"
    ];
    //Create constructor for view
    var indices = iota(dimension);
    var args = indices.map(function(i) {
        return "i" + i;
    });
    var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i;
    }).join("+");
    var shapeArg = indices.map(function(i) {
        return "b" + i;
    }).join(",");
    var strideArg = indices.map(function(i) {
        return "c" + i;
    }).join(",");
    code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension);
    //view.size:
    code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function(i) {
        return "this.shape[" + i + "]";
    }).join("*"), "}})");
    //view.order:
    if (dimension === 1) code.push("proto.order=[0]");
    else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
            code.push("function " + className + "_order(){");
            if (dimension === 2) code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
            else if (dimension === 3) code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
        } else code.push("ORDER})");
    }
    //view.set(i0, ..., v):
    code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
    if (useGetters) code.push("return this.data.set(" + index_str + ",v)}");
    else code.push("return this.data[" + index_str + "]=v}");
    //view.get(i0, ...):
    code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
    if (useGetters) code.push("return this.data.get(" + index_str + ")}");
    else code.push("return this.data[" + index_str + "]}");
    //view.index:
    code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}");
    //view.hi():
    code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i) {
        return [
            "(typeof i",
            i,
            "!=='number'||i",
            i,
            "<0)?this.shape[",
            i,
            "]:i",
            i,
            "|0"
        ].join("");
    }).join(",") + "," + indices.map(function(i) {
        return "this.stride[" + i + "]";
    }).join(",") + ",this.offset)}");
    //view.lo():
    var a_vars = indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    });
    var c_vars = indices.map(function(i) {
        return "c" + i + "=this.stride[" + i + "]";
    });
    code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
    for(var i1 = 0; i1 < dimension; ++i1)code.push("if(typeof i" + i1 + "==='number'&&i" + i1 + ">=0){\
d=i" + i1 + "|0;\
b+=c" + i1 + "*d;\
a" + i1 + "-=d}");
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "c" + i;
    }).join(",") + ",b)}");
    //view.step():
    code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i + "=this.stride[" + i + "]";
    }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
    for(var i1 = 0; i1 < dimension; ++i1)code.push("if(typeof i" + i1 + "==='number'){\
d=i" + i1 + "|0;\
if(d<0){\
c+=b" + i1 + "*(a" + i1 + "-1);\
a" + i1 + "=ceil(-a" + i1 + "/d)\
}else{\
a" + i1 + "=ceil(a" + i1 + "/d)\
}\
b" + i1 + "*=d\
}");
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i;
    }).join(",") + ",c)}");
    //view.transpose():
    var tShape = new Array(dimension);
    var tStride = new Array(dimension);
    for(var i1 = 0; i1 < dimension; ++i1){
        tShape[i1] = "a[i" + i1 + "]";
        tStride[i1] = "b[i" + i1 + "]";
    }
    code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
        return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
    }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}");
    //view.pick():
    code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
    for(var i1 = 0; i1 < dimension; ++i1)code.push("if(typeof i" + i1 + "==='number'&&i" + i1 + ">=0){c=(c+this.stride[" + i1 + "]*i" + i1 + ")|0}else{a.push(this.shape[" + i1 + "]);b.push(this.stride[" + i1 + "])}");
    code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
    //Add return statement
    code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i) {
        return "shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "stride[" + i + "]";
    }).join(",") + ",offset)}");
    //Compile procedure
    var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
    return procedure(CACHED_CONSTRUCTORS[dtype], order);
}
function arrayDType(data) {
    if (isBuffer(data)) return "buffer";
    if (hasTypedArrays) switch(Object.prototype.toString.call(data)){
        case "[object Float64Array]":
            return "float64";
        case "[object Float32Array]":
            return "float32";
        case "[object Int8Array]":
            return "int8";
        case "[object Int16Array]":
            return "int16";
        case "[object Int32Array]":
            return "int32";
        case "[object Uint8Array]":
            return "uint8";
        case "[object Uint16Array]":
            return "uint16";
        case "[object Uint32Array]":
            return "uint32";
        case "[object Uint8ClampedArray]":
            return "uint8_clamped";
        case "[object BigInt64Array]":
            return "bigint64";
        case "[object BigUint64Array]":
            return "biguint64";
    }
    if (Array.isArray(data)) return "array";
    return "generic";
}
var CACHED_CONSTRUCTORS = {
    "float32": [],
    "float64": [],
    "int8": [],
    "int16": [],
    "int32": [],
    "uint8": [],
    "uint16": [],
    "uint32": [],
    "array": [],
    "uint8_clamped": [],
    "bigint64": [],
    "biguint64": [],
    "buffer": [],
    "generic": []
};
function wrappedNDArrayCtor(data, shape, stride, offset) {
    if (data === undefined) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
    } else if (typeof data === "number") data = [
        data
    ];
    if (shape === undefined) shape = [
        data.length
    ];
    var d = shape.length;
    if (stride === undefined) {
        stride = new Array(d);
        for(var i = d - 1, sz = 1; i >= 0; --i){
            stride[i] = sz;
            sz *= shape[i];
        }
    }
    if (offset === undefined) {
        offset = 0;
        for(var i = 0; i < d; ++i)if (stride[i] < 0) offset -= (shape[i] - 1) * stride[i];
    }
    var dtype = arrayDType(data);
    var ctor_list = CACHED_CONSTRUCTORS[dtype];
    while(ctor_list.length <= d + 1)ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
    var ctor = ctor_list[d + 1];
    return ctor(data, shape, stride, offset);
}
module.exports = wrappedNDArrayCtor;

},{"iota-array":"hvCq1","is-buffer":"9JmUB"}],"hvCq1":[function(require,module,exports) {
"use strict";
function iota(n) {
    var result = new Array(n);
    for(var i = 0; i < n; ++i)result[i] = i;
    return result;
}
module.exports = iota;

},{}],"9JmUB":[function(require,module,exports) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ // The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],"6mCoB":[function(require,module,exports) {
"use strict";
module.exports = ndSelect;
module.exports.compile = lookupCache;
//Macros
var ARRAY = "a";
var RANK = "K";
var CMP = "C";
var DATA = "d";
var OFFSET = "o";
var RND = "R";
var TMP = "T";
var LO = "L";
var HI = "H";
var PIVOT = "X";
function SHAPE(i) {
    return "s" + i;
}
function STRIDE(i) {
    return "t" + i;
}
function STEP(i) {
    return "u" + i;
}
function STEP_CMP(i) {
    return "v" + i;
}
function INDEX(i) {
    return "i" + i;
}
function PICK(i) {
    return "p" + i;
}
function PTR(i) {
    return "x" + i;
}
//Create new order where index 0 is slowest index
function permuteOrder(order) {
    var norder = order.slice();
    norder.splice(order.indexOf(0), 1);
    norder.unshift(0);
    return norder;
}
//Generate quick select procedure
function compileQuickSelect(order, useCompare, dtype) {
    order = permuteOrder(order);
    var dimension = order.length;
    var useGetter = dtype === "generic";
    var funcName = "ndSelect" + dtype + order.join("_") + "_" + (useCompare ? "cmp" : "lex");
    var code = [];
    //Get arguments for code
    var args = [
        ARRAY,
        RANK
    ];
    if (useCompare) args.push(CMP);
    //Unpack ndarray variables
    var vars = [
        DATA + "=" + ARRAY + ".data",
        OFFSET + "=" + ARRAY + ".offset|0",
        RND + "=Math.random",
        TMP
    ];
    for(var i2 = 0; i2 < 2; ++i2)vars.push(PTR(i2) + "=0");
    for(var i2 = 0; i2 < dimension; ++i2)vars.push(SHAPE(i2) + "=" + ARRAY + ".shape[" + i2 + "]|0", STRIDE(i2) + "=" + ARRAY + ".stride[" + i2 + "]|0", INDEX(i2) + "=0");
    for(var i2 = 1; i2 < dimension; ++i2)if (i2 > 1) vars.push(STEP_CMP(i2) + "=(" + STRIDE(i2) + "-" + SHAPE(i2 - 1) + "*" + STRIDE(i2 - 1) + ")|0", STEP(order[i2]) + "=(" + STRIDE(order[i2]) + "-" + SHAPE(order[i2 - 1]) + "*" + STRIDE(order[i2 - 1]) + ")|0");
    else vars.push(STEP_CMP(i2) + "=" + STRIDE(i2), STEP(order[i2]) + "=" + STRIDE(order[i2]));
    if (useCompare) for(var i2 = 0; i2 < 2; ++i2)vars.push(PICK(i2) + "=" + ARRAY + ".pick(0)");
    vars.push(PIVOT + "=0", LO + "=0", HI + "=" + SHAPE(order[0]) + "-1");
    function compare(out, i0, i1) {
        if (useCompare) code.push(PICK(0), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");", PICK(1), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");", out, "=", CMP, "(", PICK(0), ",", PICK(1), ");");
        else {
            code.push(PTR(0), "=", OFFSET, "+", STRIDE(0), "*(", i0, ");", PTR(1), "=", OFFSET, "+", STRIDE(0), "*(", i1, ");");
            if (dimension > 1) code.push("_cmp:");
            for(var i = dimension - 1; i > 0; --i)code.push("for(", INDEX(i), "=0;", INDEX(i), "<", SHAPE(i), ";", INDEX(i), "++){");
            if (useGetter) code.push(out, "=", DATA, ".get(", PTR(0), ")-", DATA, ".get(", PTR(1), ");");
            else code.push(out, "=", DATA, "[", PTR(0), "]-", DATA, "[", PTR(1), "];");
            if (dimension > 1) code.push("if(", out, ")break _cmp;");
            for(var i = 1; i < dimension; ++i)code.push(PTR(0), "+=", STEP_CMP(i), ";", PTR(1), "+=", STEP_CMP(i), "}");
        }
    }
    function swap(i0, i1) {
        code.push(PTR(0), "=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");", PTR(1), "=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");");
        for(var i = dimension - 1; i > 0; --i)code.push("for(", INDEX(order[i]), "=0;", INDEX(order[i]), "<", SHAPE(order[i]), ";", INDEX(order[i]), "++){");
        if (useGetter) code.push(TMP, "=", DATA, ".get(", PTR(0), ");", DATA, ".set(", PTR(0), ",", DATA, ".get(", PTR(1), "));", DATA, ".set(", PTR(1), ",", TMP, ");");
        else code.push(TMP, "=", DATA, "[", PTR(0), "];", DATA, "[", PTR(0), "]=", DATA, "[", PTR(1), "];", DATA, "[", PTR(1), "]=", TMP, ";");
        for(var i = 1; i < dimension; ++i)code.push(PTR(0), "+=", STEP(order[i]), ";", PTR(1), "+=", STEP(order[i]), "}");
    }
    code.push("while(", LO, "<", HI, "){", PIVOT, "=(", RND, "()*(", HI, "-", LO, "+1)+", LO, ")|0;");
    //Partition array by pivot
    swap(PIVOT, HI) // Store pivot temporarily at the end of the array
    ;
    code.push(PIVOT, "=", LO, ";", "for(", INDEX(0), "=", LO, ";", INDEX(0), "<", HI, ";", INDEX(0), "++){") // Loop over other elements (unequal to the pivot), note that HI now points to the pivot
    ;
    compare(TMP, INDEX(0), HI) // Lexicographical compare of element with pivot
    ;
    code.push("if(", TMP, "<0){");
    swap(PIVOT, INDEX(0)) // Swap current element with element at index PIVOT if it is less than the pivot
    ;
    code.push(PIVOT, "++;");
    code.push("}}");
    swap(PIVOT, HI) // Store pivot right after all elements that are less than the pivot (implying that all elements >= the pivot are behind the pivot)
    ;
    //Check pivot bounds
    code.push("if(", PIVOT, "===", RANK, "){", LO, "=", PIVOT, ";", "break;", "}else if(", RANK, "<", PIVOT, "){", HI, "=", PIVOT, "-1;", "}else{", LO, "=", PIVOT, "+1;", "}", "}");
    if (useCompare) code.push(PICK(0), ".offset=", OFFSET, "+", LO, "*", STRIDE(0), ";", "return ", PICK(0), ";");
    else code.push("return ", ARRAY, ".pick(", LO, ");");
    //Compile and link js together
    var procCode = [
        "'use strict';function ",
        funcName,
        "(",
        args,
        "){",
        "var ",
        vars.join(),
        ";",
        code.join(""),
        "};return ",
        funcName
    ].join("");
    var proc = new Function(procCode);
    return proc();
}
var CACHE = {
};
function lookupCache(order, useCompare, dtype) {
    var typesig = order.join() + useCompare + dtype;
    var proc = CACHE[typesig];
    if (proc) return proc;
    return CACHE[typesig] = compileQuickSelect(order, useCompare, dtype);
}
function ndSelect(array, k, compare) {
    k |= 0;
    if (array.dimension === 0 || array.shape[0] <= k || k < 0) return null;
    var useCompare = !!compare;
    var proc = lookupCache(array.order, useCompare, array.dtype);
    if (useCompare) return proc(array, k, compare);
    else return proc(array, k);
}

},{}],"48txd":[function(require,module,exports) {
"use strict";
var ndarray = require("ndarray");
var do_convert = require("./doConvert.js");
module.exports = function convert(arr, result) {
    var shape = [], c = arr, sz = 1;
    while(Array.isArray(c)){
        shape.push(c.length);
        sz *= c.length;
        c = c[0];
    }
    if (shape.length === 0) return ndarray();
    if (!result) result = ndarray(new Float64Array(sz), shape);
    do_convert(result, arr);
    return result;
};

},{"ndarray":"1nDU8","./doConvert.js":"kOMeM"}],"kOMeM":[function(require,module,exports) {
module.exports = require('cwise-compiler')({
    "args": [
        "array",
        "scalar",
        "index"
    ],
    "pre": {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    "body": {
        "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
        "args": [
            {
                "name": "_inline_1_arg0_",
                "lvalue": true,
                "rvalue": false,
                "count": 1
            },
            {
                "name": "_inline_1_arg1_",
                "lvalue": false,
                "rvalue": true,
                "count": 1
            },
            {
                "name": "_inline_1_arg2_",
                "lvalue": false,
                "rvalue": true,
                "count": 4
            }
        ],
        "thisVars": [],
        "localVars": [
            "_inline_1_i",
            "_inline_1_v"
        ]
    },
    "post": {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    "funcName": "convert",
    "blockSize": 64
});

},{"cwise-compiler":"7GqVQ"}],"7GqVQ":[function(require,module,exports) {
"use strict";
var createThunk = require("./lib/thunk.js");
function Procedure() {
    this.argTypes = [];
    this.shimArgs = [];
    this.arrayArgs = [];
    this.arrayBlockIndices = [];
    this.scalarArgs = [];
    this.offsetArgs = [];
    this.offsetArgIndex = [];
    this.indexArgs = [];
    this.shapeArgs = [];
    this.funcName = "";
    this.pre = null;
    this.body = null;
    this.post = null;
    this.debug = false;
}
function compileCwise(user_args) {
    //Create procedure
    var proc = new Procedure();
    //Parse blocks
    proc.pre = user_args.pre;
    proc.body = user_args.body;
    proc.post = user_args.post;
    //Parse arguments
    var proc_args = user_args.args.slice(0);
    proc.argTypes = proc_args;
    for(var i = 0; i < proc_args.length; ++i){
        var arg_type = proc_args[i];
        if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
            proc.argTypes[i] = "array";
            proc.arrayArgs.push(i);
            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
            proc.shimArgs.push("array" + i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) throw new Error("cwise: pre() block may not reference array args");
            if (i < proc.post.args.length && proc.post.args[i].count > 0) throw new Error("cwise: post() block may not reference array args");
        } else if (arg_type === "scalar") {
            proc.scalarArgs.push(i);
            proc.shimArgs.push("scalar" + i);
        } else if (arg_type === "index") {
            proc.indexArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) throw new Error("cwise: pre() block may not reference array index");
            if (i < proc.body.args.length && proc.body.args[i].lvalue) throw new Error("cwise: body() block may not write to array index");
            if (i < proc.post.args.length && proc.post.args[i].count > 0) throw new Error("cwise: post() block may not reference array index");
        } else if (arg_type === "shape") {
            proc.shapeArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) throw new Error("cwise: pre() block may not write to array shape");
            if (i < proc.body.args.length && proc.body.args[i].lvalue) throw new Error("cwise: body() block may not write to array shape");
            if (i < proc.post.args.length && proc.post.args[i].lvalue) throw new Error("cwise: post() block may not write to array shape");
        } else if (typeof arg_type === "object" && arg_type.offset) {
            proc.argTypes[i] = "offset";
            proc.offsetArgs.push({
                array: arg_type.array,
                offset: arg_type.offset
            });
            proc.offsetArgIndex.push(i);
        } else throw new Error("cwise: Unknown argument type " + proc_args[i]);
    }
    //Make sure at least one array argument was specified
    if (proc.arrayArgs.length <= 0) throw new Error("cwise: No array arguments specified");
    //Make sure arguments are correct
    if (proc.pre.args.length > proc_args.length) throw new Error("cwise: Too many arguments in pre() block");
    if (proc.body.args.length > proc_args.length) throw new Error("cwise: Too many arguments in body() block");
    if (proc.post.args.length > proc_args.length) throw new Error("cwise: Too many arguments in post() block");
    //Check debug flag
    proc.debug = !!user_args.printCode || !!user_args.debug;
    //Retrieve name
    proc.funcName = user_args.funcName || "cwise";
    //Read in block size
    proc.blockSize = user_args.blockSize || 64;
    return createThunk(proc);
}
module.exports = compileCwise;

},{"./lib/thunk.js":"fBD3l"}],"fBD3l":[function(require,module,exports) {
"use strict";
// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }
var compile = require("./compile.js");
function createThunk(proc) {
    var code = [
        "'use strict'",
        "var CACHED={}"
    ];
    var vars = [];
    var thunkName = proc.funcName + "_cwise_thunk";
    //Build thunk
    code.push([
        "return function ",
        thunkName,
        "(",
        proc.shimArgs.join(","),
        "){"
    ].join(""));
    var typesig = [];
    var string_typesig = [];
    var proc_args = [
        [
            "array",
            proc.arrayArgs[0],
            ".shape.slice(",
            Math.max(0, proc.arrayBlockIndices[0]),
            proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
        ].join("")
    ];
    var shapeLengthConditions = [], shapeConditions = [];
    // Process array arguments
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        var j = proc.arrayArgs[i];
        vars.push([
            "t",
            j,
            "=array",
            j,
            ".dtype,",
            "r",
            j,
            "=array",
            j,
            ".order"
        ].join(""));
        typesig.push("t" + j);
        typesig.push("r" + j);
        string_typesig.push("t" + j);
        string_typesig.push("r" + j + ".join()");
        proc_args.push("array" + j + ".data");
        proc_args.push("array" + j + ".stride");
        proc_args.push("array" + j + ".offset|0");
        if (i > 0) {
            shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
            shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
        }
    }
    // Check for shape equality
    if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
        code.push("}");
    }
    // Process scalar arguments
    for(var i = 0; i < proc.scalarArgs.length; ++i)proc_args.push("scalar" + proc.scalarArgs[i]);
    // Check for cached function (and if not present, generate it)
    vars.push([
        "type=[",
        string_typesig.join(","),
        "].join()"
    ].join(""));
    vars.push("proc=CACHED[type]");
    code.push("var " + vars.join(","));
    code.push([
        "if(!proc){",
        "CACHED[type]=proc=compile([",
        typesig.join(","),
        "])}",
        "return proc(",
        proc_args.join(","),
        ")}"
    ].join(""));
    if (proc.debug) console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
    //Compile thunk
    var thunk = new Function("compile", code.join("\n"));
    return thunk(compile.bind(undefined, proc));
}
module.exports = createThunk;

},{"./compile.js":"lX50N"}],"lX50N":[function(require,module,exports) {
"use strict";
var uniq = require("uniq");
// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
    for(i = 0; i < dimension; ++i)vars.push([
        "i",
        i,
        "=0"
    ].join(""));
    //Compute scan deltas
    for(j = 0; j < nargs; ++j)for(i = 0; i < dimension; ++i){
        pidx = idx;
        idx = order[i];
        if (i === 0) vars.push([
            "d",
            j,
            "s",
            i,
            "=t",
            j,
            "p",
            idx
        ].join(""));
        else vars.push([
            "d",
            j,
            "s",
            i,
            "=(t",
            j,
            "p",
            idx,
            "-s",
            pidx,
            "*t",
            j,
            "p",
            pidx,
            ")"
        ].join(""));
    }
    if (vars.length > 0) code.push("var " + vars.join(","));
    //Scan loop
    for(i = dimension - 1; i >= 0; --i){
        idx = order[i];
        code.push([
            "for(i",
            i,
            "=0;i",
            i,
            "<s",
            idx,
            ";++i",
            i,
            "){"
        ].join(""));
    }
    //Push body of inner loop
    code.push(body);
    //Advance scan pointers
    for(i = 0; i < dimension; ++i){
        pidx = idx;
        idx = order[i];
        for(j = 0; j < nargs; ++j)code.push([
            "p",
            j,
            "+=d",
            j,
            "s",
            i
        ].join(""));
        if (has_index) {
            if (i > 0) code.push([
                "index[",
                pidx,
                "]-=s",
                pidx
            ].join(""));
            code.push([
                "++index[",
                idx,
                "]"
            ].join(""));
        }
        code.push("}");
    }
    return code.join("\n");
}
// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
    for(var i = 0; i < nargs; ++i)code.push([
        "var offset",
        i,
        "=p",
        i
    ].join(""));
    //Generate loops for unmatched dimensions
    // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
    // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
    for(var i = matched; i < dimension; ++i){
        code.push([
            "for(var j" + i + "=SS[",
            order[i],
            "]|0;j",
            i,
            ">0;){"
        ].join("")) // Iterate back to front
        ;
        code.push([
            "if(j",
            i,
            "<",
            blockSize,
            "){"
        ].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
        ;
        code.push([
            "s",
            order[i],
            "=j",
            i
        ].join(""));
        code.push([
            "j",
            i,
            "=0"
        ].join(""));
        code.push([
            "}else{s",
            order[i],
            "=",
            blockSize
        ].join(""));
        code.push([
            "j",
            i,
            "-=",
            blockSize,
            "}"
        ].join(""));
        if (has_index) code.push([
            "index[",
            order[i],
            "]=j",
            i
        ].join(""));
    }
    for(var i = 0; i < nargs; ++i){
        var indexStr = [
            "offset" + i
        ];
        for(var j = matched; j < dimension; ++j)indexStr.push([
            "j",
            j,
            "*t",
            i,
            "p",
            order[j]
        ].join(""));
        code.push([
            "p",
            i,
            "=(",
            indexStr.join("+"),
            ")"
        ].join(""));
    }
    code.push(innerFill(order, proc, body));
    for(var i = matched; i < dimension; ++i)code.push("}");
    return code.join("\n");
}
//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
    var matched = 0, dimension = orders[0].length;
    while(matched < dimension){
        for(var j = 1; j < orders.length; ++j){
            if (orders[j][matched] !== orders[0][matched]) return matched;
        }
        ++matched;
    }
    return matched;
}
//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
    var code = block.body;
    var pre = [];
    var post = [];
    for(var i = 0; i < block.args.length; ++i){
        var carg = block.args[i];
        if (carg.count <= 0) continue;
        var re = new RegExp(carg.name, "g");
        var ptrStr = "";
        var arrNum = proc.arrayArgs.indexOf(i);
        switch(proc.argTypes[i]){
            case "offset":
                var offArgIndex = proc.offsetArgIndex.indexOf(i);
                var offArg = proc.offsetArgs[offArgIndex];
                arrNum = offArg.array;
                ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
                ;
            case "array":
                ptrStr = "p" + arrNum + ptrStr;
                var localStr = "l" + i;
                var arrStr = "a" + arrNum;
                if (proc.arrayBlockIndices[arrNum] === 0) {
                    if (carg.count === 1) {
                        if (dtypes[arrNum] === "generic") {
                            if (carg.lvalue) {
                                pre.push([
                                    "var ",
                                    localStr,
                                    "=",
                                    arrStr,
                                    ".get(",
                                    ptrStr,
                                    ")"
                                ].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                                ;
                                code = code.replace(re, localStr);
                                post.push([
                                    arrStr,
                                    ".set(",
                                    ptrStr,
                                    ",",
                                    localStr,
                                    ")"
                                ].join(""));
                            } else code = code.replace(re, [
                                arrStr,
                                ".get(",
                                ptrStr,
                                ")"
                            ].join(""));
                        } else code = code.replace(re, [
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join(""));
                    } else if (dtypes[arrNum] === "generic") {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            ".get(",
                            ptrStr,
                            ")"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) post.push([
                            arrStr,
                            ".set(",
                            ptrStr,
                            ",",
                            localStr,
                            ")"
                        ].join(""));
                    } else {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) post.push([
                            arrStr,
                            "[",
                            ptrStr,
                            "]=",
                            localStr
                        ].join(""));
                    }
                } else {
                    var reStrArr = [
                        carg.name
                    ], ptrStrArr = [
                        ptrStr
                    ];
                    for(var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++){
                        reStrArr.push("\\s*\\[([^\\]]+)\\]");
                        ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j) // Matched index times stride
                        ;
                    }
                    re = new RegExp(reStrArr.join(""), "g");
                    ptrStr = ptrStrArr.join("+");
                    if (dtypes[arrNum] === "generic") /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/ throw new Error("cwise: Generic arrays not supported in combination with blocks!");
                    else // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                    code = code.replace(re, [
                        arrStr,
                        "[",
                        ptrStr,
                        "]"
                    ].join(""));
                }
                break;
            case "scalar":
                code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
                break;
            case "index":
                code = code.replace(re, "index");
                break;
            case "shape":
                code = code.replace(re, "shape");
                break;
        }
    }
    return [
        pre.join("\n"),
        code,
        post.join("\n")
    ].join("\n").trim();
}
function typeSummary(dtypes) {
    var summary = new Array(dtypes.length);
    var allEqual = true;
    for(var i = 0; i < dtypes.length; ++i){
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) digits = "";
        else digits = digits[0];
        if (t.charAt(0) === 0) summary[i] = "u" + t.charAt(1) + digits;
        else summary[i] = t.charAt(0) + digits;
        if (i > 0) allEqual = allEqual && summary[i] === summary[i - 1];
    }
    if (allEqual) return summary[0];
    return summary.join("");
}
//Generates a cwise operator
function generateCWiseOp(proc, typesig) {
    //Compute dimension
    // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
    var orders = new Array(proc.arrayArgs.length);
    var dtypes = new Array(proc.arrayArgs.length);
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
    }
    //Determine where block and loop indices start and end
    var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
    ;
    var loopBegin = [], loopEnd = [] // These indices are iterated over
    ;
    var loopOrders = [] // orders restricted to the loop indices
    ;
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        if (proc.arrayBlockIndices[i] < 0) {
            loopBegin.push(0);
            loopEnd.push(dimension);
            blockBegin.push(dimension);
            blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
            loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
            ;
            loopEnd.push(proc.arrayBlockIndices[i] + dimension);
            blockBegin.push(0);
            blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for(var j = 0; j < orders[i].length; j++)if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) newOrder.push(orders[i][j] - loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
        ;
        loopOrders.push(newOrder);
    }
    //First create arguments for procedure
    var arglist = [
        "SS"
    ] // SS is the overall shape over which we iterate
    ;
    var code = [
        "'use strict'"
    ];
    var vars = [];
    for(var j = 0; j < dimension; ++j)vars.push([
        "s",
        j,
        "=SS[",
        j,
        "]"
    ].join("")) // The limits for each dimension.
    ;
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        arglist.push("a" + i) // Actual data array
        ;
        arglist.push("t" + i) // Strides
        ;
        arglist.push("p" + i) // Offset in the array at which the data starts (also used for iterating over the data)
        ;
        for(var j = 0; j < dimension; ++j)vars.push([
            "t",
            i,
            "p",
            j,
            "=t",
            i,
            "[",
            loopBegin[i] + j,
            "]"
        ].join(""));
        for(var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j)vars.push([
            "t",
            i,
            "b",
            j,
            "=t",
            i,
            "[",
            blockBegin[i] + j,
            "]"
        ].join(""));
    }
    for(var i = 0; i < proc.scalarArgs.length; ++i)arglist.push("Y" + i);
    if (proc.shapeArgs.length > 0) vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
    ;
    if (proc.indexArgs.length > 0) {
        // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
        var zeros = new Array(dimension);
        for(var i = 0; i < dimension; ++i)zeros[i] = "0";
        vars.push([
            "index=[",
            zeros.join(","),
            "]"
        ].join(""));
    }
    for(var i = 0; i < proc.offsetArgs.length; ++i){
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for(var j = 0; j < off_arg.offset.length; ++j){
            if (off_arg.offset[j] === 0) continue;
            else if (off_arg.offset[j] === 1) init_string.push([
                "t",
                off_arg.array,
                "p",
                j
            ].join(""));
            else init_string.push([
                off_arg.offset[j],
                "*t",
                off_arg.array,
                "p",
                j
            ].join(""));
        }
        if (init_string.length === 0) vars.push("q" + i + "=0");
        else vars.push([
            "q",
            i,
            "=",
            init_string.join("+")
        ].join(""));
    }
    //Prepare this variables
    var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
    vars = vars.concat(thisVars);
    if (vars.length > 0) code.push("var " + vars.join(","));
    for(var i = 0; i < proc.arrayArgs.length; ++i)code.push("p" + i + "|=0");
    //Inline prelude
    if (proc.pre.body.length > 3) code.push(processBlock(proc.pre, proc, dtypes));
    //Process body
    var body = processBlock(proc.body, proc, dtypes);
    var matched = countMatches(loopOrders);
    if (matched < dimension) code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
    ;
    else code.push(innerFill(loopOrders[0], proc, body));
    //Inline epilog
    if (proc.post.body.length > 3) code.push(processBlock(proc.post, proc, dtypes));
    if (proc.debug) console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
    var loopName = [
        proc.funcName || "unnamed",
        "_cwise_loop_",
        orders[0].join("s"),
        "m",
        matched,
        typeSummary(dtypes)
    ].join("");
    var f = new Function([
        "function ",
        loopName,
        "(",
        arglist.join(","),
        "){",
        code.join("\n"),
        "} return ",
        loopName
    ].join(""));
    return f();
}
module.exports = generateCWiseOp;

},{"uniq":"itPtS"}],"itPtS":[function(require,module,exports) {
"use strict";
function unique_pred(list, compare) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i){
        b = a;
        a = list[i];
        if (compare(a, b)) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique_eq(list) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i, b = a){
        b = a;
        a = list[i];
        if (a !== b) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique(list, compare, sorted) {
    if (list.length === 0) return list;
    if (compare) {
        if (!sorted) list.sort(compare);
        return unique_pred(list, compare);
    }
    if (!sorted) list.sort();
    return unique_eq(list);
}
module.exports = unique;

},{}],"kXyuI":[function(require,module,exports) {
"use strict";
var compile = require("cwise-compiler");
var EmptyProc = {
    body: "",
    args: [],
    thisVars: [],
    localVars: []
};
function fixup(x) {
    if (!x) return EmptyProc;
    for(var i = 0; i < x.args.length; ++i){
        var a = x.args[i];
        if (i === 0) x.args[i] = {
            name: a,
            lvalue: true,
            rvalue: !!x.rvalue,
            count: x.count || 1
        };
        else x.args[i] = {
            name: a,
            lvalue: false,
            rvalue: true,
            count: 1
        };
    }
    if (!x.thisVars) x.thisVars = [];
    if (!x.localVars) x.localVars = [];
    return x;
}
function pcompile(user_args) {
    return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
    });
}
function makeOp(user_args) {
    var args = [];
    for(var i = 0; i < user_args.args.length; ++i)args.push("a" + i);
    var wrapper = new Function("P", [
        "return function ",
        user_args.funcName,
        "_ndarrayops(",
        args.join(","),
        ") {P(",
        args.join(","),
        ");return a0}"
    ].join(""));
    return wrapper(pcompile(user_args));
}
var assign_ops = {
    add: "+",
    sub: "-",
    mul: "*",
    div: "/",
    mod: "%",
    band: "&",
    bor: "|",
    bxor: "^",
    lshift: "<<",
    rshift: ">>",
    rrshift: ">>>"
};
(function() {
    for(var id in assign_ops){
        var op = assign_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a" + op + "=b"
            },
            rvalue: true,
            funcName: id + "eq"
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a" + op + "=s"
            },
            rvalue: true,
            funcName: id + "seq"
        });
    }
})();
var unary_ops = {
    not: "!",
    bnot: "~",
    neg: "-",
    recip: "1.0/"
};
(function() {
    for(var id in unary_ops){
        var op = unary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=" + op + "b"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array"
            ],
            body: {
                args: [
                    "a"
                ],
                body: "a=" + op + "a"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
    }
})();
var binary_ops = {
    and: "&&",
    or: "||",
    eq: "===",
    neq: "!==",
    lt: "<",
    gt: ">",
    leq: "<=",
    geq: ">="
};
(function() {
    for(var id in binary_ops){
        var op = binary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=a" + op + "b"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a=a" + op + "s"
            },
            rvalue: true,
            count: 2,
            funcName: id + "seq"
        });
    }
})();
var math_unary = [
    "abs",
    "acos",
    "asin",
    "atan",
    "ceil",
    "cos",
    "exp",
    "floor",
    "log",
    "round",
    "sin",
    "sqrt",
    "tan"
];
(function() {
    for(var i = 0; i < math_unary.length; ++i){
        var f = math_unary[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a"
                ],
                body: "a=this_f(a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
    }
})();
var math_comm = [
    "max",
    "min",
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_comm.length; ++i){
        var f = math_comm[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "s"
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
        exports[f + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "seq"
        });
    }
})();
var math_noncomm = [
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_noncomm.length; ++i){
        var f = math_noncomm[i];
        exports[f + "op"] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "op"
        });
        exports[f + "ops"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "ops"
        });
        exports[f + "opeq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opeq"
        });
        exports[f + "opseq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opseq"
        });
    }
})();
exports.any = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(a){return true}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return false"
    },
    funcName: "any"
});
exports.all = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(!x){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "all"
});
exports.sum = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s+=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "sum"
});
exports.prod = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=1"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s*=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "prod"
});
exports.norm2squared = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm2squared"
});
exports.norm2 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return Math.sqrt(this_s)"
    },
    funcName: "norm2"
});
exports.norminf = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 4
            }
        ],
        body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norminf"
});
exports.norm1 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 3
            }
        ],
        body: "this_s+=a<0?-a:a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm1"
});
exports.sup = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.inf = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.argmin = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.argmax = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.random = makeOp({
    args: [
        "array"
    ],
    pre: {
        args: [],
        body: "this_f=Math.random",
        thisVars: [
            "this_f"
        ]
    },
    body: {
        args: [
            "a"
        ],
        body: "a=this_f()",
        thisVars: [
            "this_f"
        ]
    },
    funcName: "random"
});
exports.assign = makeOp({
    args: [
        "array",
        "array"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assign"
});
exports.assigns = makeOp({
    args: [
        "array",
        "scalar"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assigns"
});
exports.equals = compile({
    args: [
        "array",
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            },
            {
                name: "y",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "equals"
});

},{"cwise-compiler":"7GqVQ"}],"7acsC":[function(require,module,exports) {
"use strict";
var ndarray = require("ndarray");
var ops = require("ndarray-ops");
var pool = require("typedarray-pool");
function clone(array) {
    var dtype = array.dtype;
    if (dtype === "generic" || dtype === "array") dtype = "double";
    var data = pool.malloc(array.size, dtype);
    var result = ndarray(data, array.shape);
    ops.assign(result, array);
    return result;
}
exports.clone = clone;
function malloc(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    return ndarray(pool.malloc(sz, dtype), shape, stride, 0);
}
exports.malloc = malloc;
function free(array) {
    if (array.dtype === "generic" || array.dtype === "array") return;
    pool.free(array.data);
}
exports.free = free;
function zeros(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i)buf[i] = 0;
    return ndarray(buf, shape, stride, 0);
}
exports.zeros = zeros;
function ones(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i)buf[i] = 1;
    return ndarray(buf, shape, stride, 0);
}
exports.ones = ones;
function eye(shape, dtype) {
    var i, offset;
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(i = 0; i < sz; ++i)buf[i] = 0;
    var mindim = Infinity;
    var offsum = 0;
    for(i = shape.length - 1; i >= 0; i--){
        offsum += stride[i];
        mindim = Math.min(mindim, shape[i]);
    }
    for(i = 0, offset = 0; i < mindim; i++, offset += offsum)buf[offset] = 1;
    return ndarray(buf, shape, stride, 0);
}
exports.eye = eye;

},{"ndarray":"1nDU8","ndarray-ops":"kXyuI","typedarray-pool":"1RryJ"}],"1RryJ":[function(require,module,exports) {
'use strict';
var global = arguments[3];
var bits = require('bit-twiddle');
var dup = require('dup');
var Buffer = require('buffer').Buffer;
//Legacy pool support
if (!global.__TYPEDARRAY_POOL) global.__TYPEDARRAY_POOL = {
    UINT8: dup([
        32,
        0
    ]),
    UINT16: dup([
        32,
        0
    ]),
    UINT32: dup([
        32,
        0
    ]),
    BIGUINT64: dup([
        32,
        0
    ]),
    INT8: dup([
        32,
        0
    ]),
    INT16: dup([
        32,
        0
    ]),
    INT32: dup([
        32,
        0
    ]),
    BIGINT64: dup([
        32,
        0
    ]),
    FLOAT: dup([
        32,
        0
    ]),
    DOUBLE: dup([
        32,
        0
    ]),
    DATA: dup([
        32,
        0
    ]),
    UINT8C: dup([
        32,
        0
    ]),
    BUFFER: dup([
        32,
        0
    ])
};
var hasUint8C = typeof Uint8ClampedArray !== 'undefined';
var hasBigUint64 = typeof BigUint64Array !== 'undefined';
var hasBigInt64 = typeof BigInt64Array !== 'undefined';
var POOL = global.__TYPEDARRAY_POOL;
//Upgrade pool
if (!POOL.UINT8C) POOL.UINT8C = dup([
    32,
    0
]);
if (!POOL.BIGUINT64) POOL.BIGUINT64 = dup([
    32,
    0
]);
if (!POOL.BIGINT64) POOL.BIGINT64 = dup([
    32,
    0
]);
if (!POOL.BUFFER) POOL.BUFFER = dup([
    32,
    0
]);
//New technique: Only allocate from ArrayBufferView and Buffer
var DATA = POOL.DATA, BUFFER = POOL.BUFFER;
exports.free = function free(array) {
    if (Buffer.isBuffer(array)) BUFFER[bits.log2(array.length)].push(array);
    else {
        if (Object.prototype.toString.call(array) !== '[object ArrayBuffer]') array = array.buffer;
        if (!array) return;
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
    }
};
function freeArrayBuffer(buffer) {
    if (!buffer) return;
    var n = buffer.length || buffer.byteLength;
    var log_n = bits.log2(n);
    DATA[log_n].push(buffer);
}
function freeTypedArray(array) {
    freeArrayBuffer(array.buffer);
}
exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeBigUint64 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeBigInt64 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
exports.freeArrayBuffer = freeArrayBuffer;
exports.freeBuffer = function freeBuffer(array) {
    BUFFER[bits.log2(array.length)].push(array);
};
exports.malloc = function malloc(n, dtype) {
    if (dtype === undefined || dtype === 'arraybuffer') return mallocArrayBuffer(n);
    else switch(dtype){
        case 'uint8':
            return mallocUint8(n);
        case 'uint16':
            return mallocUint16(n);
        case 'uint32':
            return mallocUint32(n);
        case 'int8':
            return mallocInt8(n);
        case 'int16':
            return mallocInt16(n);
        case 'int32':
            return mallocInt32(n);
        case 'float':
        case 'float32':
            return mallocFloat(n);
        case 'double':
        case 'float64':
            return mallocDouble(n);
        case 'uint8_clamped':
            return mallocUint8Clamped(n);
        case 'bigint64':
            return mallocBigInt64(n);
        case 'biguint64':
            return mallocBigUint64(n);
        case 'buffer':
            return mallocBuffer(n);
        case 'data':
        case 'dataview':
            return mallocDataView(n);
        default:
            return null;
    }
    return null;
};
function mallocArrayBuffer(n) {
    var n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var d = DATA[log_n];
    if (d.length > 0) return d.pop();
    return new ArrayBuffer(n);
}
exports.mallocArrayBuffer = mallocArrayBuffer;
function mallocUint8(n) {
    return new Uint8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocUint8 = mallocUint8;
function mallocUint16(n) {
    return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocUint16 = mallocUint16;
function mallocUint32(n) {
    return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocUint32 = mallocUint32;
function mallocInt8(n) {
    return new Int8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocInt8 = mallocInt8;
function mallocInt16(n) {
    return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocInt16 = mallocInt16;
function mallocInt32(n) {
    return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocInt32 = mallocInt32;
function mallocFloat(n) {
    return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
function mallocDouble(n) {
    return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
function mallocUint8Clamped(n) {
    if (hasUint8C) return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
    else return mallocUint8(n);
}
exports.mallocUint8Clamped = mallocUint8Clamped;
function mallocBigUint64(n) {
    if (hasBigUint64) return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
    else return null;
}
exports.mallocBigUint64 = mallocBigUint64;
function mallocBigInt64(n) {
    if (hasBigInt64) return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
    else return null;
}
exports.mallocBigInt64 = mallocBigInt64;
function mallocDataView(n) {
    return new DataView(mallocArrayBuffer(n), 0, n);
}
exports.mallocDataView = mallocDataView;
function mallocBuffer(n) {
    n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var cache = BUFFER[log_n];
    if (cache.length > 0) return cache.pop();
    return new Buffer(n);
}
exports.mallocBuffer = mallocBuffer;
exports.clearCache = function clearCache() {
    for(var i = 0; i < 32; ++i){
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.BIGUINT64[i].length = 0;
        POOL.BIGINT64[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
    }
};

},{"bit-twiddle":"9kWjw","dup":"VRu11","buffer":"fCgem"}],"9kWjw":[function(require,module,exports) {
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */ "use strict";
"use restrict";
//Number of bits in an integer
var INT_BITS = 32;
//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 2147483647;
exports.INT_MIN = -1 << INT_BITS - 1;
//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
    return (v > 0) - (v < 0);
};
//Computes absolute value of integer
exports.abs = function(v) {
    var mask = v >> INT_BITS - 1;
    return (v ^ mask) - mask;
};
//Computes minimum of integers x and y
exports.min = function(x, y) {
    return y ^ (x ^ y) & -(x < y);
};
//Computes maximum of integers x and y
exports.max = function(x, y) {
    return x ^ (x ^ y) & -(x < y);
};
//Checks if a number is a power of two
exports.isPow2 = function(v) {
    return !(v & v - 1) && !!v;
};
//Computes log base 2 of v
exports.log2 = function(v) {
    var r, shift;
    r = (v > 65535) << 4;
    v >>>= r;
    shift = (v > 255) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 15) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 3) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
};
//Computes log base 10 of v
exports.log10 = function(v) {
    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};
//Counts number of bits
exports.popCount = function(v) {
    v = v - (v >>> 1 & 1431655765);
    v = (v & 858993459) + (v >>> 2 & 858993459);
    return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
};
//Counts number of trailing zeros
function countTrailingZeros(v) {
    var c = 32;
    v &= -v;
    if (v) c--;
    if (v & 65535) c -= 16;
    if (v & 16711935) c -= 8;
    if (v & 252645135) c -= 4;
    if (v & 858993459) c -= 2;
    if (v & 1431655765) c -= 1;
    return c;
}
exports.countTrailingZeros = countTrailingZeros;
//Rounds to next power of 2
exports.nextPow2 = function(v) {
    v += v === 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
};
//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v - (v >>> 1);
};
//Computes parity of word
exports.parity = function(v) {
    v ^= v >>> 16;
    v ^= v >>> 8;
    v ^= v >>> 4;
    v &= 15;
    return 27030 >>> v & 1;
};
var REVERSE_TABLE = new Array(256);
(function(tab) {
    for(var i = 0; i < 256; ++i){
        var v = i, r = i, s = 7;
        for(v >>>= 1; v; v >>>= 1){
            r <<= 1;
            r |= v & 1;
            --s;
        }
        tab[i] = r << s & 255;
    }
})(REVERSE_TABLE);
//Reverse bits in a 32 bit word
exports.reverse = function(v) {
    return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
};
//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
    x &= 65535;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y &= 65535;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
};
//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
    v = v >>> n & 1431655765;
    v = (v | v >>> 1) & 858993459;
    v = (v | v >>> 2) & 252645135;
    v = (v | v >>> 4) & 16711935;
    v = (v | v >>> 16) & 65535;
    return v << 16 >> 16;
};
//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
    x &= 1023;
    x = (x | x << 16) & 4278190335;
    x = (x | x << 8) & 251719695;
    x = (x | x << 4) & 3272356035;
    x = (x | x << 2) & 1227133513;
    y &= 1023;
    y = (y | y << 16) & 4278190335;
    y = (y | y << 8) & 251719695;
    y = (y | y << 4) & 3272356035;
    y = (y | y << 2) & 1227133513;
    x |= y << 1;
    z &= 1023;
    z = (z | z << 16) & 4278190335;
    z = (z | z << 8) & 251719695;
    z = (z | z << 4) & 3272356035;
    z = (z | z << 2) & 1227133513;
    return x | z << 2;
};
//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
    v = v >>> n & 1227133513;
    v = (v | v >>> 2) & 3272356035;
    v = (v | v >>> 4) & 251719695;
    v = (v | v >>> 8) & 4278190335;
    v = (v | v >>> 16) & 1023;
    return v << 22 >> 22;
};
//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
    var t = v | v - 1;
    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],"VRu11":[function(require,module,exports) {
"use strict";
function dupe_array(count, value, i) {
    var c = count[i] | 0;
    if (c <= 0) return [];
    var result = new Array(c), j;
    if (i === count.length - 1) for(j = 0; j < c; ++j)result[j] = value;
    else for(j = 0; j < c; ++j)result[j] = dupe_array(count, value, i + 1);
    return result;
}
function dupe_number(count, value) {
    var result, i;
    result = new Array(count);
    for(i = 0; i < count; ++i)result[i] = value;
    return result;
}
function dupe(count, value) {
    if (typeof value === "undefined") value = 0;
    switch(typeof count){
        case "number":
            if (count > 0) return dupe_number(count | 0, value);
            break;
        case "object":
            if (typeof count.length === "number") return dupe_array(count, value, 0);
            break;
    }
    return [];
}
module.exports = dupe;

},{}],"fCgem":[function(require,module,exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = require('base64-js');
const ieee754 = require('ieee754');
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 2147483647;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError("The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type " + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError("The \"target\" argument must be one of type Buffer or Uint8Array. Received type " + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 2147483647) byteOffset = 2147483647;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 255 // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i1;
    if (dir) {
        let foundIndex = -1;
        for(i1 = byteOffset; i1 < arrLength; i1++)if (read(arr, i1) === read(val, foundIndex === -1 ? 0 : i1 - foundIndex)) {
            if (foundIndex === -1) foundIndex = i1;
            if (i1 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i1 -= i1 - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i1 = byteOffset; i1 >= 0; i1--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i1 + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i1;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 128) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 192) === 128) {
                        tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                        if (tempCodePoint > 127) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                        if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                        tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                        if (tempCodePoint > 65535 && tempCodePoint < 1114112) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 65533;
            bytesPerSequence = 1;
        } else if (codePoint > 65535) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 127);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength1, noAssert) {
    offset = offset >>> 0;
    byteLength1 = byteLength1 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength1, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength1 && (mul *= 256))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset + --byteLength2];
    let mul = 1;
    while(byteLength2 > 0 && (mul *= 256))val += this[offset + --byteLength2] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 65536 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength3 && (mul *= 256))val += this[offset + i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength4, noAssert) {
    offset = offset >>> 0;
    byteLength4 = byteLength4 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength4, this.length);
    let i = byteLength4;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 256))val += this[offset + --i] * mul;
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 65536 + (last << 24) // Overflow
    ;
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 65536 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + this[++offset] * 65536 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 65536 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength5, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength5 = byteLength5 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength5) - 1;
        checkInt(this, value, offset, byteLength5, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while(++i < byteLength5 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength5;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength6, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength6 = byteLength6 >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength6) - 1;
        checkInt(this, value, offset, byteLength6, maxBytes, 0);
    }
    let i = byteLength6 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256))this[offset + i] = value / mul & 255;
    return offset + byteLength6;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength7, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength7 - 1);
        checkInt(this, value, offset, byteLength7, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while(++i < byteLength7 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength7;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength8, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength8 - 1);
        checkInt(this, value, offset, byteLength8, limit - 1, -limit);
    }
    let i = byteLength8 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while(--i >= 0 && (mul *= 256)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength8;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {
};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength9) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength9] === undefined) boundsError(offset, buf.length - (byteLength9 + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength10) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength10 > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength10 + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength10 + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength10 + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength10);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 55295 && codePoint < 57344) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 56319) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 56320) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 255);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}

},{"base64-js":"eIiSV","ieee754":"cO95r"}],"eIiSV":[function(require,module,exports) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len1 = b64.length;
    if (len1 % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len1;
    var placeHoldersLen = validLen === len1 ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i1;
    for(i1 = 0; i1 < len2; i1 += 4){
        tmp = revLookup[b64.charCodeAt(i1)] << 18 | revLookup[b64.charCodeAt(i1 + 1)] << 12 | revLookup[b64.charCodeAt(i1 + 2)] << 6 | revLookup[b64.charCodeAt(i1 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i1)] << 2 | revLookup[b64.charCodeAt(i1 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i1)] << 10 | revLookup[b64.charCodeAt(i1 + 1)] << 4 | revLookup[b64.charCodeAt(i1 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i2 = start; i2 < end; i2 += 3){
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len3 = uint8.length;
    var extraBytes = len3 % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i3 = 0, len2 = len3 - extraBytes; i3 < len2; i3 += maxChunkLength)parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len2 ? len2 : i3 + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len3 - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len3 - 2] << 8) + uint8[len3 - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + '=');
    }
    return parts.join('');
}

},{}],"cO95r":[function(require,module,exports) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"7V1A8":[function(require,module,exports) {
"use strict";
var bits = require("bit-twiddle");
function rootInorder(n) {
    var ptree = (bits.nextPow2(n + 1) >>> 1) - 1;
    var f = n - ptree;
    if (bits.nextPow2(f) - 1 >= ptree) return ptree;
    return (ptree >>> 1) + f;
}
exports.root = rootInorder;
function beginInorder(n) {
    return 0;
}
exports.begin = beginInorder;
function endInorder(n) {
    return n - 1;
}
exports.end = endInorder;
//This is really horrible because n is not necessarily a power of 2
// If it was, we could just do:
//
//    height = bits.countTrailingZeros(~x)
//
// Instead, we just binary search because doing the right thing here is way too complicated.
function heightInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return heightInorder(n - r - 1, x - r - 1);
    else if (x === r) return bits.log2(n);
    return heightInorder(r, x);
}
exports.height = heightInorder;
function prevInorder(n, x) {
    return Math.max(x - 1, 0);
}
exports.prev = prevInorder;
function nextInorder(n, x) {
    return Math.min(x + 1, n - 1);
}
exports.next = nextInorder;
//The version for n = (1<<k)-1:
//
//  parent = (x & ~(1<<(h+1))) + (1<<h)
//
function parentInorder(n, x) {
    if (n <= 0) return -1;
    var r = rootInorder(n);
    if (x > r) {
        var q = parentInorder(n - r - 1, x - r - 1);
        if (q < 0) return r;
        else return q + r + 1;
    } else if (x === r) return -1;
    var q = parentInorder(r, x);
    if (q < 0) return r;
    return q;
}
exports.parent = parentInorder;
//Again, we get screwed because n is not a power of two -1.  If it was, we could do:
//
//    left = x - (1 << (h-1) )
//
// Where h is the height of the node
//
function leftInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return leftInorder(n - r - 1, x - r - 1) + r + 1;
    else if (x === r) return rootInorder(x);
    return leftInorder(r, x);
}
exports.left = leftInorder;
//for power of two minus one:
//
//    right = x + (1<<(h-1))
//
function rightInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return rightInorder(n - r - 1, x - r - 1) + r + 1;
    else if (x === r) return rootInorder(n - r - 1) + r + 1;
    return rightInorder(r, x);
}
exports.right = rightInorder;
function leafInorder(n, x) {
    return heightInorder(n, x) === 0;
}
exports.leaf = leafInorder;
function loInorder(n, x) {
    n |= 0;
    x |= 0;
    var l = 0;
    while(n > 1){
        var r = rootInorder(n);
        if (x > r) {
            l += r + 1;
            n -= r + 1;
            x -= r + 1;
        } else if (x === r) break;
        else n = r;
    }
    return l;
}
exports.lo = loInorder;
function hiInorder(n, x) {
    n |= 0;
    x |= 0;
    var l = 0;
    while(n > 1){
        var r = rootInorder(n);
        if (x > r) {
            l += r + 1;
            n -= r + 1;
            x -= r + 1;
        } else if (x === r) {
            l += n - 1;
            break;
        } else n = r;
    }
    return l;
}
exports.hi = hiInorder;

},{"bit-twiddle":"aFqxf"}],"aFqxf":[function(require,module,exports) {
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */ "use strict";
"use restrict";
//Number of bits in an integer
var INT_BITS = 32;
//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 2147483647;
exports.INT_MIN = -1 << INT_BITS - 1;
//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
    return (v > 0) - (v < 0);
};
//Computes absolute value of integer
exports.abs = function(v) {
    var mask = v >> INT_BITS - 1;
    return (v ^ mask) - mask;
};
//Computes minimum of integers x and y
exports.min = function(x, y) {
    return y ^ (x ^ y) & -(x < y);
};
//Computes maximum of integers x and y
exports.max = function(x, y) {
    return x ^ (x ^ y) & -(x < y);
};
//Checks if a number is a power of two
exports.isPow2 = function(v) {
    return !(v & v - 1) && !!v;
};
//Computes log base 2 of v
exports.log2 = function(v) {
    var r, shift;
    r = (v > 65535) << 4;
    v >>>= r;
    shift = (v > 255) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 15) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 3) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
};
//Computes log base 10 of v
exports.log10 = function(v) {
    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};
//Counts number of bits
exports.popCount = function(v) {
    v = v - (v >>> 1 & 1431655765);
    v = (v & 858993459) + (v >>> 2 & 858993459);
    return (v + (v >>> 4) & 252645135) * 16843009 >>> 24;
};
//Counts number of trailing zeros
function countTrailingZeros(v) {
    var c = 32;
    v &= -v;
    if (v) c--;
    if (v & 65535) c -= 16;
    if (v & 16711935) c -= 8;
    if (v & 252645135) c -= 4;
    if (v & 858993459) c -= 2;
    if (v & 1431655765) c -= 1;
    return c;
}
exports.countTrailingZeros = countTrailingZeros;
//Rounds to next power of 2
exports.nextPow2 = function(v) {
    v += v === 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
};
//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v - (v >>> 1);
};
//Computes parity of word
exports.parity = function(v) {
    v ^= v >>> 16;
    v ^= v >>> 8;
    v ^= v >>> 4;
    v &= 15;
    return 27030 >>> v & 1;
};
var REVERSE_TABLE = new Array(256);
(function(tab) {
    for(var i = 0; i < 256; ++i){
        var v = i, r = i, s = 7;
        for(v >>>= 1; v; v >>>= 1){
            r <<= 1;
            r |= v & 1;
            --s;
        }
        tab[i] = r << s & 255;
    }
})(REVERSE_TABLE);
//Reverse bits in a 32 bit word
exports.reverse = function(v) {
    return REVERSE_TABLE[v & 255] << 24 | REVERSE_TABLE[v >>> 8 & 255] << 16 | REVERSE_TABLE[v >>> 16 & 255] << 8 | REVERSE_TABLE[v >>> 24 & 255];
};
//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
    x &= 65535;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y &= 65535;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
};
//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
    v = v >>> n & 1431655765;
    v = (v | v >>> 1) & 858993459;
    v = (v | v >>> 2) & 252645135;
    v = (v | v >>> 4) & 16711935;
    v = (v | v >>> 16) & 65535;
    return v << 16 >> 16;
};
//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
    x &= 1023;
    x = (x | x << 16) & 4278190335;
    x = (x | x << 8) & 251719695;
    x = (x | x << 4) & 3272356035;
    x = (x | x << 2) & 1227133513;
    y &= 1023;
    y = (y | y << 16) & 4278190335;
    y = (y | y << 8) & 251719695;
    y = (y | y << 4) & 3272356035;
    y = (y | y << 2) & 1227133513;
    x |= y << 1;
    z &= 1023;
    z = (z | z << 16) & 4278190335;
    z = (z | z << 8) & 251719695;
    z = (z | z << 4) & 3272356035;
    z = (z | z << 2) & 1227133513;
    return x | z << 2;
};
//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
    v = v >>> n & 1227133513;
    v = (v | v >>> 2) & 3272356035;
    v = (v | v >>> 4) & 251719695;
    v = (v | v >>> 8) & 4278190335;
    v = (v | v >>> 16) & 1023;
    return v << 22 >> 22;
};
//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
    var t = v | v - 1;
    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],"epTUT":[function(require,module,exports) {
"use strict";
module.exports = KDTHeap;
var pool = require("typedarray-pool");
function heapParent(i) {
    if (i & 1) return i - 1 >> 1;
    return (i >> 1) - 1;
}
function KDTHeap(n, d) {
    this.count = 0;
    this.dataSize = d;
    this.index = pool.mallocInt32(n);
    this.data = pool.mallocFloat64(n * d);
}
var proto = KDTHeap.prototype;
proto.heapSwap = function(_i, _j) {
    var data = this.data;
    var index = this.index;
    var d = this.dataSize;
    var tmp = index[_i];
    index[_i] = index[_j];
    index[_j] = tmp;
    var aptr = d * _i;
    var bptr = d * _j;
    for(var _k = 0; _k < d; ++_k){
        var t2 = data[aptr];
        data[aptr] = data[bptr];
        data[bptr] = t2;
        aptr += 1;
        bptr += 1;
    }
};
proto.heapUp = function(i) {
    var d = this.dataSize;
    var index = this.index;
    var data = this.data;
    var w = data[d * i];
    while(i > 0){
        var parent = heapParent(i);
        if (parent >= 0) {
            var pw = data[d * parent];
            if (w < pw) {
                this.heapSwap(i, parent);
                i = parent;
                continue;
            }
        }
        break;
    }
};
proto.heapDown = function(i) {
    var d = this.dataSize;
    var index = this.index;
    var data = this.data;
    var count = this.count;
    var w = data[d * i];
    while(true){
        var tw = w;
        var left = 2 * i + 1;
        var right = 2 * (i + 1);
        var next = i;
        if (left < count) {
            var lw = data[d * left];
            if (lw < tw) {
                next = left;
                tw = lw;
            }
        }
        if (right < count) {
            var rw = data[d * right];
            if (rw < tw) next = right;
        }
        if (next === i) break;
        this.heapSwap(i, next);
        i = next;
    }
};
//Clear item from top of heap
proto.pop = function() {
    this.count -= 1;
    this.heapSwap(0, this.count);
    this.heapDown(0);
};
//Assume object already written to data
proto.push = function() {
    this.heapUp(this.count);
    this.count += 1;
};
proto.dispose = function() {
    pool.freeInt32(this.index);
    pool.freeFloat64(this.data);
};

},{"typedarray-pool":"1RryJ"}],"1UeYf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _closestPoint = require("./closestPoint");
var _closestPointDefault = parcelHelpers.interopDefault(_closestPoint);
var _getHorizontalCurve = require("./getHorizontalCurve");
var _getHorizontalCurveDefault = parcelHelpers.interopDefault(_getHorizontalCurve);
var _getCorrectMidPoints = require("./getCorrectMidPoints");
var _getCorrectMidPointsDefault = parcelHelpers.interopDefault(_getCorrectMidPoints);
function refreshRelationships({ relationships , nodes , dx =0 , dy =0 ,  }) {
    relationships.forEach((r)=>{
        const midPoints = _getCorrectMidPointsDefault.default(r);
        let tempOriginNode;
        let tempEndNode;
        let linePath;
        if (nodes.some((n)=>n.options.id === r.parent.options.id
        )) {
            tempOriginNode = r.parent.getTempPathWithCorrectPositionFor({
                pathElement: r.parent.vect,
                dx,
                dy
            });
            tempEndNode = r.child.getTempPathWithCorrectPositionFor({
                // this one is all about rotation
                pathElement: r.child.vect,
                dx: 0,
                dy: 0
            });
            const childPathContext = _closestPointDefault.default(tempEndNode || r.child.vect, midPoints.parent);
            const pointOnChildPath = childPathContext.bestPoint;
            const parentPathContext = _closestPointDefault.default(tempOriginNode || r.parent.vect, pointOnChildPath);
            const pointOnParentPath = parentPathContext.bestPoint;
            linePath = _getHorizontalCurveDefault.default(pointOnParentPath, pointOnChildPath);
        } else {
            tempEndNode = r.child.getTempPathWithCorrectPositionFor({
                pathElement: r.child.vect,
                dx,
                dy
            });
            tempOriginNode = r.parent.getTempPathWithCorrectPositionFor({
                // this one is all about rotation
                pathElement: r.parent.vect,
                dx: 0,
                dy: 0
            });
            const childPathContext = _closestPointDefault.default(tempEndNode || r.child.vect, midPoints.parent);
            const pointOnChildPath = childPathContext.bestPoint;
            const parentPathContext = _closestPointDefault.default(tempOriginNode || r.parent.vect, pointOnChildPath);
            const pointOnParentPath = parentPathContext.bestPoint;
            linePath = _getHorizontalCurveDefault.default(pointOnParentPath, pointOnChildPath);
        }
        const _attr = {
            stroke: r.lineColor,
            fill: 'none',
            'stroke-width': r.lineWidth,
            'fill-opacity': r.lineOpacity,
            opacity: r.lineOpacity,
            filter: r.lineEffect ? `url(#${r.lineEffect})` : ''
        };
        // stop connection re-draws when shift+alt drag until the move is up because the lines are hidden anyways
        if (!(r.isAlt && r.isShift) || r.isAlt && r.isShift && r.isUp) _attr.path = linePath;
        if (r.showChildArrow) Object.assign(_attr, {
            'arrow-end': 'classic'
        });
        else Object.assign(_attr, {
            'arrow-end': 'none'
        });
        if (r.showParentArrow) Object.assign(_attr, {
            'arrow-start': 'classic'
        });
        else Object.assign(_attr, {
            'arrow-start': 'none'
        });
        r.line.attr(_attr);
        if (tempOriginNode) tempOriginNode.remove();
        if (tempEndNode) tempEndNode.remove();
    });
    // always push the grid back
    if (nodes.length > 0) {
        nodes[0].slate?.grid?.toBack();
        nodes[0].slate?.canvas?.bgToBack();
    }
}
exports.default = refreshRelationships;

},{"./closestPoint":"6gfM6","./getHorizontalCurve":"dzUMr","./getCorrectMidPoints":"b3ZJc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6gfM6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function closestPoint(pathNode, point) {
    const pathLength = pathNode.getTotalLength();
    let precision = 64 // increase this value for better performance at a risk of worse point approximation; in future this should be scaled according to number of path segments (there could be a better solution)
    ;
    let best;
    let bestLength;
    let bestDistance = Infinity;
    function distance2(p) {
        // squared distance between two points
        const dx = p.x - point.x;
        const dy = p.y - point.y;
        return dx * dx + dy * dy;
    }
    // linear scan for coarse approximation
    for(let scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision)if ((scanDistance = distance2(scan = pathNode.getPointAtLength(scanLength))) < bestDistance) best = scan, bestLength = scanLength, bestDistance = scanDistance;
    // binary search for precise estimate
    precision /= 2;
    while(precision > 0.5){
        let before;
        let after;
        let beforeLength;
        let afterLength;
        let beforeDistance;
        let afterDistance;
        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pathNode.getPointAtLength(beforeLength))) < bestDistance) best = before, bestLength = beforeLength, bestDistance = beforeDistance;
        else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pathNode.getPointAtLength(afterLength))) < bestDistance) best = after, bestLength = afterLength, bestDistance = afterDistance;
        else precision /= 2;
    }
    return {
        bestPoint: best,
        bestLength
    };
}
exports.default = closestPoint;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dzUMr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getHorizontalCurve(originPoint, endPoint) {
    const x1 = originPoint.x;
    const y1 = originPoint.y;
    const x2 = endPoint.x;
    const y2 = endPoint.y;
    const middlePointX = (x1 + x2) / 2;
    return [
        'M',
        x1.toFixed(2),
        y1.toFixed(2),
        'C',
        middlePointX.toFixed(2),
        y1.toFixed(2),
        middlePointX.toFixed(2),
        y2.toFixed(2),
        x2.toFixed(2),
        y2.toFixed(2), 
    ].join(' ');
}
exports.default = getHorizontalCurve;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b3ZJc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
function getCorrectMidPoints(opts = {
}) {
    const originBB = opts.parent ? opts.parent.vect.getBBox() : opts.parent.vect.getBBox();
    const endBB = opts.child ? opts.child.vect.getBBox() : opts.child.vect.getBBox();
    function inn(val) {
        return !Number.isNaN(parseFloat(val)) && Number.isFinite(val);
    }
    const pcx = inn(originBB.cx) && originBB.cx;
    const pcy = inn(originBB.cy) && originBB.cy;
    const ccx = inn(endBB.cx) && endBB.cx;
    const ccy = inn(endBB.cy) && endBB.cy;
    let relevantParentMiddlePoint;
    const px1 = originBB.x;
    const py1 = originBB.y;
    const px2 = originBB.x2;
    const py2 = originBB.y;
    const px3 = originBB.x2;
    const py3 = originBB.y2;
    const px4 = originBB.x;
    const py4 = originBB.y2;
    /*
    generic line equation
    y = ((y2-y1)/(x2-x1)) * (x-x1) + y1

    line 1: line passing through upper left corner and bottom right corner
    y = ((py3 - py1)/(px3 - px1)) * (x - px1) + py1

    line 2: line passing through bottom left corner and upper right corner
    y = ((py2 - py4)/(px2 - px4)) * (x - px4) + py4
   */ // NOTE: comments below apply to a Cartesian coordinate system; the svg coordinate system is slightly different with (0,0) in upper left corner of the plane
    // it means that regular above means below here
    if (ccy >= (py3 - py1) / (px3 - px1) * (ccx - px1) + py1) {
        // means that child center point is above line 1
        if (ccy >= (py2 - py4) / (px2 - px4) * (ccx - px4) + py4) // means that child center point is above line 2
        relevantParentMiddlePoint = {
            x: pcx,
            y: py3
        };
        else // means that child center point is either below line 2 or is on line 2
        relevantParentMiddlePoint = {
            x: px1,
            y: pcy
        };
    } else // means that child center point is below line 1
    if (ccy >= (py2 - py4) / (px2 - px4) * (ccx - px4) + py4) // means that child center point is above line 2
    relevantParentMiddlePoint = {
        x: px2,
        y: pcy
    };
    else // means that child center point is either below line 2 or is on line 2
    relevantParentMiddlePoint = {
        x: pcx,
        y: py1
    };
    let relevantChildMiddlePoint;
    const cx1 = endBB.x;
    const cy1 = endBB.y;
    const cx2 = endBB.x2;
    const cy2 = endBB.y;
    const cx3 = endBB.x2;
    const cy3 = endBB.y2;
    const cx4 = endBB.x;
    const cy4 = endBB.y2;
    /*
   generic line equation
   y = ((y2-y1)/(x2-x1)) * (x-x1) + y1

   line 1: line passing through upper left corner and bottom right corner
   y = ((cy3 - cy1)/(cx3 - cx1)) * (x - cx1) + cy1

   line 2: line passing through bottom left corner and upper right corner
   y = ((cy2 - cy4)/(cx2 - cx4)) * (x - cx4) + cy4
   */ // NOTE: comments below apply to a Cartesian coordinate system; the svg coordinate system is slightly different with (0,0) in upper left corner of the plane
    // it means that regular above means below here
    if (pcy >= (cy3 - cy1) / (cx3 - cx1) * (pcx - cx1) + cy1) {
        // means that child center point is above line 1
        if (pcy >= (cy2 - cy4) / (cx2 - cx4) * (pcx - cx4) + cy4) // means that child center point is above line 2
        relevantChildMiddlePoint = {
            x: ccx,
            y: cy3
        };
        else // means that child center point is either below line 2 or is on line 2
        relevantChildMiddlePoint = {
            x: cx1,
            y: ccy
        };
    } else // means that child center point is below line 1
    if (pcy >= (cy2 - cy4) / (cx2 - cx4) * (pcx - cx4) + cy4) // means that child center point is above line 2
    relevantChildMiddlePoint = {
        x: cx2,
        y: ccy
    };
    else // means that child center point is either below line 2 or is on line 2
    relevantChildMiddlePoint = {
        x: ccx,
        y: cy1
    };
    return {
        child: relevantChildMiddlePoint,
        parent: relevantParentMiddlePoint
    };
}
exports.default = getCorrectMidPoints;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6en3b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-use-before-define */ /* eslint-disable no-underscore-dangle */ var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class rotate {
    static getRotationAngle(origPoint, newPoint, centerPoint) {
        const vx = origPoint.x - centerPoint.x;
        const vy = origPoint.y - centerPoint.y;
        const ux = newPoint.x - centerPoint.x;
        const uy = newPoint.y - centerPoint.y;
        const magnitudeV = Math.sqrt(vx ** 2 + vy ** 2);
        const magnitudeU = Math.sqrt(ux ** 2 + uy ** 2);
        let angleDegrees;
        if (vx === 0 && vy === 0 || ux === 0 && uy === 0 || vx === ux && vy === uy) ;
        else {
            const cosine = (vx * ux + vy * uy) / (magnitudeV * magnitudeU);
            const angleRadians = Math.acos(cosine);
            angleDegrees = angleRadians * 180 / Math.PI // unsigned angle
            ;
            const detVxU = vx * uy - vy * ux // cross product of V and U (VxU)
            ;
            if (detVxU < 0) angleDegrees = -angleDegrees // add negative sign
            ;
        }
        return angleDegrees;
    }
    rta() {
        const self = this;
        self.rotate.transform(`R${self.rotationAngle}, ${self.origCenter.x}, ${self.origCenter.y}`);
        const rotationContext = {
            rotate: {
                rotationAngle: (self.node.options.rotate.rotationAngle + self.rotationAngle) % 360,
                point: self.origCenter
            }
        };
        const transformString = self.node.getTransformString(rotationContext);
        self.node.vect.transform(transformString);
        self.node.text.transform(transformString);
    }
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.rotate = null;
        self.rotateTemp = null;
        self._dragAllowed = false;
        self._isResizing = false;
        self._initPosFix = false;
        self.origCenter = {
        } // during rotation raphael changes the center point of bbox for some reason
        ;
        self.rotationAngle = null;
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.selectedNodes = [];
        self.rotateEvents = {
            start () {
                const s = this;
                self.selectedNodes = self.node.relationships.getSelectedNodes();
                const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
                self.relationshipsToTranslate = _associations.relationshipsToTranslate;
                self.relationshipsToRefresh = _associations.relationshipsToRefresh;
                self.slate.isBeingResized = true;
                self._initPosFix = false;
                self.rotateTemp.attr({
                    x: self.rotateTemp.attr('x') - 1000,
                    y: self.rotateTemp.attr('y') - 1000,
                    width: 10000,
                    height: 10000
                });
                self.rotate.ox = self.rotate.attr('x');
                self.rotate.oy = self.rotate.attr('y');
                self.node.relationships.updateAssociationsWith({
                    activeNode: self.node.options.id,
                    currentDx: 0,
                    currentDy: 0,
                    action: 'rotate'
                });
                self._isResizing = true;
                const tempPath = self.slate.paper.path(self.node.vect.attr('path'));
                const noRotationBB = tempPath.getBBox();
                if (!self.node.options.rotate?.point || Object.entries(self.node.options.rotate.point).length === 0) self.node.options.rotate.point = {
                    x: noRotationBB.cx,
                    y: noRotationBB.cy
                };
                tempPath.remove();
                self.slate.multiSelection?.end();
                s.ox = noRotationBB.x;
                s.oy = noRotationBB.y;
                self.origCenter = self.node.options.rotate.point;
                self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>n.options.id !== self.node.options.id
                ).map((n)=>({
                        id: n.options.id,
                        bbox: n.vect.getBBox(),
                        point: [
                            n.options.xPos,
                            n.options.yPos
                        ]
                    })
                );
                self.kdTree = _staticKdtreeDefault.default(self.foreignPoints.map((fp)=>fp.point
                ));
                self.node.setStartDrag();
                self.node.connectors.remove();
                self.node.resize.hide();
                self._dragAllowed = self.slate.options.allowDrag;
                self.slate.disable(false, true);
                self.slate.toggleFilters(true, self.node.options.id);
            },
            move (dx, dy) {
                const s = this;
                try {
                    // for snapping
                    const nearest = self.kdTree.knn([
                        node.options.xPos,
                        node.options.yPos
                    ], 5);
                    nearest.forEach((n)=>{
                        self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox, false, 200);
                    });
                    /*
          Rotation angle is obtained using vector properties. Further explanation can be found here: https://stackoverflow.com/questions/10507620/finding-the-angle-between-vectors
          Vectors are of form:
          v = <vx, vy>
          u = <ux, uy>
          Notation explanation:
          ||v|| - magnitude of vector v
          v . u - dot product of vectors u and v (commutative)
          v x u - cross product of vectors v and u (not commutative!); for 2D vectors it is essentially the determinant of a 2D matrix created by v and u
    
          cos(angle) = (v . u)/(||v|| * ||u||)
          angle = arccos((v . u)/(||v|| * ||u||))
          angle is unsigned, i.e. it assumes values 0 and PI radians
    
          If v x u < 0 then the angle needs a negative sign; otherwise the sign is already correct.
    
          If either vector is a 0 vector, i.e. v = <0, 0> or u = <0, 0> then the angle between v and u does not exist
          and the function will return an undefined angle.
    
          The returned angle is converted to degrees and is between -180 and 180.
          */ self.rotationAngle = rotate.getRotationAngle({
                        x: s.ox,
                        y: s.oy
                    }, {
                        x: s.ox + dx,
                        y: s.oy + dy
                    }, self.origCenter);
                    if (self.rotationAngle) // const _ra = Math.abs(Math.ceil(self.node.vect.matrix.split().rotate));
                    // const _ra = Math.abs(Math.ceil(self.rotationAngle)); //
                    // if (!self.node.snappedAt && ([0, 45, 90, 135, 180, 225, 270].indexOf(_ra) > -1)) { //% 45 === 0 || _ra === 0 || (_ra + 1) % 270 === 0)) {
                    //   console.log("snapped ra is ", self.node.options.rotate.rotationAngle, self.rotationAngle, _ra, self.node.vect.matrix.split().rotate);
                    //   //self.rotationAngle = _ra;
                    //   //self.rotationAngle = Math.abs(Math.ceil(self.rotationAngle));
                    //   self.node.snappedAt = _ra; // self.rotationAngle;
                    //   _rta();
                    // } else if (self.rotationAngle >= self.node.snappedAt + 25 || self.rotationAngle <= self.node.snappedAt - 25) {
                    //   delete self.node.snappedAt;
                    // }
                    {
                        if (!self.node.snappedAt) self.rta();
                    }
                } catch (err) {
                    finalize();
                }
            },
            up () {
                finalize();
                self.slate.toggleFilters(false, self.node.options.id);
            }
        };
        function finalize() {
            const _ran = self.node.snappedAt || self.rotationAngle;
            if (_ran) {
                const rotationContext = {
                    rotationAngle: (self.node.options.rotate.rotationAngle + _ran) % 360,
                    point: self.origCenter
                };
                Object.assign(self.node.options.rotate, rotationContext);
                const bb = self.node.vect.getBBox();
                self.node.options.width = bb.width;
                self.node.options.height = bb.height;
                self.rotateTemp.remove();
                self.node.relationships.updateAssociationsWith({
                    rotationAngle: self.node.options.rotate.rotationAngle
                });
                self.node.gridLines.clear();
                delete self.foreignPoints;
                delete self.kdTree;
                delete self.node.snappedAt;
            }
            self.slate.isBeingResized = false;
            self.node.menu.hide();
            self._isResizing = false;
            self.slate.enable(false, true);
            self.node.setEndDrag();
            self.node.relationships.refreshOwnRelationships();
            self.node.relationships.showOwn();
            self.rotate.remove();
            if (self.node.events?.onRotated?.apply) self.node.events?.onRotated?.apply(self, [
                _self.send
            ]);
            else self.send();
        }
    }
    show(x, y) {
        const self = this;
        if (self.node.options.allowResize) {
            self.rotateTemp?.remove();
            const r = self.slate.paper;
            self.rotate = r.path('M16.659,24c-5.078,0-9.213-3.987-9.475-9h2.975l-4.5-5l-4.5,5h3.025 c0.264,6.671,5.74,12,12.475,12c3.197,0,6.104-1.21,8.315-3.185l-2.122-2.122C21.188,23.127,19.027,24,16.659,24z M29.133,14c-0.265-6.669-5.74-12-12.475-12c-3.197,0-6.104,1.21-8.315,3.185   l2.122,2.122C12.129,5.873,14.29,5,16.659,5c5.077,0,9.213,3.987,9.475,9h-2.975l4.5,5l4.5-5H29.133z').attr({
                fill: '#fff',
                stroke: '#000',
                x: x - 5,
                y: y - 5
            });
            let rotatePathBB = self.rotate.getBBox();
            const rotatePathString = _utilsDefault.default._transformPath(self.rotate.attr('path'), `T${x - rotatePathBB.x - 15},${y - rotatePathBB.y - 15}`);
            self.rotate.attr({
                path: rotatePathString
            });
            rotatePathBB = self.rotate.getBBox();
            self.rotateTemp = r.rect(rotatePathBB.x, rotatePathBB.y, rotatePathBB.width, rotatePathBB.height).attr({
                fill: '#f00',
                opacity: 0.00000001
            }).toFront();
            self.rotate.mouseover((e)=>{
                self.rotate.attr({
                    cursor: 'alias'
                });
            });
            self.rotateTemp.mouseover((e)=>{
                self.rotateTemp.attr({
                    cursor: 'alias'
                });
            });
            self.rotateTemp.drag(self.rotateEvents.move, self.rotateEvents.start, self.rotateEvents.up);
        }
        return self.rotate;
    }
    hide() {
        this.rotate?.remove();
        this.rotateTemp?.remove();
    }
    send() {
        // broadcast change to birdsEye and collaborators
        const pkg = {
            type: 'onNodeRotated',
            data: {
                id: this.node.options.id,
                rotate: this.node.options.rotate,
                textOffset: this.node.options.textOffset,
                imageOrigWidth: this.node.options.imageOrigWidth,
                imageOrigHeight: this.node.options.imageOrigHeight,
                associations: this.node.relationships.associations.map((a)=>({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr('path').toString()
                    })
                )
            }
        };
        this.slate.birdsEye?.nodeChanged(pkg);
        this.slate.collab?.send(pkg);
    }
    applyImageRotation(opts = {
    }) {
        const { r  } = this.slate.options.viewPort.zoom;
        this.node.vect.transform('');
        this.node.text.transform('');
        const boundingClientRect = opts.boundingClientRect || this.node.vect[0].getBoundingClientRect();
        // clone current node to get actual dimensions with no hidden transforms (transform("") doesn't affect bbox -- it still has dimensions as if transforms were still there)
        const tempPath = this.slate.paper.path(this.node.vect.attr('path'));
        const bb = tempPath.getBBox();
        const transformString = this.node.getTransformString(opts);
        this.node.vect.transform(transformString);
        this.node.text.transform(transformString);
        if (this.node.vect.pattern) {
            const img = this.node.vect.pattern.getElementsByTagName('image')[0];
            img.setAttribute('y', (boundingClientRect.height / r - bb.height) / 2 - 4);
            img.setAttribute('x', (boundingClientRect.width / r - bb.width) / 2 - 4);
        }
        tempPath.remove();
    }
    animateSet(data, opts) {
        const self = this;
        const transformString = `...R${data.rotationAngle},${data.rotate.point.x}, ${data.rotate.point.y}`;
        self.node.vect.animate({
            transform: transformString
        }, opts.duration || 500, opts.easing || '>', ()=>{
            const tstr = self.node.getTransformString();
            self.node.vect.transform(tstr);
            // self.node.text.transform(tstr);
            if (opts.cb) opts.cb();
        });
        self.node.text.animate({
            transform: transformString
        }, opts.duration || 500, opts.easing || '>', ()=>{
            const tstr = self.node.getTransformString();
            self.node.text.transform(tstr);
        });
        opts.associations.forEach((assoc)=>{
            const a = self.node.relationships.associations.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId
            );
            if (a) a.line.animate({
                path: assoc.linePath
            }, opts.duration || 500, opts.easing || '>', ()=>{
                a.line.attr({
                    path: assoc.linePath
                });
            });
        });
    }
}
exports.default = rotate;

},{"static-kdtree":"i8GTt","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"91LgF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
class menu {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this._m = null;
        this._isOpen = false;
    }
    isOpen() {
        return this._isOpen;
    }
    show() {
        const self = this;
        const r = self.slate.paper;
        if (self._m) {
            _lodashInvokeDefault.default(self._m, 'remove');
            self._m = null;
        }
        const bb = self.node.vect.getBBox();
        const _x = bb.x;
        const _y = bb.y;
        self._m = r.set();
        self._isOpen = true;
        // right, bottom, and settings connectors
        self.node.connectors.show(_x, _y, self._m, ()=>{
            if (self.slate.events?.onMenuRequested) self.slate.events?.onMenuRequested(self.node, ()=>{
            });
        });
    }
    hide(exceptionElemId) {
        if (this._m) {
            this._m.forEach((m)=>{
                if (m.id !== exceptionElemId) m.remove();
            });
            this._m.items = exceptionElemId ? null : this._m.items.filter((item)=>item.id !== exceptionElemId
            );
            this.node?.connectors?.iconBar?.remove();
        }
        this.node.rotate.hide();
        this._isOpen = false;
    }
}
exports.default = menu;

},{"lodash.invoke":"6VYuy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h710n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable new-cap */ /* eslint-disable no-underscore-dangle */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class connectors {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.buttons = null;
        this.iconBar = null;
        this._lastUnpinned = {
            options: {
                xPos: null,
                width: null,
                yPos: null
            }
        };
    }
    _broadcast(_snap) {
        const pkg = {
            type: 'onNodeAdded',
            data: this.slate.exportDifference(_snap)
        };
        this.slate.collab && this.slate.collab.send(pkg);
    }
    remove() {
        const self = this;
        if (self.buttons) Object.keys(self.buttons).forEach((btn)=>{
            self.buttons[btn].remove();
        });
        self.iconBar?.remove();
        self.node.menu._isOpen = false;
    }
    removeSettingsButton() {
        this.buttons.setting.remove();
    }
    show(x, y, _m, onSettingsClicked) {
        const self = this;
        const r = self.slate.paper;
        const bb = self.node.vect.getBBox();
        const widthOffset = bb.width / 2;
        const btnAttr = {
            fill: '#fff',
            stroke: '#000'
        };
        function conditionallyShow(nodeType) {
            switch(nodeType){
                case 'delete':
                    if (self.node.options.showDelete) self.buttons.trash = r.trash().transform([
                        't',
                        x + widthOffset - 80,
                        ',',
                        y - 58
                    ].join()).attr({
                        fill: '#fff',
                        stroke: '#f00'
                    });
                    else if (self.node.options.showAddAndDeleteConditionally && self.node.options.copiedFromId) {
                        const copiedTimestamps = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId
                        ).map((nx)=>nx.options.copiedAt
                        );
                        if (self.node.options.copiedAt >= Math.max(...copiedTimestamps)) self.buttons.trash = r.trash().transform([
                            't',
                            x + widthOffset - 80,
                            ',',
                            y - 58
                        ].join()).attr({
                            fill: '#fff',
                            stroke: '#f00'
                        });
                    }
                    break;
                case 'add':
                    {
                        const copies = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.id
                        ).length;
                        if (self.node.options.showAdd || copies === 0 && self.node.options.showAddAndDeleteConditionally && !self.node.options.copiedFromId) self.buttons.unPinned = r.plus().transform([
                            't',
                            x + widthOffset + 40,
                            ',',
                            y - 58
                        ].join()).attr(btnAttr);
                        else if (self.node.options.showAddAndDeleteConditionally && self.node.options.copiedFromId) {
                            const copiedTimestamps = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId
                            ).map((nx)=>nx.options.copiedAt
                            );
                            if (self.node.options.copiedAt >= Math.max(...copiedTimestamps)) self.buttons.unPinned = r.plus().transform([
                                't',
                                x + widthOffset + 40,
                                ',',
                                y - 58
                            ].join()).attr(btnAttr);
                        }
                        break;
                    }
                default:
                    break;
            }
        }
        self.buttons = {
        };
        if (self.slate.isCommentOnly() && self.node.options.isComment || !self.slate.isCommentOnly()) {
            if (self.node.options.showMenu) self.buttons.setting = r.setting().transform([
                't',
                x + widthOffset,
                ',',
                y - 58
            ].join()).attr(btnAttr);
            if (self.node.options.isComment && self.slate.canRemoveComments()) conditionallyShow('delete');
        }
        if (!self.node.options.isLocked && !self.node.options.isComment && !self.slate.isCommentOnly()) {
            conditionallyShow('add');
            conditionallyShow('delete');
            if (self.node.options.showRelationshipConnector) self.buttons.handle = r.handle().transform([
                't',
                x + widthOffset - 40,
                ',',
                y - 58
            ].join()).attr(btnAttr);
        }
        [
            'mousedown'
        ].forEach((eventType)=>{
            if (self.buttons.setting) self.buttons.setting[eventType]((e)=>{
                self.slate.unglow();
                onSettingsClicked.apply(self);
                _utilsDefault.default.stopEvent(e);
                // self.remove();
                if (self.slate.multiSelection) self.slate.multiSelection.end();
                if (self.node.context) self.node.context.remove();
                if (self.node.links) self.node.links.end();
            });
            if (self.buttons.unPinned) self.buttons.unPinned[eventType](function unp(e) {
                _utilsDefault.default.stopEvent(e);
                this.loop();
                self.slate.unglow();
                self.node.connectors?.addNode();
                self.node.menu?.hide();
                self.node.context?.remove();
            });
            if (self.buttons.trash) self.buttons.trash[eventType]((e)=>{
                const gid = self.node.options.groupId;
                _utilsDefault.default.stopEvent(e);
                self.node.del();
                self.slate.unglow();
                const delPkg = {
                    type: 'onNodeDeleted',
                    data: {
                        id: self.node.options.id,
                        isComment: self.node.options.isComment
                    }
                };
                self.slate.collab?.send(delPkg);
                self.slate.birdsEye?.nodeDeleted(delPkg);
                if (gid) // reselect the group after the node is deleted
                self.slate.multiSelection.showGroup(gid);
            });
            if (self.buttons.handle) self.buttons.handle[eventType]((e)=>{
                _utilsDefault.default.stopEvent(e);
                self.slate.unglow();
                self.node.relationships.initiateTempNode(e, self.node, true);
            });
        });
        if (Object.keys(self.buttons).length > 1) {
            const barWidth = Object.keys(self.buttons).length * 40;
            self.iconBar = r.rect(x + widthOffset - 85, y - 63, barWidth, 43, 3).attr({
                stroke: '#000',
                fill: '#fff'
            }).toFront();
        }
        Object.keys(self.buttons).forEach((btn)=>{
            const button = self.buttons[btn];
            button.toFront();
            _m.push(button);
            button.mouseover(function mo() {
                self.slate.glow(this);
            });
            button.mouseout(()=>{
                self.slate.unglow();
            });
        });
        if (!self.node.options.isLocked && !self.node.options.isComment && !self.slate.isCommentOnly()) {
            if (self.node.options.showResize) {
                const rs = self.node.resize.show(x + bb.width, y + bb.height);
                _m.push(rs);
            }
            if (self.node.options.showRotate) {
                const rotate = self.node.rotate.show(x, y);
                _m.push(rotate);
            }
        }
        return self;
    }
    reset() {
        this._lastUnpinned = {
            options: {
                xPos: null,
                width: null,
                yPos: null
            }
        };
    }
    createNode(skipCenter, options, targetXPos, targetYPos, snap) {
        const self = this;
        const newNode = new _nodeDefault.default(options);
        self.slate.nodes.add(newNode);
        _utilsDefault.default.transformPath(newNode, `T${targetXPos - newNode.options.xPos}, ${targetYPos - newNode.options.yPos}`);
        newNode.options.xPos = targetXPos;
        newNode.options.yPos = targetYPos;
        const coords = newNode.textCoords({
            x: newNode.options.xPos,
            y: newNode.options.yPos
        });
        newNode.text.attr(coords);
        self._lastUnpinned = newNode.options;
        if (self.slate.options.mindMapMode) self.node.relationships.addAssociation(newNode);
        self.slate.birdsEye?.refresh(false);
        self._broadcast(snap);
        // var _pkg = { type: "addRelationship", data: { type: 'association', parent: self.node.options.id, child: newNode.options.id} };
        // self.slate.collab && self.slate.collab.send(_pkg);
        // fire the editor if the menu can be shown
        if (newNode.options.showMenu && skipCenter === undefined) newNode.position('center', ()=>{
            // fire event
            self.slate.events?.onTextPaneRequested?.apply(this, [
                newNode,
                (opts)=>{
                // ('changed', opts);
                }, 
            ]);
        });
        return newNode;
    }
    // eslint-disable-next-line consistent-return
    addNode(skipCenter) {
        const self = this;
        // add new node to the right of this one.
        const _snap = self.slate.snapshot();
        const copies = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId && n.options.copiedAt >= self.node.options.copiedAt
        ).length;
        if (copies === 1) self.reset();
        const options = JSON.parse(JSON.stringify(self.node.options));
        delete options.id;
        delete options.link;
        delete options.showParentArrow;
        const targetXPos = (self._lastUnpinned.xPos || self.node.options.xPos) + (self._lastUnpinned.width || self.node.options.width || 220) + self.node.options.spaceBetweenNodesWhenAdding || 30;
        const targetYPos = self._lastUnpinned.yPos || self.node.options.yPos;
        // don't replace text if the shape is alpha, otherwise the intent here is to copy the text
        if (options.opacity > 10) options.text = '';
        options.width = self.node.options.width;
        options.height = self.node.options.height;
        options.copiedFromId = self.node.options.copiedFromId || self.node.options.id;
        options.copiedAt = new Date().valueOf();
        // use the next theme shape if this slate is set to sync the theme
        if (!self.slate.options.basedOnThemeId) return self.createNode(skipCenter, options, targetXPos, targetYPos, _snap);
        // adjust the node's shape and color prior to insertion
        self.slate.events.onThemeRequired({
            themeId: self.slate.options.basedOnThemeId
        }, (err, theme)=>{
            if (err) console.error('Unable to apply theme', err);
            else {
                const children = self.slate.findChildren([
                    options.id
                ]);
                let nextChild = children.length + 1;
                if (nextChild > Object.keys(theme.styles).length) nextChild = 1;
                const base = theme.styles[`child_${nextChild}`];
                Object.assign(options, base);
            }
            return self.createNode(skipCenter, options, targetXPos, targetYPos, _snap);
        });
    }
}
exports.default = connectors;

},{"../helpers/utils":"8QI6M","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4vYbQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-use-before-define */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var _lodashThrottle = require("lodash.throttle");
var _lodashThrottleDefault = parcelHelpers.interopDefault(_lodashThrottle);
var _lodashClone = require("lodash.clone");
var _lodashCloneDefault = parcelHelpers.interopDefault(_lodashClone);
var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
class resize {
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.resize = null;
        self.resizeTemp = null;
        self.origX = null;
        self.origY = null;
        self.lastDx = null;
        self.lastDy = null;
        self._minWidth = 5;
        self._minHeight = 5;
        self._dragAllowed = false;
        self._origWidth = null;
        self._origHeight = null;
        self._isResizing = false;
        self.origPath = null;
        self.origPoint = {
        };
        self.resizeEvents = {
            start () {
                const s = this;
                self.node.toggleImage({
                    active: true,
                    keepResizerOpen: true
                });
                self.origPath = self.node.options.vectorPath;
                self.origPoint = self.node.options.rotate.point;
                self.origX = self.resizeTemp.attr('x');
                self.origY = self.resizeTemp.attr('y');
                self.node.options.hasResized = true;
                // create a huge dragging area in order to prevent mouse from losing focus on the correct element
                self.resizeTemp.attr({
                    x: self.resizeTemp.attr('x') - 1000,
                    y: self.resizeTemp.attr('y') - 1000,
                    width: 10000,
                    height: 10000
                });
                self.slate.isBeingResized = true;
                self.node.relationships.updateAssociationsWith({
                    activeNode: self.node.options.id,
                    currentDx: 0,
                    currentDy: 0,
                    action: 'resize'
                });
                self.lastDx = 0;
                self.lastDy = 0;
                const bbr = self.resize.getBBox();
                self.resize.ox = bbr.x;
                self.resize.oy = bbr.y;
                self._isResizing = true;
                self.slate.multiSelection?.end();
                // the resize coords at the start
                s.ox = s.attr('x');
                s.oy = s.attr('y');
                self.node.setStartDrag();
                self.node.connectors.remove();
                self.node.rotate.hide();
                self._dragAllowed = self.slate.options.allowDrag;
                self.slate.disable(false, true);
                if (self.node.options.text !== ' ') {
                    self._minWidth = 10;
                    self._minHeight = 10;
                }
                self._origWidth = self.node.options.width;
                self._origHeight = self.node.options.height;
                self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>n.options.id !== self.node.options.id
                ).map((n)=>({
                        id: n.options.id,
                        bbox: n.vect.getBBox(),
                        point: [
                            n.options.xPos,
                            n.options.yPos
                        ]
                    })
                );
                self.kdTree = _staticKdtreeDefault.default(self.foreignPoints.map((fp)=>fp.point
                ));
                self.node.relationships.conditionallyHideAll();
                self.slate.toggleFilters(false);
            },
            move (dx, dy) {
                const s = this;
                try {
                    const _zr = self.slate.options.viewPort.zoom.r;
                    // for snapping
                    if (self.slate.options.viewPort.showGrid && self.slate.options.viewPort.snapToGrid) {
                        const gridSize = self.slate.options.viewPort.gridSize || 10;
                        dx = Math.round(dx / gridSize) * gridSize;
                        dy = Math.round(dy / gridSize) * gridSize;
                    }
                    dx += dx / _zr - dx;
                    dy += dy / _zr - dy;
                    const nearest = self.kdTree.knn([
                        node.options.xPos,
                        node.options.yPos
                    ], 5);
                    nearest.forEach((n)=>{
                        self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox, false, 200);
                    });
                    let transWidth = self._origWidth + dx * 2;
                    let transHeight = self._origHeight + dy * 2;
                    if (self.slate.isCtrl && self.node.options.origVectWidth && self.node.options.origVectHeight) {
                        const max = Math.max(transWidth, transHeight);
                        // keep it proportional to the original dimensions unless ctrl is pressed while resizing
                        if (max === transWidth) // change width
                        transWidth = self.node.options.origVectWidth * transHeight / self.node.options.origVectHeight;
                        else // change height
                        transHeight = self.node.options.origVectHeight * transWidth / self.node.options.origVectWidth;
                    }
                    if (transWidth > self._minWidth) s.attr({
                        x: s.ox + dx
                    });
                    else // tx = 0;
                    s.attr({
                        x: s.ox
                    });
                    if (transHeight > self._minHeight) s.attr({
                        y: s.oy + dy
                    });
                    else // ty = 0;
                    s.attr({
                        y: s.oy
                    });
                    // if (transWidth > self._minWidth && transHeight > self._minHeight) {
                    const ts = `T${dx}, ${dy}`;
                    self.resize.transform(ts);
                    // }
                    self.node.events?.onResizing?.apply(self, [
                        transWidth,
                        transHeight
                    ]);
                    self.set(transWidth, transHeight, {
                        isMoving: true,
                        getRotationPoint: self.node.options.rotate.rotationAngle
                    });
                    self.node.images.imageSizeCorrection() // self is a potential performance choke point
                    ;
                    self.lastDx = dx * 2;
                    self.lastDy = dy * 2;
                } catch (err) {
                    finalize();
                }
            },
            async up () {
                self.slate.toggleFilters(false);
                finalize();
            }
        };
        function finalize() {
            // self.resizeTemp.attr({ x: self.origX + self.lastDx, y: self.origY + self.lastDy, width: self.resize.attr("width"), height: self.resize.attr("height") });
            // self.node.options.vectorPath = _optimizedContext.path;
            self.node.vect.attr({
                path: self.node.options.vectorPath
            });
            self.node.relationships.showAll(true);
            self.slate.isBeingResized = false;
            self._isResizing = false;
            self.slate.enable(false, true);
            self.resize.remove();
            self.resizeTemp.remove();
            self.node.setEndDrag();
            // self.node.relationships.wireHoverEvents();
            const _bbox = self.node.vect.getBBox();
            self.node.toggleImage({
                active: false,
                width: _bbox.width,
                height: _bbox.height
            });
            self.node.options.width = _bbox.width;
            self.node.options.height = _bbox.height;
            self.node.options.xPos = _bbox.x;
            self.node.options.yPos = _bbox.y;
            self.node.editor.setTextOffset();
            self.node.text.attr(self.node.textCoords({
                x: self.node.options.xPos,
                y: self.node.options.yPos
            }));
            self.node.gridLines.clear();
            delete self.foreignPoints;
            delete self.kdTree;
            if (self.node.events && self.node.events?.onResized) self.node.events.onResized.apply(self, [
                self.send
            ]);
            else self.send();
        }
    }
    show(x, y) {
        const self = this;
        if (self.node.options.allowResize) {
            self.resizeTemp?.remove();
            const r = self.slate.paper;
            const resizePath = _utilsDefault.default._transformPath(_sbIconsDefault.default.icons.resize, `t${x - 5},${y - 5} r95`);
            self.resize = r.path(resizePath).attr({
                fill: '#fff',
                stroke: '#000'
            });
            self.resizeTemp = r.rect(x - 6, y - 6, 20, 20).attr({
                fill: '#f00',
                opacity: 0.00000001
            }).toFront();
            self.resizeTemp.mouseover((e)=>{
                self.node.overMenuButton = true;
                self.resizeTemp.attr({
                    cursor: 'pointer'
                });
            });
            self.resizeTemp.mouseout((e)=>{
                self.node.overMenuButton = false;
            });
            self.resizeTemp.drag(self.resizeEvents.move, self.resizeEvents.start, self.resizeEvents.up);
            return self.resize;
        }
    }
    hide() {
        this.resizeTemp?.remove();
        this.resize?.remove();
    }
    send() {
        // broadcast change to birdsEye and collaborators
        const textAttrs = this.node.text.attrs;
        const pkg = {
            type: 'onNodeResized',
            data: {
                id: this.node.options.id,
                textPosition: {
                    x: textAttrs.x,
                    y: textAttrs.y
                },
                rotate: this.node.options.rotate,
                vectorPath: this.node.options.vectorPath,
                associations: this.node.relationships.associations.map((a)=>({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr('path').toString()
                    })
                )
            }
        };
        const currentRotationPoint = _lodashCloneDefault.default(this.node.options.rotate.point);
        this.slate.birdsEye?.nodeChanged(pkg);
        this.node.options.rotate.point = currentRotationPoint;
        this.slate.collab?.send(pkg);
    }
    lazySend() {
        _lodashThrottleDefault.default(this.send, 700);
    }
    animateSet(data, opts) {
        const self = this;
        self.node.text.animate(data.textPosition, opts.duration || 500, opts.easing || '>');
        self.node.vect.animate({
            path: data.vectorPath,
            transform: `R${data.rotate.rotationAngle}, ${data.rotate.point.x}, ${data.rotate.point.y}`
        }, opts.duration || 500, opts.easing || '>', ()=>{
            const { image , imageOrigHeight , imageOrigWidth  } = self.node.options;
            if (image && !!imageOrigHeight && !!imageOrigWidth) self.node.images.imageSizeCorrection();
        });
        opts.associations.forEach((assoc)=>{
            const a = self.node.relationships.associations.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId
            );
            if (opts.animate) {
                if (a) a.line.animate({
                    path: assoc.linePath
                }, opts.duration || 500, opts.easing || '>', ()=>{
                    a.line.attr({
                        path: assoc.linePath
                    });
                });
            } else if (a) a.line.attr({
                path: assoc.linePath
            });
        });
    }
    set(width, height, opts = {
    }) {
        // let latt, tatt;
        const self = this;
        let pathWithPotentialTransformations = self.node.vect.attr('path').toString();
        if (opts.getRotationPoint) self.origPoint = self.node.options.rotate.point;
        if (self.origPoint && Object.entries(self.origPoint).length > 0 && self.node.options.rotate.rotationAngle > 0) pathWithPotentialTransformations = _raphaelSvg.Raphael.transformPath(pathWithPotentialTransformations, `R${self.node.options.rotate.rotationAngle}, ${self.origPoint.x}, ${self.origPoint.y}`);
        self.node.vect.transform('');
        self.node.text.transform('');
        self.node.vect.attr({
            path: pathWithPotentialTransformations
        });
        self.node.text.attr({
            path: pathWithPotentialTransformations
        });
        const rotationBB = self.node.vect.getBBox();
        let widthScalar = 1;
        let heightScalar = 1;
        if (width > self._minWidth) {
            widthScalar = width / rotationBB.width;
            self.node.options.width = width;
        } else {
            widthScalar = self._minWidth / rotationBB.width;
            self.node.options.width = self._minWidth;
        }
        if (height > self._minHeight) {
            heightScalar = height / rotationBB.height;
            self.node.options.height = height;
        } else {
            heightScalar = self._minHeight / rotationBB.height;
            self.node.options.height = self._minHeight;
        }
        const scaleTransform = `s${widthScalar}, ${heightScalar}`;
        const scaledVectPath = _raphaelSvg.Raphael.transformPath(self.node.vect.attr('path').toString(), scaleTransform).toString();
        pathWithPotentialTransformations = scaledVectPath;
        self.node.vect.attr({
            path: scaledVectPath
        });
        if (self.origPoint && Object.entries(self.origPoint).length > 0 && self.node.options.rotate.rotationAngle > 0) pathWithPotentialTransformations = _raphaelSvg.Raphael.transformPath(pathWithPotentialTransformations, `R${-self.node.options.rotate.rotationAngle}, ${self.origPoint.x}, ${self.origPoint.y}`).toString();
        self.node.vect.attr({
            path: pathWithPotentialTransformations
        });
        self.node.options.vectorPath = pathWithPotentialTransformations;
        const noRotationBB = self.node.vect.getBBox();
        self.node.options.rotate.point = {
            x: noRotationBB.cx,
            y: noRotationBB.cy
        };
        self.node.setPosition({
            x: noRotationBB.x,
            y: noRotationBB.y
        }, true);
        self.node.rotate.applyImageRotation();
        const lc = self.node.linkCoords();
        self.node.link.transform([
            't',
            lc.x,
            ',',
            lc.y,
            's',
            '.8',
            ',',
            '.8',
            'r',
            '180'
        ].join());
        self.node.relationships.refreshOwnRelationships();
        self.node.editor.setTextOffset();
        self.node.text.attr(self.node.textCoords({
            x: self.node.options.xPos,
            y: self.node.options.yPos
        }));
    }
}
exports.default = resize;

},{"lodash.throttle":"bGJVT","lodash.clone":"j9BUC","static-kdtree":"i8GTt","../deps/raphael/raphael.svg":"jK21R","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGJVT":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result1, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result1 = func.apply(thisArg, args);
        return result1;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result1;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) return trailingEdge(time);
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) return invokeFunc(time);
        lastArgs = lastThis = undefined;
        return result1;
    }
    function cancel() {
        if (timerId !== undefined) clearTimeout(timerId);
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result1 : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) return leadingEdge(lastCallTime);
            if (maxing) {
                // Handle invocations in a tight loop.
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
        return result1;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */ function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
    });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') return value;
    if (isSymbol(value)) return NAN;
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') return value === 0 ? value : +value;
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = throttle;

},{}],"j9BUC":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {
};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */ function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
}
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */ function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
}
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */ function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) break;
    }
    return array;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */ function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {
    }
    return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {
    };
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    return this.__data__['delete'](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */ function baseClone(value, isDeep, isFull, customizer, key1, object, stack) {
    var result;
    if (customizer) result = object ? customizer(value, key1, object, stack) : customizer(value);
    if (result !== undefined) return result;
    if (!isObject(value)) return value;
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray(value, result);
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) return cloneBuffer(value, isDeep);
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) return object ? value : {
            };
            result = initCloneObject(isFunc ? {
            } : value);
            if (!isDeep) return copySymbols(value, baseAssign(result, value));
        } else {
            if (!cloneableTags[tag]) return object ? value : {
            };
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
    arrayEach(props || value, function(subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
}
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */ function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {
    };
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    return objectToString.call(value);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != 'constructor') result.push(key);
    return result;
}
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */ function cloneBuffer(buffer, isDeep) {
    if (isDeep) return buffer.slice();
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
}
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */ function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */ function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */ function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
}
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */ function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */ function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
}
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */ function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {
    };
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */ function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    object || (object = {
    });
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */ function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {
    };
}
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
            return new Ctor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
            return new Ctor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
            return cloneSymbol(object);
    }
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e1) {
        }
    }
    return '';
}
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */ function clone(value) {
    return baseClone(value, false, true);
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = clone;

},{}],"jLcMC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _emile = require("../deps/emile");
class images {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    getTargetImageDimensions() {
        let transImageHeight;
        let transImageWidth;
        const origImageRatio = this.node.options.imageOrigWidth / this.node.options.imageOrigHeight;
        const noRotationPath = this.slate.paper.path(this.node.vect.attr('path'));
        const noRotationBB = noRotationPath.getBBox();
        const nodeRatio = noRotationBB.width / noRotationBB.height;
        if (origImageRatio < nodeRatio) {
            transImageWidth = noRotationBB.width;
            transImageHeight = noRotationBB.width / origImageRatio;
        } else if (origImageRatio > nodeRatio) {
            transImageHeight = noRotationBB.height;
            transImageWidth = noRotationBB.height * origImageRatio;
        } else {
            transImageWidth = noRotationBB.width;
            transImageHeight = noRotationBB.height;
        }
        noRotationPath.remove();
        return {
            width: transImageWidth,
            height: transImageHeight
        };
    }
    imageSizeCorrection() {
        if (this.node.vect.pattern) {
            const targetImageDimensions = this.getTargetImageDimensions();
            const img = this.node.vect.pattern.getElementsByTagName('image')[0];
            img.setAttribute('height', targetImageDimensions.height);
            img.setAttribute('width', targetImageDimensions.width);
        }
    }
    set(img, w, h, blnKeepResizerOpen) {
        this.node.vect.data({
            relativeFill: true
        });
        this.node.options.image = img;
        this.node.options.origImage = {
            w,
            h
        } // needed for image copying if done later
        ;
        this.node.options.imageOrigHeight = h // for scaling node to image size purposes; this value should never be changed
        ;
        this.node.options.imageOrigWidth = w;
        this.node.options['fill-opacity'] = 1;
        const sz = {
            fill: `url(${this.node.options.image})`,
            'stroke-width': this.node.options.borderWidth,
            stroke: '#000'
        };
        const targetImageDimensions = this.getTargetImageDimensions();
        this.node.vect.imageOrigHeight = targetImageDimensions.height;
        this.node.vect.imageOrigWidth = targetImageDimensions.width;
        this.node.vect.attr({
            'fill-opacity': 1
        }) // IMPORTANT: for some reason Raphael breaks when setting 'sz' object and this at the same time
        ;
        this.node.vect.attr(sz);
        const rotatedBB = this.node.vect.getBBox();
        this.node.options.width = rotatedBB.width;
        this.node.options.height = rotatedBB.height;
        this.node.relationships.refreshOwnRelationships();
        if (blnKeepResizerOpen) {
            this.node.setPosition({
                x: rotatedBB.x,
                y: rotatedBB.y
            }, true);
            this.node.menu?.hide();
            this.node.rotate?.hide();
        } else this.node.setPosition({
            x: rotatedBB.x,
            y: rotatedBB.y
        });
        this.node.connectors?.remove();
    }
}
exports.default = images;

},{"../deps/emile":"dd61Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kA5hP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class shapes {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    async set(pkg = {
        sendCollab: false
    }) {
        this.slate.unglow();
        let _path = '';
        switch(pkg.shape){
            case 'ellipse':
                _path = _utilsDefault.default._transformPath(`M${this.node.options.xPos + 75},${this.node.options.yPos + 50} m -75,0 a75,50 0 1,0 150,0 a 75,50 0 1,0 -150,0Z`);
                this.node.options.isEllipse = true;
                break;
            case 'rect':
                if (pkg.rx > 0) _path = _utilsDefault.default._transformPath(`M${this.node.options.xPos},${this.node.options.yPos} h130 a10,10 0 0 1 10,10 v80 a10,10 0 0 1 -10,10 h-130 a10,10 0 0 1 -10,-10 v-80 a10,10 0 0 1 10,-10 z`);
                else _path = _utilsDefault.default._transformPath(`M${this.node.options.xPos},${this.node.options.yPos} h150 v100 h-150 v-100 z`);
                this.node.options.isEllipse = false;
                break;
            default:
                _path = _utilsDefault.default._transformPath(pkg.shape, `T${this.node.options.xPos},${this.node.options.yPos}`);
                this.node.options.isEllipse = false;
                break;
        }
        this.node.options.vectorPath = _path;
        this.node.options.origVectWidth = pkg.width;
        this.node.options.origVectHeight = pkg.height;
        this.node.options.width = pkg.width;
        this.node.options.height = pkg.height;
        this.node.vect.attr({
            path: _path
        });
        this.node.editor.setTextOffset();
        this.node.text.attr(this.node.textCoords({
            x: this.node.options.xPos,
            y: this.node.options.yPos
        }));
        // apply image fill rotation
        if (this.node.vect.pattern) {
            this.node.images.imageSizeCorrection();
            this.node.rotate.applyImageRotation();
        }
        this.node.text.toFront();
        this.node.link.toFront();
        this.node.relationships.refreshOwnRelationships();
        if (pkg.keepResizerOpen) {
            this.node.menu?.hide();
            this.node.rotate?.hide();
        }
        // needed for tofront and toback ops of the context menu
        this.node.vect.data({
            id: this.node.options.id
        });
        this.node.context.create();
        if (pkg.sendCollab) {
            const _pkg = {
                type: 'onNodeShapeChanged',
                data: {
                    id: this.node.options.id,
                    shape: pkg.shape,
                    width: pkg.width,
                    height: pkg.height,
                    sendCollab: false,
                    rx: pkg.rx
                }
            };
            this.slate.collab?.send(_pkg);
            this.slate.birdsEye?.nodeChanged(_pkg);
        }
    }
}
exports.default = shapes;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edbtN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class customShapes {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    set(path, width, height, sendCollab) {
        let upath = path;
        if (width && height) {
            // calculate the scale of the path
            const scale = Math.max(this.node.options.width, this.node.options.height) / Math.max(width, height);
            upath = _utilsDefault.default._transformPath(path, [
                's',
                scale,
                ',',
                scale
            ].join(''));
        }
        this.node.shapes.set({
            shape: upath.toString(),
            sendCollab: sendCollab != null ? sendCollab : true
        });
    }
}
exports.default = customShapes;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJAST":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class colorPicker {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    set(cast) {
        this.node.options.backgroundColor = cast.color;
        if (cast.opacity != null) this.node.options.opacity = cast.opacity;
        this.node.vect.attr({
            fill: cast.color,
            'fill-opacity': this.node.options.opacity
        });
        if (cast.color === '' && this.node.options.text !== '') {
            this.node.vect.attr({
                stroke: this.node.options.borderColor || '#000'
            });
            this.node.options.borderWidth = 0;
        } else this.node.vect.attr({
            stroke: this.node.options.borderColor || '#000',
            'stroke-width': this.node.options.borderWidth
        });
        this.node.relationships.refreshOwnRelationships();
    }
}
exports.default = colorPicker;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"185nI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class context {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this._contextMenu = null;
        this._priorAllowDrag = true;
    }
    ctx(e) {
        this._priorAllowDrag = this.node.options.allowDrag;
        this.node.options.allowDrag = false;
        this.remove();
        this.buildContext(e);
        setTimeout(()=>{
            this.node.options.allowDrag = this._priorAllowDrag;
        }, 2);
        return _utilsDefault.default.stopEvent(e);
    }
    create() {
        if (this.node.text && this.node.text.node && this.node.options.allowContext && !this.node.slate.isAlt && !this.node.slate.isShift) {
            this.node.text.node.oncontextmenu = this.ctx;
            this.node.vect.node.oncontextmenu = this.ctx;
        }
    }
    buildContext(e) {
        this._contextMenu = document.createElement('div');
        this._contextMenu.setAttribute('id', `contextMenu_${this.node.options.id}`);
        this._contextMenu.setAttribute('class', 'sb_cm');
        document.body.appendChild(this._contextMenu);
        this.setContext(e);
    }
    menuItems() {
        const tmp = "<div style='padding:5px;' class='sbthis._contextMenuItem' rel='{func}'>{text}</div>";
        let inside = tmp.replace(/{func}/g, 'tofront').replace(/{text}/g, 'to front');
        inside += tmp.replace(/{func}/g, 'toback').replace(/{text}/g, 'to back');
        if (this._priorAllowDrag) inside += tmp.replace(/{func}/g, 'lock').replace(/{text}/g, 'lock');
        else inside += tmp.replace(/{func}/g, 'unlock').replace(/{text}/g, 'unlock');
        inside += tmp.replace(/{func}/g, 'close').replace(/{text}/g, 'close');
        return inside;
    }
    setContext(e) {
        const self = this;
        this._contextMenu.innerHTML = this.menuItems();
        const all = _utilsDefault.default.select('div.contextMenuItem');
        for(let s = all.length; s < all.length; s += 1){
            const elem = all[s];
            elem.onclick = ()=>{
                const act = this.getAttribute('rel');
                let _reorder = false;
                const pkg = {
                    type: '',
                    data: {
                        id: self.node.options.id
                    }
                };
                switch(act){
                    case 'tofront':
                        self.node.toFront();
                        _reorder = true;
                        pkg.type = 'onNodeToFront';
                        break;
                    case 'toback':
                        self.node.toBack();
                        _reorder = true;
                        pkg.type = 'onNodeToBack';
                        break;
                    case 'lock':
                        self.node.options.isLocked = true // self is not a part of the self.node.disable function on purpose
                        ;
                        self.node.disable();
                        pkg.type = 'onNodeLocked';
                        break;
                    case 'unlock':
                        self.node.options.isLocked = false // self is not a part of the self.node.enable function on purpose
                        ;
                        self.node.enable();
                        pkg.type = 'onNodeUnlocked';
                        break;
                    case 'close':
                    default:
                        break;
                }
                if (_reorder) {
                    let zIndex = 0;
                    for(let node = self.node.slate.paper.bottom; node != null; node = node.next)if (node.type === 'ellipse' || node.type === 'rect') {
                        zIndex += 1;
                        const _id = node.data('id');
                        // not all rects have an id (the menu box is a rect, but it has no options.id because it is not a node
                        // so you cannot always show self...
                        if (_id) {
                            const reorderedNode = self.node.slate.nodes.allNodes.find((n)=>n.options.id === _id
                            );
                            reorderedNode.sortorder = zIndex;
                        }
                    }
                    self.node.slate.nodes.allNodes.sort((a, b)=>a.sortorder < b.sortorder ? -1 : 1
                    );
                }
                if (pkg.type !== '') self.broadcast(pkg);
                this.remove();
            };
        }
        const mp = _utilsDefault.default.mousePos(e);
        const _x = mp.x;
        const _y = mp.y;
        this._contextMenu.style.left = `${_x}px`;
        this._contextMenu.style.top = `${_y}px`;
    }
    broadcast(pkg) {
        // broadcast
        if (this.node.slate.collab) this.node.slate.collab.send(pkg);
        if (this.node.slate.birdsEye) this.node.slate.birdsEye.nodeChanged(pkg);
    }
    remove() {
        this.node.slate?.removeContextMenus();
        this._contextMenu = null;
    }
    isVisible() {
        return this._contextMenu !== null;
    }
}
exports.default = context;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c3gfk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-param-reassign */ var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class lineOptions {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.m = {
        };
    }
    broadcast(pkg) {
        pkg.data.id = this.node.options.id;
        this.slate.collab?.send(pkg);
    }
    set(pkg) {
        const a = this.node.relationships.associations[pkg.index];
        if (pkg.updateChild) a.child.options[pkg.prop] = pkg.val;
        else this.node.options[pkg.prop] = pkg.val;
        if (pkg.val === 'toggle') a[pkg.prop] = a[pkg.prop] ? (pkg.prop, false) : true;
        else a[pkg.prop] = pkg.val;
        _refreshRelationshipsDefault.default({
            relationships: [
                a
            ],
            nodes: [
                this.node
            ]
        });
    }
    show(e, c) {
        const self = this;
        self.hideAll();
        self.slate.nodes.closeAllLineOptions(c.id);
        const a = self.node.relationships.associations.find((ax)=>ax.id === c.id
        );
        const r = self.slate.paper;
        const mp = _utilsDefault.default.mousePos(e);
        const off = _utilsDefault.default.positionedOffset(self.slate.options.container);
        const z = self.slate.options.viewPort.zoom.r;
        const opacity = '1.0';
        let x = (mp.x + self.slate.options.viewPort.left - off.left - 90) / z;
        let y = (mp.y + self.slate.options.viewPort.top - off.top - 30) / z;
        const bb = a.line.getBBox();
        x = bb.cx;
        y = bb.cy;
        self.m[c.id] = r.set();
        const transformToolbar = (xx, yy)=>[
                't',
                x + xx,
                ',',
                y + yy
            ].join()
        ;
        const toolbarAttr = {
            fill: '#fff',
            'fill-opacity': opacity,
            stroke: '#333',
            'stroke-width': 1,
            cursor: 'pointer'
        };
        const toolbar = [];
        const reassign = self.node.options.showRelationshipReassign ? r.handle().attr(toolbarAttr).transform(transformToolbar(15, 0)) : null;
        const props = self.node.options.showRelationshipProperties ? r.setting().attr(toolbarAttr).transform(transformToolbar(-15, 0)) : null;
        const del = self.node.options.showRelationshipDelete ? r.trash().transform(transformToolbar(-45, 0)).attr({
            fill: '#fff',
            stroke: '#f00'
        }) : null;
        if (reassign) toolbar.push(reassign);
        if (toolbar) toolbar.push(props);
        if (del) toolbar.push(del);
        const toolbarGlows = [];
        toolbar.forEach((toolbarElem)=>{
            toolbarElem.mouseover(function g() {
                toolbarGlows.push(this.glow());
                _utilsDefault.default.stopEvent(e);
            });
            toolbarElem.mouseout(()=>{
                toolbarGlows.forEach((t)=>{
                    t.remove();
                });
                _utilsDefault.default.stopEvent(e);
            });
        });
        if (props) props.mousedown((ex)=>{
            _utilsDefault.default.stopEvent(ex);
            toolbarGlows.forEach((t)=>{
                t.remove();
            });
            const assoc = self.node.relationships.associations.find((ax)=>ax.id === c.id
            );
            if (self.slate.events?.onLineMenuRequested) {
                self.hideAll();
                self.slate.events?.onLineMenuRequested(self.node, assoc, ()=>{
                // finished
                });
            }
        });
        function removeRelationship(ex) {
            toolbarGlows.forEach((t)=>{
                t.remove();
            });
            _utilsDefault.default.stopEvent(ex);
            if (self.slate.options.enabled) {
                const pkg = {
                    type: 'removeRelationship',
                    data: {
                        parent: c.parent.options.id,
                        child: c.child.options.id
                    }
                };
                self.slate.nodes.removeRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
                self.broadcast(pkg);
                self.hide(c.id);
            }
        }
        // reassign relationship
        if (reassign) reassign.mousedown(()=>{
            removeRelationship();
            self.node.relationships.initiateTempNode(e, c.parent, {
                showChildArrow: a.showChildArrow,
                showParentArrow: a.showParentArrow
            });
        });
        // remove relationship
        if (del) del.mousedown(()=>{
            removeRelationship();
        });
        toolbar.forEach((toolbarElem)=>{
            self.m[c.id].push(toolbarElem);
        });
        return self;
    }
    hide(id) {
        if (this.m[id]) {
            _lodashInvokeDefault.default(this.m[id], 'remove');
            this.m[id] = null;
        }
    }
    hideAll() {
        const self = this;
        // self.slate.unglow();
        self.node.relationships.associations.map((r)=>r.id
        ).forEach((id)=>{
            self.hide(id);
        });
    }
}
exports.default = lineOptions;

},{"lodash.invoke":"6VYuy","../helpers/refreshRelationships":"1UeYf","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6cFRW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-param-reassign */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class gridLines {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.guideWings = 20000;
        this.guideAttrs = {
            'stroke-dasharray': '--',
            stroke: '#000'
        };
        this.guideLines = {
            rightVerticals: {
            },
            leftVerticals: {
            },
            topHorizontals: {
            },
            bottomHorizontals: {
            }
        };
    }
    clear() {
        const self = this;
        [
            'rightVerticals',
            'leftVerticals',
            'topHorizontals',
            'bottomHorizontals', 
        ].forEach((p)=>{
            if (self.guideLines[p]) Object.keys(self.guideLines[p]).forEach((k)=>self.guideLines[p][k].remove()
            );
            self.guideLines[p] = {
            };
        });
    }
    draw(id, dx, dy, bb, translateNode = true, guideVisibleAt = 100, guideSnapAt = 20) {
        const self = this;
        const snapToObjects = self.slate.options.viewPort.snapToObjects != null ? self.slate.options.viewPort.snapToObjects : true;
        let pinnedY = false;
        let pinnedX = false;
        const nbb = self.node.vect.getBBox();
        self.guideAttrs.stroke = _utilsDefault.default.whiteOrBlack(self.slate.options.containerStyle.backgroundColor);
        // RIGHT VERTICAL LINE boundary
        if (nbb.x - bb.x2 < guideVisibleAt && nbb.x - bb.x2 >= 0 || bb.x2 - nbb.x2 < guideVisibleAt && bb.x2 - nbb.x2 >= 0) {
            if (!self.guideLines.rightVerticals[id]) self.guideLines.rightVerticals[id] = self.slate.paper.path(`M ${bb.x2} ${bb.y - self.guideWings} L ${bb.x2} ${bb.y2 + self.guideWings}`).attr(self.guideAttrs);
            pinnedX = nbb.x - bb.x2 < guideSnapAt && nbb.x - bb.x2 >= 0 || bb.x2 - nbb.x2 < guideSnapAt && bb.x2 - nbb.x2 >= 0;
            if (pinnedX && snapToObjects) {
                if (nbb.x - bb.x2 < guideSnapAt && nbb.x - bb.x2 >= 0) dx -= nbb.x - bb.x2;
                else dx += bb.x2 - nbb.x2;
            }
        } else {
            self.guideLines?.rightVerticals[id]?.remove();
            delete self.guideLines?.rightVerticals[id];
        }
        // LEFT VERTICAL LINE boundary
        if (!pinnedX && (bb.x - nbb.x2 < guideVisibleAt && bb.x - nbb.x2 >= 0 || nbb.x - bb.x < guideVisibleAt && nbb.x - bb.x >= 0)) {
            if (!self.guideLines.leftVerticals[id]) self.guideLines.leftVerticals[id] = self.slate.paper.path(`M ${bb.x} ${bb.y - self.guideWings} L ${bb.x} ${bb.y2 + self.guideWings}`).attr(self.guideAttrs);
            pinnedX = bb.x - nbb.x2 < guideSnapAt && bb.x - nbb.x2 >= 0 || nbb.x - bb.x < guideSnapAt && nbb.x - bb.x >= 0;
            if (pinnedX && snapToObjects) {
                if (bb.x - nbb.x2 < guideSnapAt && bb.x - nbb.x2 >= 0) dx += bb.x - nbb.x2;
                else dx -= nbb.x - bb.x;
            }
        } else {
            self.guideLines?.leftVerticals[id]?.remove();
            delete self.guideLines?.leftVerticals[id];
        }
        // TOP HORIZONTAL LINE boundary
        if (bb.y - nbb.y2 < guideVisibleAt && bb.y - nbb.y2 >= 0 || nbb.y - bb.y < guideVisibleAt && nbb.y - bb.y >= 0) {
            if (!self.guideLines.topHorizontals[id]) self.guideLines.topHorizontals[id] = self.slate.paper.path(`M ${bb.x - self.guideWings} ${bb.y} L ${bb.x2 + self.guideWings} ${bb.y}`).attr(self.guideAttrs);
            pinnedY = bb.y - nbb.y2 < guideSnapAt && bb.y - nbb.y2 >= 0 || nbb.y - bb.y < guideSnapAt && nbb.y - bb.y >= 0;
            if (pinnedY && snapToObjects) {
                if (bb.y - nbb.y2 < guideSnapAt && bb.y - nbb.y2 >= 0) // coming from top
                dy += bb.y - nbb.y2;
                else // coming from underneath
                dy -= nbb.y - bb.y;
            }
        } else {
            self.guideLines?.topHorizontals[id]?.remove();
            delete self.guideLines?.topHorizontals[id];
        }
        // BOTTOM HORIZONTAL LINE boundary
        if (!pinnedY && (nbb.y - bb.y2 < guideVisibleAt && nbb.y - bb.y2 >= 0 || bb.y2 - nbb.y2 < guideVisibleAt && bb.y2 - nbb.y2 >= 0)) {
            if (!self.guideLines.bottomHorizontals[id]) self.guideLines.bottomHorizontals[id] = self.slate.paper.path(`M ${bb.x - self.guideWings} ${bb.y2} L ${bb.x2 + self.guideWings} ${bb.y2}`).attr(self.guideAttrs);
            pinnedY = nbb.y - bb.y2 < guideSnapAt && nbb.y - bb.y2 >= 0 || bb.y2 - nbb.y2 < guideSnapAt && bb.y2 - nbb.y2 >= 0;
            if (pinnedY && snapToObjects) {
                if (nbb.y - bb.y2 < guideSnapAt && nbb.y - bb.y2 >= 0) dy -= nbb.y - bb.y2;
                else dy += bb.y2 - nbb.y2;
            }
        } else {
            self.guideLines?.bottomHorizontals[id]?.remove();
            delete self.guideLines?.bottomHorizontals[id];
        }
        if (translateNode && (pinnedX || pinnedY)) self.node.translateWith({
            dx,
            dy
        });
        return {
            dx,
            dy
        };
    }
}
exports.default = gridLines;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BxQS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class links {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.node.link.click((e)=>{
            this.click();
        });
    }
    set(pkg, sendCollab) {
        // {
        //   type: 'url|currentSlate|externalSlate',
        //   data: 'https://xxx|id_of_node'
        // }
        this.node.options.link = pkg;
        if (sendCollab) {
            const cpkg = {
                type: 'onNodeLinkAdded',
                data: pkg
            };
            if (this.slate.collab) this.slate.collab.send(cpkg);
        }
    }
    unset(sendCollab) {
        this.node.options.link = null;
        if (sendCollab) {
            const cpkg = {
                type: 'onNodeLinkRemoved',
                data: pkg
            };
            if (this.slate.collab) this.slate.collab.send(cpkg);
        }
    }
    click() {
        //`url("https://api.miniature.io/?token=ozwPwKuD6CYUiE9K&url=miniature.io?url=${_self._.options.link.data}&size=200")`
        const self = this;
        switch(this.node.options.link.type){
            case 'url':
                window.open(self.node.options.link.data, 'sb_external');
                break;
            case 'externalSlate':
                break;
            case 'currentSlate':
                {
                    const n = self.slate.nodes.one(self.node.options.link.data);
                    console.log('pos ', n);
                    n.position('center', ()=>{
                    // done
                    }, 'swingTo', 500);
                    break;
                }
        }
    }
}
exports.default = links;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpcw7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _index = require("../index");
class multiSelection {
    constructor(slate){
        const self = this;
        self.slate = slate;
        self.selRect = null // used during selection
        ;
        self.ox = null;
        self.oy = null;
        self._init = null;
        self.marker = null // stays after selection
        ;
        self.selectedNodes = [];
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.origPos = null;
        self.resizer = null;
        self.minSize = 100;
        self._icons = [];
        self.iconBg = null;
        self.moveX = 0;
        self.moveY = 0;
        self.attrs = {
            create: {
                fill: '#fff',
                stroke: '#000'
            },
            mouseOut: {
                fill: '#fff',
                stroke: '#000'
            },
            mouseOver: {
                fill: '#ccc',
                cursor: 'pointer'
            }
        };
    }
    init() {
        const self = this;
        if (self.slate.options.isbirdsEye) return;
        function finalize() {
            // self.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
            self.slate.options.allowDrag = true;
            self.slate.birdsEye?.refresh(true);
            self.selectedNodes.forEach((node)=>{
                _utilsDefault.default.transformPath(node, `T${self.moveX},${self.moveY}`);
                node.vect.currentDx = 0;
                node.vect.currentDy = 0;
            });
            _refreshRelationshipsDefault.default({
                relationships: self.relationshipsToRefresh,
                nodes: self.selectedNodes,
                moveX: self.moveX,
                moveY: self.moveY
            });
            self.slate.nodes.saveRelationships(self.relationshipsToTranslate, {
                dx: self.moveX,
                dy: self.moveY
            });
            multiSelection.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
            self.broadcastMove();
            self.showIcons();
            self.origPos = self.marker.getBBox();
            self.marker.toBack();
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
        const c = self.slate.options.container;
        if (self.slate.options.showMultiSelect) {
            self._init = document.createElement('div');
            self._init.setAttribute('class', 'slateMultiSelect');
            self._init.style.position = 'absolute';
            self._init.style.height = '30px';
            self._init.style.left = '10px';
            self._init.style.color = '#081272';
            self._init.style.fontSize = '11pt';
            self._init.style.fontFamily = 'trebuchet ms';
            self._init.style.top = '5px';
            self._init.style.display = 'block';
            self._init.style.padding = '5px';
            self._init.style.margin = '5px;';
            self._init.style.backgroundColor = '#fff';
            self._init.style.cursor = 'pointer';
            self._init.style['user-select'] = 'none';
            self._init.innerHTML = '[multi-select]';
            self._init.style.zIndex = '0';
            c.appendChild(self._init);
            self.markerEvents = {
                init () {
                    self.hideIcons();
                    multiSelection.hideConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
                    self.moveX = 0;
                    self.moveY = 0;
                    self.slate.options.allowDrag = false;
                    self.marker.ox = self.marker.attr('x');
                    self.marker.oy = self.marker.attr('y');
                    self.selectedNodes.forEach((node)=>{
                        const bb = node.vect.getBBox();
                        node.vect.ox = bb.x;
                        node.vect.oy = bb.y;
                    });
                },
                move (dx, dy) {
                    try {
                        const _zr = self.slate.options.viewPort.zoom.r;
                        dx += dx / _zr - dx;
                        dy += dy / _zr - dy;
                        self.moveX = dx;
                        self.moveY = dy;
                        const att = {
                            x: self.marker.ox + dx,
                            y: self.marker.oy + dy
                        };
                        self.marker.attr(att);
                        self.selectedNodes.forEach((node)=>{
                            node.vect.currentDx = dx;
                            node.vect.currentDy = dy;
                            node.translateWith({
                                dx,
                                dy
                            });
                        });
                        const _nx = self.origPos.x + self.origPos.width + dx - 5;
                        const _ny = self.origPos.y + self.origPos.height + dy - 5;
                        self.resizer.transform([
                            't',
                            _nx,
                            ',',
                            _ny,
                            ' r95 s1.5,1.5'
                        ].join(''));
                    } catch (err) {
                        finalize();
                    }
                },
                up (e) {
                    finalize(e);
                }
            };
            self.resizeEvents = {
                init () {
                    self.hideIcons();
                    multiSelection.hideConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
                    self.moveX = 0;
                    self.moveY = 0;
                    self.slate.options.allowDrag = false;
                    self.selectedNodes.forEach((node)=>{
                        const bb = node.vect.getBBox();
                        node.vect.ox = bb.x;
                        node.vect.oy = bb.y;
                    });
                    self.marker.toBack();
                    self.slate?.grid.toBack();
                    self.slate?.canvas.bgToBack();
                },
                move (dx, dy) {
                    const _zr = self.slate.options.viewPort.zoom.r;
                    dx += dx / _zr - dx;
                    dy += dy / _zr - dy;
                    self.moveX = dx;
                    self.moveY = dy;
                    let _width = self.origPos.width + dx * 2;
                    let _height = self.origPos.height + dy * 2;
                    const _nx = self.origPos.x + self.origPos.width + dx - 5;
                    const _ny = self.origPos.y + self.origPos.height + dy - 5;
                    let rw = true;
                    let rh = true;
                    if (_width < self.minSize) {
                        _width = self.minSize;
                        rw = false;
                    }
                    if (_height < self.minSize) {
                        _height = self.minSize;
                        rh = false;
                    }
                    self.resizer.transform([
                        't',
                        _nx,
                        ',',
                        _ny,
                        ' r95 s1.5,1.5'
                    ].join(''));
                    const att = {
                        width: _width,
                        height: _height
                    };
                    if (rw) Object.assign(att, {
                        x: self.origPos.x - dx
                    });
                    if (rh) Object.assign(att, {
                        y: self.origPos.y - dy
                    });
                    self.marker.attr(att);
                },
                up () {
                    multiSelection.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
                    self.selectedNodes.forEach((node)=>{
                        const transWidth = node.options.width + self.moveX;
                        const transHeight = node.options.height + self.moveY;
                        node.resize.set(transWidth, transHeight, {
                            isMoving: true,
                            getRotationPoint: node.options.rotate.rotationAngle
                        });
                        node.images.imageSizeCorrection();
                    });
                    _refreshRelationshipsDefault.default({
                        relationships: self.relationshipsToRefresh.concat(self.relationshipsToTranslate),
                        nodes: self.selectedNodes,
                        dx: 0,
                        dy: 0
                    });
                    self.broadcastMove();
                    self.origPos = self.marker.getBBox();
                    const _nx = self.origPos.x + self.origPos.width;
                    const _ny = self.origPos.y + self.origPos.height;
                    self.resizer.transform([
                        't',
                        _nx - 5,
                        ',',
                        _ny - 5
                    ].join(''));
                    self.refreshMarker();
                    self.showIcons();
                    self.marker.toBack();
                    self.slate?.grid.toBack();
                    self.slate?.canvas.bgToBack();
                    self.slate.enable();
                }
            };
            _utilsDefault.default.addEvent(self._init, 'click', (e)=>{
                switch(self._init.innerHTML){
                    case '[multi-select]':
                        self.start();
                        break;
                    case 'selecting [click to stop]...':
                        self.end(false);
                        self.endSelection();
                        break;
                    default:
                        break;
                }
            });
        }
    }
    hide() {
        const self = this;
        if (self._init) self._init.style.display = 'none';
    }
    show() {
        const self = this;
        if (self._init) self._init.style.display = 'block';
    }
    start() {
        const self = this;
        self.slate.disable() // options.allowDrag = false;
        ;
        if (self._init) self._init.innerHTML = 'selecting [click to stop]...';
        document.head.insertAdjacentHTML('beforeend', `<style id='svg-no-select-text'>.slatebox-text { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }</style>`);
        // document.head.insertAdjacentHTML("beforeend", `<style id='svg-no-select-text'>svg text { pointer-events: none; }</style>`);
        const c = self.slate.options.container;
        self.slate.onSelectionStart = (e)=>{
            if (self.slate.options.showMultiSelect) {
                self.end();
                const p = self.xy(e);
                self.selRect = self.slate.paper.rect(p.x, p.y, 10, 10).attr({
                    'stroke-dasharray': '-'
                });
                _utilsDefault.default.addEvent(self.slate.canvas.get(), 'mousemove', self._move.bind(self), null);
                _utilsDefault.default.addEvent(self.slate.canvas.get(), 'mouseup', self._mouseUp.bind(self), null, true);
                _utilsDefault.default.addEvent(self.slate.canvas.get(), 'mouseleave', self._select.bind(self), null, true);
                window.addEventListener('beforeunload', self._enableOnRefresh);
                self.ox = p.x;
                self.oy = p.y;
            }
        };
    }
    _enableOnRefresh() {
        const self = this;
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.selectedNodes = [];
        self.slate.enable();
        self.broadcastMove() // broadcast an "empty" move to save the enabled state of the slate
        ;
    }
    showIcons() {
        const self = this;
        if (self.marker !== null) {
            const groupIds = _lodashUniqDefault.default(self.selectedNodes.map((n)=>n.options.groupId
            ));
            const isGrouped = groupIds.length === 1 && groupIds[0] !== null;
            const markerBB = self.marker.getBBox();
            const multiX = markerBB.x + markerBB.width + 45;
            // TODO: decide if you want to use a settings button here
            const showSettings = false;
            const height = 200;
            const heightSpacer = height / 4;
            self.iconBg?.remove();
            self.iconBg = self.slate.paper.rect(multiX - 10, markerBB.y + heightSpacer - 10, 50, heightSpacer * 3, 5).attr({
                ...self.attrs.create,
                opacity: 0.3
            }).toBack();
            const del = self.slate.paper.trash().attr({
                fill: '#fff',
                stroke: '#f00'
            }).transform([
                't',
                multiX,
                ',',
                markerBB.y + heightSpacer * 3,
                's',
                ',',
                '1.25',
                '1.25', 
            ].join());
            del.mouseover((e)=>{
                del.attr(self.attrs.mouseOver);
                _utilsDefault.default.stopEvent(e);
            });
            del.mouseout((e)=>{
                del.attr({
                    fill: '#fff',
                    stroke: '#f00'
                });
                _utilsDefault.default.stopEvent(e);
            });
            del.mousedown((e)=>{
                _utilsDefault.default.stopEvent(e);
                self.del();
            });
            const copy = self.slate.paper.copy().attr(self.attrs.create).transform([
                't',
                multiX,
                ',',
                markerBB.y + heightSpacer * 2,
                's',
                ',',
                '1.25',
                '1.25', 
            ].join());
            copy.mouseover((e)=>{
                copy.attr(self.attrs.mouseOver);
                _utilsDefault.default.stopEvent(e);
            });
            copy.mouseout((e)=>{
                copy.attr(self.attrs.mouseOut);
                _utilsDefault.default.stopEvent(e);
            });
            copy.mousedown((e)=>{
                _utilsDefault.default.stopEvent(e);
                const snap = self.slate.snapshot();
                const nGroupId = self.selectedNodes[0].options.groupId ? _utilsDefault.default.guid().replace(/-/gi, '').substring(0, 8).toUpperCase() : null;
                const orient = self.slate.getOrientation(self.selectedNodes);
                const pad = 75;
                const relationalMap = {
                };
                self.selectedNodes.forEach((node)=>{
                    const c = _lodashClonedeepDefault.default(node.options);
                    c.xPos += orient.width + pad;
                    c.groupId = nGroupId;
                    c.id = _utilsDefault.default.guid().replace(/-/gi, '').substring(0, 12);
                    relationalMap[node.options.id] = c.id;
                    c.vectorPath = _utilsDefault.default._transformPath(c.vectorPath, `T${orient.width + pad},0`);
                    const nn = new _index.Slatebox.node(c);
                    self.slate.nodes.add(nn);
                });
                // next add relationships
                const an = self.slate.nodes.allNodes;
                self.selectedNodes.forEach((node)=>{
                    const nn = an.find((n)=>n.options.id === relationalMap[node.options.id]
                    );
                    // with nn as "parent", add all its children
                    node.relationships.associations.filter((a)=>a.parent.options.id === node.options.id
                    ).forEach((a)=>{
                        const assocPkg = _lodashClonedeepDefault.default(a);
                        delete assocPkg.line // ensure new line is created
                        ;
                        assocPkg.id = _utilsDefault.default.guid().replace(/-/gi, '').substring(0, 12);
                        assocPkg.activeNode = relationalMap[assocPkg.activeNode];
                        let childNode = an.find((n)=>n.options.id === relationalMap[a.child.options.id]
                        );
                        if (!childNode) childNode = an.find((n)=>n.options.id === a.child.options.id
                        );
                        nn.relationships.addAssociation(childNode, assocPkg);
                    });
                });
                // send collaboration info
                const pkg = {
                    type: 'onNodeAdded',
                    data: self.slate.exportDifference(snap)
                };
                self.slate.collab.send(pkg);
            });
            self._icons.push(copy);
            if (!isGrouped) {
                const group = self.slate.paper.plus().attr(self.attrs.create).transform([
                    't',
                    multiX,
                    ',',
                    markerBB.y + heightSpacer,
                    's',
                    ',',
                    '1.25',
                    '1.25', 
                ].join());
                group.mouseover((e)=>{
                    group.attr(self.attrs.mouseOver);
                    _utilsDefault.default.stopEvent(e);
                });
                group.mouseout((e)=>{
                    group.attr(self.attrs.mouseOut);
                    _utilsDefault.default.stopEvent(e);
                });
                group.mousedown((e)=>{
                    const groupId = _utilsDefault.default.guid().replace(/-/gi, '').substring(0, 8).toUpperCase();
                    self.selectedNodes.forEach((n)=>{
                        n.options.groupId = groupId;
                    });
                    _utilsDefault.default.stopEvent(e);
                    self.endSelection();
                    self.end();
                    self.showGroup(groupId);
                });
                self._icons.push(group);
            } else {
                const ungroup = self.slate.paper.minus().attr(self.attrs.create).transform([
                    't',
                    multiX,
                    ',',
                    markerBB.y + heightSpacer,
                    's',
                    ',',
                    '1.25',
                    '1.25', 
                ].join());
                ungroup.mouseover((e)=>{
                    ungroup.attr(self.attrs.mouseOver);
                    _utilsDefault.default.stopEvent(e);
                });
                ungroup.mouseout((e)=>{
                    ungroup.attr(self.attrs.mouseOut);
                    _utilsDefault.default.stopEvent(e);
                });
                ungroup.mousedown((e)=>{
                    self.selectedNodes.forEach((n)=>{
                        n.options.groupId = null;
                    });
                    _utilsDefault.default.stopEvent(e);
                    self.hideIcons();
                    self.showIcons();
                });
                self._icons.push(ungroup);
                if (showSettings) {
                    const settings = self.slate.paper.setting().attr(self.attrs.create).transform([
                        't',
                        multiX,
                        ',',
                        markerBB.y + heightSpacer * 4,
                        's',
                        ',',
                        '1.25',
                        '1.25', 
                    ].join());
                    settings.mouseover((e)=>{
                        settings.attr(self.attrs.mouseOver);
                        _utilsDefault.default.stopEvent(e);
                    });
                    settings.mouseout((e)=>{
                        settings.attr(self.attrs.mouseOut);
                        _utilsDefault.default.stopEvent(e);
                    });
                    settings.mousedown((e)=>{
                        _utilsDefault.default.stopEvent(e);
                        self.selectedNodes[0].menu.show();
                    });
                    self._icons.push(settings);
                }
            }
            self._icons.push(del);
        }
    }
    hideIcons() {
        const self = this;
        self.iconBg?.remove();
        self._icons?.forEach((i)=>i.remove()
        );
    }
    isSelecting() {
        const self = this;
        return self.marker !== null;
    }
    del() {
        const self = this;
        self.slate.events.onConfirmRequested(`Confirm Deletion`, `Are you sure you want to remove these ${self.selectedNodes.length} node(s)?`, (blnConfirm)=>{
            if (blnConfirm) {
                self.selectedNodes.forEach((node)=>{
                    node.del();
                    self.slate.unglow();
                    const delPkg = {
                        type: 'onNodeDeleted',
                        data: {
                            id: node.options.id
                        }
                    };
                    self.slate.collab?.send(delPkg);
                    self.slate.birdsEye?.nodeDeleted(delPkg);
                });
                self.end();
            }
        });
    }
    end(hasMarker = true) {
        const self = this;
        if (self.marker !== null || !hasMarker) {
            self.marker?.remove();
            self.resizer?.remove();
            self.marker = null;
            self.slate.enable();
            // self.slate.keyboard && self.slate.keyboard.end();
            self.hideIcons();
            window.removeEventListener('beforeunload', self._enableOnRefresh);
        }
        if (self._init) self._init.innerHTML = '[multi-select]';
    }
    endSelection() {
        const self = this;
        self.selRect?.remove();
        self.showIcons();
        self.slate.options.allowDrag = true;
        self.slate.onSelectionStart = null;
        _utilsDefault.default.removeEvent(self.slate.canvas.get(), 'mousemove', self._move.bind(self));
    }
    xy(e) {
        const self = this;
        const mp = _utilsDefault.default.mousePos(e);
        const off = _utilsDefault.default.positionedOffset(self.slate.options.container);
        const _x = mp.x + self.slate.options.viewPort.left - off.left;
        const _y = mp.y + self.slate.options.viewPort.top - off.top;
        const z = self.slate.options.viewPort.zoom.r;
        return {
            x: _x / z,
            y: _y / z
        };
    }
    _move(e) {
        const self = this;
        if (!self.slate.draggingNode) {
            const p = self.xy(e);
            const height = p.y - self.oy;
            const width = p.x - self.ox;
            if (height > 0) self.selRect.attr({
                height
            });
            else self.selRect.attr({
                y: p.y,
                height: self.oy - p.y
            });
            if (width > 0) self.selRect.attr({
                width
            });
            else self.selRect.attr({
                x: p.x,
                width: self.ox - p.x
            });
        }
    }
    showGroup(groupId) {
        const self = this;
        self.selectedNodes = self.slate.nodes.allNodes.filter((n)=>n.options.groupId === groupId
        );
        if (self.prepSelectedNodes()) {
            self.refreshMarker();
            self.showIcons();
        }
    }
    refreshMarker() {
        const self = this;
        self.marker?.remove();
        self.resizer?.remove();
        self.iconBg?.remove();
        const z = self.slate.options.viewPort.zoom.r;
        const orient = self.slate.getOrientation(self.selectedNodes);
        let w = orient.width / z;
        let h = orient.height / z;
        if (w < self.minSize) w = self.minSize;
        if (h < self.minSize) h = self.minSize;
        self.marker = self.slate.paper.rect(orient.left / z, orient.top / z, w, h).attr({
            'stroke-dasharray': '-',
            fill: '#f8f8f8',
            opacity: 0.3
        });
        self.marker.toBack();
        self.slate?.grid.toBack();
        self.slate?.canvas.bgToBack();
        self.origPos = self.marker.getBBox();
        // self.resizer
        const _nx = self.origPos.x + self.origPos.width;
        const _ny = self.origPos.y + self.origPos.height;
        self.resizer = self.slate.paper.resize().transform([
            't',
            _nx - 5,
            ',',
            _ny - 5,
            'r95 s1.5,1.5'
        ].join()).attr({
            fill: '#fff',
            stroke: '#000'
        });
        self.resizer.toFront();
        self.resizer.mouseover((e)=>{
            self.resizer.attr(self.attrs.mouseOver);
            _utilsDefault.default.stopEvent(e);
        }) // self._resizeHover.bind(self));
        ;
        self.resizer.mouseout((e)=>{
            self.resizer.attr(self.attrs.mouseOut);
            _utilsDefault.default.stopEvent(e);
        }) // self._resizeHover.bind(self));
        ;
        // self.resizer.unmouseover(self._resizeHover.bind(self));
        self.marker.drag(self.markerEvents.move, self.markerEvents.init, self.markerEvents.up);
        self.resizer.drag(self.resizeEvents.move, self.resizeEvents.init, self.resizeEvents.up);
    }
    prepSelectedNodes() {
        const self = this;
        // select relevant connections
        if (self.selectedNodes.length > 1) {
            const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
            self.relationshipsToTranslate = _associations.relationshipsToTranslate;
            self.relationshipsToRefresh = _associations.relationshipsToRefresh;
            self.refreshMarker();
            self.endSelection();
            // unmark all and remove connectors
            self.slate.nodes.closeAllMenus({
                nodes: self.selectedNodes
            });
        } else if (self.selectedNodes.length === 1) {
            self.selectedNodes[0].menu.show();
            self.slate.enable();
            self.endSelection();
            self.end();
            return false;
        } else {
            self.slate.enable();
            self.endSelection();
            self.end();
            return true;
        }
        return false;
    }
    _mouseUp(e) {
        const self = this;
        if (self._init) self._init.innerHTML = '[multi-select]';
        this._select(e);
    }
    _select(e) {
        const self = this;
        const sr = self.selRect.getBBox();
        if (sr) {
            const withinBox = self.slate.nodes.allNodes.filter((n)=>{
                const inRange = n.options.xPos + n.options.width > sr.x && n.options.xPos < sr.x + sr.width && n.options.yPos + n.options.height > sr.y && n.options.yPos < sr.y + sr.height;
                return inRange && !n.options.isLocked;
            });
            // add any groupIds
            const groupIds = _lodashUniqDefault.default(withinBox.map((n)=>n.options.groupId
            )).filter((g)=>!!g
            );
            const alreadySelectedIds = withinBox.map((n)=>n.options.id
            );
            self.selectedNodes = self.slate.nodes.allNodes.filter((n)=>alreadySelectedIds.includes(n.options.id) || groupIds.includes(n.options.groupId)
            );
            self.prepSelectedNodes();
        }
    }
    static hideConnections(connections) {
        connections.forEach((c)=>{
            c.line.hide();
        });
    }
    static showConnections(connections) {
        connections.forEach((c)=>{
            c.line.show();
        });
    }
    broadcastMove() {
        const self = this;
        const pkg = {
            type: 'onNodesMove',
            data: self.slate.nodes.nodeMovePackage({
                nodes: self.selectedNodes,
                relationships: self.relationshipsToTranslate.concat(self.relationshipsToRefresh)
            })
        };
        self.slate.collab?.send(pkg);
        self.slate.birdsEye?.nodeChanged(pkg);
    }
}
exports.default = multiSelection;

},{"lodash.uniq":"iDalh","lodash.clonedeep":"i3u1q","../helpers/utils":"8QI6M","../helpers/refreshRelationships":"1UeYf","../index":"8lqZg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i3u1q":[function(require,module,exports) {
var global = arguments[3];
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {
};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Detect free variable `exports`. */ var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */ function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
}
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */ function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
}
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */ function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) break;
    }
    return array;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */ function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {
    }
    return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {
    };
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    return this.__data__['delete'](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */ function baseClone(value, isDeep, isFull, customizer, key1, object, stack) {
    var result;
    if (customizer) result = object ? customizer(value, key1, object, stack) : customizer(value);
    if (result !== undefined) return result;
    if (!isObject(value)) return value;
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray(value, result);
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) return cloneBuffer(value, isDeep);
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) return object ? value : {
            };
            result = initCloneObject(isFunc ? {
            } : value);
            if (!isDeep) return copySymbols(value, baseAssign(result, value));
        } else {
            if (!cloneableTags[tag]) return object ? value : {
            };
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
    arrayEach(props || value, function(subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
}
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */ function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {
    };
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    return objectToString.call(value);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != 'constructor') result.push(key);
    return result;
}
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */ function cloneBuffer(buffer, isDeep) {
    if (isDeep) return buffer.slice();
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
}
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */ function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */ function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */ function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
}
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */ function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */ function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
}
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */ function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {
    };
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */ function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    object || (object = {
    });
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */ function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {
    };
}
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
            return new Ctor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
            return new Ctor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
            return cloneSymbol(object);
    }
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {
        }
        try {
            return func + '';
        } catch (e1) {
        }
    }
    return '';
}
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */ function cloneDeep(value) {
    return baseClone(value, true, true);
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = cloneDeep;

},{}],"bRqCq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _slate = require("../core/slate");
var _slateDefault = parcelHelpers.interopDefault(_slate);
class birdsEye {
    constructor(slate){
        this.slate = slate;
        this.be = null;
        this.corner = null;
        this.handle = null;
        this.orx = null;
        this.sp = null;
        this.options = {
            size: 200,
            onHandleMove: null
        };
        this.parentDimen = null;
        this.lastX = null;
        this.lastY = null;
        this.wpadding = null;
        this.hpadding = null;
    }
    setBe() {
        if (this.be) this.be.style.left = `${this.parentDimen.width - this.options.size}px`;
        if (this.be) this.be.style.top = '-2px';
    }
    _hideText() {
        this.corner.nodes.allNodes.forEach((node)=>{
            node.text.hide();
        });
    }
    _wireHandle() {
        const self = this;
        let start = {
        };
        const init = function hnd() {
            self.handle.ox = this.attr('x');
            self.handle.oy = this.attr('y');
            start = _utilsDefault.default.positionedOffset(self.slate.canvas.internal);
        };
        const move = function mv(x, y) {
            const _zr = self.corner.options.viewPort.originalWidth / self.sp;
            x += x / _zr - x;
            y += y / _zr - y;
            const _mx = self.handle.ox + x;
            const _my = self.handle.oy + y;
            self.handle.attr({
                x: _mx,
                y: _my
            });
            const bb = self.handle.getBBox();
            const _cx = bb.x * self.slate.options.viewPort.zoom.r;
            const _cy = bb.y * self.slate.options.viewPort.zoom.r;
            self.options.onHandleMove?.apply(self, [
                _cx,
                _cy
            ]);
            self.slate.canvas.move({
                x: _cx,
                y: _cy,
                dur: 0,
                isAbsolute: true
            });
            self.lastX = bb.x;
            self.lastY = bb.y;
        };
        const up = ()=>{
            self.refresh();
            const end = _utilsDefault.default.positionedOffset(self.slate.canvas.internal);
            self.slate.canvas.broadcast({
                x: start.left - end.left,
                y: start.top - end.top
            });
        };
        self.handle.drag(move, init, up);
    }
    show(_options) {
        const self = this;
        Object.assign(self.options, _options);
        const c = self.slate.options.container;
        self.parentDimen = _utilsDefault.default.getDimensions(c);
        self.be = document.createElement('div');
        self.be.setAttribute('id', `slatebirdsEye_${self.slate.options.id}`);
        self.be.setAttribute('class', 'slatebirdsEye');
        self.be.style.position = 'absolute';
        self.be.style.height = `${self.options.size}px`;
        self.be.style.width = `${self.options.size}px`;
        self.be.style.border = '2px inset #333';
        self.be.style.backgroundColor = '#fff';
        c.appendChild(self.be);
        self.setBe();
        self.corner = new _slateDefault.default({
            container: `slatebirdsEye_${self.slate.options.id}`,
            viewPort: {
                allowDrag: false
            },
            collaboration: {
                allow: false
            },
            showZoom: false,
            showUndoRedo: false,
            showMultiSelect: false,
            showbirdsEye: false,
            showLocks: false,
            imageFolder: '',
            isbirdsEye: true
        }, {
            onNodeDragged () {
                self.slate.nodes.copyNodePositions(self.corner.nodes.allNodes);
            }
        }).init();
        self.refresh();
        _utilsDefault.default.addEvent(window, 'resize', ()=>{
            const cx = self.slate.options.container;
            self.parentDimen = _utilsDefault.default.getDimensions(cx);
            self.setBe();
        });
    }
    enabled() {
        return this.corner !== null;
    }
    enable() {
        if (!this.corner) this.show();
        this.be.style.display = 'block';
    }
    disable() {
        this.be.style.display = 'none';
    }
    relationshipsChanged(pkg) {
        if (this.corner) switch(pkg.type){
            case 'removeRelationship':
                this.corner.nodes.removeRelationship(pkg.data);
                break;
            case 'addRelationship':
                var __pkg = JSON.parse(JSON.stringify(pkg));
                Object.assign(__pkg.data, {
                    options: {
                        lineWidth: 1
                    }
                });
                // data: { id: this.slate.options.id, relationships: rels} };
                this.corner.nodes.addRelationship(__pkg.data);
                break;
            default:
                break;
        }
    }
    nodeChanged(pkg) {
        if (this.corner) {
            if (pkg.type === 'onNodesMove') this.corner.nodes.moveNodes(pkg, {
                useMainCanvas: true
            });
            else {
                const _node = this.corner.nodes.one(pkg.data.id);
                if (_node) {
                    const useMainCanvas = true;
                    switch(pkg.type){
                        case 'onNodeShapeChanged':
                            _node.shapes.set(pkg.data);
                            break;
                        case 'onNodeTextChanged':
                            _node.editor.set(pkg.data.text, pkg.data.fontSize, pkg.data.fontFamily, pkg.data.fontColor, pkg.data.textXAlign, pkg.data.textYAlign);
                            break;
                        case 'onNodeColorChanged':
                            _node.colorPicker.set(pkg.data);
                            break;
                        case 'onNodeImageChanged':
                            _node.images.set(pkg.data.img, pkg.data.w, pkg.data.h, useMainCanvas);
                            this.refresh();
                            break;
                        case 'onNodeResized':
                            Object.assign(_node.options, pkg.data);
                            _node.vect.attr({
                                path: pkg.data.vectorPath
                            });
                            if (_node.vect.pattern) _node.images.imageSizeCorrection();
                            this.refresh();
                            break;
                        case 'onNodeRotated':
                            {
                                pkg.data.associations.forEach((association)=>{
                                    const currentAssociation = _node.relationships.associations.find((ass)=>ass.child.options.id === association.childId && ass.parent.options.id === association.parentId
                                    );
                                    if (currentAssociation) currentAssociation.line.attr({
                                        path: association.linePath
                                    });
                                });
                                Object.assign(_node.options, _lodashOmitDefault.default(pkg.data, 'associations'));
                                const tempPath = this.slate.paper.path(_node.vect.attr('path'));
                                tempPath.remove();
                                _node.rotate.applyImageRotation();
                                this.refresh();
                                break;
                            }
                        case 'onNodeToFront':
                            _node.vect.toFront();
                            break;
                        case 'onNodeToBack':
                            _node.vect.toBack();
                            break;
                        case 'onNodeLocked':
                            _node.options.allowDrag = false;
                            break;
                        case 'onNodeUnlocked':
                            _node.options.allowDrag = true;
                            break;
                        case 'changeLineColor':
                            _node.lineOptions.set(pkg.data);
                            break;
                        default:
                            break;
                    }
                }
            }
        }
    }
    nodeDeleted(pkg) {
        if (this.corner) {
            const _node = this.corner.nodes.one(pkg.data.id);
            _node.del();
        }
    }
    nodeDetatched(pkg) {
        if (this.corner) {
            const _node = this.corner.nodes.one(pkg.data.id);
            _node.relationships.detatch();
        }
    }
    reload(json) {
        this.handle?.remove();
        this.corner.loadJSON(json);
        this.refresh(true);
    }
    refresh(blnNoAdditions) {
        if (this.corner) {
            const c = this.slate.options.container;
            this.parentDimen = _utilsDefault.default.getDimensions(c);
            this.handle?.remove();
            if (blnNoAdditions === true) {
                this.corner.canvas.move({
                    x: this.slate.options.viewPort.left,
                    y: this.slate.options.viewPort.top,
                    dur: 0,
                    isAbsolute: true
                });
                const useMainCanvas = true;
                this.corner.nodes.copyNodePositions(this.slate.nodes.allNodes, useMainCanvas);
            } else {
                const _export = this.slate.exportDifference(this.corner, 1) // line width override
                ;
                this.corner.loadJSON(_export, true, true, true, true);
            }
            this.orx = this.slate.getOrientation();
            if (this.slate.options.viewPort.left < this.orx.left) this.wpadding = this.slate.options.viewPort.left - this.orx.left;
            else this.wpadding = this.slate.options.viewPort.left - this.orx.left + (this.parentDimen.width - this.orx.width);
            this.hpadding = this.slate.options.viewPort.top - this.orx.top;
            const _pw = Math.max(Math.abs(this.wpadding), this.orx.width < this.parentDimen.width ? this.parentDimen.width - this.orx.width : 0);
            const _ph = Math.max(Math.abs(this.hpadding), this.orx.height < this.parentDimen.height ? this.parentDimen.height - this.orx.height : 0);
            const wp = (this.orx.width + _pw) / this.options.size * this.slate.options.viewPort.width;
            const hp = (this.orx.height + _ph) / this.options.size * this.slate.options.viewPort.height;
            this.sp = Math.max(wp, hp);
            const _r = Math.max(this.slate.options.viewPort.width, this.slate.options.viewPort.height) / this.sp;
            const l = (this.orx.left + (this.wpadding < 0 ? this.wpadding : 0)) * _r - 5;
            const t = (this.orx.top + (this.hpadding < 0 ? this.hpadding : 0)) * _r - 5;
            this.corner.zoom(0, 0, this.sp, this.sp, true);
            this.corner.options.viewPort.zoom.r = this.corner.options.viewPort.originalWidth / this.sp;
            // this.corner.zoom();
            this.corner.canvas.move({
                x: l,
                y: t,
                dur: 0,
                isAbsolute: true
            });
            this.corner.disable();
            const _ix = this.slate.options.viewPort.left / this.slate.options.viewPort.zoom.r;
            const _iy = this.slate.options.viewPort.top / this.slate.options.viewPort.zoom.r;
            const _w = this.parentDimen.width / this.slate.options.viewPort.zoom.r;
            const _h = this.parentDimen.height / this.slate.options.viewPort.zoom.r;
            this.handle = this.corner.paper.rect(_ix, _iy, _w, _h).attr({
                stroke: '#000',
                'stroke-width': 2,
                fill: '#FFEB3A',
                'fill-opacity': '.5'
            });
            this._hideText();
            this._wireHandle();
        }
    }
}
exports.default = birdsEye;

},{"lodash.omit":"82TGT","../helpers/utils":"8QI6M","../core/slate":"khicH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9OwD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _wheelGestures = require("wheel-gestures");
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class inertia {
    constructor(slate){
        this.slate = slate;
        this.scale = 1;
        this.wheelEnd = null;
        this.xyOffset = null;
        if (slate.options.viewPort.useInertiaScrolling) this._init();
    }
    setScale(val) {
        this.scale = val;
    }
    _init() {
        const self = this;
        const wheelGestures = _wheelGestures.WheelGestures({
            momentum: true
        });
        // find and observe the element the user can interact with
        wheelGestures.observe(self.slate.canvas.internal);
        // function scale() {
        //   window.requestAnimationFrame(() => {
        //     const style = { transform: `scale(${self.scale})` } //, "transform-origin": `${self.slate.options.viewPort.left}px ${self.slate.options.viewPort.top}px` };
        //     console.log("ws is now", self.xyOffset);
        //     self.slate.canvas.internal.style["transform-origin"] = `${self.slate.options.viewPort.left + self.xyOffset.x}px ${self.slate.options.viewPort.top + self.xyOffset.y}px`;
        //     self.slate.canvas.internal.style.transform = `scale(${self.slate.options.viewPort.zoom.r})`; // = style;
        //   })
        // }
        // add your event callback
        let start = {
        };
        wheelGestures.on('wheel', (e)=>{
            if (self.slate.options.allowDrag) {
                if (e.event.ctrlKey) ;
                else {
                    const deltaX = e.event.deltaX * 0.8 // .5 is the modifier to slow self down a bit
                    ;
                    const deltaY = e.event.deltaY * 0.8;
                    if (e.isStart) {
                        start = _utilsDefault.default.positionedOffset(self.slate.canvas.internal);
                        // hide filters during dragging
                        self.slate.toggleFilters(true);
                    }
                    self.slate.canvas.move({
                        x: deltaX,
                        y: deltaY,
                        dur: 0,
                        isAbsolute: false
                    });
                    if (e.isEnding) {
                        const end = _utilsDefault.default.positionedOffset(self.slate.canvas.internal);
                        self.slate.birdsEye?.refresh(true);
                        self.slate.canvas.broadcast({
                            x: start.left - end.left,
                            y: start.top - end.top
                        });
                        // show filters after dragging
                        self.slate.toggleFilters(false);
                    }
                }
            }
        });
    }
}
exports.default = inertia;

},{"wheel-gestures":"9N55x","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9N55x":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WheelGestures", ()=>WheelGestures
);
parcelHelpers.export(exports, "absMax", ()=>absMax
);
parcelHelpers.export(exports, "addVectors", ()=>addVectors
);
parcelHelpers.export(exports, "average", ()=>average
);
parcelHelpers.export(exports, "clamp", ()=>clamp
);
parcelHelpers.export(exports, "configDefaults", ()=>configDefaults
);
parcelHelpers.export(exports, "deepFreeze", ()=>deepFreeze
);
parcelHelpers.export(exports, "lastOf", ()=>lastOf
);
parcelHelpers.export(exports, "projection", ()=>projection
);
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var DECAY = 0.996;
/**
 * movement projection based on velocity
 * @param velocityPxMs
 * @param decay
 */ var projection = function projection(velocityPxMs, decay) {
    if (decay === void 0) decay = DECAY;
    return velocityPxMs * decay / (1 - decay);
};
function lastOf(array) {
    return array[array.length - 1];
}
function average(numbers) {
    return numbers.reduce(function(a, b) {
        return a + b;
    }) / numbers.length;
}
var clamp = function clamp(value, min, max) {
    return Math.min(Math.max(min, value), max);
};
function addVectors(v1, v2) {
    if (v1.length !== v2.length) throw new Error('vectors must be same length');
    return v1.map(function(val, i) {
        return val + v2[i];
    });
}
function absMax(numbers) {
    return Math.max.apply(Math, numbers.map(Math.abs));
} // eslint-disable-next-line @typescript-eslint/ban-types
function deepFreeze(o) {
    Object.freeze(o);
    Object.values(o).forEach(function(value) {
        if (value !== null && typeof value === 'object' && !Object.isFrozen(value)) deepFreeze(value);
    });
    return o;
}
function EventBus() {
    var listeners = {
    };
    function on(type, listener) {
        listeners[type] = (listeners[type] || []).concat(listener);
        return function() {
            return off(type, listener);
        };
    }
    function off(type, listener) {
        listeners[type] = (listeners[type] || []).filter(function(l) {
            return l !== listener;
        });
    }
    function dispatch(type, data) {
        if (!(type in listeners)) return;
        listeners[type].forEach(function(l) {
            return l(data);
        });
    }
    return deepFreeze({
        on: on,
        off: off,
        dispatch: dispatch
    });
}
function WheelTargetObserver(eventListener) {
    var targets = []; // add event listener to target element
    var observe = function observe(target) {
        target.addEventListener('wheel', eventListener, {
            passive: false
        });
        targets.push(target);
        return function() {
            return unobserve(target);
        };
    }; /// remove event listener from target element
    var unobserve = function unobserve(target) {
        target.removeEventListener('wheel', eventListener);
        targets = targets.filter(function(t) {
            return t !== target;
        });
    }; // stops watching all of its target elements for visibility changes.
    var disconnect = function disconnect() {
        targets.forEach(unobserve);
    };
    return deepFreeze({
        observe: observe,
        unobserve: unobserve,
        disconnect: disconnect
    });
}
var LINE_HEIGHT = 18;
var PAGE_HEIGHT = typeof window !== 'undefined' && window.innerHeight || 800;
var DELTA_MODE_UNIT = [
    1,
    LINE_HEIGHT,
    PAGE_HEIGHT
];
function normalizeWheel(e) {
    var deltaX = e.deltaX * DELTA_MODE_UNIT[e.deltaMode];
    var deltaY = e.deltaY * DELTA_MODE_UNIT[e.deltaMode];
    var deltaZ = (e.deltaZ || 0) * DELTA_MODE_UNIT[e.deltaMode];
    return {
        timeStamp: e.timeStamp,
        axisDelta: [
            deltaX,
            deltaY,
            deltaZ
        ]
    };
}
var reverseAll = [
    -1,
    -1,
    -1
];
function reverseAxisDeltaSign(wheel, reverseSign) {
    if (!reverseSign) return wheel;
    var multipliers = reverseSign === true ? reverseAll : reverseSign.map(function(shouldReverse) {
        return shouldReverse ? -1 : 1;
    });
    return _extends({
    }, wheel, {
        axisDelta: wheel.axisDelta.map(function(delta, i) {
            return delta * multipliers[i];
        })
    });
}
var DELTA_MAX_ABS = 700;
var clampAxisDelta = function clampAxisDelta(wheel) {
    return _extends({
    }, wheel, {
        axisDelta: wheel.axisDelta.map(function(delta) {
            return clamp(delta, -DELTA_MAX_ABS, DELTA_MAX_ABS);
        })
    });
};
var __DEV__ = true;
var ACC_FACTOR_MIN = 0.6;
var ACC_FACTOR_MAX = 0.96;
var WHEELEVENTS_TO_MERGE = 2;
var WHEELEVENTS_TO_ANALAZE = 5;
var configDefaults = /*#__PURE__*/ deepFreeze({
    preventWheelAction: true,
    reverseSign: [
        true,
        true,
        false
    ]
});
var WILL_END_TIMEOUT_DEFAULT = 400;
function createWheelGesturesState() {
    return {
        isStarted: false,
        isStartPublished: false,
        isMomentum: false,
        startTime: 0,
        lastAbsDelta: Infinity,
        axisMovement: [
            0,
            0,
            0
        ],
        axisVelocity: [
            0,
            0,
            0
        ],
        accelerationFactors: [],
        scrollPoints: [],
        scrollPointsToMerge: [],
        willEndTimeout: WILL_END_TIMEOUT_DEFAULT
    };
}
function WheelGestures(optionsParam) {
    if (optionsParam === void 0) optionsParam = {
    };
    var _EventBus = EventBus(), on = _EventBus.on, off = _EventBus.off, dispatch = _EventBus.dispatch;
    var config = configDefaults;
    var state = createWheelGesturesState();
    var currentEvent;
    var negativeZeroFingerUpSpecialEvent = false;
    var prevWheelEventState;
    var feedWheel = function feedWheel(wheelEvents) {
        if (Array.isArray(wheelEvents)) wheelEvents.forEach(function(wheelEvent) {
            return processWheelEventData(wheelEvent);
        });
        else processWheelEventData(wheelEvents);
    };
    var updateOptions = function updateOptions(newOptions) {
        if (newOptions === void 0) newOptions = {
        };
        if (Object.values(newOptions).some(function(option) {
            return option === undefined || option === null;
        })) {
            __DEV__ && console.error('updateOptions ignored! undefined & null options not allowed');
            return config;
        }
        return config = deepFreeze(_extends({
        }, configDefaults, config, newOptions));
    };
    var publishWheel = function publishWheel(additionalData) {
        var wheelEventState = _extends({
            event: currentEvent,
            isStart: false,
            isEnding: false,
            isMomentumCancel: false,
            isMomentum: state.isMomentum,
            axisDelta: [
                0,
                0,
                0
            ],
            axisVelocity: state.axisVelocity,
            axisMovement: state.axisMovement,
            get axisMovementProjection () {
                return addVectors(wheelEventState.axisMovement, wheelEventState.axisVelocity.map(function(velocity) {
                    return projection(velocity);
                }));
            }
        }, additionalData);
        dispatch('wheel', _extends({
        }, wheelEventState, {
            previous: prevWheelEventState
        })); // keep reference without previous, otherwise we would create a long chain
        prevWheelEventState = wheelEventState;
    }; // should prevent when there is mainly movement on the desired axis
    var shouldPreventDefault = function shouldPreventDefault(deltaMaxAbs, axisDelta) {
        var _config = config, preventWheelAction = _config.preventWheelAction;
        var deltaX = axisDelta[0], deltaY = axisDelta[1], deltaZ = axisDelta[2];
        if (typeof preventWheelAction === 'boolean') return preventWheelAction;
        switch(preventWheelAction){
            case 'x':
                return Math.abs(deltaX) >= deltaMaxAbs;
            case 'y':
                return Math.abs(deltaY) >= deltaMaxAbs;
            case 'z':
                return Math.abs(deltaZ) >= deltaMaxAbs;
            default:
                __DEV__ && console.warn('unsupported preventWheelAction value: ' + preventWheelAction, 'warn');
                return false;
        }
    };
    var processWheelEventData = function processWheelEventData(wheelEvent) {
        var _clampAxisDelta = clampAxisDelta(reverseAxisDeltaSign(normalizeWheel(wheelEvent), config.reverseSign)), axisDelta = _clampAxisDelta.axisDelta, timeStamp = _clampAxisDelta.timeStamp;
        var deltaMaxAbs = absMax(axisDelta);
        if (wheelEvent.preventDefault && shouldPreventDefault(deltaMaxAbs, axisDelta)) wheelEvent.preventDefault();
        if (!state.isStarted) start();
        else if (state.isMomentum && deltaMaxAbs > Math.max(2, state.lastAbsDelta * 2)) {
            end(true);
            start();
        } // special finger up event on windows + blink
        if (deltaMaxAbs === 0 && Object.is && Object.is(wheelEvent.deltaX, -0)) {
            negativeZeroFingerUpSpecialEvent = true; // return -> zero delta event should not influence velocity
            return;
        }
        currentEvent = wheelEvent;
        state.axisMovement = addVectors(state.axisMovement, axisDelta);
        state.lastAbsDelta = deltaMaxAbs;
        state.scrollPointsToMerge.push({
            axisDelta: axisDelta,
            timeStamp: timeStamp
        });
        mergeScrollPointsCalcVelocity(); // only wheel event (move) and not start/end get the delta values
        publishWheel({
            axisDelta: axisDelta,
            isStart: !state.isStartPublished
        }); // state.isMomentum ? MOMENTUM_WHEEL : WHEEL, { axisDelta })
        // publish start after velocity etc. have been updated
        state.isStartPublished = true; // calc debounced end function, to recognize end of wheel event stream
        willEnd();
    };
    var mergeScrollPointsCalcVelocity = function mergeScrollPointsCalcVelocity() {
        if (state.scrollPointsToMerge.length === WHEELEVENTS_TO_MERGE) {
            state.scrollPoints.unshift({
                axisDeltaSum: state.scrollPointsToMerge.map(function(b) {
                    return b.axisDelta;
                }).reduce(addVectors),
                timeStamp: average(state.scrollPointsToMerge.map(function(b) {
                    return b.timeStamp;
                }))
            }); // only update velocity after a merged scrollpoint was generated
            updateVelocity(); // reset toMerge array
            state.scrollPointsToMerge.length = 0; // after calculation of velocity only keep the most recent merged scrollPoint
            state.scrollPoints.length = 1;
            if (!state.isMomentum) detectMomentum();
        } else if (!state.isStartPublished) updateStartVelocity();
    };
    var updateStartVelocity = function updateStartVelocity() {
        state.axisVelocity = lastOf(state.scrollPointsToMerge).axisDelta.map(function(d) {
            return d / state.willEndTimeout;
        });
    };
    var updateVelocity = function updateVelocity() {
        // need to have two recent points to calc velocity
        var _state$scrollPoints = state.scrollPoints, latestScrollPoint = _state$scrollPoints[0], prevScrollPoint = _state$scrollPoints[1];
        if (!prevScrollPoint || !latestScrollPoint) return;
         // time delta
        var deltaTime = latestScrollPoint.timeStamp - prevScrollPoint.timeStamp;
        if (deltaTime <= 0) {
            __DEV__ && console.warn('invalid deltaTime');
            return;
        } // calc the velocity per axes
        var velocity = latestScrollPoint.axisDeltaSum.map(function(d) {
            return d / deltaTime;
        }); // calc the acceleration factor per axis
        var accelerationFactor = velocity.map(function(v, i) {
            return v / (state.axisVelocity[i] || 1);
        });
        state.axisVelocity = velocity;
        state.accelerationFactors.push(accelerationFactor);
        updateWillEndTimeout(deltaTime);
    };
    var updateWillEndTimeout = function updateWillEndTimeout(deltaTime) {
        // use current time between events rounded up and increased by a bit as timeout
        var newTimeout = Math.ceil(deltaTime / 10) * 12; // double the timeout, when momentum was not detected yet
        if (!state.isMomentum) newTimeout = Math.max(100, newTimeout * 2);
        state.willEndTimeout = Math.min(1000, Math.round(newTimeout));
    };
    var accelerationFactorInMomentumRange = function accelerationFactorInMomentumRange(accFactor) {
        // when main axis is the the other one and there is no movement/change on the current one
        if (accFactor === 0) return true;
        return accFactor <= ACC_FACTOR_MAX && accFactor >= ACC_FACTOR_MIN;
    };
    var detectMomentum = function detectMomentum() {
        if (state.accelerationFactors.length >= WHEELEVENTS_TO_ANALAZE) {
            if (negativeZeroFingerUpSpecialEvent) {
                negativeZeroFingerUpSpecialEvent = false;
                if (absMax(state.axisVelocity) >= 0.2) {
                    recognizedMomentum();
                    return;
                }
            }
            var recentAccelerationFactors = state.accelerationFactors.slice(WHEELEVENTS_TO_ANALAZE * -1); // check recent acceleration / deceleration factors
            // all recent need to match, if any did not match
            var detectedMomentum = recentAccelerationFactors.every(function(accFac) {
                // when both axis decelerate exactly in the same rate it is very likely caused by momentum
                var sameAccFac = !!accFac.reduce(function(f1, f2) {
                    return f1 && f1 < 1 && f1 === f2 ? 1 : 0;
                }); // check if acceleration factor is within momentum range
                var bothAreInRangeOrZero = accFac.filter(accelerationFactorInMomentumRange).length === accFac.length; // one the requirements must be fulfilled
                return sameAccFac || bothAreInRangeOrZero;
            });
            if (detectedMomentum) recognizedMomentum();
             // only keep the most recent events
            state.accelerationFactors = recentAccelerationFactors;
        }
    };
    var recognizedMomentum = function recognizedMomentum() {
        state.isMomentum = true;
    };
    var start = function start() {
        state = createWheelGesturesState();
        state.isStarted = true;
        state.startTime = Date.now();
        prevWheelEventState = undefined;
        negativeZeroFingerUpSpecialEvent = false;
    };
    var willEnd = function() {
        var willEndId;
        return function() {
            clearTimeout(willEndId);
            willEndId = setTimeout(end, state.willEndTimeout);
        };
    }();
    var end = function end(isMomentumCancel) {
        if (isMomentumCancel === void 0) isMomentumCancel = false;
        if (!state.isStarted) return;
        if (state.isMomentum && isMomentumCancel) publishWheel({
            isEnding: true,
            isMomentumCancel: true
        });
        else publishWheel({
            isEnding: true
        });
        state.isMomentum = false;
        state.isStarted = false;
    };
    var _WheelTargetObserver = WheelTargetObserver(feedWheel), observe = _WheelTargetObserver.observe, unobserve = _WheelTargetObserver.unobserve, disconnect = _WheelTargetObserver.disconnect;
    updateOptions(optionsParam);
    return deepFreeze({
        on: on,
        off: off,
        observe: observe,
        unobserve: unobserve,
        disconnect: disconnect,
        feedWheel: feedWheel,
        updateOptions: updateOptions
    });
}
exports.default = WheelGestures;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2xnBR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class controller {
    constructor(slate){
        this.slate = slate;
    }
    static perform(pkg, node, op, cb) {
        const det = op.split('@');
        let dur = pkg.defaultDuration || 300;
        const param = det[1];
        switch(det[0]){
            case 'zoom':
                dur = det.length > 2 ? parseFloat(det[2], 10) : pkg.defaultDuration;
                node.zoom(param, dur, cb);
                break;
            case 'position':
                {
                    const ease = det.length > 2 ? det[2] : pkg.defaultEasing;
                    dur = det.length > 3 ? parseFloat(det[3], 10) : pkg.defaultDuration;
                    node.position(param, cb, ease, dur);
                    break;
                }
            default:
                break;
        }
    }
    scaleToFitNodes(_opts) {
        const opts = {
            nodes: null,
            dur: 0,
            cb: null,
            offset: 0,
            minWidth: 60,
            minHeight: 30
        };
        Object.assign(opts, _opts);
        const orient = this.slate.getOrientation(opts.nodes);
        const d = _utilsDefault.default.getDimensions(this.slate.options.container);
        const r = this.slate.options.viewPort.zoom.r || 1;
        const widthZoomPercent = parseInt(d.width / (orient.width / r) * 100, 10) // division by r converts it back from the scaled version
        ;
        const heightZoomPercent = parseInt(d.height / (orient.height / r) * 100, 10);
        // zoom canvas
        this.slate.canvas.zoom({
            dur: opts.dur,
            callbacks: {
                after () {
                    if (opts.cb) opts.cb();
                }
            },
            easing: 'easeFromTo',
            zoomPercent: Math.min(widthZoomPercent, heightZoomPercent)
        });
    }
    // useful for centering the canvas on a collection of nodes
    centerOnNodes(_opts) {
        const self = this;
        const opts = {
            nodes: null,
            dur: 500,
            cb: null
        };
        Object.assign(opts, _opts);
        const orient = self.slate.getOrientation(opts.nodes);
        const d = _utilsDefault.default.getDimensions(self.slate.options.container);
        const cw = d.width;
        const ch = d.height;
        const nw = orient.width;
        const nh = orient.height;
        // get upper left coords
        const x = orient.left - (cw / 2 - nw / 2);
        const y = orient.top - (ch / 2 - nh / 2);
        self.slate.canvas.move({
            x,
            y,
            isAbsolute: true,
            dur: opts.dur,
            easing: 'swingFromTo',
            callbacks: {
                after () {
                    setTimeout(()=>{
                        self.slate.birdseye?.refresh(true);
                    }, 100);
                    if (opts.cb) opts.cb();
                }
            }
        });
    }
    // useful for centering the canvas by comparing the viewport's previous width/height to its current width/height
    center(_opts) {
        const self = this;
        const opts = {
            previousWindowSize: {
            },
            dur: 500,
            cb: null
        };
        Object.assign(opts, _opts);
        const ws = _utilsDefault.default.windowSize();
        this.slate.canvas.move({
            x: (ws.width - opts.previousWindowSize.w) / 2 * -1,
            y: (ws.height - opts.previousWindowSize.h) / 2 * -1,
            duration: opts.dur,
            isAbsolute: false,
            easing: 'swingFromTo',
            callbacks: {
                after: ()=>{
                    self.slate.birdseye?.refresh(true);
                    if (opts.cb) opts.cb();
                }
            }
        });
        return ws;
    }
    // experimental
    bop(opts) {
        const dur = opts && opts.dur && opts.dur !== 0 ? opts.dur : 300;
        const locale = 'center';
        const ease = 'easeTo';
        const presentNodes = _.map(this.slate.nodes.allNodes, (a)=>({
                name: a.options.name,
                operations: [
                    `position@${locale}@${ease}@${dur}`
                ]
            })
        );
        this.slate.controller.present({
            nodes: presentNodes,
            // eslint-disable-next-line no-unused-vars
            nodeChanged: (node)=>{
            },
            // eslint-disable-next-line no-unused-vars
            opChanged: (op)=>{
            },
            complete: ()=>{
            },
            sync: {
                zoom: true,
                position: true
            }
        });
    }
    // expiremental
    shakeNodes() {
        const self = this;
        let s = 0;
        function move() {
            s += 1;
            const mPkg = {
                dur: 500,
                moves: [
                    {
                        id: '*',
                        x: s % 2 === 0 ? 20 : -20,
                        y: s % 2 === 0 ? -20 : -20
                    }, 
                ]
            };
            const pkg = self.slate.nodes.nodeMovePackage(mPkg);
            self.slate.nodes.moveNodes(pkg, {
                animate: true,
                cb: ()=>{
                    setTimeout(()=>{
                        move();
                    }, 4000);
                }
            });
        }
        move();
    }
    pulse(opts) {
        let cycles = 0;
        let dur = 10000 // slow
        ;
        let czp;
        let zp;
        function calc() {
            czp = this.slate.options.viewPort.zoom.r * 100;
            zp = {
                in: czp + 5,
                out: czp - 5
            } // nuance;
            ;
            if (opts) {
                switch(opts.speed){
                    case 'fast':
                        dur = 3000;
                        break;
                    default:
                        break;
                }
                switch(opts.subtlety){
                    case 'trump':
                        zp = {
                            in: czp + 60,
                            out: czp - 60
                        };
                        break;
                    default:
                        break;
                }
            }
        }
        function run(zpp, cb) {
            this.slate.canvas.zoom({
                dur,
                callbacks: {
                    after () {
                        if (cb) cb();
                    }
                },
                easing: 'easeFromTo',
                zoomPercent: zpp
            });
        }
        function cycle() {
            run(zp.in, ()=>{
                run(zp.out, ()=>{
                    cycles += 1;
                    if (opts && opts.cycle && cycles >= opts.cycle) {
                        if (opts.cb) opts.cb();
                    } else cycle();
                });
            });
        }
        if (opts && opts.center) this.scaleToFitAndCenter(()=>{
            calc();
            cycle();
        });
        else {
            calc();
            cycle();
        }
    }
    scaleToFitAndCenter(cb, dur) {
        this.slate.controller.scaleToFitNodes({
            dur: dur != null ? dur : 0,
            cb: ()=>{
                this.centerOnNodes({
                    dur: 0
                });
                if (cb) cb();
            }
        });
    }
    present(pkg) {
        const self = this;
        let currentOperations = [];
        let n = null;
        function next() {
            if (currentOperations.length === 0) {
                if (pkg.nodes.length > 0) {
                    const node = pkg.nodes.shift();
                    n = this.slate.nodes.allNodes.find((nx)=>nx.options.name === node.name
                    );
                    currentOperations = node.operations;
                    if (pkg.nodeChanged) pkg.nodeChanged(node);
                }
            }
            if (currentOperations.length > 0) {
                const op = currentOperations.shift();
                if (pkg.opChanged) pkg.opChanged(op);
                controller.perform(pkg, n, op, (p)=>{
                    const sync = pkg.sync !== undefined ? pkg.sync[p.operation] : false;
                    switch(p.operation){
                        case 'zoom':
                            if (sync) this.slate.collab?.send({
                                type: 'onZoom',
                                data: {
                                    id: p.id,
                                    zoomLevel: p.zoomLevel
                                }
                            });
                            break;
                        case 'position':
                            if (sync) this.slate.collab?.send({
                                type: 'onNodePositioned',
                                data: {
                                    id: p.id,
                                    location: p.location,
                                    easing: p.easing
                                }
                            });
                            break;
                        default:
                            break;
                    }
                    next();
                });
            } else if (pkg.complete) pkg.complete();
        }
        next();
    }
}
exports.default = controller;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6TbYF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class zoomSlider {
    constructor(slate){
        const self = this;
        self.slate = slate;
        self.slider = null;
        self.sliderId = `sb-zoom-slider-${_utilsDefault.default.guid().substring(8)}`;
    }
    setValue(val) {
        if (this.slider) this.slider.setValue(val);
    }
    hide() {
    // this.slider.style.display = 'none'
    }
    show(_options) {
        const self = this;
        console.log('showing zoom', self.slate.isReadOnly(), self.slate.isCommentOnly());
        if (!self.slate.isReadOnly() && !self.slate.isCommentOnly()) {
            self.hide();
            const options = {
                height: 320,
                width: 28,
                offset: {
                    left: 39,
                    top: 85
                },
                slider: {
                    height: 300,
                    min: 6000,
                    max: 200000,
                    set: 5000
                }
            };
            Object.assign(options, _options);
            const c = self.slate.options.container;
            const scx = document.createElement('div');
            scx.setAttribute('id', `slateSlider_${self.slate.options.id}`);
            scx.style.position = 'absolute';
            scx.style.height = `${options.height}px`;
            scx.style.width = `${options.width}px`;
            scx.style.left = `${options.offset.left}px`;
            scx.style.top = `${options.offset.top}px`;
            scx.style.borderRadius = '7px';
            scx.style.border = '1px solid #ccc';
            scx.style.backgroundColor = '#fff';
            c.appendChild(scx);
            self.slider = document.createElement('input');
            self.slider.setAttribute('orient', 'vertical');
            self.slider.setAttribute('type', 'range');
            self.slider.setAttribute('min', '6000');
            self.slider.setAttribute('step', '50');
            self.slider.setAttribute('max', '200000');
            self.slider.setAttribute('value', self.slate.options.viewPort.zoom.w || 50000);
            self.slider.setAttribute('id', self.sliderId);
            self.slider.style['writing-mode'] = 'bt-lr';
            self.slider.style['-webkit-appearance'] = 'slider-vertical';
            self.slider.style.width = `20px`;
            self.slider.style.height = `${options.height - 5}px`;
            self.slider.style.padding = `0 5px`;
            self.slider.style.transform = `rotate(180deg)`;
            self.slider.addEventListener('input', (e)=>{
                const val = parseFloat(e.target.value);
                self.set(val);
                self.slate.birdsEye?.refresh(true);
            });
            self.slider.addEventListener('change', (e)=>{
                const val = parseFloat(e.target.value);
                self.set(val);
                self.slate.collab?.send({
                    type: 'onZoom',
                    data: {
                        zoomLevel: val
                    }
                });
            });
            scx.appendChild(self.slider);
        }
    }
    set(val) {
        const self = this;
        if (self.slider) self.slider.value = val;
        if (self.slate.canvas.resize(val) || !self.slate.canvas.completeInit) {
            self.slate.zoom(0, 0, val, val, false);
            const z = self.slate.options.viewPort.zoom;
            self.slate.options.viewPort.width = z.w;
            self.slate.options.viewPort.height = z.h;
            self.slate.options.viewPort.left = z.l;
            self.slate.options.viewPort.top = z.t;
        }
    }
}
exports.default = zoomSlider;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"78ZfO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class undoRedo {
    constructor(slate){
        this.slate = slate;
        this.stateSlate = null;
        this.actions = [];
        this.actionIndex = -1;
        this.toolbar = [];
    }
    setVisibility() {
        const self = this;
        self.toolbar[0].data({
            disabled: false
        });
        self.toolbar[1].data({
            disabled: false
        });
        if (!this.actions[this.actionIndex - 1]) {
            self.toolbar[0].attr({
                'fill-opacity': '0.3'
            });
            self.toolbar[0].data({
                disabled: true
            });
        } else self.toolbar[0].attr({
            'fill-opacity': '1.0'
        });
        if (!this.actions[this.actionIndex + 1]) {
            self.toolbar[1].attr({
                'fill-opacity': '0.3'
            });
            self.toolbar[1].data({
                disabled: true
            });
        } else self.toolbar[1].attr({
            'fill-opacity': '1.0'
        });
    }
    run() {
        const state = this.actions[this.actionIndex];
        this.slate.loadJSON(state);
        this.slate.birdsEye?.reload(state);
        const pkg = {
            type: 'onSaveRequested'
        };
        this.slate.collaboration?.onCollaboration({
            type: 'custom',
            slate: this.slate,
            pkg
        });
    }
    undo() {
        if (this.actions[this.actionIndex - 1]) {
            this.actionIndex -= 1;
            this.setVisibility();
            this.run();
        } else this.setVisibility();
    }
    redo() {
        if (this.actions[this.actionIndex + 1]) {
            this.actionIndex += 1;
            this.setVisibility();
            this.run();
        } else this.setVisibility();
    }
    hide() {
        if (_utilsDefault.default.el('slateUndoRedo') !== null) try {
            this.slate.options.container.removeChild(_utilsDefault.default.el('slateUndoRedo'));
        } catch (err) {
        }
    }
    show(_options) {
        const self = this;
        self.hide();
        const options = {
            height: 80,
            width: 130,
            offset: {
                left: 10,
                top: 8
            }
        };
        Object.assign(options, _options);
        const c = self.slate.options.container;
        const scx = document.createElement('div');
        scx.setAttribute('id', 'slateUndoRedo');
        scx.style.position = 'absolute';
        scx.style.height = `${options.height}px`;
        scx.style.width = `${options.width}px`;
        scx.style.left = `${options.offset.left}px`;
        scx.style.top = `${options.offset.top}px`;
        c.appendChild(scx);
        const x = options.offset.left;
        const y = options.offset.top + 30;
        options.paper = _raphaelSvg.Raphael('slateUndoRedo', options.width, options.height);
        self.toolbar = [
            options.paper.undo().data({
                msg: 'Undo',
                width: 50,
                height: 22
            }).attr({
                fill: '#fff',
                cursor: 'pointer'
            }).attr({
                fill: '#333',
                stroke: '#fff'
            }).transform([
                't',
                x,
                ',',
                y,
                's',
                '1.5',
                '1.5'
            ].join()),
            options.paper.redo().data({
                msg: 'Redo',
                width: 50,
                height: 22
            }).attr({
                fill: '#fff',
                cursor: 'pointer'
            }).attr({
                fill: '#333',
                stroke: '#fff'
            }).transform([
                't',
                x + 50,
                ',',
                y,
                's',
                '-1.5',
                '1.5'
            ].join()), 
        ];
        self.toolbar.forEach((toolbarElem)=>{
            toolbarElem.mouseover(function m(e) {
                _utilsDefault.default.stopEvent(e);
                self.slate.multiSelection?.hide();
                // $(e.target).style.cursor = "pointer";
                if (!this.data('disabled')) {
                    self.slate.glow(this);
                    const text = this.data('msg');
                    self.slate.addtip(this.tooltip({
                        type: 'text',
                        msg: text
                    }, this.data('width'), this.data('height')));
                }
            });
            toolbarElem.mouseout(function m(e) {
                _utilsDefault.default.stopEvent(e);
                self.slate.multiSelection?.show();
                self.slate.unglow();
                this.untooltip();
            });
        });
        self.toolbar[0].mousedown(function m(e) {
            _utilsDefault.default.stopEvent(e);
            self.slate.unglow();
            if (!this.data('disabled')) self.undo();
        });
        self.toolbar[1].mousedown(function m(e) {
            _utilsDefault.default.stopEvent(e);
            self.slate.unglow();
            if (!this.data('disabled')) self.redo();
        });
        // set the buttons both to be disabled
        self.setVisibility();
        // register the initial state
        setTimeout(()=>{
            self.snap(true);
        }, 500);
    }
    snap(init) {
        const self = this;
        self.actionIndex += 1;
        if (self.actionIndex !== self.actions.length) // work has bene performed, so abandon the forked record
        self.actions.splice(self.actionIndex);
        const exp = self.slate.exportJSON();
        self.actions.push(exp);
        clearTimeout(self.saveSnapshot);
        self.saveSnapshot = setTimeout(async ()=>{
            if (self.slate.events.onTakeSnapshot) await self.slate.events.onTakeSnapshot({
                slateId: self.slate.options.id,
                snapshot: exp
            });
        }, 3000) // once the slate settles for 3 secs, take a snapshot
        ;
        if (!init) self.setVisibility();
    }
}
exports.default = undoRedo;

},{"../helpers/utils":"8QI6M","../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ixIFt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class grid {
    constructor(slate){
        this.slate = slate;
        this._grid = null;
        if (this.slate.options.viewPort.showGrid) this.show();
    // produce the required grid patterns
    // <defs>
    //   <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
    //     <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" stroke-width="0.5"/>
    //   </pattern>
    //   <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
    //     <rect width="100" height="100" fill="url(#smallGrid)"/>
    //     <path d="M 100 0 L 0 0 0 100" fill="none" stroke="gray" stroke-width="1"/>
    //   </pattern>
    // </defs>`;
    }
    setGrid() {
        const gbg = this.slate.options.containerStyle.backgroundColor;
        const gridColor = _utilsDefault.default.whiteOrBlack(gbg);
        if (!this.slate.options.viewPort.gridSize) this.slate.options.viewPort.gridSize = 50;
        const { gridSize  } = this.slate.options.viewPort;
        this.slate.paper.def({
            tag: 'pattern',
            id: 'sbSmallGrid',
            height: gridSize,
            width: gridSize,
            patternUnits: 'userSpaceOnUse',
            inside: [
                {
                    type: 'path',
                    attrs: {
                        d: `M ${gridSize} 0 L 0 0 0 ${gridSize}`,
                        fill: 'none',
                        stroke: gridColor,
                        'stroke-width': '0.5'
                    }
                }, 
            ]
        });
        this.slate.paper.def({
            tag: 'pattern',
            id: 'sbGrid',
            height: gridSize * 10,
            width: gridSize * 10,
            patternUnits: 'userSpaceOnUse',
            inside: [
                {
                    type: 'rect',
                    attrs: {
                        width: gridSize * 10,
                        height: gridSize * 10,
                        fill: 'url(#sbSmallGrid)'
                    }
                },
                {
                    type: 'path',
                    attrs: {
                        d: `M ${gridSize * 10} 0 L 0 0 0 ${gridSize * 10}`,
                        fill: 'none',
                        stroke: gridColor,
                        'stroke-width': '0.5'
                    }
                }, 
            ]
        });
    }
    show() {
        const self = this;
        this.setGrid();
        self._grid = self.slate.paper.rect(0, 0, self.slate.options.viewPort.width, self.slate.options.viewPort.height).attr({
            fill: 'url(#sbGrid)'
        }).toBack();
        self.slate.canvas.bgToBack();
    }
    toBack() {
        this._grid?.toBack();
    }
    destroy() {
        this._grid?.remove();
    }
}
exports.default = grid;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g3tty":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable new-cap */ /* eslint-disable no-underscore-dangle */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class comments {
    constructor(slate){
        this.slate = slate;
        this.engaged = false;
    }
    engage() {
        const self = this;
        if (!self.engaged) {
            const comment = `M 14.4761 0 H 3.102 C 1.3888 0 0 1.3888 0 3.102 V 8.5307 c 0 1.7132 1.3888 3.102 3.102 3.102 H 9.8297 l 2.803 4.2412 l 0.9018 -4.2412 h 0.9418 c 1.7132 0 3.102 -1.3888 3.102 -3.102 V 3.102 C 17.5781 1.3888 16.1893 0 14.4761 0 z`;
            const svg = self.slate.canvas.internal.querySelector('svg');
            svg.addEventListener('mousedown', (e)=>{
                const mp = _utilsDefault.default.mousePos(e);
                const x = mp.x + self.slate.options.viewPort.left;
                const y = mp.y + self.slate.options.viewPort.top;
                const tpath = _utilsDefault.default._transformPath(comment, `T${x},${y}s2,2`);
                const pbox = _utilsDefault.default.getBBox({
                    path: tpath
                });
                const commentNodeOpts = {
                    text: '',
                    xPos: x,
                    yPos: y,
                    height: pbox.height,
                    width: pbox.width,
                    vectorPath: tpath,
                    allowMenu: false,
                    allowDrag: true,
                    opacity: 1,
                    borderOpacity: 1,
                    textOpacity: 1
                };
                const commentNode = new _nodeDefault.default(commentNodeOpts);
                self.slate.nodes.add(commentNode);
            });
            self.engaged = true;
        }
    }
}
exports.default = comments;

},{"../helpers/utils":"8QI6M","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fRVV4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/* eslint-disable no-underscore-dangle */ var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class keyboard {
    constructor(slate){
        const self = this;
        self.slate = slate;
        self.bindGlobalUp = self.keyUp.bind(self);
        self.bindGlobalDown = self.keyDown.bind(self);
        self.bindGlobal();
    }
    bindGlobal() {
        const self = this;
        _utilsDefault.default.addEvent(document, 'keydown', self.bindGlobalDown);
        _utilsDefault.default.addEvent(document, 'keyup', self.bindGlobalUp);
    }
    unbindGlobal() {
        const self = this;
        _utilsDefault.default.removeEvent(document, 'keydown', self.bindGlobalDown);
        _utilsDefault.default.removeEvent(document, 'keyup', self.bindGlobalUp);
    }
    key(e, blnKeyDown) {
        const self = this;
        const node = self.slate.nodes.allNodes.find((n)=>n.menu.isOpen()
        );
        const key = _utilsDefault.default.getKey(e);
        switch(key){
            case 91:
            case 17:
                self.slate.isCtrl = blnKeyDown;
                break;
            case 16:
                self.slate.isShift = blnKeyDown;
                break;
            case 18:
                self.slate.isAlt = blnKeyDown;
                break;
            default:
                break;
        }
        if (node) switch(key){
            case 37:
            case 38:
            case 39:
            case 40:
                if (blnKeyDown) {
                    let span = 2;
                    if (self.slate.options.viewPort.zoom.r >= 1) span = 1;
                    else if (self.slate.options.viewPort.zoom.r <= 0.5) span = 5;
                    node.relationships._initDrag(self, e);
                    if (key === 37) // left
                    node.relationships.enactMove(-span, 0, true);
                    else if (key === 38) // up
                    node.relationships.enactMove(0, -span, true);
                    else if (key === 39) {
                        // right
                        if (self.slate.isCtrl) node.connectors.addNode(true);
                        else node.relationships.enactMove(span, 0, true);
                    } else if (key === 40) // down
                    node.relationships.enactMove(0, span, true);
                    node.relationships.showMenu();
                } else node.relationships.finishDrag(true);
                break;
            default:
                break;
        }
    }
    keyUp(e) {
        this.key(e, false);
    }
    keyDown(e) {
        this.key(e, true);
    }
}
exports.default = keyboard;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"JAVXJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class filters {
    constructor(slate){
        this.slate = slate;
        this.exposeDefaults();
    }
    addDeps(deps) {
        const self = this;
        deps.forEach((d)=>{
            const depDef = {
                id: _utilsDefault.default.guid().substring(10),
                tag: d.type,
                ...d.attrs,
                inside: []
            };
            d.nested.forEach((n)=>{
                depDef.inside.push({
                    type: n.type,
                    attrs: n.attrs
                });
            });
            self.slate.paper.def(depDef);
        });
    }
    add(filter, isDefault) {
        const self = this;
        const filterDef = {
            id: filter.id || _utilsDefault.default.guid().substring(10),
            tag: 'filter',
            filterUnits: 'userSpaceOnUse',
            ...filter.attrs,
            inside: []
        };
        filter.filters.forEach((ff)=>{
            if (ff.nested) filterDef.inside.push({
                type: ff.type,
                nested: ff.nested
            });
            else filterDef.inside.push({
                type: ff.type,
                attrs: ff.attrs
            });
        });
        self.slate.paper.def(filterDef);
        if (!isDefault) {
            if (!self.slate.customFilters) self.slate.customFilters = [];
            self.slate.customFilters.push(filterDef);
        }
        return filter.id;
    }
    remove(id) {
        const self = this;
        self.slate?.filters.splice(self.slate?.filters.findIndex((f)=>f.id === id
        ));
        return true;
    }
    // <feGaussianBlur in="SourceAlpha" stdDeviation="3"/> <\!-- stdDeviation is how much to blur -->
    // <feOffset dx="2" dy="2" result="offsetblur"/> <\!-- how much to offset -->
    // <feComponentTransfer>
    //   <feFuncA type="linear" slope="0.5"/> <\!-- slope is the opacity of the shadow -->
    // </feComponentTransfer>
    // <feMerge>
    //   <feMergeNode/> <\!-- this contains the offset blurred image -->
    //   <feMergeNode in="SourceGraphic"/> <\!-- this contains the element that the filter is applied to -->
    // </feMerge>
    exposeDefaults() {
        const self = this;
        self.availableFilters = {
            dropShadow: {
                levers: {
                    feDropShadow: {
                        stdDeviation: {
                            label: 'distance',
                            default: 1.5,
                            range: [
                                1,
                                10
                            ]
                        },
                        dx: {
                            label: 'x-displacement',
                            default: 5,
                            range: [
                                1,
                                50
                            ]
                        },
                        dy: {
                            label: 'y-displacement',
                            default: 5,
                            range: [
                                1,
                                50
                            ]
                        }
                    }
                },
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '3',
                            in: 'SourceAlpha'
                        }
                    },
                    {
                        type: 'feOffset',
                        attrs: {
                            dx: '5',
                            dy: '5',
                            result: 'offsetblur'
                        }
                    },
                    {
                        type: 'feComponentTransfer',
                        nested: [
                            {
                                type: 'feFuncA',
                                attrs: {
                                    type: 'linear',
                                    slope: '0.8'
                                }
                            }, 
                        ]
                    },
                    {
                        type: 'feMerge',
                        nested: [
                            {
                                type: 'feMergeNode',
                                attrs: {
                                }
                            },
                            {
                                type: 'feMergeNode',
                                attrs: {
                                    in: 'SourceGraphic'
                                }
                            }, 
                        ]
                    }, 
                ]
            },
            postItNote: {
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '2',
                            in: 'SourceAlpha'
                        }
                    },
                    {
                        type: 'feOffset',
                        attrs: {
                            dx: '0',
                            dy: '4',
                            result: 'offsetblur'
                        }
                    },
                    {
                        type: 'feComponentTransfer',
                        nested: [
                            {
                                type: 'feFuncA',
                                attrs: {
                                    type: 'linear',
                                    slope: '0.5'
                                }
                            }, 
                        ]
                    },
                    {
                        type: 'feMerge',
                        nested: [
                            {
                                type: 'feMergeNode',
                                attrs: {
                                }
                            },
                            {
                                type: 'feMergeNode',
                                attrs: {
                                    in: 'SourceGraphic'
                                }
                            }, 
                        ]
                    }, 
                ]
            },
            tattered: {
                levers: {
                    feDisplacementMap: {
                        scale: {
                            label: 'torn',
                            default: '10',
                            range: [
                                2,
                                50
                            ]
                        }
                    }
                },
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'turbulence',
                            baseFrequency: '.05 .05',
                            numOctaves: '05',
                            seed: '2',
                            stitchTiles: 'noStitch',
                            result: 'turbulence'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            in: 'SourceGraphic',
                            in2: 'turbulence',
                            scale: '10',
                            xChannelSelector: 'R',
                            yChannelSelector: 'B',
                            result: 'displacementMap'
                        }
                    }, 
                ]
            },
            blur: {
                levers: {
                    feGaussianBlur: {
                        stdDeviation: {
                            label: 'displacement',
                            default: 2,
                            range: [
                                1,
                                10
                            ]
                        }
                    }
                },
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '2',
                            in: 'SourceGraphic',
                            edgeMode: 'none'
                        }
                    }, 
                ]
            },
            outline: {
                levers: {
                    feMorphology: {
                        radius: {
                            label: 'cutout',
                            default: '1',
                            range: [
                                1,
                                10
                            ]
                        }
                    }
                },
                types: [
                    'text',
                    'line'
                ],
                filters: [
                    {
                        type: 'feMorphology',
                        attrs: {
                            operator: 'dilate',
                            radius: '1',
                            in: 'SourceGraphic',
                            result: 'thickness'
                        }
                    },
                    {
                        type: 'feComposite',
                        attrs: {
                            operator: 'out',
                            in: 'thickness',
                            in2: 'SourceGraphic'
                        }
                    }, 
                ]
            },
            pixelate: {
                levers: {
                    feImage: {
                        width: {
                            label: 'width',
                            default: '8',
                            range: [
                                1,
                                30
                            ]
                        },
                        height: {
                            label: 'height',
                            default: '8',
                            range: [
                                1,
                                30
                            ]
                        }
                    }
                },
                types: [
                    'image'
                ],
                filters: [
                    // https://stackoverflow.com/questions/37451189/can-one-pixelate-images-with-an-svg-filter
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '2',
                            in: 'SourceGraphic',
                            result: 'smoothed'
                        }
                    },
                    {
                        type: 'feImage',
                        attrs: {
                            width: '8',
                            height: '8',
                            'xlink:href': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAWSURBVAgdY1ywgOEDAwKxgJhIgFQ+AP/vCNK2s+8LAAAAAElFTkSuQmCC',
                            result: 'displacement-map'
                        }
                    },
                    {
                        type: 'feTile',
                        attrs: {
                            in: 'displacement-map',
                            result: 'pixelate-map'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            in: 'smoothed',
                            in2: 'pixelate-map',
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '30',
                            result: 'pre-final'
                        }
                    },
                    {
                        type: 'feComposite',
                        attrs: {
                            operator: 'in',
                            in2: 'SourceGraphic'
                        }
                    }, 
                ]
            },
            posterize: {
                levers: {
                },
                types: [
                    'image'
                ],
                filters: [
                    {
                        type: 'feComponentTransfer',
                        nested: {
                            feFuncR: {
                                type: 'discrete',
                                tableValues: '.25 .4 .5 .75 1'
                            },
                            feFuncG: {
                                type: 'discrete',
                                tableValues: '.25 .4 .5 .75 1'
                            },
                            feFuncB: {
                                type: 'discrete',
                                tableValues: '.25 .4 .5 .75 1'
                            }
                        }
                    }, 
                ]
            },
            pencil: {
                // https://heredragonsabound.blogspot.com/2020/02/creating-pencil-effect-in-svg.html
                levers: {
                },
                types: [
                    'vect',
                    'line',
                    'text',
                    'image'
                ],
                filters: [
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'fractalNoise',
                            baseFrequency: '0.03',
                            numOctaves: '3',
                            seed: '1',
                            result: 'f1'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '5',
                            in: 'SourceGraphic',
                            in2: 'f1',
                            result: 'f4'
                        }
                    },
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'fractalNoise',
                            baseFrequency: '0.03',
                            numOctaves: '3',
                            seed: '10',
                            result: 'f2'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '5',
                            in: 'SourceGraphic',
                            in2: 'f2',
                            result: 'f5'
                        }
                    },
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'fractalNoise',
                            baseFrequency: '1.2',
                            numOctaves: '2',
                            seed: '100',
                            result: 'f3'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '3',
                            in: 'SourceGraphic',
                            in2: 'f3',
                            result: 'f6'
                        }
                    },
                    {
                        type: 'feBlend',
                        attrs: {
                            mode: 'multiply',
                            in2: 'f4',
                            in: 'f5',
                            result: 'out1'
                        }
                    },
                    {
                        type: 'feBlend',
                        attrs: {
                            mode: 'multiply',
                            in: 'out1',
                            in2: 'f6',
                            result: 'out2'
                        }
                    }, 
                ]
            }
        };
    }
} // <filter id="f1" x="0" y="0" width="200%" height="200%">
 //   <feOffset result="offOut" in="SourceGraphic" dx="20" dy="20" />
 //   <feBlend in="SourceGraphic" in2="offOut" mode="normal" />
 // </filter>
 // <feBlend>
 // <feColorMatrix>
 // <feComponentTransfer>
 // <feComposite>
 // <feConvolveMatrix>
 // <feDiffuseLighting>
 // <feDisplacementMap>
 // <feDropShadow>
 // <feFlood>
 // <feGaussianBlur>
 // <feImage>
 // <feMerge>
 // <feMorphology>
 // <feOffset>
 // <feSpecularLighting>
 // <feTile>
 // <feTurbulence></feTurbulence>
 // https://github.com/svgdotjs/svg.filter
 // <filter id="displacementFilter">
 //   <feTurbulence type="turbulence" baseFrequency="0.05" numOctaves="5" seed="2" result="turbulence"/>
 //   <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="2"/>
 // </filter>
exports.default = filters;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8dkR":[function(require,module,exports) {
var _indexJs = require("../../index.js");
_indexJs.Slatebox.base.registerPlugin({
    name: "attempt",
    opts: {
    },
    plugin: class extends _indexJs.Slatebox.node {
        doAttempt() {
            console.log("HELLO NODE do I have inherited properties? ", this.disable);
        }
    }
});

},{"../../index.js":"8lqZg"}],"evEf8":[function(require,module,exports) {
var _indexJs = require("../../index.js");
_indexJs.Slatebox.base.registerPlugin({
    name: "attempt",
    opts: {
    },
    plugin: class extends _indexJs.Slatebox.slate {
        doSecond() {
            console.log("SLATE hello do I have inherited properties? ", this);
        }
    }
});

},{"../../index.js":"8lqZg"}]},["3czh9","620jy"], "620jy", "parcelRequire561b")

</script>
  </body>
</html>
