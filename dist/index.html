<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <div style="border: 1px solid red; width: 100%; height: 800px" id="slateCanvas"></div>
    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        globalObject
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"kWC2B":[function(require,module,exports,__globalThis) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "51221d3ac2cb24fb";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , disposedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == 'https:' && ![
        'localhost',
        '127.0.0.1',
        '0.0.0.0'
    ].includes(hostname) ? 'wss' : 'ws';
    var ws;
    if (HMR_USE_SSE) ws = new EventSource('/__parcel_hmr');
    else try {
        ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === 'undefined' ? typeof chrome === 'undefined' ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes('test.js');
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        disposedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === 'reload') fullReload();
        else if (data.type === 'update') {
            // Remove error overlay if there is one
            if (typeof document !== 'undefined') removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') window.dispatchEvent(new CustomEvent('parcelhmraccept'));
                await hmrApplyUpdates(assets);
                hmrDisposeQueue();
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                let processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === 'error') {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
            }
            if (typeof document !== 'undefined') {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement('div');
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, '') : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + '</div>').join('')}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ''}
      </div>
    `;
    }
    errorHTML += '</div>';
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ('reload' in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute('href');
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute('href', // $FlowFixMe
    href.split('?')[0] + '?' + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute('href');
            var hostname = getHostname();
            var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === 'js') {
        if (typeof document !== 'undefined') {
            let script = document.createElement('script');
            script.src = asset.url + '?t=' + Date.now();
            if (asset.outputFormat === 'esmodule') script.type = 'module';
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === 'function') {
            // Worker scripts
            if (asset.outputFormat === 'esmodule') return import(asset.url + '?t=' + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + '?t=' + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === 'css') reloadCSS();
    else if (asset.type === 'js') {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        }
        // Always traverse to the parent bundle, even if we already replaced the asset in this bundle.
        // This is required in case modules are duplicated. We need to ensure all instances have the updated code.
        if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDisposeQueue() {
    // Dispose all old assets.
    for(let i = 0; i < assetsToDispose.length; i++){
        let id = assetsToDispose[i][1];
        if (!disposedAssets[id]) {
            hmrDispose(assetsToDispose[i][0], id);
            disposedAssets[id] = true;
        }
    }
    assetsToDispose = [];
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
        let assetsToAlsoAccept = [];
        cached.hot._acceptCallbacks.forEach(function(cb) {
            let additionalAssets = cb(function() {
                return getParents(module.bundle.root, id);
            });
            if (Array.isArray(additionalAssets) && additionalAssets.length) assetsToAlsoAccept.push(...additionalAssets);
        });
        if (assetsToAlsoAccept.length) {
            let handled = assetsToAlsoAccept.every(function(a) {
                return hmrAcceptCheck(a[0], a[1]);
            });
            if (!handled) return fullReload();
            hmrDisposeQueue();
        }
    }
}

},{}],"620jy":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _indexJs = require("./index.js");
var _attemptJs = require("./plugins/node/attempt.js");
var _secondJs = require("./plugins/slate/second.js");
var _utilsJs = require("./helpers/utils.js");
var _utilsJsDefault = parcelHelpers.interopDefault(_utilsJs);
async function load() {
    const s = await new (0, _indexJs.Slatebox).slate({
        name: 'New Slate',
        id: 'collab-demo',
        description: '',
        defaultLineColor: '#333',
        container: 'slateCanvas',
        basedOnThemeId: '',
        syncWithTheme: false,
        viewPort: {
            useInertiaScrolling: true,
            showGrid: false,
            snapToObjects: true,
            gridSize: 50,
            width: 50000,
            height: 50000,
            left: 25000,
            top: 25000
        },
        enabled: true,
        allowDrag: true,
        showbirdsEye: true,
        sizeOfbirdsEye: 150,
        showMultiSelect: true,
        showZoom: true,
        showUndoRedo: true,
        showStatus: true,
        showLocks: true,
        mindMapMode: true,
        isPublic: true,
        isUnlisted: false,
        autoEnableDefaultFilters: true,
        allowCollaboration: true,
        followMe: false,
        containerStyle: {
            backgroundColor: '',
            backgroundImage: '',
            backgroundSize: '',
            backgroundEffect: '',
            backgroundColorAsGradient: true,
            backgroundGradientType: 'radial',
            backgroundGradientColors: [
                '#fff',
                '#333'
            ],
            backgroundGradientStrategy: 'shades'
        }
    }, {
        onInitCollaboration: async ()=>{
            return {
                websocketUrl: `ws://localhost:1122`,
                // DEMO (in mongo)
                websocketParams: {
                    bearer: 'xxx',
                    timestamp: '2024-01-29T03:19:34.877Z'
                },
                userName: 'guest1',
                color: '#000',
                x: 0,
                y: 0
            };
        },
        onCollaborationUsersRemoved: (users)=>{
            console.log('collab users removed', users);
        },
        onCollaborationUsersAdded: (users)=>{
            console.log('collab users added', users);
        },
        onConfirmRequested: async (title, msg, cb)=>{
        // implement confirmation dialog
        },
        onTakeSnapshot: async (opts)=>{
        // implement slate snapshot
        },
        onTextPaneRequested: (node, cb)=>{
        // implement text pane
        },
        onLineMenuRequested: (node, association, cb)=>{
        // implement line menu request
        },
        onMenuRequested: (node, cb)=>{
        // implement menu request
        },
        onBase64ImageRequested: (imgUrl, imageType, cb)=>{
        // implement base64 image request
        },
        // onOptimizeSVG: (svg, cb) => {
        //   // implement SVG optimization
        // },
        isReadOnly: ()=>{
            // is the slate read only for this user?
            return false;
        },
        isCommentOnly: ()=>{
            // does the user have comment only access to this slate?
            return false;
        },
        canRemoveComments: ()=>{
        // can the user remove comments?
        },
        onThemeRequired: (opts, cb)=>{
        // expirmental: provide a them in the cb
        }
    }).init();
    // await s.collab.init()
    //this is a new slate
    // s.shareId = 'test'
    // const defaultNodeOpts = {
    //   name: 'MASTER_NODE',
    //   text: 'Welcome to Slatebox!',
    //   xPos: 5500,
    //   yPos: 5300,
    //   height: 100,
    //   width: 175,
    //   vectorPath: 'roundedrectangle',
    //   backgroundColor: '90-#031634-#2D579A', //blue default
    //   foregroundColor: '#fff',
    //   lineColor: '#333',
    //   lineWidth: 5,
    //   allowDrag: true,
    // }
    // const n = new Slatebox.node(defaultNodeOpts)
    // s.nodes.add(n)
    const nodes = [
        // new Slatebox.node({
        //   id: 'note_TEMP1001',
        //   name: 'note_TEMP1001',
        //   xPos: 10000,
        //   yPos: 10000,
        //   width: 267.109375,
        //   height: 94,
        //   vectorPath: 'custom',
        //   shapeHint: 'rectangle',
        //   groupId: 'category_main',
        //   text: 'Future-Ready Skills\nMap Template for\nTranshumanism Education',
        //   backgroundColor: '#d2e5f6',
        //   opacity: 1,
        //   fontFamily: 'Roboto Sans',
        //   fontSize: '16',
        //   foregroundColor: '#000000',
        //   lineColor: '#333',
        //   lineWidth: 5,
        //   filters: {
        //     vect: 'postItNote',
        //   },
        //   svgString:
        //     "<svg width='1400' height='1000' xmlns='http://www.w3.org/2000/svg'><text x='600' y='60' text-anchor='middle' font-size='24' font-weight='bold'>Future-Ready Skills Map: Preparing Students for a Transhumanist Future</text><text x='600' y='90' text-anchor='middle' font-size='16' font-style='italic'>Based on key themes from the Transhumanism Critical Overview</text><path d='M50,120 L1350,120' stroke='black' stroke-width='2'/><text x='150' y='160' font-size='18' font-weight='bold'>Scientific Literacy</text><text x='150' y='185' font-size='14'>(CRISPR, Biotechnology)</text><path d='M100,200 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='550' y='160' font-size='18' font-weight='bold'>Ethical Decision-Making</text><text x='550' y='185' font-size='14'>(Genetic Enhancement, Privacy)</text><path d='M500,200 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='950' y='160' font-size='18' font-weight='bold'>Digital Citizenship</text><text x='950' y='185' font-size='14'>(AI Integration, Data Privacy)</text><path d='M900,200 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='150' y='410' font-size='18' font-weight='bold'>Social Impact Analysis</text><text x='150' y='435' font-size='14'>(Inequality, Access)</text><path d='M100,450 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='550' y='410' font-size='18' font-weight='bold'>Critical Thinking</text><text x='550' y='435' font-size='14'>(Bio-Conservative vs. Progressive)</text><path d='M500,450 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='950' y='410' font-size='18' font-weight='bold'>Future Adaptability</text><text x='950' y='435' font-size='14'>(Emerging Technologies)</text><path d='M900,450 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='150' y='660' font-size='18' font-weight='bold'>Policy Understanding</text><text x='150' y='685' font-size='14'>(WHO Guidelines, Regulations)</text><path d='M100,700 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='550' y='660' font-size='18' font-weight='bold'>Cross-Cultural Awareness</text><text x='550' y='685' font-size='14'>(Global Implications)</text><path d='M500,700 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><text x='950' y='660' font-size='18' font-weight='bold'>Innovation Mindset</text><text x='950' y='685' font-size='14'>(Scientific Advancement)</text><path d='M900,700 h400 v150 h-400 Z' stroke='grey' stroke-width='2' fill='url(#grid)'/><defs><pattern id='grid' width='10' height='10' patternUnits='userSpaceOnUse'><path d='M 10 0 L 0 0 0 10' fill='none' stroke='lightgrey' stroke-width='0.5'/></pattern></defs></svg>",
        // }),
        new (0, _indexJs.Slatebox).node({
            id: 'first_node',
            name: 'first_node',
            text: 'drag me',
            xPos: 25110,
            yPos: 25120,
            height: 60,
            width: 120,
            vectorPath: 'roundedrectangle',
            backgroundColor: '#24A8E0',
            lineColor: '#333',
            lineWidth: 5,
            allowMenu: false,
            link: {
                show: true,
                type: 'currentSlate',
                data: 'second_node'
            },
            filters: {
                vect: 'dropShadow'
            }
        }),
        new (0, _indexJs.Slatebox).node({
            id: 'second_node',
            name: 'second_node',
            text: 'drag me',
            xPos: 25310,
            yPos: 25220,
            height: 60,
            width: 120,
            vectorPath: 'roundedrectangle',
            backgroundColor: '#24A8E0',
            lineColor: '#333',
            lineWidth: 5,
            allowMenu: false,
            link: {
                show: true,
                type: 'url',
                data: 'https://slatebox.com'
            }
        })
    ];
    s.nodes.addRange(nodes);
    nodes[0].relationships.addAssociation(nodes[1], {
        showChildArrow: true,
        showParentArrow: true
    });
}
load() // setTimeout(() => {
 //   s.svg()
 // }, 1000)
 // console.log('node plugins ', n.plugins)
 // n.plugins.attempt.doAttempt()
 // s.plugins.attempt.doSecond()
 // const largePath = 'M 100 100 L 300 100 L 200 300 z'
 // console.log('subpaths are', utils.splitPath(largePath))
;

},{"./index.js":"8lqZg","./plugins/node/attempt.js":"c8dkR","./plugins/slate/second.js":"evEf8","./helpers/utils.js":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8lqZg":[function(require,module,exports,__globalThis) {
/* eslint-disable import/prefer-default-export */ /* eslint-disable import/no-cycle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Slatebox", ()=>Slatebox);
var _slate = require("./core/slate");
var _slateDefault = parcelHelpers.interopDefault(_slate);
var _node = require("./core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
var _base = require("./core/base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _utils = require("./helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
const Slatebox = {
    slate: (0, _slateDefault.default),
    node: (0, _nodeDefault.default),
    base: (0, _baseDefault.default),
    utils: (0, _utilsDefault.default)
};

},{"./core/slate":"khicH","./core/node":"bAVQb","./core/base":"cmkOb","./helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"khicH":[function(require,module,exports,__globalThis) {
/* eslint-disable no-template-curly-in-string */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ /* eslint-disable no-unused-expressions */ /* eslint-disable new-cap */ /* eslint-disable import/no-cycle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _deepmerge = require("deepmerge");
var _deepmergeDefault = parcelHelpers.interopDefault(_deepmerge);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _canvas = require("../slate/canvas");
var _canvasDefault = parcelHelpers.interopDefault(_canvas);
var _collab = require("../slate/collab");
var _collabDefault = parcelHelpers.interopDefault(_collab);
var _nodeController = require("../slate/nodeController");
var _nodeControllerDefault = parcelHelpers.interopDefault(_nodeController);
var _multiSelection = require("../slate/multiSelection");
var _multiSelectionDefault = parcelHelpers.interopDefault(_multiSelection);
var _birdsEye = require("../slate/birdsEye");
var _birdsEyeDefault = parcelHelpers.interopDefault(_birdsEye);
var _inertia = require("../slate/inertia");
var _inertiaDefault = parcelHelpers.interopDefault(_inertia);
var _controller = require("../slate/controller");
var _controllerDefault = parcelHelpers.interopDefault(_controller);
var _zoomSlider = require("../slate/zoomSlider");
var _zoomSliderDefault = parcelHelpers.interopDefault(_zoomSlider);
var _undoRedo = require("../slate/undoRedo");
var _undoRedoDefault = parcelHelpers.interopDefault(_undoRedo);
var _grid = require("../slate/grid");
var _gridDefault = parcelHelpers.interopDefault(_grid);
var _comments = require("../slate/comments");
var _commentsDefault = parcelHelpers.interopDefault(_comments);
var _keyboard = require("../slate/keyboard");
var _keyboardDefault = parcelHelpers.interopDefault(_keyboard);
var _filters = require("../slate/filters");
var _filtersDefault = parcelHelpers.interopDefault(_filters);
var _base = require("./base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _node = require("./node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class slate extends (0, _baseDefault.default) {
    constructor(_options, events){
        super(_options);
        this.options = {
            id: _options.id || (0, _utilsDefault.default).guid(),
            container: '',
            name: '',
            description: '',
            basedOnThemeId: '',
            syncWithTheme: false,
            tags: [],
            templateMarkdown: '',
            containerStyle: {
                backgroundColor: 'transparent',
                backgroundImage: '',
                backgroundSize: '',
                backgroundEffect: '',
                backgroundColorAsGradient: null,
                backgroundGradientType: null,
                backgroundGradientColors: [],
                backgroundGradientStrategy: null
            },
            viewPort: {
                useInertiaScrolling: true,
                showGrid: false,
                snapToObjects: true,
                gridSize: 50,
                width: 50000,
                height: 50000,
                left: 5000,
                top: 5000
            },
            enabled: true,
            allowDrag: true,
            showbirdsEye: true,
            sizeOfbirdsEye: 200,
            showMultiSelect: true,
            showZoom: true,
            showUndoRedo: true,
            showStatus: true,
            showLocks: true,
            mindMapMode: true,
            isPublic: true,
            isUnlisted: false,
            autoEnableDefaultFilters: true,
            autoResizeNodesBasedOnText: true,
            disableAutoLayoutOfManuallyPositionedNodes: true,
            followMe: false,
            useLayoutQuandrants: false,
            huddleType: 'disabled',
            allowCollaboration: true
        };
        this.options = (0, _deepmergeDefault.default)(this.options, _options);
        this.events = events || {
            onNodeDragged: null,
            onCanvasClicked: null,
            onImagesRequested: null,
            onRequestSave: null,
            onInitCollaboration: null,
            isReadOnly: null
        };
        // console.log("SLATE - share details are", this.options.shareId, this.options.userId, this.options.orgId);
        // ensure container is always an object
        if (!(0, _utilsDefault.default).isElement(this.options.container)) this.options.container = (0, _utilsDefault.default).el(this.options.container);
        this.constants = {
            statusPanelAtRest: 33,
            statusPanelExpanded: 200
        };
        this.glows = [];
        this.tips = [];
        this.tempNodeId = (0, _utilsDefault.default).guid();
        this.allLines = [];
        this.candidatesForSelection = {};
    }
    prep() {
        const self = this;
        // instantiate all the dependencies for the slate -- order here is importantish
        // (birdsEye, undoRedo, zoomSlider are used in canvas, and inertia uses canvas)
        self.nodes = new (0, _nodeControllerDefault.default)(self);
        self.collab = new (0, _collabDefault.default)(self);
        self.birdsEye = new (0, _birdsEyeDefault.default)(self);
        self.zoomSlider = new (0, _zoomSliderDefault.default)(self);
        if (!self.isReadOnly() && !self.isCommentOnly()) {
            self.undoRedo = new (0, _undoRedoDefault.default)(self);
            self.multiSelection = new (0, _multiSelectionDefault.default)(self);
        }
        self.controller = new (0, _controllerDefault.default)(self);
        self.filters = new (0, _filtersDefault.default)(self);
        self.canvas = new (0, _canvasDefault.default)(self);
        self.canvas.init();
        self.inertia = new (0, _inertiaDefault.default)(self);
        self.grid = new (0, _gridDefault.default)(self);
        self.comments = new (0, _commentsDefault.default)(self);
        self.keyboard = new (0, _keyboardDefault.default)(self);
        self.autoLoadFilters();
        if (self.options.onInitCompleted) self.options.onInitCompleted.apply(self);
    }
    initPlain() {
        const self = this;
        self.prep();
        return self;
    }
    async init() {
        const self = this;
        self.prep();
        if (self.multiSelection) await self.multiSelection.init();
        if (self.options.allowCollaboration ?? true) setTimeout(async ()=>{
            await self.collab.init();
        }, 100);
        return self;
    }
    url(opt) {
        return this.options.ajax.rootUrl + this.options.ajax.urlFlavor + opt;
    }
    glow(obj) {
        this.glows.push(obj.glow());
    }
    cursor(obj) {
        const self = this;
        const c = self.options.container;
        const ele = self.canvas.internal;
        if (!self.cursors) {
            self.offsetsForCursor = {
                container: (0, _utilsDefault.default).positionedOffset(c),
                canvas: (0, _utilsDefault.default).positionedOffset(ele)
            };
            self.cursorTimeouts = {};
            self.cursors = {};
            // create observer
            const observer = new MutationObserver(()=>{
                self.offsetsForCursor.canvas = (0, _utilsDefault.default).positionedOffset(ele);
            });
            observer.observe(ele, {
                attributes: true,
                childList: false,
                subtree: false
            });
        }
        if (!self.cursors[obj.clientID]) {
            const pos = document.createElement('div');
            pos.setAttribute('class', 'slateCursor');
            pos.style.position = 'absolute';
            pos.style.padding = '0px';
            pos.style.margin = '0px;';
            pos.style.display = 'block';
            pos.style['user-select'] = 'none';
            pos.style.zIndex = '0';
            const flex = document.createElement('div');
            flex.style.display = 'flex';
            flex.style.padding = 0;
            flex.style.margin = 0;
            const dot = document.createElement('div');
            dot.innerHTML = `
        <svg width="30px" height="30px" viewBox="-2.4 -2.4 28.80 28.80" role="img" xmlns="http://www.w3.org/2000/svg" stroke="${obj.color}" stroke-width="2.4" stroke-linecap="square" stroke-linejoin="miter" fill="${obj.color}" color="${obj.color}" transform="matrix(1, 0, 0, 1, 0, 0)"><g><polygon points="7 20 7 4 19 16 12 16 7 21"></polygon> </g></svg>`;
            // dot.style.backgroundColor = obj.color || '#000'
            flex.appendChild(dot);
            const txt = document.createElement('div');
            txt.style.fontSize = '11pt';
            txt.style.height = '25px';
            txt.style.whiteSpace = 'nowrap';
            txt.style.backgroundColor = '#fff';
            txt.style.color = '#000';
            txt.style.padding = '1px 7px 1px 7px';
            txt.style.border = `1px solid black`;
            txt.style.borderRadius = '5px';
            txt.style.fontFamily = 'trebuchet ms';
            txt.innerHTML = `${obj.userName || 'Guest'}`;
            flex.appendChild(txt);
            pos.appendChild(flex);
            self.cursors[obj.clientID] = pos;
            c.appendChild(pos);
        }
        const multiplier = self.options.viewPort.zoom.r / obj.currentZoom;
        const top = obj.y * multiplier + obj.top * multiplier - Math.abs(self.offsetsForCursor.canvas?.top || 0) - self.offsetsForCursor.container?.top || 0;
        const left = obj.x * multiplier + obj.left * multiplier - Math.abs(self.offsetsForCursor.canvas?.left || 0) - self.offsetsForCursor.container?.left || 0;
        self.cursors[obj.clientID].style.top = `${top}px`;
        self.cursors[obj.clientID].style.left = `${left}px`;
        // expire after 10 of no activity
        clearTimeout(self.cursorTimeouts[obj.clientID]);
        self.cursorTimeouts[obj.clientID] = setTimeout(()=>{
            c.removeChild(self.cursors[obj.clientID]);
            delete self.cursors[obj.clientID];
        }, 2000);
    }
    unglow() {
        this.glows.forEach((glow)=>{
            glow.remove();
        });
        this.glows = [];
    }
    addtip(tip) {
        if (tip) this.tips.push(tip);
    }
    untooltip() {
        this.tips.forEach((tip)=>{
            tip && tip.remove();
        });
    }
    toggleFilters(blnHide, nodeId, esc) {
        // hide filters during dragging
        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile()) {
            if (this.nodes.allNodes.length > 20) {
                this.nodes.allNodes.forEach((n)=>{
                    if (!nodeId || n.options.id === nodeId) n.toggleFilters(blnHide);
                });
                this.allLines.filter((l)=>l.lineEffect).forEach((c)=>{
                    if (blnHide) c.line.attr('filter', '');
                    else c.line.attr('filter', `url(#${c.lineEffect})`);
                });
                if (blnHide) this.canvas.hideBg();
                if (esc) setTimeout(()=>{
                    this.toggleFilters(!blnHide);
                    this.canvas.hideBg(1);
                }, 500);
            }
        }
    }
    removeContextMenus() {
        const _cm = (0, _utilsDefault.default).select('div.sb_cm');
        _cm.forEach((elem)=>{
            document.body.removeChild(elem);
        });
    }
    remove() {
        this.nodes.allNodes.forEach((nn)=>{
            nn.del();
        });
        this.paper.remove();
    // delete self;
    }
    zoom(x, y, w, h, fit) {
        this.nodes.closeAllLineOptions();
        this.paper.setViewBox(x, y, w, h, fit);
    }
    png(ropts, cb) {
        const self = this;
        self.svg({
            ...ropts,
            isPNG: true,
            useDataImageUrls: true,
            backgroundOnly: ropts?.backgroundOnly
        }, (opts)=>{
            function makeTransparent(ctx, alpha, cnvs) {
                // get the image data object
                const imageData = ctx.getImageData(0, 0, cnvs.width, cnvs.height);
                const data = imageData.data;
                // if it is a background defined of #f3f3f3 then it can be transparent here
                for(let ix = 3; ix < data.length; ix += 4){
                    const isBg = [
                        data[ix - 3],
                        data[ix - 2],
                        data[ix - 1]
                    ].every((v)=>v === 243);
                    // console.log('isBg', alpha, isBg, data[ix - 3])
                    if ([
                        data[ix - 3],
                        data[ix - 2],
                        data[ix - 1]
                    ].every((v)=>v === 243)) data[ix] = alpha;
                }
                // and put the imagedata back to the canvas
                ctx.putImageData(imageData, 0, 0);
            }
            if (self.events.onCreateImage) self.events.onCreateImage({
                svg: opts.svg,
                orient: opts.orient,
                type: 'png'
            }, (err, base64)=>{
                if (err) console.error('Unable to create png server side', svg, err);
                else if (ropts?.base64) cb(base64);
                else {
                    const img = new Image();
                    img.src = base64;
                    img.onload = ()=>{
                        const cnvs = document.createElement('canvas');
                        cnvs.width = img.naturalWidth;
                        cnvs.height = img.naturalHeight;
                        const ctx = cnvs.getContext('2d');
                        ctx.imageSmoothingEnabled = false;
                        ctx.drawImage(img, 0, 0);
                        if (ropts?.alpha != null) makeTransparent(ctx, ropts.alpha, cnvs);
                        cnvs.toBlob((blob)=>{
                            if (cb && opts?.asBinary) cb(blob);
                            else {
                                const link = document.createElement('a');
                                link.setAttribute('download', `${(self.options.name || 'slate').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${self.options.id}.png`);
                                link.href = URL.createObjectURL(blob);
                                const event = new MouseEvent('click');
                                link.dispatchEvent(event);
                                cb && cb();
                            }
                        });
                    };
                }
            });
            else {
                const cnvs = document.createElement('canvas');
                cnvs.width = opts.orient.width;
                cnvs.height = opts.orient.height;
                const blb = new Blob([
                    opts.svg
                ], {
                    type: 'image/svg+xml;charset=utf8'
                });
                const url = URL.createObjectURL(blb);
                const ctx = cnvs.getContext('2d');
                const img = document.createElement('img');
                img.src = url;
                img.onload = ()=>{
                    ctx.drawImage(img, 0, 0);
                    if (ropts?.alpha != null) makeTransparent(ctx, ropts.alpha, cnvs);
                    if (ropts?.asBinary) cnvs.toBlob((blob)=>{
                        cb(blob);
                    });
                    else {
                        const imgsrc = cnvs.toDataURL('image/png');
                        if (ropts?.base64) {
                            cb(imgsrc);
                            URL.revokeObjectURL(img.src);
                        } else {
                            const a = document.createElement('a');
                            a.download = `${(self.options.name || 'slate').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${self.options.id}.png`;
                            a.href = imgsrc;
                            a.click();
                            URL.revokeObjectURL(img.src);
                            cb && cb();
                        }
                    }
                };
                img.onerror = (err)=>{
                    console.log('error loading image', err);
                };
            }
        });
    }
    async pngSync(ropts) {
        const self = this;
        return new Promise((resolve, reject)=>{
            self.png(ropts, (base64)=>{
                resolve(base64);
            });
        });
    }
    copy(opts) {
        const self = this;
        if (!self.copySlate) self.copySlate = new slate({
            container: opts.container,
            containerStyle: this.options.containerStyle,
            defaultLineColor: this.options.defaultLineColor,
            viewPort: this.options.viewPort,
            name: this.options.name,
            description: this.options.description,
            allowCollaboration: false,
            showbirdsEye: false,
            showMultiSelect: false,
            showUndoRedo: false,
            showZoom: false
        }).initPlain();
        const _json = JSON.parse(this.exportJSON());
        _json.nodes.forEach((nde)=>{
            const _mpkg = opts.moves ? opts.moves.find((m)=>m.id === nde.options.id || m.id === '*') : null;
            if (_mpkg) {
                nde.options.xPos += _mpkg.x;
                nde.options.yPos += _mpkg.y;
                const _transforms = [
                    `t${_mpkg.x}, ${_mpkg.y}`
                ];
                nde.options.vectorPath = (0, _getTransformedPathDefault.default)(nde.options.vectorPath, _transforms);
            }
        });
        self.copySlate.loadJSON(JSON.stringify(_json));
        self.copySlate.nodes.refreshAllRelationships();
        return self.copySlate;
    }
    svg(opts, cb) {
        const self = this;
        const nodesToOrient = opts?.nodes ? self.nodes.allNodes.filter((n)=>opts?.nodes.indexOf(n.options.id) > -1) : null;
        const _orient = self.getOrientation(nodesToOrient, true);
        const _r = 1 // this.options.viewPort.zoom.r || 1;
        ;
        const _resizedSlate = JSON.parse(self.exportJSON(opts?.backgroundOnly ? [] : opts?.nodes ? opts.nodes : null));
        _resizedSlate.nodes.forEach((n)=>{
            const _ty = n.options.yPos * _r;
            const _tx = n.options.xPos * _r;
            const _width = n.options.width;
            const _height = n.options.height;
            n.options.yPos = _ty - _orient.top;
            n.options.xPos = _tx - _orient.left;
            n.options.width = _width * _r;
            n.options.height = _height * _r;
            if (n.options.rotate && n.options.rotate.point) {
                n.options.rotate.point.x = n.options.rotate.point.x * _r - _orient.left;
                n.options.rotate.point.y = n.options.rotate.point.y * _r - _orient.top;
            }
            const _updatedPath = (0, _utilsDefault.default)._transformPath(n.options.vectorPath, [
                'T',
                _orient.left / _r * -1,
                ',',
                _orient.top / _r * -1,
                's',
                ',',
                _r,
                ',',
                _r
            ].join(''));
            n.options.vectorPath = _updatedPath;
        });
        const _div = document.createElement('div');
        _div.setAttribute('id', 'tempSvgSlate');
        _div.style.width = `${_orient.width}px`;
        _div.style.height = `${_orient.height}px`;
        _div.style.visibility = 'hidden';
        document.body.appendChild(_div);
        const exportOptions = (0, _deepmergeDefault.default)(_resizedSlate.options, {
            container: 'tempSvgSlate',
            containerStyle: {
                backgroundColor: opts.noBackground ? 'transparent' : _resizedSlate.options.containerStyle.backgroundColor,
                backgroundColorAsGradient: opts.noBackground ? null : _resizedSlate.options.containerStyle.backgroundColorAsGradient,
                backgroundGradientType: opts.noBackground ? null : _resizedSlate.options.containerStyle.backgroundGradientType,
                backgroundGradientColors: opts.noBackground ? null : _resizedSlate.options.containerStyle.backgroundGradientColors,
                backgroundGradientStrategy: opts.noBackground ? null : _resizedSlate.options.containerStyle.backgroundGradientStrategy
            },
            defaultLineColor: _resizedSlate.options.defaultLineColor,
            viewPort: {
                allowDrag: false,
                originalWidth: _orient.width,
                width: _orient.width,
                height: _orient.height,
                left: 0,
                top: 0,
                zoom: {
                    w: _orient.width * 1.5,
                    h: _orient.height * 1.5
                },
                showGrid: false
            },
            name: _resizedSlate.options.name,
            description: _resizedSlate.options.description,
            showbirdsEye: false,
            showMultiSelect: false,
            showUndoRedo: false,
            showZoom: false,
            showLocks: false,
            isEmbedding: true,
            allowCollaboration: false
        });
        async function execute() {
            // we don't yet load the nodes by default even though they're passed in on the options below...
            const _exportCanvas = await new slate(exportOptions).init();
            // ...that's done in the loadJSON...which seems weird
            _exportCanvas.loadJSON(JSON.stringify({
                options: exportOptions,
                nodes: _resizedSlate.nodes
            }), false, true);
            // events don't serialize, so add them explicitly
            _exportCanvas.events = self.events;
            _exportCanvas.nodes.refreshAllRelationships();
            // add the bgColor (this is done on html styling in slatebox proper view)
            let bg = null;
            if (_resizedSlate.options.containerStyle.backgroundImage) {
                const img = document.createElement('img');
                img.setAttribute('src', _resizedSlate.options.containerStyle.backgroundImage);
                img.style.visibility = 'hidden';
                document.body.appendChild(img);
                let bw = img.naturalWidth;
                let bh = img.naturalHeight;
                if (self.options.containerStyle.backgroundSize === 'cover') {
                    const ratio = self.canvas.internal.parentElement.offsetWidth / bw;
                    bw *= ratio;
                    bh *= ratio;
                }
                img.remove();
                const iw = Math.max(bw, _orient.width);
                const ih = Math.max(bh, _orient.height);
                bg = _exportCanvas.paper.image(_resizedSlate.options.containerStyle.backgroundImage, 0, 0, iw, ih);
            } else bg = _exportCanvas.paper.rect(0, 0, _orient.width, _orient.height).attr({
                fill: _resizedSlate.options.containerStyle.backgroundColor,
                stroke: 'none'
            });
            bg.toBack();
            // the timeout is critical to ensure that the SVG canvas settles
            // and the url-fill images appear.
            setTimeout(async ()=>{
                // pass skipOptimize to rawSVG to avoid double optimization
                _exportCanvas.canvas.rawSVG({
                    skipOptimize: opts.skipOptimize
                }, (svg1)=>{
                    // presume download if no cb is sent
                    const svgBlob = new Blob([
                        svg1
                    ], {
                        type: 'image/svg+xml;charset=utf-8'
                    });
                    if (!cb) {
                        const svgUrl = URL.createObjectURL(svgBlob);
                        const dl = document.createElement('a');
                        dl.href = svgUrl;
                        dl.download = `${(self.options.name || 'slate').replace(/[^a-z0-9]/gi, '_').toLowerCase()}_${self?.shareId}.svg`;
                        dl.click();
                    } else if (opts?.asBinary && !opts.isPNG) cb(svgBlob);
                    else cb({
                        svg: svg1,
                        orient: _orient
                    });
                    _div.remove();
                });
            }, 100);
        }
        execute();
    }
    autoLoadFilters() {
        const self = this;
        // if auto filter is on, then these filters become immediately availalbe in their default form
        if (self.options.autoEnableDefaultFilters && self.filters?.availableFilters) Object.keys(self.filters.availableFilters).forEach((type)=>{
            self.filters.add({
                id: type,
                filters: self.filters.availableFilters[type].filters
            }, true);
            if (self.filters.availableFilters[type].deps) self.filters.addDeps(self.filters.availableFilters[type].deps);
        });
    }
    loadJSON(_jsonSlate, blnPreserve, blnSkipZoom, useMainCanvas = false) {
        const self = this;
        if (blnPreserve === undefined) {
            self.paper && self.paper.clear();
            if (self.nodes) self.nodes.allNodes = [];
        }
        const loadedSlate = JSON.parse(_jsonSlate);
        Object.assign(self.options, loadedSlate.options);
        self.autoLoadFilters();
        // bgcolor set
        self.canvas?.refreshBackground();
        // grid
        if (self.options.viewPort.showGrid) self.grid?.show();
        else self.grid?.destroy();
        // zoom
        if (!blnSkipZoom) self.zoomSlider?.set(self.options.viewPort.zoom.w || 50000);
        // sort nodes by their last painted order to honor toBack/toFront
        loadedSlate.nodes.sort((n1, n2)=>{
            const i1 = loadedSlate.options.nodeOrder?.findIndex((n)=>n === n1.options.id);
            const i2 = loadedSlate.options.nodeOrder?.findIndex((n)=>n === n2.options.id);
            return i1 - i2;
        });
        const deferredRelationships = [];
        loadedSlate.nodes.forEach((n)=>{
            n.options.allowDrag = true // must default
            ;
            n.options.allowMenu = true;
            const _boundTo = new (0, _nodeDefault.default)(n.options);
            self.nodes.add(_boundTo, useMainCanvas);
            deferredRelationships.push({
                bt: _boundTo,
                json: n
            });
        });
        deferredRelationships.forEach((relationship)=>{
            const _bounded = relationship;
            _bounded.bt.addRelationships(_bounded.json);
        });
        if (self.options.showLocks) self.displayLocks();
        // refreshes all relationships
        self.nodes.allNodes.forEach((_node)=>{
            _node.relationships.updateAssociationsWith({
                activeNode: _node.options.id,
                currentDx: 0,
                currentDy: 0
            });
        });
        self.nodes.refreshAllRelationships();
        // finally invoke toFront in order
        self.nodes.allNodes.forEach((n)=>n.toFront());
        // always add style tag to the <defs> for font embedding
        self.paper.def({
            tag: 'style',
            type: 'text/css',
            id: `embeddedSBStyles_${self.options.id}`
        });
        self.paper.def({
            tag: 'path',
            id: `raphael-marker-classic`,
            'stroke-linecap': 'round',
            d: 'M5,0 0,2.5 5,5 3.5,3 3.5,2z'
        });
        self.loadAllFonts();
        if (!blnSkipZoom) self.controller.centerOnNodes({
            dur: 0
        });
    }
    loadAllFonts() {
        // load all fonts
        const fonts = (0, _lodashUniqDefault.default)(this.nodes.allNodes.map((n)=>n.options.fontFamily)).join('|');
        if (document.getElementById('googleFonts')) document.getElementById('googleFonts').setAttribute('href', `https://fonts.googleapis.com/css?family=${fonts}`);
        else {
            const sc = document.createElement('link');
            sc.setAttribute('src', 'https://fonts.googleapis.com/css?family=${fonts}');
            sc.setAttribute('id', 'googleFonts');
            sc.setAttribute('rel', 'stylesheet');
            sc.setAttribute('type', 'text/css');
            document.head.appendChild(sc);
        }
    }
    displayLocks() {
        this.nodes.allNodes.forEach((nd)=>{
            nd.initLock();
        });
    }
    hideLocks() {
        this.nodes.allNodes.forEach((nd)=>{
            nd.hideLock();
        });
    }
    isReadOnly() {
        return !this.events.isReadOnly || this.events.isReadOnly && this.events.isReadOnly();
    }
    isCommentOnly() {
        return !this.events.isCommentOnly || this.events.isCommentOnly && this.events.isCommentOnly();
    }
    canRemoveComments() {
        return !this.events.canRemoveComments || this.events.canRemoveComments && this.events.canRemoveComments();
    }
    // the granularity is at the level of the node...
    exportDifference(compare, lineWidthOverride) {
        const _difOpts = {
            ...this.options
        };
        delete _difOpts.container;
        // birdsEye specific -- if this is not here, then locks
        // show up on the birdsEye
        _difOpts.showLocks = compare.options.showLocks;
        const jsonSlate = {
            options: JSON.parse(JSON.stringify(_difOpts)),
            nodes: []
        };
        const tnid = this.tempNodeId;
        this.nodes.allNodes.forEach((nd)=>{
            let _exists = false;
            const pn = nd;
            if (pn.options.id !== tnid) {
                compare.nodes.allNodes.forEach((nodeInner)=>{
                    if (nodeInner.options.id === pn.options.id) _exists = true;
                });
                if (!_exists) jsonSlate.nodes.push(pn.serialize(lineWidthOverride));
            }
        });
        return JSON.stringify(jsonSlate);
    }
    exportJSON(nodes) {
        const _cont = this.options.container;
        const _opts = this.options;
        delete _opts.container;
        const jsonSlate = {
            options: JSON.parse(JSON.stringify(_opts)),
            nodes: []
        };
        this.options.container = _cont;
        delete jsonSlate.options.ajax;
        delete jsonSlate.options.container;
        const tnid = this.tempNodeId;
        this.nodes.allNodes.forEach((nd)=>{
            if (nd.options.id !== tnid && (!nodes || nodes.includes(nd.options.id))) jsonSlate.nodes.push(nd.serialize());
        });
        jsonSlate.shareId = this.shareId;
        return JSON.stringify(jsonSlate);
    }
    snapshot() {
        const _snap = JSON.parse(this.exportJSON());
        _snap.nodes.allNodes = _snap.nodes;
        return _snap;
    }
    getOrientation(nodesToOrient, alwaysOne) {
        let orient = 'landscape';
        let sWidth = this.options.viewPort.width;
        let sHeight = this.options.viewPort.height;
        const bb = [];
        bb.left = 99999;
        bb.right = 0;
        bb.top = 99999;
        bb.bottom = 0;
        const an = nodesToOrient || this.nodes.allNodes;
        if (an.length > 0) {
            for(let _px = 0; _px < an.length; _px += 1){
                const sbw = 10;
                const _bb = an[_px].vect.getBBox();
                if (_bb) {
                    const _r = alwaysOne ? 1 : this.options.viewPort.zoom.r || 1;
                    const x = _bb.x * _r;
                    const y = _bb.y * _r;
                    const w = _bb.width * _r;
                    const h = _bb.height * _r;
                    bb.left = Math.abs(Math.min(bb.left, x - sbw));
                    bb.right = Math.abs(Math.max(bb.right, x + w + sbw));
                    bb.top = Math.abs(Math.min(bb.top, y - sbw));
                    bb.bottom = Math.abs(Math.max(bb.bottom, y + h + sbw));
                }
            }
            sWidth = bb.right - bb.left;
            sHeight = bb.bottom - bb.top;
            if (sHeight > sWidth) orient = 'portrait';
        }
        return {
            orientation: orient,
            height: sHeight,
            width: sWidth,
            left: bb.left,
            top: bb.top
        };
    }
    resize(_size, dur, pad) {
        let _p = pad || 0;
        if (_p < 6) _p = 6;
        _size -= _p * 2 || 0;
        const orx = this.getOrientation();
        const wp = orx.width / _size * this.options.viewPort.width;
        const hp = orx.height / _size * this.options.viewPort.height;
        const sp = Math.max(wp, hp);
        const _r = Math.max(this.options.viewPort.width, this.options.viewPort.height) / sp;
        const l = orx.left * _r - _p;
        const t = orx.top * _r - _p;
        this.zoom(0, 0, sp, sp, true);
        this.options.viewPort.zoom = {
            w: sp,
            h: sp,
            l: parseInt(l * -1, 10),
            t: parseInt(t * -1, 10),
            r: this.options.viewPort.originalWidth / sp
        };
        this.canvas.move({
            x: l,
            y: t,
            dur,
            isAbsolute: true
        });
    }
    disable(exemptSlate, exemptNodes, full) {
        if (!exemptNodes) this.nodes.allNodes.forEach((nd)=>{
            nd.disable();
        });
        if (!exemptSlate) {
            this.options.enabled = false;
            this.options.allowDrag = false;
            if (full) {
                this.multiSelection?.hideIcons();
                this.undoRedo?.hide();
                this.birdsEye?.disable();
                this.zoomSlider?.hide();
            }
        }
    }
    enable(exemptSlate, exemptNodes) {
        if (!exemptNodes) this.nodes.allNodes.forEach((nd)=>{
            !nd.options.isLocked && nd.enable();
        });
        if (!exemptSlate) {
            this.options.enabled = true;
            this.options.allowDrag = true;
        }
    }
    reorderNodes() {
        // these ids will come out in the order that they are painted on the screen - toFront and toBack adjusts this, so we need
        // to always keep this hand so that when the slate is reloaded, it can order the nodes by these ids (which are going to be dif
        // from the saved JSON order of arrays)
        const ids = Array.from(this.canvas.internal.querySelector('svg').querySelectorAll('path')).map((a)=>a.getAttribute('rel')?.replace(/^nodrag_|^nodrag_text-/, '')) // ensure the nodrag convention prefixes are removed
        .filter((r)=>!!r);
        // console.log("order of nodes", ids);
        this.options.nodeOrder = ids;
    }
    findChildren(nodeIds, allChildren = []) {
        const self = this;
        // get his node's children - then recursively call findChildren on that node
        const nodes = self.nodes.allNodes.filter((n)=>nodeIds.includes(n.options.id));
        allChildren = allChildren.concat(nodes.map((n)=>n.options.id));
        const children = [];
        nodes.forEach((n)=>{
            n.relationships.associations.filter((a)=>a.parent.options.id === n.options.id).forEach((a)=>children.push(a.child.options.id));
        });
        if (children.length) return self.findChildren(children, allChildren);
        return allChildren;
    }
    applyTheme(theme, syncWithTheme, revertTheme) {
        const self = this;
        if (!revertTheme) {
            self.options.basedOnThemeId = theme.themeId || theme._id;
            self.options.syncWithTheme = syncWithTheme;
        } else {
            self.options.basedOnThemeId = null;
            self.options.syncWithTheme = null;
        }
        const nodeStyle = {};
        const currentNodesByColor = {};
        const totChildren = [];
        // first apply slate
        if (theme.containerStyle.backgroundImage) self.collab.invoke({
            type: 'onSlateBackgroundImageChanged',
            data: {
                bg: {
                    size: theme.containerStyle.backgroundSize,
                    url: theme.containerStyle.backgroundImage
                }
            }
        });
        else if (theme.containerStyle.backgroundEffect) self.collab.invoke({
            type: 'onSlateBackgroundEffectChanged',
            data: {
                effect: theme.containerStyle.backgroundEffect
            }
        });
        else self.collab.invoke({
            type: 'onSlateBackgroundColorChanged',
            data: {
                color: theme.containerStyle.backgroundColor,
                asGradient: theme.containerStyle.backgroundColorAsGradient,
                gradientType: theme.containerStyle.backgroundGradientType,
                gradientColors: theme.containerStyle.backgroundGradientColors,
                gradientStrategy: theme.containerStyle.backgroundGradientStrategy
            }
        });
        self.collab.invoke({
            type: 'onLineColorChanged',
            data: {
                color: theme.defaultLineColor
            }
        });
        function applyStyle(id) {
            const allKeys = Object.keys(theme.styles);
            const lastStyle = theme.styles[allKeys[allKeys.length - 1]];
            const styleBase = theme.styles[nodeStyle[id]] || lastStyle;
            // borders
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderWidth',
                    val: styleBase.borderWidth
                }
            });
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderColor',
                    val: styleBase.borderColor
                }
            });
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderOpacity',
                    val: styleBase.borderOpacity
                }
            });
            self.collab.invoke({
                type: 'onNodeBorderPropertiesChanged',
                data: {
                    id,
                    prop: 'borderStyle',
                    val: styleBase.borderStyle
                }
            });
            // shape
            if (styleBase.vectorPath && syncWithTheme) // const node = self.nodes.one(id);
            // const sendPath = utils._transformPath(styleBase.vectorPath, `T${node.options.xPos},${node.options.xPos}`);
            self.collab.invoke({
                type: 'onNodeShapeChanged',
                data: {
                    id,
                    hint: styleBase.hint,
                    shape: styleBase.vectorPath
                }
            });
            // text
            if (syncWithTheme) self.collab.invoke({
                type: 'onNodeTextChanged',
                data: {
                    id,
                    fontSize: styleBase.fontSize,
                    fontFamily: styleBase.fontFamily,
                    fontColor: styleBase.foregroundColor,
                    textOpacity: styleBase.textOpacity
                }
            });
            // effects
            self.collab.invoke({
                type: 'onNodeEffectChanged',
                data: {
                    id,
                    filter: {
                        apply: 'text',
                        id: styleBase.filters.text
                    }
                }
            });
            // background color
            self.collab.invoke({
                type: 'onNodeColorChanged',
                data: {
                    id,
                    opacity: styleBase.opacity,
                    color: styleBase.backgroundColor
                }
            });
            // effects
            self.collab.invoke({
                type: 'onNodeEffectChanged',
                data: {
                    id,
                    filter: {
                        apply: 'vect',
                        id: styleBase.filters.vect
                    }
                }
            });
            // lines
            const styleNode = self.nodes.one(id);
            // console.log("node is ", id, node);
            styleNode.relationships.associations.forEach((a, ind)=>{
                self.collab.invoke({
                    type: 'onLineColorChanged',
                    data: {
                        id,
                        color: styleBase.lineColor
                    }
                });
                self.collab.invoke({
                    type: 'onLinePropertiesChanged',
                    data: {
                        id,
                        prop: 'lineOpacity',
                        val: a.lineOpacity === 0 ? 0 : styleBase.lineOpacity,
                        associationId: a.id,
                        index: ind
                    }
                });
                self.collab.invoke({
                    type: 'onLinePropertiesChanged',
                    data: [
                        {
                            id,
                            prop: 'lineEffect',
                            val: styleBase.lineEffect,
                            associationId: a.id,
                            index: ind
                        },
                        {
                            id,
                            prop: 'lineWidth',
                            val: styleBase.lineWidth,
                            associationId: a.id,
                            index: ind
                        },
                        {
                            id,
                            prop: 'lineType',
                            val: styleBase.lineType,
                            associationId: a.id,
                            index: ind
                        },
                        {
                            id,
                            prop: 'lineCurveType',
                            val: styleBase.lineCurveType,
                            associationId: a.id,
                            index: ind
                        },
                        {
                            id,
                            prop: 'lineCurviness',
                            val: styleBase.lineCurviness,
                            associationId: a.id,
                            index: ind
                        }
                    ]
                });
            });
        }
        self.nodes.allNodes.forEach((nd)=>{
            if (self.options.mindMapMode || syncWithTheme) {
                const children = self.findChildren([
                    nd.options.id
                ]);
                totChildren.push(children);
            } else {
                if (!currentNodesByColor[nd.options.backgroundColor]) currentNodesByColor[nd.options.backgroundColor] = [];
                currentNodesByColor[nd.options.backgroundColor].push(nd.options.id);
            }
        });
        if (self.options.mindMapMode || syncWithTheme) {
            totChildren.sort((a, b)=>a.length - b.length);
            totChildren.forEach((t)=>{
                t.forEach((n, ind)=>{
                    nodeStyle[n] = ind === 0 ? `parent` : `child_${ind}`;
                });
            });
        } else {
            const colorsByUsage = Object.keys(currentNodesByColor).sort((a, b)=>currentNodesByColor[b].length - currentNodesByColor[a].length);
            let styleIndex = -1;
            colorsByUsage.forEach((c, index)=>{
                if (Object.keys(theme.styles).length < index) styleIndex = -1;
                styleIndex += 1;
                currentNodesByColor[c].forEach((id)=>{
                    nodeStyle[id] = styleIndex === 0 ? `parent` : `child_${styleIndex}`;
                });
            });
        }
        Object.keys(nodeStyle).forEach((id)=>{
            applyStyle(id);
        });
    }
}
exports.default = slate;

},{"lodash.uniq":"iDalh","lodash.clonedeep":"i3u1q","deepmerge":"ck1Q2","../helpers/utils":"8QI6M","../helpers/getTransformedPath":"6wubb","../slate/canvas":"kpLaV","../slate/collab":"eYgJm","../slate/nodeController":"6wl7A","../slate/multiSelection":"kpcw7","../slate/birdsEye":"bRqCq","../slate/inertia":"l9OwD","../slate/controller":"2xnBR","../slate/zoomSlider":"6TbYF","../slate/undoRedo":"78ZfO","../slate/grid":"ixIFt","../slate/comments":"g3tty","../slate/keyboard":"fRVV4","../slate/filters":"JAVXJ","./base":"cmkOb","./node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iDalh":[function(require,module,exports,__globalThis) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var funcTag = '[object Function]', genTag = '[object GeneratorFunction]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) return baseFindIndex(array, baseIsNaN, fromIndex);
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {}
    return result;
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var splice = arrayProto.splice;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, 'Map'), Set = getNative(root, 'Set'), nativeCreate = getNative(Object, 'create');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length)this.add(values[index]);
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */ function baseUniq(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) return setToArray(set);
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
    } else seen = iteratee ? [] : result;
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while(seenIndex--){
                if (seen[seenIndex] === computed) continue outer;
            }
            if (iteratee) seen.push(computed);
            result.push(value);
        } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) seen.push(computed);
            result.push(value);
        }
    }
    return result;
}
/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */ var createSet = !(Set && 1 / setToArray(new Set([
    ,
    -0
]))[1] == INFINITY) ? noop : function(values) {
    return new Set(values);
};
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + '';
        } catch (e) {}
    }
    return '';
}
/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each
 * element is kept.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */ function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */ function noop() {
// No operation performed.
}
module.exports = uniq;

},{}],"i3u1q":[function(require,module,exports,__globalThis) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Detect free variable `exports`. */ var freeExports = exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && true && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */ function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
}
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */ function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
}
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */ function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) break;
    }
    return array;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */ function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {}
    return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    return this.__data__['delete'](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */ function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
    if (result !== undefined) return result;
    if (!isObject(value)) return value;
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray(value, result);
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) return cloneBuffer(value, isDeep);
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) return object ? value : {};
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) return copySymbols(value, baseAssign(result, value));
        } else {
            if (!cloneableTags[tag]) return object ? value : {};
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
    arrayEach(props || value, function(subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
}
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */ function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    return objectToString.call(value);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != 'constructor') result.push(key);
    return result;
}
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */ function cloneBuffer(buffer, isDeep) {
    if (isDeep) return buffer.slice();
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
}
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */ function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */ function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */ function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
}
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */ function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */ function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
}
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */ function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */ function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */ function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
            return new Ctor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
            return new Ctor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
            return cloneSymbol(object);
    }
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + '';
        } catch (e) {}
    }
    return '';
}
/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */ function cloneDeep(value) {
    return baseClone(value, true, true);
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = cloneDeep;

},{}],"ck1Q2":[function(require,module,exports,__globalThis) {
'use strict';
var isMergeableObject = function isMergeableObject(value) {
    return isNonNullObject(value) && !isSpecial(value);
};
function isNonNullObject(value) {
    return !!value && typeof value === 'object';
}
function isSpecial(value) {
    var stringValue = Object.prototype.toString.call(value);
    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
}
// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;
function isReactElement(value) {
    return value.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(val) {
    return Array.isArray(val) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(value, options) {
    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
}
function defaultArrayMerge(target, source, options) {
    return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
    });
}
function getMergeFunction(key, options) {
    if (!options.customMerge) return deepmerge;
    var customMerge = options.customMerge(key);
    return typeof customMerge === 'function' ? customMerge : deepmerge;
}
function getEnumerableOwnPropertySymbols(target) {
    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
    }) : [];
}
function getKeys(target) {
    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
}
function propertyIsOnObject(object, property) {
    try {
        return property in object;
    } catch (_) {
        return false;
    }
}
// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
     && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
     && Object.propertyIsEnumerable.call(target, key) // and also unsafe if they're nonenumerable.
    );
}
function mergeObject(target, source, options) {
    var destination = {};
    if (options.isMergeableObject(target)) getKeys(target).forEach(function(key) {
        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
    });
    getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) return;
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        else destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
    });
    return destination;
}
function deepmerge(target, source, options) {
    options = options || {};
    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
    // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
    // implementations can use it. The caller may not replace it.
    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
    var sourceIsArray = Array.isArray(source);
    var targetIsArray = Array.isArray(target);
    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
    if (!sourceAndTargetTypesMatch) return cloneUnlessOtherwiseSpecified(source, options);
    else if (sourceIsArray) return options.arrayMerge(target, source, options);
    else return mergeObject(target, source, options);
}
deepmerge.all = function deepmergeAll(array, options) {
    if (!Array.isArray(array)) throw new Error('first argument should be an array');
    return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
    }, {});
};
var deepmerge_1 = deepmerge;
module.exports = deepmerge_1;

},{}],"8QI6M":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ /* eslint-disable no-param-reassign */ /* eslint-disable no-return-assign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class utils {
    static easing = {
        elastic (pos) {
            return -1 * 4 ** (-8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
        },
        swingFromTo (pos) {
            let s = 1.70158;
            return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s *= 1.525) + 1) * pos - s)) : 0.5 * ((pos -= 2) * pos * (((s *= 1.525) + 1) * pos + s) + 2);
        },
        swingFrom (pos) {
            const s = 1.70158;
            return pos * pos * ((s + 1) * pos - s);
        },
        swingTo (pos) {
            const s = 1.70158;
            return (pos -= 1) * pos * ((s + 1) * pos + s) + 1;
        },
        bounce (pos) {
            if (pos < 1 / 2.75) return 7.5625 * pos * pos;
            if (pos < 2 / 2.75) return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
            if (pos < 2.5 / 2.75) return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
            return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
        },
        bouncePast (pos) {
            if (pos < 1 / 2.75) return 7.5625 * pos * pos;
            if (pos < 2 / 2.75) return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
            if (pos < 2.5 / 2.75) return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
            return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
        },
        easeFromTo (pos) {
            if ((pos /= 0.5) < 1) return 0.5 * pos ** 4;
            return -0.5 * ((pos -= 2) * pos ** 3 - 2);
        },
        easeFrom (pos) {
            return pos ** 4;
        },
        easeTo (pos) {
            return pos ** 0.25;
        },
        none (pos) {
            return -Math.cos(pos * Math.PI) / 2 + 0.5;
        }
    };
    static availColors = [
        {
            hex: '000000',
            to: '575757',
            fore: 'fff'
        },
        {
            hex: 'FFFFFF',
            to: 'd9d9d9',
            fore: '000'
        },
        {
            hex: 'FF0000',
            to: 'a31616',
            fore: '000'
        },
        {
            hex: 'C3FF68',
            to: 'afff68',
            fore: '000'
        },
        {
            hex: '0B486B',
            to: '3B88B5',
            fore: 'fff'
        },
        {
            hex: 'FBB829',
            to: 'cd900e',
            fore: '000'
        },
        {
            hex: 'BFF202',
            to: 'D1F940',
            fore: '000'
        },
        {
            hex: 'FF0066',
            to: 'aa1d55',
            fore: '000'
        },
        {
            hex: '800F25',
            to: '3d0812',
            fore: 'fff'
        },
        {
            hex: 'A40802',
            to: 'd70b03',
            fore: 'fff'
        },
        {
            hex: 'FF5EAA',
            to: 'cf5d93',
            fore: '000'
        },
        {
            hex: '740062',
            to: 'D962C6',
            fore: 'fff'
        },
        {
            hex: 'FF4242',
            to: 'A61515',
            fore: 'fff'
        },
        {
            hex: 'D15C57',
            to: '9D5C58',
            fore: '000'
        },
        {
            hex: 'FCFBE3',
            to: 'c9c56f',
            fore: '000'
        },
        {
            hex: 'FF9900',
            to: 'c98826',
            fore: '000'
        },
        {
            hex: '369001',
            to: '9CEE6C',
            fore: '000'
        },
        {
            hex: '9E906E',
            to: '675324',
            fore: 'fff'
        },
        {
            hex: 'F3D915',
            to: 'F9EA7C',
            fore: '000'
        },
        {
            hex: '031634',
            to: '2D579A',
            fore: 'fff'
        },
        {
            hex: '556270',
            to: '7b92ab',
            fore: 'fff'
        },
        {
            hex: '1693A5',
            to: '23aad6',
            fore: 'fff'
        },
        {
            hex: 'ADD8C7',
            to: '59a989',
            fore: '000'
        },
        {
            special: {
                // line options display only colors; node menu displays colors and transparent button
                color: {
                    hex: '8D5800',
                    to: 'EB9605'
                },
                other: {
                    transparent: true
                }
            }
        }
    ];
    static polygonCache = {};
    static async pause(millis) {
        return new Promise((resolve)=>{
            window.setTimeout(()=>{
                resolve();
            }, millis);
        });
    }
    static windowSize() {
        let w = 0;
        let h = 0;
        // IE
        if (!window.innerWidth) {
            // strict mode
            if (!(document.documentElement.clientWidth == 0)) {
                w = document.documentElement.clientWidth;
                h = document.documentElement.clientHeight;
            } else {
                w = document.body.clientWidth;
                h = document.body.clientHeight;
            }
        } else {
            w = window.innerWidth;
            h = window.innerHeight;
        }
        return {
            width: w,
            height: h
        };
    }
    static isElement(o) {
        return typeof HTMLElement === 'object' ? o instanceof HTMLElement // DOM2
         : typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';
    }
    // convenience
    static el(id) {
        if (id.indexOf('#') > -1 || id.indexOf('.') > -1) return document.querySelector(id);
        return document.getElementById(id);
    }
    // let arr = select("elem.className");
    static select(query) {
        const els = [];
        const index = query.indexOf('.');
        if (index !== -1) {
            const tag = query.slice(0, index) || '*';
            const klass = query.slice(index + 1, query.length);
            const all = document.getElementsByTagName(tag);
            for(let d = 0; d < all.length; d += 1){
                const elem = all[d];
                if (elem.className && elem.className.indexOf(klass) !== -1) els.push(elem);
            }
        }
        return els;
    }
    static getKey(e) {
        let keyCode = 0;
        try {
            keyCode = e.keyCode;
        } catch (Err) {
            keyCode = e.which;
        }
        return keyCode;
    }
    // fix event inconsistencies across browsers
    static stopEvent(e) {
        e = e || window.event;
        if (e.preventDefault) {
            e.stopPropagation();
            e.preventDefault();
        } else {
            e.returnValue = false;
            e.cancelBubble = true;
        }
        return false;
    }
    static toShortDateString(jsonDate) {
        let date = jsonDate;
        try {
            const d = new Date(parseInt(jsonDate.substr(6), 10));
            date = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
        } catch (Err) {}
        return date;
    }
    static addEvent(obj, type, fn) {
        obj.addEventListener(type, fn);
    }
    static removeEvent(obj, type, fn) {
        obj.removeEventListener(type, fn);
    }
    // push an event listener into existing array of listeners
    static bind(to, evt, fn) {
        to[evt] = to[evt] || [];
        to[evt].push(fn);
    }
    static imageExists(u, cb, id) {
        const iid = `temp_${utils.guid()}`;
        const img = document.body.appendChild(document.createElement('img'));
        img.style.position = 'absolute';
        img.style.top = '-10000px';
        img.style.left = '-10000px';
        img.setAttribute('src', u);
        img.setAttribute('id', iid);
        this.addEvent(img, 'load', function(e) {
            const d = getDimensions(img);
            document.body.removeChild(img);
            cb.apply(this, [
                true,
                d.width,
                d.height,
                id
            ]);
        });
        this.addEvent(img, 'error', function(e) {
            document.body.removeChild(img);
            cb.apply(this, [
                false,
                0,
                0,
                id
            ]);
        });
    }
    static ajax(u, f, d, v, x, h) {
        x = this.ActiveXObject;
        // the guid is essential to break the cache because ie8< seems to want to cache this. argh.
        u = [
            u,
            u.indexOf('?') === -1 ? '?' : '&',
            `guid=${utils.guid()}`
        ].join('');
        x = new (x || XMLHttpRequest)('Microsoft.XMLHTTP');
        const vx = d ? v || 'POST' : v || 'GET';
        x.open(vx, u, 1);
        x.setRequestHeader('Content-type', 'application/json; charset=utf-8');
        h.forEach((hElem)=>{
            x.setRequestHeader(hElem.n, hElem.v);
        });
        x.onreadystatechange = ()=>{
            // eslint-disable-next-line no-unused-expressions
            x.readyState > 3 && f && f(x.responseText, x);
        };
        x.send(d);
    }
    static randomInt(min, max) {
        return Math.floor(min + Math.random() * (max - min + 1));
    }
    static isMobile() {
        return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    }
    static isSafari() {
        const isSafari = navigator.vendor.match(/apple/i) && !navigator.userAgent.match(/crios/i) && !navigator.userAgent.match(/fxios/i) && !navigator.userAgent.match(/Opera|OPT\//);
        return isSafari;
    }
    static hasClass(el, className) {
        if (el.classList) el.classList.contains(className);
        else new RegExp(`(^| )${className}( |$)`, 'gi').test(el.className);
    }
    static addClass(el, className) {
        if (el.classList) el.classList.add(className);
        else el.className += ` ${className}`;
    }
    static S4() {
        // eslint-disable-next-line no-bitwise
        return ((1 + Math.random()) * 0x10000 | 0).toString(16).substring(1);
    }
    static guid(len) {
        let g = this.S4() + this.S4() + this.S4();
        if (len) g = g.replace(/-/gi, '').substring(0, len).toUpperCase();
        return g;
    }
    static getJSON(url, callback) {
        const id = this.S4() + this.S4();
        let script = document.createElement('script');
        const token = `__jsonp${id}`;
        // callback should be a global function
        window[token] = callback;
        // url should have "?" parameter which is to be replaced with a global callback name
        script.src = url.replace(/\?(&|$)/, `__jsonp${id}$1`);
        // clean up on load: remove script tag, null script variable and delete global callback function
        script.onload = ()=>{
            script = null;
        };
        document.getElementsByTagName('head')[0].appendChild(script);
    }
    static getBBox(opts) {
        const cont = document.createElement('div');
        cont.setAttribute('id', 'hiddenPaper');
        cont.style.display = 'none';
        document.body.appendChild(cont);
        const pp = new (0, _raphaelSvg.Raphael)(cont);
        const bb = pp.path(opts.path).getBBox();
        document.body.removeChild(cont);
        return bb;
    }
    static obtainProportionateWidthAndHeightForResizing(dx, dy, currentVectWidth, currentVectHeight, origVectWidth, origVectHeight, isCtrl, isCustom) {
        let transWidth = currentVectWidth + dx * 2;
        let transHeight = currentVectHeight + dy * 2;
        const useOrigVectorWidth = origVectWidth ?? currentVectWidth;
        const useOrigVectorHeight = origVectHeight ?? currentVectHeight;
        if (!isCtrl && isCustom && useOrigVectorWidth && useOrigVectorHeight) {
            // const max = Math.max(transWidth, transHeight)
            // // keep it proportional to the original dimensions unless ctrl is pressed while resizing
            // if (max === transWidth) {
            // change width
            transHeight = useOrigVectorHeight * transWidth / useOrigVectorWidth;
            transWidth = useOrigVectorWidth * transHeight / useOrigVectorHeight;
        // } else {
        //   // change height
        //   transWidth = (useOrigVectorWidth * transHeight) / useOrigVectorHeight
        //   transHeight = (useOrigVectorHeight * transWidth) / useOrigVectorWidth
        // }
        }
        return {
            transWidth,
            transHeight
        };
    }
    static positionedOffset(obj) {
        let curleft = 0;
        let curtop = 0;
        if (obj.offsetParent) do {
            curleft += obj.offsetLeft;
            curtop += obj.offsetTop;
        // eslint-disable-next-line no-cond-assign
        }while (obj = obj.offsetParent);
        return {
            left: curleft,
            top: curtop
        };
    }
    static getDimensions(ele) {
        let width = 0;
        let height = 0;
        if (typeof ele.clip !== 'undefined') {
            width = ele.clip.width;
            height = ele.clip.height;
        } else if (ele.style?.pixelWidth) {
            width = ele.style.pixelWidth;
            height = ele.style.pixelHeight;
        } else {
            width = ele.offsetWidth;
            height = ele.offsetHeight;
        }
        return {
            width,
            height
        };
    }
    static mousePos(e) {
        let mouseX = null;
        let mouseY = null;
        const allTouches = [];
        if (e.targetTouches) {
            if (e.targetTouches.length) {
                const t = e.targetTouches[0];
                mouseX = t.clientX;
                mouseY = t.clientY;
                e.targetTouches.forEach((tx)=>{
                    allTouches.push({
                        x: e.targetTouches[tx].clientX,
                        y: e.targetTouches[tx].clientY
                    });
                });
            }
        } else {
            mouseX = e.pageX;
            mouseY = e.pageY;
        }
        return {
            x: mouseX,
            y: mouseY,
            allTouches
        };
    }
    static centerAndScalePathToFitContainer(opts) {
        // scale and transform the path to fit the box...
        // first get the bbox of the untouched path
        let bb = this.getBBox({
            path: opts.path
        });
        // calculate the scale of the path
        const scale = opts.scaleSize / Math.max(bb.width, bb.height);
        // scale the untouched path
        let newPath = this._transformPath(opts.path, [
            's',
            scale,
            ',',
            scale
        ].join(''));
        // go get the bbox of the scaled path
        bb = this.getBBox({
            path: newPath
        });
        // finally, move the scaled vector to the centered x,y coords
        // of the enclosed box
        const tp = [
            'T',
            bb.x * -1 + (opts.containerSize - bb.width) / 2,
            ',',
            bb.y * -1 + (opts.containerSize - bb.height) / 2
        ].join('');
        newPath = this._transformPath(newPath, tp);
        return {
            path: newPath,
            width: bb.width,
            height: bb.height
        };
    }
    static buildStyle(_styles) {
        let _str = '';
        Object.keys(_styles).forEach((k)=>{
            _str += `${k}:${_styles[k]};`;
        });
        return _str;
    }
    static getRGBComponents(bgColor) {
        const r = bgColor.substring(1, 3);
        const g = bgColor.substring(3, 5);
        const b = bgColor.substring(5, 7);
        return {
            R: parseInt(r, 16),
            G: parseInt(g, 16),
            B: parseInt(b, 16)
        };
    }
    static whiteOrBlack(hex) {
        function getRGB(c) {
            return parseInt(c, 16) || c;
        }
        function getsRGB(c) {
            return getRGB(c) / 255 <= 0.03928 ? getRGB(c) / 255 / 12.92 : Math.pow((getRGB(c) / 255 + 0.055) / 1.055, 2.4);
        }
        function getLuminance(hexColor) {
            return 0.2126 * getsRGB(hexColor.substr(1, 2)) + 0.7152 * getsRGB(hexColor.substr(3, 2)) + 0.0722 * getsRGB(hexColor.substr(-2));
        }
        function getContrast(f, b) {
            const L1 = getLuminance(f);
            const L2 = getLuminance(b);
            return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
        }
        const whiteContrast = getContrast(hex || '#fff', '#ffffff');
        const blackContrast = getContrast(hex || '#fff', '#000000');
        return whiteContrast > blackContrast ? '#ffffff' : '#000000';
    }
    // https://gist.github.com/iconifyit/958e7abba71806d663de6c2c273dc0da
    static splitPath(pathData) {
        function pathToAbsoluteSubPaths(path_string) {
            var path_commands = (0, _raphaelSvg.Raphael).parsePathString(path_string), end_point = [
                0,
                0
            ], sub_paths = [], command = [], i = 0;
            while(i < path_commands.length){
                command = path_commands[i];
                end_point = getNextEndPoint(end_point, command);
                if (command[0] === 'm') command = [
                    'M',
                    end_point[0],
                    end_point[1]
                ];
                var sub_path = [
                    command.join(' ')
                ];
                i++;
                while(!endSubPath(path_commands, i)){
                    command = path_commands[i];
                    sub_path.push(command.join(' '));
                    end_point = getNextEndPoint(end_point, command);
                    i++;
                }
                sub_paths.push(sub_path.join(' '));
            }
            return sub_paths;
        }
        function getNextEndPoint(end_point, command) {
            var x = end_point[0], y = end_point[1];
            if (isRelative(command)) switch(command[0]){
                case 'h':
                    x += command[1];
                    break;
                case 'v':
                    y += command[1];
                    break;
                case 'z':
                    // back to [0,0]?
                    x = 0;
                    y = 0;
                    break;
                default:
                    x += command[command.length - 2];
                    y += command[command.length - 1];
            }
            else switch(command[0]){
                case 'H':
                    x = command[1];
                    break;
                case 'V':
                    y = command[1];
                    break;
                case 'Z':
                    // back to [0,0]?
                    x = 0;
                    y = 0;
                    break;
                default:
                    x = command[command.length - 2];
                    y = command[command.length - 1];
            }
            return [
                x,
                y
            ];
        }
        function isRelative(command) {
            return command[0] === command[0].toLowerCase();
        }
        function endSubPath(commands, index) {
            if (index >= commands.length) return true;
            else return commands[index][0].toLowerCase() === 'm';
        }
        return pathToAbsoluteSubPaths(pathData);
    }
    static _transformPath(original, transform) {
        const rpath = (0, _raphaelSvg.Raphael).transformPath(original, transform).toString();
        return rpath;
    }
    static transformPath(_node, _transformation) {
        const _path = (0, _raphaelSvg.Raphael).transformPath(_node.vect.attr('path').toString(), _transformation).toString();
        _node.options.vectorPath = _path;
        _node.vect.transform('');
        _node.vect.attr({
            path: _node.options.vectorPath
        });
        const bb = _node.vect.getBBox();
        const rotationContext = {
            point: {
                x: bb.cx,
                y: bb.cy
            }
        };
        Object.assign(_node.options.rotate, rotationContext);
        const transformString = _node.getTransformString();
        _node.vect.transform(transformString);
        _node.text.transform('');
        // xPos and yPos are updated in the setPosition in Slatebox.node.js
        _node.text.attr(_node.textCoords({
            x: _node.options.xPos,
            y: _node.options.yPos
        }));
        _node.text.transform(transformString);
    }
    static htmlToElement(html) {
        const template = document.createElement('template');
        html = html.trim();
        template.innerHTML = html;
        return template.content.firstChild;
    }
    static buildNodeStyleFromTheme({ theme, childNumber = 1 }) {
        const allKeys = Object.keys(theme.styles);
        const lastStyle = theme.styles[allKeys[allKeys.length - 1]];
        const styleBase = theme.styles[`child_${childNumber}`] || lastStyle;
        const configurableProps = [
            'borderWidth',
            'borderColor',
            'borderOpacity',
            'borderStyle',
            'fontSize',
            'fontFamily',
            'fontColor',
            'textOpacity',
            'filter.vect',
            'filter.text',
            'opacity',
            'backgroundColor',
            'lineOpacity',
            'lineWidth',
            'lineType',
            'lineCurveType',
            'lineCurviness',
            'lineEffect'
        ] // vectorPath
        ;
        const nodeOptions = {};
        configurableProps.forEach((p)=>{
            if (styleBase[p] != null) nodeOptions[p] = styleBase[p];
            else switch(p){
                case 'filter.vect':
                case 'filter.text':
                    nodeOptions.filter ??= {};
                    nodeOptions.filter[p.split('.')[1]] = styleBase.filters[p.split('.')[1]];
                    break;
            }
        });
        return nodeOptions;
    }
    // static getTextWidthByFontSize(str, fontSize) {
    //   const widths = [
    //     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    //     0, 0, 0, 0, 0, 0, 0, 0.2796875, 0.2765625, 0.3546875, 0.5546875,
    //     0.5546875, 0.8890625, 0.665625, 0.190625, 0.3328125, 0.3328125, 0.3890625,
    //     0.5828125, 0.2765625, 0.3328125, 0.2765625, 0.3015625, 0.5546875,
    //     0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.5546875,
    //     0.5546875, 0.5546875, 0.5546875, 0.2765625, 0.2765625, 0.584375,
    //     0.5828125, 0.584375, 0.5546875, 1.0140625, 0.665625, 0.665625, 0.721875,
    //     0.721875, 0.665625, 0.609375, 0.7765625, 0.721875, 0.2765625, 0.5,
    //     0.665625, 0.5546875, 0.8328125, 0.721875, 0.7765625, 0.665625, 0.7765625,
    //     0.721875, 0.665625, 0.609375, 0.721875, 0.665625, 0.94375, 0.665625,
    //     0.665625, 0.609375, 0.2765625, 0.3546875, 0.2765625, 0.4765625, 0.5546875,
    //     0.3328125, 0.5546875, 0.5546875, 0.5, 0.5546875, 0.5546875, 0.2765625,
    //     0.5546875, 0.5546875, 0.221875, 0.240625, 0.5, 0.221875, 0.8328125,
    //     0.5546875, 0.5546875, 0.5546875, 0.5546875, 0.3328125, 0.5, 0.2765625,
    //     0.5546875, 0.5, 0.721875, 0.5, 0.5, 0.5, 0.3546875, 0.259375, 0.353125,
    //     0.5890625,
    //   ]
    //   const avg = 0.5279276315789471
    //   return (
    //     Array.from(str).reduce(
    //       (acc, cur) => acc + (widths[cur.charCodeAt(0)] ?? avg),
    //       0
    //     ) * fontSize
    //   )
    // }
    // https://stackoverflow.com/questions/118241/calculate-text-width-with-javascript
    static getTextWidth(text, font) {
        const splitText = text.split('\n');
        const textWidthCanvas = document.createElement('canvas');
        const metrics = [];
        splitText.forEach((t)=>{
            // textWidthCanvas.setAttribute('id', `measuretext`)
            const context = textWidthCanvas.getContext('2d');
            // I'm finding that the font should be reduced by ~22% in order to be accurate
            const multiplier = 1 // 0.78
            ;
            const fontSplit = font.split(' ');
            font = `${fontSplit?.[0]} ${parseFloat(fontSplit?.[1]?.replace(/pt/gi, '') ?? 1) * multiplier}pt ${fontSplit?.[2]}`;
            context.font = font;
            metrics.push(context.measureText(t));
        });
        textWidthCanvas.remove();
        let height = 0;
        metrics.forEach((m)=>height += m.fontBoundingBoxAscent + m.fontBoundingBoxDescent);
        const red = {
            width: Math.max(...metrics.map((m)=>m.width)) + 10,
            height: height + 10
        };
        return red;
    }
    static chunk(arr, chunkSize = 1, cache = []) {
        const tmp = [
            ...arr
        ];
        if (chunkSize <= 0) return cache;
        while(tmp.length)cache.push(tmp.splice(0, chunkSize));
        return cache;
    }
    static createMultiLineText(text, lineCount) {
        const words = text.split(/ /g);
        const chars = text.split('');
        const charsPerLine = chars.length / lineCount;
        const lines = [];
        let wordsOnLine = [];
        let curCharCount = 0;
        // console.log(
        //   'words are 1',
        //   words.length,
        //   chars.length,
        //   charsPerLine,
        //   lines.length,
        //   lineCount,
        //   curCharCount
        // )
        words.forEach((w)=>{
            curCharCount += w.length;
            // console.log(
            //   'words are 2',
            //   words.length,
            //   chars.length,
            //   charsPerLine,
            //   lines.length,
            //   lineCount,
            //   curCharCount
            // )
            if (curCharCount < charsPerLine || lines.length === lineCount - 1) wordsOnLine.push(w);
            else {
                lines.push(wordsOnLine.join(' '));
                curCharCount = w.length;
                wordsOnLine = [
                    w
                ];
            }
        });
        if (wordsOnLine.length > 0) lines.push(wordsOnLine.join(' '));
        return lines.join('\n');
    }
    static toDataUrl = (url)=>fetch(url, {
            mode: 'cors'
        }).then((response)=>response.blob()).then((blob)=>new Promise((resolve, reject)=>{
                const reader = new FileReader();
                reader.onloadend = ()=>resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            }));
}
exports.default = utils;

},{"../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jK21R":[function(require,module,exports,__globalThis) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Raphael", ()=>Raphael);
var _eveJs = require("../eve.js");
var _raphaelCoreJs = require("./raphael.core.js");
const Raphael = function() {
    const has = 'hasOwnProperty';
    const Str = String;
    const toFloat = parseFloat;
    const toInt = parseInt;
    const math = Math;
    const mmax = math.max;
    const { abs } = math;
    const { pow } = math;
    const separator = /[, ]+/;
    const E = '';
    const S = ' ';
    const xlink = 'http://www.w3.org/1999/xlink';
    const markers = {
        block: 'M5,0 0,2.5 5,5z',
        classic: 'M5,0 0,2.5 5,5 3.5,3 3.5,2z',
        diamond: 'M2.5,0 5,2.5 2.5,5 0,2.5z',
        open: 'M6,1 1,3.5 6,6',
        oval: 'M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z'
    };
    const markerCounter = {};
    var $ = function(el, attr) {
        if (attr) {
            if (typeof el === 'string') el = $(el);
            for(const key in attr)if (attr[has](key)) {
                if (key.substring(0, 6) == 'xlink:') el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
                else el.setAttribute(key, Str(attr[key]));
            }
        } else {
            el = (0, _raphaelCoreJs.R)._g.doc.createElementNS('http://www.w3.org/2000/svg', el);
            el.style && (el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)');
        }
        return el;
    };
    const addGradientFill = function(element, gradient) {
        let type = 'linear';
        let id = element.id + gradient;
        let fx = 0.5;
        let fy = 0.5;
        const o = element.node;
        const SVG = element.paper;
        const s = o.style;
        let el = (0, _raphaelCoreJs.R)._g.doc.getElementById(id);
        if (!el) {
            gradient = Str(gradient).replace((0, _raphaelCoreJs.R)._radial_gradient, (all, _fx, _fy)=>{
                type = 'radial';
                if (_fx && _fy) {
                    fx = toFloat(_fx);
                    fy = toFloat(_fy);
                    const dir = (fy > 0.5) * 2 - 1(fx - 0.5) ** 2 + (fy - 0.5) ** 2 > 0.25 && (fy = math.sqrt(0.25 - (fx - 0.5) ** 2) * dir + 0.5) && fy != 0.5 && (fy = fy.toFixed(5) - 1e-5 * dir);
                }
                return E;
            });
            gradient = gradient.split(/\s*\-\s*/);
            if (type == 'linear') {
                let angle = gradient.shift();
                angle = -toFloat(angle);
                if (isNaN(angle)) return null;
                var vector = [
                    0,
                    0,
                    math.cos((0, _raphaelCoreJs.R).rad(angle)),
                    math.sin((0, _raphaelCoreJs.R).rad(angle))
                ];
                const max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
                vector[2] *= max;
                vector[3] *= max;
                if (vector[2] < 0) {
                    vector[0] = -vector[2];
                    vector[2] = 0;
                }
                if (vector[3] < 0) {
                    vector[1] = -vector[3];
                    vector[3] = 0;
                }
            }
            const dots = (0, _raphaelCoreJs.R)._parseDots(gradient);
            if (!dots) return null;
            id = id.replace(/[\(\)\s,\xb0#]/g, '_');
            if (element.gradient && id != element.gradient.id) {
                SVG.defs.removeChild(element.gradient);
                delete element.gradient;
            }
            if (!element.gradient) {
                el = $(`${type}Gradient`, {
                    id
                });
                element.gradient = el;
                $(el, type == 'radial' ? {
                    fx,
                    fy
                } : {
                    x1: vector[0],
                    y1: vector[1],
                    x2: vector[2],
                    y2: vector[3],
                    gradientTransform: element.matrix.invert()
                });
                SVG.defs.appendChild(el);
                for(let i = 0, ii = dots.length; i < ii; i++)el.appendChild($('stop', {
                    offset: dots[i].offset ? dots[i].offset : i ? '100%' : '0%',
                    'stop-color': dots[i].color || '#fff',
                    'stop-opacity': isFinite(dots[i].opacity) ? dots[i].opacity : 1
                }));
            }
        }
        $(o, {
            fill: fillurl(id),
            opacity: 1,
            'fill-opacity': 1
        });
        s.fill = E;
        s.opacity = 1;
        s.fillOpacity = 1;
        return 1;
    };
    const isIE9or10 = function() {
        const mode = document.documentMode;
        return mode && (mode === 9 || mode === 10);
    };
    var fillurl = function(id) {
        // SLATEBOX - always make the fillurl relative to the page, makes svg exports work
        return `url('#${id}')`;
    // if (isIE9or10()) {
    //     return "url('#" + id + "')";
    // }
    // var location = document.location;
    // var locationString = (
    //     location.protocol + '//' +
    //     location.host +
    //     location.pathname +
    //     location.search
    // );
    // return "url('" + locationString + "#" + id + "')";
    };
    // SLATEBOX - edit for image filling (not tiling patterns) of path elements
    const updatePosition = function(o) {
        if (!o.data('relativeFill')) {
            const bbox = o.getBBox(1);
            $(o.pattern, {
                patternTransform: `${o.matrix.invert()} translate(${bbox.x},${bbox.y})`
            });
        }
    };
    const addArrow = function(o, value, isEnd) {
        if (o.type == 'path') {
            const values = Str(value).toLowerCase().split('-');
            const p = o.paper;
            const se = isEnd ? 'end' : 'start';
            const { node } = o;
            const { attrs } = o;
            const stroke = attrs['stroke-width'];
            let i = values.length;
            let type = 'classic';
            let from;
            let to;
            let dx;
            let refX;
            let attr;
            let w = 3;
            let h = 3;
            let t = 5;
            while(i--)switch(values[i]){
                case 'block':
                case 'classic':
                case 'oval':
                case 'diamond':
                case 'open':
                case 'none':
                    type = values[i];
                    break;
                case 'wide':
                    h = 5;
                    break;
                case 'narrow':
                    h = 2;
                    break;
                case 'long':
                    w = 5;
                    break;
                case 'short':
                    w = 2;
                    break;
            }
            if (type == 'open') {
                w += 2;
                h += 2;
                t += 2;
                dx = 1;
                refX = isEnd ? 4 : 1;
                attr = {
                    fill: 'none',
                    stroke: attrs.stroke
                };
            } else {
                refX = dx = w / 2;
                attr = {
                    fill: attrs.stroke,
                    stroke: 'none'
                };
            }
            if (o._.arrows) {
                if (isEnd) {
                    o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                    o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
                } else {
                    o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                    o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
                }
            } else o._.arrows = {};
            if (type != 'none') {
                const pathId = `raphael-marker-${type}`;
                const markerId = `raphael-marker-${se}${type}${w}${h}-obj${o.id}`;
                // SLATEBOX - addition to make sure arrows show in svg extract
                if (!(0, _raphaelCoreJs.R)._g.doc.getElementById(pathId) || (0, _raphaelCoreJs.R)._g.doc.getElementById(pathId) && getComputedStyle((0, _raphaelCoreJs.R)._g.doc.getElementById(pathId)).display === 'none') {
                    p.defs.appendChild($($('path'), {
                        'stroke-linecap': 'round',
                        d: markers[type],
                        id: pathId
                    }));
                    markerCounter[pathId] = 1;
                } else markerCounter[pathId]++;
                let marker = (0, _raphaelCoreJs.R)._g.doc.getElementById(markerId);
                let use;
                if (!marker) {
                    marker = $($('marker'), {
                        id: markerId,
                        markerHeight: h,
                        markerWidth: w,
                        orient: 'auto',
                        refX,
                        refY: h / 2
                    });
                    use = $($('use'), {
                        'xlink:href': `#${pathId}`,
                        transform: `${isEnd ? `rotate(180 ${w / 2} ${h / 2}) ` : E}scale(${w / t},${h / t})`,
                        'stroke-width': (1 / ((w / t + h / t) / 2)).toFixed(4)
                    });
                    marker.appendChild(use);
                    p.defs.appendChild(marker);
                    markerCounter[markerId] = 1;
                } else {
                    markerCounter[markerId]++;
                    use = marker.getElementsByTagName('use')[0];
                }
                $(use, attr);
                const delta = dx * (type != 'diamond' && type != 'oval');
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - delta * stroke;
                } else {
                    from = delta * stroke;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                attr = {};
                attr[`marker-${se}`] = `url(#${markerId})`;
                if (to || from) attr.d = (0, _raphaelCoreJs.R).getSubpath(attrs.path, from, to);
                $(node, attr);
                o._.arrows[`${se}Path`] = pathId;
                o._.arrows[`${se}Marker`] = markerId;
                o._.arrows[`${se}dx`] = delta;
                o._.arrows[`${se}Type`] = type;
                o._.arrows[`${se}String`] = value;
            } else {
                if (isEnd) {
                    from = o._.arrows.startdx * stroke || 0;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - from;
                } else {
                    from = 0;
                    to = (0, _raphaelCoreJs.R).getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
                }
                o._.arrows[`${se}Path`] && $(node, {
                    d: (0, _raphaelCoreJs.R).getSubpath(attrs.path, from, to)
                });
                delete o._.arrows[`${se}Path`];
                delete o._.arrows[`${se}Marker`];
                delete o._.arrows[`${se}dx`];
                delete o._.arrows[`${se}Type`];
                delete o._.arrows[`${se}String`];
            }
            for(attr in markerCounter)if (markerCounter[has](attr) && !markerCounter[attr]) {
                const item = (0, _raphaelCoreJs.R)._g.doc.getElementById(attr);
                item && item.parentNode.removeChild(item);
            }
        }
    };
    const dasharray = {
        '-': [
            3,
            1
        ],
        '.': [
            1,
            1
        ],
        '-.': [
            3,
            1,
            1,
            1
        ],
        '-..': [
            3,
            1,
            1,
            1,
            1,
            1
        ],
        '. ': [
            1,
            3
        ],
        '- ': [
            4,
            3
        ],
        '--': [
            8,
            3
        ],
        '- .': [
            4,
            3,
            1,
            3
        ],
        '--.': [
            8,
            3,
            1,
            3
        ],
        '--..': [
            8,
            3,
            1,
            3,
            1,
            3
        ]
    };
    const addDashes = function(o, value, params) {
        value = dasharray[Str(value).toLowerCase()];
        if (value) {
            const width = o.attrs['stroke-width'] || '1';
            const butt = {
                round: width,
                square: width,
                butt: 0
            }[o.attrs['stroke-linecap'] || params['stroke-linecap']] || 0;
            const dashes = [];
            let i = value.length;
            while(i--)dashes[i] = value[i] * width + (i % 2 ? 1 : -1) * butt;
            $(o.node, {
                'stroke-dasharray': dashes.join(',')
            });
        } else $(o.node, {
            'stroke-dasharray': 'none'
        });
    };
    const setFillAndStroke = function(o, params) {
        const { node } = o;
        const { attrs } = o;
        const vis = node.style.visibility;
        node.style.visibility = 'hidden';
        for(let att in params)if (params[has](att)) {
            if (!(0, _raphaelCoreJs.R)._availableAttrs[has](att)) continue;
            let value = params[att];
            attrs[att] = value;
            switch(att){
                case 'blur':
                    o.blur(value);
                    break;
                case 'title':
                    var title = node.getElementsByTagName('title');
                    // Use the existing <title>.
                    if (title.length && (title = title[0])) title.firstChild.nodeValue = value;
                    else {
                        title = $('title');
                        const val = (0, _raphaelCoreJs.R)._g.doc.createTextNode(value);
                        title.appendChild(val);
                        node.appendChild(title);
                    }
                    break;
                case 'href':
                case 'target':
                    var pn = node.parentNode;
                    if (pn.tagName.toLowerCase() != 'a') {
                        const hl = $('a');
                        pn.insertBefore(hl, node);
                        hl.appendChild(node);
                        pn = hl;
                    }
                    if (att == 'target') pn.setAttributeNS(xlink, 'show', value == 'blank' ? 'new' : value);
                    else pn.setAttributeNS(xlink, att, value);
                    break;
                case 'cursor':
                    node.style.cursor = value;
                    break;
                case 'transform':
                    o.transform(value);
                    break;
                case 'arrow-start':
                    addArrow(o, value);
                    break;
                case 'arrow-end':
                    addArrow(o, value, 1);
                    break;
                case 'clip-rect':
                    var rect = Str(value).split(separator);
                    if (rect.length == 4) {
                        o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                        var el = $('clipPath');
                        const rc = $('rect');
                        el.id = (0, _raphaelCoreJs.R).createUUID();
                        $(rc, {
                            x: rect[0],
                            y: rect[1],
                            width: rect[2],
                            height: rect[3]
                        });
                        el.appendChild(rc);
                        o.paper.defs.appendChild(el);
                        $(node, {
                            'clip-path': `url(#${el.id})`
                        });
                        o.clip = rc;
                    }
                    if (!value) {
                        const path = node.getAttribute('clip-path');
                        if (path) {
                            const clip = (0, _raphaelCoreJs.R)._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                            clip && clip.parentNode.removeChild(clip);
                            $(node, {
                                'clip-path': E
                            });
                            delete o.clip;
                        }
                    }
                    break;
                case 'path':
                    // SLATEBOX - changed "$(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});"
                    // to $(node, {d: value ? attrs.path = value : "M0,0"}); in the line below -->
                    if (o.type == 'path') {
                        $(node, {
                            d: value ? attrs.path = value : 'M0,0'
                        }) // <--
                        ;
                        o._.dirty = 1;
                        if (o._.arrows) {
                            'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                            'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                        }
                    }
                    break;
                case 'width':
                    node.setAttribute(att, value);
                    o._.dirty = 1;
                    if (attrs.fx) {
                        att = 'x';
                        value = attrs.x;
                    } else break;
                case 'x':
                    if (attrs.fx) value = -attrs.x - (attrs.width || 0);
                case 'rx':
                    if (att == 'rx' && o.type == 'rect') break;
                case 'cx':
                    node.setAttribute(att, value);
                    o.pattern && updatePosition(o);
                    o._.dirty = 1;
                    break;
                case 'height':
                    node.setAttribute(att, value);
                    o._.dirty = 1;
                    if (attrs.fy) {
                        att = 'y';
                        value = attrs.y;
                    } else break;
                case 'y':
                    if (attrs.fy) value = -attrs.y - (attrs.height || 0);
                case 'ry':
                    if (att == 'ry' && o.type == 'rect') break;
                case 'cy':
                    node.setAttribute(att, value);
                    o.pattern && updatePosition(o);
                    o._.dirty = 1;
                    break;
                case 'r':
                    if (o.type == 'rect') $(node, {
                        rx: value,
                        ry: value
                    });
                    else node.setAttribute(att, value);
                    o._.dirty = 1;
                    break;
                case 'src':
                    if (o.type == 'image') node.setAttributeNS(xlink, 'href', value);
                    break;
                case 'stroke-width':
                    if (o._.sx != 1 || o._.sy != 1) value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                    node.setAttribute(att, value);
                    if (attrs['stroke-dasharray']) addDashes(o, attrs['stroke-dasharray'], params);
                    if (o._.arrows) {
                        'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                        'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                    }
                    break;
                case 'stroke-dasharray':
                    addDashes(o, value, params);
                    break;
                case 'fill':
                    // SLATEBOX a few edits for image filling (not tiling patterns) of path elements
                    var relativeFill = o.data('relativeFill');
                    var isURL = Str(value).match((0, _raphaelCoreJs.R)._ISURL);
                    if (isURL) {
                        if (value.indexOf('(#') > -1) // internal reference
                        $(node, {
                            fill: value
                        });
                        else {
                            // image, external
                            el = $('pattern');
                            var ig = $('image');
                            el.id = (0, _raphaelCoreJs.R).createUUID();
                            $(el, {
                                x: 0,
                                y: 0,
                                patternUnits: relativeFill ? 'objectBoundingBox' : 'userSpaceOnUse',
                                height: 1,
                                width: 1
                            });
                            $(ig, {
                                x: 0,
                                y: 0,
                                'xlink:href': isURL[1]
                            });
                            el.appendChild(ig);
                            (function(el) {
                                (0, _raphaelCoreJs.R)._preload(isURL[1], function() {
                                    const w = this.offsetWidth;
                                    const h = this.offsetHeight;
                                    const tempPath = o.paper.path(o.attr('path'));
                                    const bbox = tempPath.getBBox();
                                    $(el, {
                                        width: relativeFill ? 1 : w,
                                        height: relativeFill ? 1 : h
                                    });
                                    // SLATEBOX - image fixes for FF/safari
                                    $(ig, {
                                        width: relativeFill ? o.imageOrigWidth || bbox.width : w,
                                        height: relativeFill ? o.imageOrigHeight || bbox.height : h
                                    });
                                    delete o.imageOrigHeight;
                                    delete o.imageOrigWidth;
                                    tempPath.remove();
                                // end image fixes for SB
                                });
                            })(el);
                            o.paper.defs.appendChild(el);
                            $(node, {
                                fill: `url(#${el.id})`
                            });
                            o.pattern = el;
                            o.pattern && updatePosition(o);
                        }
                        break;
                    }
                    var clr = (0, _raphaelCoreJs.R).getRGB(value);
                    if (!clr.error) {
                        delete params.gradient;
                        delete attrs.gradient;
                        !(0, _raphaelCoreJs.R).is(attrs.opacity, 'undefined') && (0, _raphaelCoreJs.R).is(params.opacity, 'undefined') && $(node, {
                            opacity: attrs.opacity
                        });
                        !(0, _raphaelCoreJs.R).is(attrs['fill-opacity'], 'undefined') && (0, _raphaelCoreJs.R).is(params['fill-opacity'], 'undefined') && $(node, {
                            'fill-opacity': attrs['fill-opacity']
                        });
                    } else if ((o.type == 'circle' || o.type == 'ellipse' || Str(value).charAt() != 'r') && addGradientFill(o, value)) {
                        if ('opacity' in attrs || 'fill-opacity' in attrs) {
                            var gradient = (0, _raphaelCoreJs.R)._g.doc.getElementById(node.getAttribute('fill').replace(/^url\(#|\)$/g, E));
                            if (gradient) {
                                var stops = gradient.getElementsByTagName('stop');
                                $(stops[stops.length - 1], {
                                    'stop-opacity': ('opacity' in attrs ? attrs.opacity : 1) * ('fill-opacity' in attrs ? attrs['fill-opacity'] : 1)
                                });
                            }
                        }
                        attrs.gradient = value;
                        attrs.fill = 'none';
                        break;
                    }
                    clr[has]('opacity') && $(node, {
                        'fill-opacity': clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                    });
                case 'stroke':
                    clr = (0, _raphaelCoreJs.R).getRGB(value);
                    node.setAttribute(att, clr.hex);
                    att == 'stroke' && clr[has]('opacity') && $(node, {
                        'stroke-opacity': clr.opacity > 1 ? clr.opacity / 100 : clr.opacity
                    });
                    if (att == 'stroke' && o._.arrows) {
                        'startString' in o._.arrows && addArrow(o, o._.arrows.startString);
                        'endString' in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                    }
                    break;
                case 'gradient':
                    (o.type == 'circle' || o.type == 'ellipse' || Str(value).charAt() != 'r') && addGradientFill(o, value);
                    break;
                case 'opacity':
                    if (attrs.gradient && !attrs[has]('stroke-opacity')) $(node, {
                        'stroke-opacity': value > 1 ? value / 100 : value
                    });
                // fall
                case 'fill-opacity':
                    if (attrs.gradient) {
                        gradient = (0, _raphaelCoreJs.R)._g.doc.getElementById(node.getAttribute('fill').replace(/^url\(#|\)$/g, E));
                        if (gradient) {
                            stops = gradient.getElementsByTagName('stop');
                            $(stops[stops.length - 1], {
                                'stop-opacity': value
                            });
                        }
                        break;
                    }
                default:
                    att == 'font-size' && (value = `${toInt(value, 10)}px`);
                    var cssrule = att.replace(/(\-.)/g, (w)=>w.substring(1).toUpperCase());
                    node.style[cssrule] = value;
                    o._.dirty = 1;
                    node.setAttribute(att, value);
                    break;
            }
        }
        tuneText(o, params);
        node.style.visibility = vis;
    };
    const leading = 1.2;
    var tuneText = function(el, params) {
        if (el.type != 'text' || !(params[has]('text') || params[has]('font') || params[has]('font-size') || params[has]('x') || params[has]('y'))) return;
        const a = el.attrs;
        const { node } = el;
        const fontSize = node.firstChild ? toInt((0, _raphaelCoreJs.R)._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue('font-size'), 10) : 10;
        if (params[has]('text')) {
            a.text = params.text;
            while(node.firstChild)node.removeChild(node.firstChild);
            const texts = Str(params.text).split('\n');
            var tspans = [];
            let tspan;
            for(var i = 0, ii = texts.length; i < ii; i++){
                tspan = $('tspan');
                i && $(tspan, {
                    dy: fontSize * leading,
                    x: a.x
                });
                tspan.appendChild((0, _raphaelCoreJs.R)._g.doc.createTextNode(texts[i]));
                node.appendChild(tspan);
                tspans[i] = tspan;
            }
        } else {
            tspans = node.getElementsByTagName('tspan');
            for(i = 0, ii = tspans.length; i < ii; i++)if (i) $(tspans[i], {
                dy: fontSize * leading,
                x: a.x
            });
            else $(tspans[0], {
                dy: 0
            });
        }
        $(node, {
            x: a.x,
            y: a.y
        });
        el._.dirty = 1;
        const bb = el._getBBox();
        const dif = a.y - (bb.y + bb.height / 2);
        dif && (0, _raphaelCoreJs.R).is(dif, 'finite') && $(tspans[0], {
            dy: dif
        });
    };
    const getRealNode = function(node) {
        if (node.parentNode && node.parentNode.tagName.toLowerCase() === 'a') return node.parentNode;
        return node;
    };
    const Element = function(node, svg) {
        const X = 0;
        const Y = 0;
        /* \
       * Element.node
       [ property (object) ]
       **
       * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
       **
       * Note: Dont mess with it.
       > Usage
       | // draw a circle at coordinate 10,10 with radius of 10
       | var c = paper.circle(10, 10, 10);
       | c.node.onclick = function () {
       |     c.attr("fill", "red");
       | };
      \ */ this[0] = this.node = node;
        /* \
       * Element.raphael
       [ property (object) ]
       **
       * Internal reference to @Raphael object. In case it is not available.
       > Usage
       | Raphael.el.red = function () {
       |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
       |     hsb.h = 1;
       |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
       | }
      \ */ node.raphael = true;
        /* \
       * Element.id
       [ property (number) ]
       **
       * Unique id of the element. Especially useful when you want to listen to events of the element,
       * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
      \ */ this.id = guid();
        node.raphaelid = this.id;
        /**
     * Method that returns a 5 letter/digit id, enough for 36^5 = 60466176 elements
     * @returns {string} id
     */ function guid() {
            return `0000${(Math.random() * 36 ** 5 << 0).toString(36)}`.slice(-5);
        }
        this.matrix = (0, _raphaelCoreJs.R).matrix();
        this.realPath = null;
        /* \
       * Element.paper
       [ property (object) ]
       **
       * Internal reference to paper where object drawn. Mainly for use in plugins and element extensions.
       > Usage
       | Raphael.el.cross = function () {
       |     this.attr({fill: "red"});
       |     this.paper.path("M10,10L50,50M50,10L10,50")
       |         .attr({stroke: "red"});
       | }
      \ */ this.paper = svg;
        this.attrs = this.attrs || {};
        this._ = {
            transform: [],
            sx: 1,
            sy: 1,
            deg: 0,
            dx: 0,
            dy: 0,
            dirty: 1
        };
        !svg.bottom && (svg.bottom = this);
        /* \
       * Element.prev
       [ property (object) ]
       **
       * Reference to the previous element in the hierarchy.
      \ */ this.prev = svg.top;
        svg.top && (svg.top.next = this);
        svg.top = this;
        /* \
       * Element.next
       [ property (object) ]
       **
       * Reference to the next element in the hierarchy.
      \ */ this.next = null;
    };
    const elproto = (0, _raphaelCoreJs.R).el;
    Element.prototype = elproto;
    elproto.constructor = Element;
    (0, _raphaelCoreJs.R)._engine.path = function(pathString, SVG) {
        const el = $('path');
        SVG.canvas && SVG.canvas.appendChild(el);
        const p = new Element(el, SVG);
        p.type = 'path';
        setFillAndStroke(p, {
            fill: 'none',
            stroke: '#000',
            path: pathString
        });
        return p;
    };
    /* \
   * Element.rotate
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds rotation by given angle around given point to the list of
   * transformations of the element.
   > Parameters
   - deg (number) angle in degrees
   - cx (number) #optional x coordinate of the centre of rotation
   - cy (number) #optional y coordinate of the centre of rotation
   * If cx & cy arent specified centre of the shape is used as a point of rotation.
   = (object) @Element
  \ */ elproto.rotate = function(deg, cx, cy) {
        if (this.removed) return this;
        deg = Str(deg).split(separator);
        if (deg.length - 1) {
            cx = toFloat(deg[1]);
            cy = toFloat(deg[2]);
        }
        deg = toFloat(deg[0]);
        cy == null && (cx = cy);
        if (cx == null || cy == null) {
            const bbox = this.getBBox(1);
            cx = bbox.x + bbox.width / 2;
            cy = bbox.y + bbox.height / 2;
        }
        this.transform(this._.transform.concat([
            [
                'r',
                deg,
                cx,
                cy
            ]
        ]));
        return this;
    };
    /* \
   * Element.scale
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds scale by given amount relative to given point to the list of
   * transformations of the element.
   > Parameters
   - sx (number) horisontal scale amount
   - sy (number) vertical scale amount
   - cx (number) #optional x coordinate of the centre of scale
   - cy (number) #optional y coordinate of the centre of scale
   * If cx & cy arent specified centre of the shape is used instead.
   = (object) @Element
  \ */ elproto.scale = function(sx, sy, cx, cy) {
        if (this.removed) return this;
        sx = Str(sx).split(separator);
        if (sx.length - 1) {
            sy = toFloat(sx[1]);
            cx = toFloat(sx[2]);
            cy = toFloat(sx[3]);
        }
        sx = toFloat(sx[0]);
        sy == null && (sy = sx);
        cy == null && (cx = cy);
        if (cx == null || cy == null) var bbox = this.getBBox(1);
        cx = cx == null ? bbox.x + bbox.width / 2 : cx;
        cy = cy == null ? bbox.y + bbox.height / 2 : cy;
        this.transform(this._.transform.concat([
            [
                's',
                sx,
                sy,
                cx,
                cy
            ]
        ]));
        return this;
    };
    /* \
   * Element.translate
   [ method ]
   **
   * Deprecated! Use @Element.transform instead.
   * Adds translation by given amount to the list of transformations of the element.
   > Parameters
   - dx (number) horisontal shift
   - dy (number) vertical shift
   = (object) @Element
  \ */ elproto.translate = function(dx, dy) {
        if (this.removed) return this;
        dx = Str(dx).split(separator);
        if (dx.length - 1) dy = toFloat(dx[1]);
        dx = toFloat(dx[0]) || 0;
        dy = +dy || 0;
        this.transform(this._.transform.concat([
            [
                't',
                dx,
                dy
            ]
        ]));
        return this;
    };
    /* \
   * Element.transform
   [ method ]
   **
   * Adds transformation to the element which is separate to other attributes,
   * i.e. translation doesnt change `x` or `y` of the rectange. The format
   * of transformation string is similar to the path string syntax:
   | "t100,100r30,100,100s2,2,100,100r45s1.5"
   * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
   * scale and `m` is for matrix.
   *
   * There are also alternative absolute translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
   *
   * So, the example line above could be read like translate by 100, 100; rotate 30 around 100, 100; scale twice around 100, 100;
   * rotate 45 around centre; scale 1.5 times relative to centre. As you can see rotate and scale commands have origin
   * coordinates as optional parameters, the default is the centre point of the element.
   * Matrix accepts six parameters.
   > Usage
   | var el = paper.rect(10, 20, 300, 200);
   | // translate 100, 100, rotate 45, translate -100, 0
   | el.transform("t100,100r45t-100,0");
   | // if you want you can append or prepend transformations
   | el.transform("...t50,50");
   | el.transform("s2...");
   | // or even wrap
   | el.transform("t50,50...t-50-50");
   | // to reset transformation call method with empty string
   | el.transform("");
   | // to get current value call it without parameters
   | console.log(el.transform());
   > Parameters
   - tstr (string) #optional transformation string
   * If tstr isnt specified
   = (string) current transformation string
   * else
   = (object) @Element
  \ */ elproto.transform = function(tstr) {
        const { _ } = this;
        if (tstr == null) return _.transform;
        (0, _raphaelCoreJs.R)._extractTransform(this, tstr);
        this.clip && $(this.clip, {
            transform: this.matrix.invert()
        });
        this.pattern && updatePosition(this);
        this.node && $(this.node, {
            transform: this.matrix
        });
        if (_.sx != 1 || _.sy != 1) {
            const sw = this.attrs[has]('stroke-width') ? this.attrs['stroke-width'] : 1;
            this.attr({
                'stroke-width': sw
            });
        }
        return this;
    };
    /* \
   * Element.hide
   [ method ]
   **
   * Makes element invisible. See @Element.show.
   = (object) @Element
  \ */ elproto.hide = function() {
        if (!this.removed) this.node.style.display = 'none';
        return this;
    };
    /* \
   * Element.show
   [ method ]
   **
   * Makes element visible. See @Element.hide.
   = (object) @Element
  \ */ elproto.show = function() {
        if (!this.removed) this.node.style.display = '';
        return this;
    };
    /* \
   * Element.remove
   [ method ]
   **
   * Removes element from the paper.
  \ */ elproto.remove = function() {
        const node = getRealNode(this.node);
        if (this.removed || !node.parentNode) return;
        const { paper } = this;
        paper.__set__ && paper.__set__.exclude(this);
        (0, _eveJs.eve).unbind(`raphael.*.*.${this.id}`);
        if (this.gradient) paper.defs.removeChild(this.gradient);
        (0, _raphaelCoreJs.R)._tear(this, paper);
        node.parentNode.removeChild(node);
        // Remove custom data for element
        this.removeData();
        for(const i in this)this[i] = typeof this[i] === 'function' ? (0, _raphaelCoreJs.R)._removedFactory(i) : null;
        this.removed = true;
    };
    elproto._getBBox = function() {
        if (this.node.style.display == 'none') {
            this.show();
            var hide = true;
        }
        let canvasHidden = false;
        let containerStyle;
        if (this.paper.canvas.parentElement) containerStyle = this.paper.canvas.parentElement.style;
        else if (this.paper.canvas.parentNode) containerStyle = this.paper.canvas.parentNode.style;
        if (containerStyle && containerStyle.display == 'none') {
            canvasHidden = true;
            containerStyle.display = '';
        }
        let bbox = {};
        try {
            bbox = this.node.getBBox();
        } catch (e) {
            // Firefox 3.0.x, 25.0.1 (probably more versions affected) play badly here - possible fix
            bbox = {
                x: this.node.clientLeft,
                y: this.node.clientTop,
                width: this.node.clientWidth,
                height: this.node.clientHeight
            };
        } finally{
            bbox = bbox || {};
            if (canvasHidden) containerStyle.display = 'none';
        }
        hide && this.hide();
        return bbox;
    };
    /* \
   * Element.attr
   [ method ]
   **
   * Sets the attributes of the element.
   > Parameters
   - attrName (string) attributes name
   - value (string) value
   * or
   - params (object) object of name/value pairs
   * or
   - attrName (string) attributes name
   * or
   - attrNames (array) in this case method returns array of current values for given attribute names
   = (object) @Element if attrsName & value or params are passed in.
   = (...) value of the attribute if only attrsName is passed in.
   = (array) array of values of the attribute if attrsNames is passed in.
   = (object) object of attributes if nothing is passed in.
   > Possible parameters
   # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
   o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
   o clip-rect (string) comma or space separated values: x, y, width and height
   o cursor (string) CSS type of the cursor
   o cx (number) the x-axis coordinate of the center of the circle, or ellipse
   o cy (number) the y-axis coordinate of the center of the circle, or ellipse
   o fill (string) colour, gradient or image
   o fill-opacity (number)
   o font (string)
   o font-family (string)
   o font-size (number) font size in pixels
   o font-weight (string)
   o height (number)
   o href (string) URL, if specified element behaves as hyperlink
   o opacity (number)
   o path (string) SVG path string format
   o r (number) radius of the circle, ellipse or rounded corner on the rect
   o rx (number) horisontal radius of the ellipse
   o ry (number) vertical radius of the ellipse
   o src (string) image URL, only works for @Element.image element
   o stroke (string) stroke colour
   o stroke-dasharray (string) [, none, `-`, `.`, `-.`, `-..`, `. `, `- `, `--`, `- .`, `--.`, `--..`]
   o stroke-linecap (string) [`butt`, `square`, `round`]
   o stroke-linejoin (string) [`bevel`, `round`, `miter`]
   o stroke-miterlimit (number)
   o stroke-opacity (number)
   o stroke-width (number) stroke width in pixels, default is '1'
   o target (string) used with href
   o text (string) contents of the text element. Use `\n` for multiline text
   o text-anchor (string) [`start`, `middle`, `end`], default is `middle`
   o title (string) will create tooltip with a given text
   o transform (string) see @Element.transform
   o width (number)
   o x (number)
   o y (number)
   > Gradients
   * Linear gradient format: `angle-colour[-colour[:offset]]*-colour`, example: `90-#fff-#000`  90
   * gradient from white to black or `0-#fff-#f00:20-#000`  0 gradient from white via red (at 20%) to black.
   *
   * radial gradient: `r[(fx, fy)]colour[-colour[:offset]]*-colour`, example: `r#fff-#000` 
   * gradient from white to black or `r(0.25, 0.75)#fff-#000`  gradient from white to black with focus point
   * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
   > Path String
   # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a paths data attributes format are described in the SVG specification.">SVG documentation regarding path string</a>. Raphal fully supports it.</p>
   > Colour Parsing
   # <ul>
   #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
   #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
   #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
   #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
   #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
   #     <li>rgba(, , , )  red, green and blue channels values: (<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>)</li>
   #     <li>rgba(%, %, %, %)  same as above, but in %: (<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>)</li>
   #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
   #     <li>hsb(%, %, %)  same as above, but in %</li>
   #     <li>hsba(, , , )  same as above, but with opacity</li>
   #     <li>hsl(, , )  almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
   #     <li>hsl(%, %, %)  same as above, but in %</li>
   #     <li>hsla(, , , )  same as above, but with opacity</li>
   #     <li>Optionally for hsb and hsl you could specify hue as a degree: <code>hsl(240deg,&nbsp;1,&nbsp;.5)</code> or, if you want to go fancy, <code>hsl(240,&nbsp;1,&nbsp;.5)</code></li>
   # </ul>
  \ */ elproto.attr = function(name, value) {
        if (this.removed) return this;
        if (name == null) {
            const res = {};
            for(const a in this.attrs)if (this.attrs[has](a)) res[a] = this.attrs[a];
            res.gradient && res.fill == 'none' && (res.fill = res.gradient) && delete res.gradient;
            res.transform = this._.transform;
            return res;
        }
        if (value == null && (0, _raphaelCoreJs.R).is(name, 'string')) {
            if (name == 'fill' && this.attrs.fill == 'none' && this.attrs.gradient) return this.attrs.gradient;
            if (name == 'transform') return this._.transform;
            const names = name.split(separator);
            var out = {};
            for(var i = 0, ii = names.length; i < ii; i++){
                name = names[i];
                if (name in this.attrs) out[name] = this.attrs[name];
                else if ((0, _raphaelCoreJs.R).is(this.paper.customAttributes[name], 'function')) out[name] = this.paper.customAttributes[name].def;
                else out[name] = (0, _raphaelCoreJs.R)._availableAttrs[name];
            }
            return ii - 1 ? out : out[names[0]];
        }
        if (value == null && (0, _raphaelCoreJs.R).is(name, 'array')) {
            out = {};
            for(i = 0, ii = name.length; i < ii; i++)out[name[i]] = this.attr(name[i]);
            return out;
        }
        if (value != null) {
            var params = {};
            params[name] = value;
        } else if (name != null && (0, _raphaelCoreJs.R).is(name, 'object')) params = name;
        for(var key in params)(0, _eveJs.eve)(`raphael.attr.${key}.${this.id}`, this, params[key]);
        for(key in this.paper.customAttributes)if (this.paper.customAttributes[has](key) && params[has](key) && (0, _raphaelCoreJs.R).is(this.paper.customAttributes[key], 'function')) {
            const par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
            this.attrs[key] = params[key];
            for(const subkey in par)if (par[has](subkey)) params[subkey] = par[subkey];
        }
        setFillAndStroke(this, params);
        return this;
    };
    /* \
   * Element.toFront
   [ method ]
   **
   * Moves the element so it is the closest to the viewers eyes, on top of other elements.
   = (object) @Element
  \ */ elproto.toFront = function() {
        if (this.removed) return this;
        const node = getRealNode(this.node);
        node.parentNode.appendChild(node);
        const svg = this.paper;
        svg.top != this && (0, _raphaelCoreJs.R)._tofront(this, svg);
        return this;
    };
    /* \
   * Element.toBack
   [ method ]
   **
   * Moves the element so it is the furthest from the viewers eyes, behind other elements.
   = (object) @Element
  \ */ elproto.toBack = function() {
        if (this.removed) return this;
        const node = getRealNode(this.node);
        const { parentNode } = node;
        parentNode.insertBefore(node, parentNode.firstChild);
        (0, _raphaelCoreJs.R)._toback(this, this.paper);
        const svg = this.paper;
        return this;
    };
    /* \
   * Element.insertAfter
   [ method ]
   **
   * Inserts current object after the given one.
   = (object) @Element
  \ */ elproto.insertAfter = function(element) {
        if (this.removed || !element) return this;
        const node = getRealNode(this.node);
        const afterNode = getRealNode(element.node || element[element.length - 1].node);
        if (afterNode.nextSibling) afterNode.parentNode.insertBefore(node, afterNode.nextSibling);
        else afterNode.parentNode.appendChild(node);
        (0, _raphaelCoreJs.R)._insertafter(this, element, this.paper);
        return this;
    };
    /* \
   * Element.insertBefore
   [ method ]
   **
   * Inserts current object before the given one.
   = (object) @Element
  \ */ elproto.insertBefore = function(element) {
        if (this.removed || !element) return this;
        const node = getRealNode(this.node);
        const beforeNode = getRealNode(element.node || element[0].node);
        beforeNode.parentNode.insertBefore(node, beforeNode);
        (0, _raphaelCoreJs.R)._insertbefore(this, element, this.paper);
        return this;
    };
    elproto.blur = function(size) {
        // Experimental. No Safari support. Use it on your own risk.
        const t = this;
        if (+size !== 0) {
            const fltr = $('filter');
            const blur = $('feGaussianBlur');
            t.attrs.blur = size;
            fltr.id = (0, _raphaelCoreJs.R).createUUID();
            $(blur, {
                stdDeviation: +size || 1.5
            });
            fltr.appendChild(blur);
            t.paper.defs.appendChild(fltr);
            t._blur = fltr;
            $(t.node, {
                filter: `url(#${fltr.id})`
            });
        } else {
            if (t._blur) {
                t._blur.parentNode.removeChild(t._blur);
                delete t._blur;
                delete t.attrs.blur;
            }
            t.node.removeAttribute('filter');
        }
        return t;
    };
    (0, _raphaelCoreJs.R)._engine.circle = function(svg, x, y, r) {
        const el = $('circle');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            cx: x,
            cy: y,
            r,
            fill: 'none',
            stroke: '#000'
        };
        res.type = 'circle';
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.rect = function(svg, x, y, w, h, r) {
        const el = $('rect');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            width: w,
            height: h,
            rx: r || 0,
            ry: r || 0,
            fill: 'none',
            stroke: '#000'
        };
        res.type = 'rect';
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.g = function(svg) {
        const el = $('g');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.type = 'g';
        res.canvas = res.node;
        // adding support for adding elements inside <g>
        const elements = [
            'circle',
            'rect',
            'ellipse',
            'image',
            'text',
            'g',
            'path'
        ];
        elements.forEach((element)=>{
            res[element] = function() {
                const args = [
                    res
                ];
                for(let i = 0; i < arguments.length; i++)args.push(arguments[i]);
                const out = (0, _raphaelCoreJs.R)._engine[element].apply(this, args);
                return out;
            };
        });
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.def = function(def) {
        // SLATEBOX - add ability to programattically add defs
        // {
        //   type: "pattern",
        //   id: "smallGrid",
        //   height: 10,
        //   width: 10,
        //   patternUnits: "userSpaceOnUse",
        //   inside: {
        //     type: "path",
        //     attrs: {
        //       d: "M 10 0 L 0 0 0 10",
        //       fill: "none",
        //       stroke: "gray",
        //       "stroke-width": "0.5"
        //     }
        //   }
        // }
        /*
      <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
        <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" stroke-width="0.5"/>
      </pattern>
    */ const id = def.id || `raphael-def-${(0, _raphaelCoreJs.R).createUUID()}`;
        // if exists, remove and rebuild
        const exists = Array.prototype.slice.call(this.defs.children).find((c)=>c.getAttribute('id') === id);
        exists && this.defs.removeChild(exists);
        const defOpts = {
            id
        };
        Object.assign(defOpts, {
            ...def
        });
        // no need to have inside=[object object] as it is used elsewhere below
        delete defOpts.inside;
        // if (def.height != null) defOpts.height = def.height;
        // if (def.width != null) defOpts.width = def.width;
        // switch (def.type) {
        //   case "pattern": {
        //     defOpts.patternUnits = def.patternUnits || "userSpaceOnUse";
        //     break;
        //   }
        //   case "filter": {
        //     if (def.x != null) defOpts.x = def.x;
        //     if (def.y != null) defOpts.y = def.y;
        //     break;
        //   }
        //   case "style": {
        //     defOpts.type = "text/css";
        //     break;
        //   }
        //   case "path": {
        //     Object.assign(defOpts, {...def});
        //     break;
        //   }
        // }
        // always rebuild
        const rDef = $($(def.tag || 'pattern'), defOpts);
        if (def.inside) def.inside.forEach((i)=>{
            const ins = $($(i.type), i.attrs || {});
            rDef.appendChild(ins);
            if (i.nested) {
                if (i.nested.forEach) i.nested.forEach((nx)=>{
                    const nest = $($(nx.type), nx.attrs || {});
                    ins.appendChild(nest);
                });
                else Object.keys(i.nested).forEach((n)=>{
                    const nest = $($(n), i.nested[n] || {});
                    ins.appendChild(nest);
                });
            }
        });
        this.defs.appendChild(rDef);
    };
    (0, _raphaelCoreJs.R)._engine.ellipse = function(svg, x, y, rx, ry) {
        const el = $('ellipse');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            cx: x,
            cy: y,
            rx,
            ry,
            fill: 'none',
            stroke: '#000'
        };
        res.type = 'ellipse';
        $(el, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.image = function(svg, src, x, y, w, h) {
        const el = $('image');
        $(el, {
            x,
            y,
            width: w,
            height: h,
            preserveAspectRatio: 'none'
        });
        el.setAttributeNS(xlink, 'href', src);
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            width: w,
            height: h,
            src
        };
        res.type = 'image';
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.text = function(svg, x, y, text) {
        const el = $('text');
        svg.canvas && svg.canvas.appendChild(el);
        const res = new Element(el, svg);
        res.attrs = {
            x,
            y,
            'text-anchor': 'middle',
            text,
            'font-family': (0, _raphaelCoreJs.R)._availableAttrs['font-family'],
            'font-size': (0, _raphaelCoreJs.R)._availableAttrs['font-size'],
            stroke: 'none',
            fill: '#000'
        };
        res.type = 'text';
        setFillAndStroke(res, res.attrs);
        return res;
    };
    (0, _raphaelCoreJs.R)._engine.setSize = function(width, height) {
        this.width = width || this.width;
        this.height = height || this.height;
        this.canvas.setAttribute('width', this.width);
        this.canvas.setAttribute('height', this.height);
        if (this._viewBox) this.setViewBox.apply(this, this._viewBox);
        return this;
    };
    (0, _raphaelCoreJs.R)._engine.create = function() {
        const con = (0, _raphaelCoreJs.R)._getContainer.apply(0, arguments);
        let container = con && con.container;
        let { x, y, width, height } = con;
        if (!container) throw new Error('SVG container not found.');
        const cnvs = $('svg');
        const css = 'overflow:hidden;';
        let isFloating;
        x = x || 0;
        y = y || 0;
        width = width || 512;
        height = height || 342;
        $(cnvs, {
            height,
            width,
            xmlns: 'http://www.w3.org/2000/svg'
        });
        if (container == 1) {
            cnvs.style.cssText = `${css}position:absolute;left:${x}px;top:${y}px`;
            (0, _raphaelCoreJs.R)._g.doc.body.appendChild(cnvs);
            isFloating = 1;
        } else {
            cnvs.style.cssText = `${css}position:relative`;
            if (container.firstChild) container.insertBefore(cnvs, container.firstChild);
            else container.appendChild(cnvs);
        }
        container = new (0, _raphaelCoreJs.R)._Paper();
        container.width = width;
        container.height = height;
        container.canvas = cnvs;
        container.clear();
        container._left = container._top = 0;
        isFloating && (container.renderfix = function() {});
        container.renderfix();
        return container;
    };
    (0, _raphaelCoreJs.R)._engine.setViewBox = function(x, y, w, h, fit) {
        (0, _eveJs.eve)('raphael.setViewBox', this, this._viewBox, [
            x,
            y,
            w,
            h,
            fit
        ]);
        const paperSize = this.getSize();
        let size = mmax(w / paperSize.width, h / paperSize.height);
        let { top } = this;
        const aspectRatio = fit ? 'xMidYMid meet' : 'xMinYMin';
        let vb;
        let sw;
        if (x == null) {
            if (this._vbSize) size = 1;
            delete this._vbSize;
            vb = `0 0 ${this.width}${S}${this.height}`;
        } else {
            this._vbSize = size;
            vb = x + S + y + S + w + S + h;
        }
        $(this.canvas, {
            viewBox: vb,
            preserveAspectRatio: aspectRatio
        });
        while(size && top){
            sw = 'stroke-width' in top.attrs ? top.attrs['stroke-width'] : 1;
            top.attr({
                'stroke-width': sw
            });
            top._.dirty = 1;
            top._.dirtyT = 1;
            top = top.prev;
        }
        this._viewBox = [
            x,
            y,
            w,
            h,
            !!fit
        ];
        return this;
    };
    /* \
   * Paper.renderfix
   [ method ]
   **
   * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependent
   * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
   * This method fixes the issue.
   **
     Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
  \ */ (0, _raphaelCoreJs.R).prototype.renderfix = function() {
        const cnvs = this.canvas;
        const s = cnvs.style;
        let pos;
        try {
            pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
        } catch (e) {
            pos = cnvs.createSVGMatrix();
        }
        const left = -pos.e % 1;
        const top = -pos.f % 1;
        if (left || top) {
            if (left) {
                this._left = (this._left + left) % 1;
                s.left = `${this._left}px`;
            }
            if (top) {
                this._top = (this._top + top) % 1;
                s.top = `${this._top}px`;
            }
        }
    };
    /* \
   * Paper.clear
   [ method ]
   **
   * Clears the paper, i.e. removes all the elements.
  \ */ (0, _raphaelCoreJs.R).prototype.clear = function() {
        (0, _raphaelCoreJs.R).eve('raphael.clear', this);
        const c = this.canvas;
        while(c.firstChild)c.removeChild(c.firstChild);
        this.bottom = this.top = null;
        c.appendChild(this.defs = $('defs'));
    };
    /* \
   * Paper.remove
   [ method ]
   **
   * Removes the paper from the DOM.
  \ */ (0, _raphaelCoreJs.R).prototype.remove = function() {
        (0, _eveJs.eve)('raphael.remove', this);
        this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
        for(const i in this)this[i] = typeof this[i] === 'function' ? (0, _raphaelCoreJs.R)._removedFactory(i) : null;
    };
    const setproto = (0, _raphaelCoreJs.R).st;
    for(const method in elproto)if (elproto[has](method) && !setproto[has](method)) setproto[method] = function(methodname) {
        return function() {
            const arg = arguments;
            return this.forEach((el)=>{
                el[methodname].apply(el, arg);
            });
        };
    }(method);
    return 0, _raphaelCoreJs.R;
}();

},{"../eve.js":"9FQ0M","./raphael.core.js":"5SUq7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9FQ0M":[function(require,module,exports,__globalThis) {
// Copyright (c) 2017 Adobe Systems Incorporated. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//  \\
//  Eve 0.5.4 - JavaScript Events Library                       \\
//  \\
//  Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/)  \\
//  \\
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eve", ()=>eve);
const eve = function() {
    var version = "0.5.4", has = "hasOwnProperty", separator = /[\.\/]/, comaseparator = /\s*,\s*/, wildcard = "*", numsort = function(a, b) {
        return a - b;
    }, current_event, stop, events = {
        n: {}
    }, firstDefined = function() {
        for(var i = 0, ii = this.length; i < ii; i++){
            if (typeof this[i] != "undefined") return this[i];
        }
    }, lastDefined = function() {
        var i = this.length;
        while(--i){
            if (typeof this[i] != "undefined") return this[i];
        }
    }, objtos = Object.prototype.toString, Str = String, isArray = Array.isArray || function(ar) {
        return ar instanceof Array || objtos.call(ar) == "[object Array]";
    }, /*\
   * eve
   [ method ]

   * Fires event with given `name`, given scope and other parameters.

   - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
   - scope (object) context for the event handlers
   - varargs (...) the rest of arguments will be sent to event handlers

   = (object) array of returned values from the listeners. Array has two methods `.firstDefined()` and `.lastDefined()` to get first or last not `undefined` value.
  \*/ eve = function(name, scope) {
        var oldstop = stop, args = Array.prototype.slice.call(arguments, 2), listeners = eve.listeners(name), z = 0, l, indexed = [], queue = {}, out = [], ce = current_event;
        out.firstDefined = firstDefined;
        out.lastDefined = lastDefined;
        current_event = name;
        stop = 0;
        for(var i = 0, ii = listeners.length; i < ii; i++)if ("zIndex" in listeners[i]) {
            indexed.push(listeners[i].zIndex);
            if (listeners[i].zIndex < 0) queue[listeners[i].zIndex] = listeners[i];
        }
        indexed.sort(numsort);
        while(indexed[z] < 0){
            l = queue[indexed[z++]];
            out.push(l.apply(scope, args));
            if (stop) {
                stop = oldstop;
                return out;
            }
        }
        for(i = 0; i < ii; i++){
            l = listeners[i];
            if ("zIndex" in l) {
                if (l.zIndex == indexed[z]) {
                    out.push(l.apply(scope, args));
                    if (stop) break;
                    do {
                        z++;
                        l = queue[indexed[z]];
                        l && out.push(l.apply(scope, args));
                        if (stop) break;
                    }while (l);
                } else queue[l.zIndex] = l;
            } else {
                out.push(l.apply(scope, args));
                if (stop) break;
            }
        }
        stop = oldstop;
        current_event = ce;
        return out;
    };
    // Undocumented. Debug only.
    eve._events = events;
    /*\
   * eve.listeners
   [ method ]

   * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

   - name (string) name of the event, dot (`.`) or slash (`/`) separated

   = (array) array of event handlers
  \*/ eve.listeners = function(name) {
        var names = isArray(name) ? name : name.split(separator), e = events, item, items, k, i, ii, j, jj, nes, es = [
            e
        ], out = [];
        for(i = 0, ii = names.length; i < ii; i++){
            nes = [];
            for(j = 0, jj = es.length; j < jj; j++){
                e = es[j].n;
                items = [
                    e[names[i]],
                    e[wildcard]
                ];
                k = 2;
                while(k--){
                    item = items[k];
                    if (item) {
                        nes.push(item);
                        out = out.concat(item.f || []);
                    }
                }
            }
            es = nes;
        }
        return out;
    };
    /*\
   * eve.separator
   [ method ]

   * If for some reasons you dont like default separators (`.` or `/`) you can specify yours
   * here. Be aware that if you pass a string longer than one character it will be treated as
   * a list of characters.

   - separator (string) new separator. Empty string resets to default: `.` or `/`.
  \*/ eve.separator = function(sep) {
        if (sep) {
            sep = Str(sep).replace(/(?=[\.\^\]\[\-])/g, "\\");
            sep = "[" + sep + "]";
            separator = new RegExp(sep);
        } else separator = /[\.\/]/;
    };
    /*\
   * eve.on
   [ method ]
   **
   * Binds given event handler with a given name. You can use wildcards `*` for the names:
   | eve.on("*.under.*", f);
   | eve("mouse.under.floor"); // triggers f
   * Use @eve to trigger the listener.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
   **
   - name (array) if you dont want to use separators, you can use array of strings
   - f (function) event handler function
   **
   = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment.
   > Example:
   | eve.on("mouse", eatIt)(2);
   | eve.on("mouse", scream);
   | eve.on("mouse", catchIt)(1);
   * This will ensure that `catchIt` function will be called before `eatIt`.
   *
   * If you want to put your handler before non-indexed handlers, specify a negative value.
   * Note: I assume most of the time you dont need to worry about z-index, but its nice to have this feature just in case.
  \*/ eve.on = function(name, f) {
        if (typeof f != "function") return function() {};
        var names = isArray(name) ? isArray(name[0]) ? name : [
            name
        ] : Str(name).split(comaseparator);
        for(var i = 0, ii = names.length; i < ii; i++)(function(name) {
            var names = isArray(name) ? name : Str(name).split(separator), e = events, exist;
            for(var i = 0, ii = names.length; i < ii; i++){
                e = e.n;
                e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {
                    n: {}
                });
            }
            e.f = e.f || [];
            for(i = 0, ii = e.f.length; i < ii; i++)if (e.f[i] == f) {
                exist = true;
                break;
            }
            !exist && e.f.push(f);
        })(names[i]);
        return function(zIndex) {
            if (+zIndex == +zIndex) f.zIndex = +zIndex;
        };
    };
    /*\
   * eve.f
   [ method ]
   **
   * Returns function that will fire given event with optional arguments.
   * Arguments that will be passed to the result function will be also
   * concated to the list of final arguments.
   | el.onclick = eve.f("click", 1, 2);
   | eve.on("click", function (a, b, c) {
   |     console.log(a, b, c); // 1, 2, [event object]
   | });
   - event (string) event name
   - varargs () and any other arguments
   = (function) possible event handler function
  \*/ eve.f = function(event) {
        var attrs = [].slice.call(arguments, 1);
        return function() {
            eve.apply(null, [
                event,
                null
            ].concat(attrs).concat([].slice.call(arguments, 0)));
        };
    };
    /*\
   * eve.stop
   [ method ]
   **
   * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
  \*/ eve.stop = function() {
        stop = 1;
    };
    /*\
   * eve.nt
   [ method ]
   **
   * Could be used inside event handler to figure out actual name of the event.
   **
   - subname (string) #optional subname of the event
   **
   = (string) name of the event, if `subname` is not specified
   * or
   = (boolean) `true`, if current events name contains `subname`
  \*/ eve.nt = function(subname) {
        var cur = isArray(current_event) ? current_event.join(".") : current_event;
        if (subname) return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(cur);
        return cur;
    };
    /*\
   * eve.nts
   [ method ]
   **
   * Could be used inside event handler to figure out actual name of the event.
   **
   **
   = (array) names of the event
  \*/ eve.nts = function() {
        return isArray(current_event) ? current_event : current_event.split(separator);
    };
    /*\
   * eve.off
   [ method ]
   **
   * Removes given function from the list of event listeners assigned to given name.
   * If no arguments specified all the events will be cleared.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
  \*/ /*\
   * eve.unbind
   [ method ]
   **
   * See @eve.off
  \*/ eve.off = eve.unbind = function(name, f) {
        if (!name) {
            eve._events = events = {
                n: {}
            };
            return;
        }
        var names = isArray(name) ? isArray(name[0]) ? name : [
            name
        ] : Str(name).split(comaseparator);
        if (names.length > 1) {
            for(var i = 0, ii = names.length; i < ii; i++)eve.off(names[i], f);
            return;
        }
        names = isArray(name) ? name : Str(name).split(separator);
        var e, key, splice, i, ii, j, jj, cur = [
            events
        ], inodes = [];
        for(i = 0, ii = names.length; i < ii; i++)for(j = 0; j < cur.length; j += splice.length - 2){
            splice = [
                j,
                1
            ];
            e = cur[j].n;
            if (names[i] != wildcard) {
                if (e[names[i]]) {
                    splice.push(e[names[i]]);
                    inodes.unshift({
                        n: e,
                        name: names[i]
                    });
                }
            } else {
                for(key in e)if (e[has](key)) {
                    splice.push(e[key]);
                    inodes.unshift({
                        n: e,
                        name: key
                    });
                }
            }
            cur.splice.apply(cur, splice);
        }
        for(i = 0, ii = cur.length; i < ii; i++){
            e = cur[i];
            while(e.n){
                if (f) {
                    if (e.f) {
                        for(j = 0, jj = e.f.length; j < jj; j++)if (e.f[j] == f) {
                            e.f.splice(j, 1);
                            break;
                        }
                        !e.f.length && delete e.f;
                    }
                    for(key in e.n)if (e.n[has](key) && e.n[key].f) {
                        var funcs = e.n[key].f;
                        for(j = 0, jj = funcs.length; j < jj; j++)if (funcs[j] == f) {
                            funcs.splice(j, 1);
                            break;
                        }
                        !funcs.length && delete e.n[key].f;
                    }
                } else {
                    delete e.f;
                    for(key in e.n)if (e.n[has](key) && e.n[key].f) delete e.n[key].f;
                }
                e = e.n;
            }
        }
        // prune inner nodes in path
        prune: for(i = 0, ii = inodes.length; i < ii; i++){
            e = inodes[i];
            for(key in e.n[e.name].f)continue prune;
            for(key in e.n[e.name].n)continue prune;
            // is empty
            delete e.n[e.name];
        }
    };
    /*\
   * eve.once
   [ method ]
   **
   * Binds given event handler with a given name to only run once then unbind itself.
   | eve.once("login", f);
   | eve("login"); // triggers f
   | eve("login"); // no listeners
   * Use @eve to trigger the listener.
   **
   - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
   - f (function) event handler function
   **
   = (function) same return function as @eve.on
  \*/ eve.once = function(name, f) {
        var f2 = function() {
            eve.off(name, f2);
            return f.apply(this, arguments);
        };
        return eve.on(name, f2);
    };
    /*\
   * eve.version
   [ property (string) ]
   **
   * Current version of the library.
  \*/ eve.version = version;
    eve.toString = function() {
        return "You are running Eve " + version;
    };
    return eve;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports,__globalThis) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, '__esModule', {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === 'default' || key === '__esModule' || Object.prototype.hasOwnProperty.call(dest, key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"5SUq7":[function(require,module,exports,__globalThis) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "R", ()=>R);
var _eveJs = require("../eve.js");
const R = function() {
    /* \
   * Raphael
   [ method ]
   **
   * Creates a canvas object on which to draw.
   * You must do this first, as all future calls to drawing methods
   * from this instance will be bound to this canvas.
   > Parameters
   **
   - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
   - width (number)
   - height (number)
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - x (number)
   - y (number)
   - width (number)
   - height (number)
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
   - callback (function) #optional callback function which is going to be executed in the context of newly created paper
   * or
   - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eves DOMLoad event. In this case method returns `undefined`.
   = (object) @Paper
   > Usage
   | // Each of the following examples create a canvas
   | // that is 320px wide by 200px high.
   | // Canvas is created at the viewports 10,50 coordinate.
   | var paper = Raphael(10, 50, 320, 200);
   | // Canvas is created at the top left corner of the #notepad element
   | // (or its top right corner in dir="rtl" elements)
   | var paper = Raphael(document.getElementById("notepad"), 320, 200);
   | // Same as above
   | var paper = Raphael("notepad", 320, 200);
   | // Image dump
   | var set = Raphael(["notepad", 320, 200, {
   |     type: "rect",
   |     x: 10,
   |     y: 10,
   |     width: 25,
   |     height: 25,
   |     stroke: "#f00"
   | }, {
   |     type: "text",
   |     x: 30,
   |     y: 40,
   |     text: "Dump"
   | }]);
  \ */ function R(first) {
        if (R.is(first, 'function')) return loaded ? first() : (0, _eveJs.eve).on('raphael.DOMload', first);
        if (R.is(first, array)) return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
        const args = Array.prototype.slice.call(arguments, 0);
        if (R.is(args[args.length - 1], 'function')) {
            const f = args.pop();
            return loaded ? f.call(R._engine.create[apply](R, args)) : (0, _eveJs.eve).on('raphael.DOMload', ()=>{
                f.call(R._engine.create[apply](R, args));
            });
        }
        return R._engine.create[apply](R, arguments);
    }
    R.version = '2.2.0';
    R.eve = (0, _eveJs.eve);
    let loaded;
    const separator = /[, ]+/;
    const elements = {
        circle: 1,
        rect: 1,
        path: 1,
        ellipse: 1,
        text: 1,
        image: 1
    };
    const formatrg = /\{(\d+)\}/g;
    const proto = 'prototype';
    const has = 'hasOwnProperty';
    const g = {
        doc: document,
        win: window
    };
    const oldRaphael = {
        was: Object.prototype[has].call(g.win, 'Raphael'),
        is: g.win.Raphael
    };
    const Paper = function() {
        /* \
       * Paper.ca
       [ property (object) ]
       **
       * Shortcut for @Paper.customAttributes
      \ */ /* \
       * Paper.customAttributes
       [ property (object) ]
       **
       * If you have a set of attributes that you would like to represent
       * as a function of some number you can do it easily with custom attributes:
       > Usage
       | paper.customAttributes.hue = function (num) {
       |     num = num % 1;
       |     return {fill: "hsb(" + num + ", 0.75, 1)"};
       | };
       | // Custom attribute hue will change fill
       | // to be given hue with fixed saturation and brightness.
       | // Now you can use it like this:
       | var c = paper.circle(10, 10, 10).attr({hue: .45});
       | // or even like this:
       | c.animate({hue: 1}, 1e3);
       |
       | // You could also create custom attribute
       | // with multiple parameters:
       | paper.customAttributes.hsb = function (h, s, b) {
       |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
       | };
       | c.attr({hsb: "0.5 .8 1"});
       | c.animate({hsb: [1, 0, 0.5]}, 1e3);
      \ */ this.ca = this.customAttributes = {};
    };
    let paperproto;
    const appendChild = 'appendChild';
    var apply = 'apply';
    const concat = 'concat';
    const supportsTouch = 'ontouchstart' in g.win || g.win.DocumentTouch && g.doc instanceof DocumentTouch // taken from Modernizr touch test
    ;
    const E = '';
    const S = ' ';
    const Str = String;
    const split = 'split';
    const events = 'click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel'[split](S);
    const touchMap = {
        mousedown: 'touchstart',
        mousemove: 'touchmove',
        mouseup: 'touchend'
    };
    const lowerCase = Str.prototype.toLowerCase;
    const math = Math;
    const mmax = math.max;
    const mmin = math.min;
    const { abs } = math;
    const { pow } = math;
    const { PI } = math;
    var nu = 'number';
    const string = 'string';
    var array = 'array';
    const toString = 'toString';
    const fillString = 'fill';
    const objectToString = Object.prototype.toString;
    const paper = {};
    const push = 'push';
    const ISURL = R._ISURL = /^url\(['"]?(.+?)['"]?\)$/i;
    const colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;
    const isnan = {
        NaN: 1,
        Infinity: 1,
        '-Infinity': 1
    };
    const bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/;
    const { round } = math;
    const setAttribute = 'setAttribute';
    const toFloat = parseFloat;
    const toInt = parseInt;
    const upperCase = Str.prototype.toUpperCase;
    const availableAttrs = R._availableAttrs = {
        'arrow-end': 'none',
        'arrow-start': 'none',
        blur: 0,
        'clip-rect': '0 0 1e9 1e9',
        cursor: 'default',
        cx: 0,
        cy: 0,
        fill: '#fff',
        'fill-opacity': 1,
        font: '10px "Arial"',
        'font-family': '"Arial"',
        'font-size': '10',
        'font-style': 'normal',
        'font-weight': 400,
        gradient: 0,
        height: 0,
        href: 'http://raphaeljs.com/',
        'letter-spacing': 0,
        opacity: 1,
        path: 'M0,0',
        r: 0,
        rx: 0,
        ry: 0,
        src: '',
        stroke: '#000',
        'stroke-dasharray': '',
        'stroke-linecap': 'butt',
        'stroke-linejoin': 'butt',
        'stroke-miterlimit': 0,
        'stroke-opacity': 1,
        'stroke-width': 1,
        target: '_blank',
        'text-anchor': 'middle',
        title: 'Raphael',
        transform: '',
        width: 0,
        x: 0,
        y: 0,
        class: '',
        filter: ''
    };
    const availableAnimAttrs = R._availableAnimAttrs = {
        blur: nu,
        'clip-rect': 'csv',
        cx: nu,
        cy: nu,
        fill: 'colour',
        'fill-opacity': nu,
        'font-size': nu,
        height: nu,
        opacity: nu,
        path: 'path',
        r: nu,
        rx: nu,
        ry: nu,
        stroke: 'colour',
        'stroke-opacity': nu,
        'stroke-width': nu,
        transform: 'transform',
        width: nu,
        x: nu,
        y: nu
    };
    const whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g;
    const commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/;
    const hsrg = {
        hs: 1,
        rg: 1
    };
    const p2s = /,?([achlmqrstvxz]),?/gi;
    const pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi;
    const tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/gi;
    const pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/gi;
    const radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/;
    const eldata = {};
    const sortByKey = function(a, b) {
        return a.key - b.key;
    };
    const sortByNumber = function(a, b) {
        return toFloat(a) - toFloat(b);
    };
    const fun = function() {};
    const pipe = function(x) {
        return x;
    };
    const rectPath = R._rectPath = function(x, y, w, h, r) {
        if (r) return [
            [
                'M',
                x + r,
                y
            ],
            [
                'l',
                w - r * 2,
                0
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                r,
                r
            ],
            [
                'l',
                0,
                h - r * 2
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                -r,
                r
            ],
            [
                'l',
                r * 2 - w,
                0
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                -r,
                -r
            ],
            [
                'l',
                0,
                r * 2 - h
            ],
            [
                'a',
                r,
                r,
                0,
                0,
                1,
                r,
                -r
            ],
            [
                'z'
            ]
        ];
        return [
            [
                'M',
                x,
                y
            ],
            [
                'l',
                w,
                0
            ],
            [
                'l',
                0,
                h
            ],
            [
                'l',
                -w,
                0
            ],
            [
                'z'
            ]
        ];
    };
    const ellipsePath = function(x, y, rx, ry) {
        if (ry == null) ry = rx;
        return [
            [
                'M',
                x,
                y
            ],
            [
                'm',
                0,
                -ry
            ],
            [
                'a',
                rx,
                ry,
                0,
                1,
                1,
                0,
                2 * ry
            ],
            [
                'a',
                rx,
                ry,
                0,
                1,
                1,
                0,
                -2 * ry
            ],
            [
                'z'
            ]
        ];
    };
    const getPath = R._getPath = {
        path (el) {
            return el.attr('path');
        },
        circle (el) {
            const a = el.attrs;
            return ellipsePath(a.cx, a.cy, a.r);
        },
        ellipse (el) {
            const a = el.attrs;
            return ellipsePath(a.cx, a.cy, a.rx, a.ry);
        },
        rect (el) {
            const a = el.attrs;
            return rectPath(a.x, a.y, a.width, a.height, a.r);
        },
        image (el) {
            const a = el.attrs;
            return rectPath(a.x, a.y, a.width, a.height);
        },
        text (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        set (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        },
        g (el) {
            const bbox = el._getBBox();
            return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
        }
    };
    /* \
     * Raphael.mapPath
     [ method ]
     **
     * Transform the path string with given matrix.
     > Parameters
     - path (string) path string
     - matrix (object) see @Matrix
     = (string) transformed path string
    \ */ const mapPath = R.mapPath = function(path, matrix) {
        if (!matrix) return path;
        let x;
        let y;
        let i;
        let j;
        let ii;
        let jj;
        let pathi;
        path = path2curve(path);
        for(i = 0, ii = path.length; i < ii; i++){
            pathi = path[i];
            for(j = 1, jj = pathi.length; j < jj; j += 2){
                x = matrix.x(pathi[j], pathi[j + 1]);
                y = matrix.y(pathi[j], pathi[j + 1]);
                pathi[j] = x;
                pathi[j + 1] = y;
            }
        }
        return path;
    };
    R._g = g;
    R.type = 'SVG';
    R.svg = true;
    R._Paper = Paper;
    /* \
   * Raphael.fn
   [ property (object) ]
   **
   * You can add your own method to the canvas. For example if you want to draw a pie chart,
   * you can create your own pie chart function and ship it as a Raphal plugin. To do this
   * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
   * Raphal instance is created, otherwise it will take no effect. Please note that the
   * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
   * ensure any namespacing ensures proper context.
   > Usage
   | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
   |     return this.path( ... );
   | };
   | // or create namespace
   | Raphael.fn.mystuff = {
   |     arrow: function () {},
   |     star: function () {},
   |     // etc
   | };
   | var paper = Raphael(10, 10, 630, 480);
   | // then use it
   | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
   | paper.mystuff.arrow();
   | paper.mystuff.star();
  \ */ R.fn = paperproto = Paper.prototype = R.prototype;
    R._id = 0;
    /* \
   * Raphael.is
   [ method ]
   **
   * Handful of replacements for `typeof` operator.
   > Parameters
   - o () any object or primitive
   - type (string) name of the type, i.e. string, function, number, etc.
   = (boolean) is given value is of given type
  \ */ R.is = function(o, type) {
        type = lowerCase.call(type);
        if (type == 'finite') return !isnan[has](+o);
        if (type == 'array') return o instanceof Array;
        return type == 'null' && o === null || type === typeof o && o !== null || type == 'object' && o === Object(o) || type == 'array' && Array.isArray && Array.isArray(o) || objectToString.call(o).slice(8, -1).toLowerCase() == type;
    };
    function clone(obj) {
        if (typeof obj === 'function' || Object(obj) !== obj) return obj;
        const res = new obj.constructor();
        for(const key in obj)if (obj[has](key)) res[key] = clone(obj[key]);
        return res;
    }
    /* \
   * Raphael.angle
   [ method ]
   **
   * Returns angle between two or three points
   > Parameters
   - x1 (number) x coord of first point
   - y1 (number) y coord of first point
   - x2 (number) x coord of second point
   - y2 (number) y coord of second point
   - x3 (number) #optional x coord of third point
   - y3 (number) #optional y coord of third point
   = (number) angle in degrees.
  \ */ R.angle = function(x1, y1, x2, y2, x3, y3) {
        if (x3 == null) {
            const x = x1 - x2;
            const y = y1 - y2;
            if (!x && !y) return 0;
            return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
        }
        return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
    };
    /* \
   * Raphael.rad
   [ method ]
   **
   * Transform angle to radians
   > Parameters
   - deg (number) angle in degrees
   = (number) angle in radians.
  \ */ R.rad = function(deg) {
        return deg % 360 * PI / 180;
    };
    /* \
   * Raphael.deg
   [ method ]
   **
   * Transform angle to degrees
   > Parameters
   - rad (number) angle in radians
   = (number) angle in degrees.
  \ */ R.deg = function(rad) {
        return Math.round(rad * 180 / PI % 360 * 1000) / 1000;
    };
    /* \
   * Raphael.snapTo
   [ method ]
   **
   * Snaps given value to given grid.
   > Parameters
   - values (array|number) given array of values or step of the grid
   - value (number) value to adjust
   - tolerance (number) #optional tolerance for snapping. Default is `10`.
   = (number) adjusted value.
  \ */ R.snapTo = function(values, value, tolerance) {
        tolerance = R.is(tolerance, 'finite') ? tolerance : 10;
        if (R.is(values, array)) {
            let i = values.length;
            while(i--)if (abs(values[i] - value) <= tolerance) return values[i];
        } else {
            values = +values;
            const rem = value % values;
            if (rem < tolerance) return value - rem;
            if (rem > values - tolerance) return value - rem + values;
        }
        return value;
    };
    /* \
   * Raphael.createUUID
   [ method ]
   **
   * Returns RFC4122, version 4 ID
  \ */ const createUUID = R.createUUID = function(uuidRegEx, uuidReplacer) {
        return function() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(uuidRegEx, uuidReplacer).toUpperCase();
        };
    }(/[xy]/g, (c)=>{
        const r = math.random() * 16 | 0;
        const v = c == 'x' ? r : r & 3 | 8;
        return v.toString(16);
    });
    /* \
   * Raphael.setWindow
   [ method ]
   **
   * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
   > Parameters
   - newwin (window) new window object
  \ */ R.setWindow = function(newwin) {
        (0, _eveJs.eve)('raphael.setWindow', R, g.win, newwin);
        g.win = newwin;
        g.doc = g.win.document;
        if (R._engine.initWin) R._engine.initWin(g.win);
    };
    var toHex = function(color) {
        const i = g.doc.createElement('i');
        i.title = 'Rapha\xebl Colour Picker';
        i.style.display = 'none';
        g.doc.body.appendChild(i);
        toHex = cacher('toHex', (color)=>{
            i.style.color = color;
            return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue('color');
        });
        return toHex(color);
    };
    const hsbtoString = function() {
        return `hsb(${[
            this.h,
            this.s,
            this.b
        ]})`;
    };
    const hsltoString = function() {
        return `hsl(${[
            this.h,
            this.s,
            this.l
        ]})`;
    };
    const rgbtoString = function() {
        return this.hex;
    };
    const prepareRGB = function(r, g, b) {
        if (g == null && R.is(r, 'object') && 'r' in r && 'g' in r && 'b' in r) {
            b = r.b;
            g = r.g;
            r = r.r;
        }
        if (g == null && R.is(r, string)) {
            const clr = R.getRGB(r);
            r = clr.r;
            g = clr.g;
            b = clr.b;
        }
        if (r > 1 || g > 1 || b > 1) {
            r /= 255;
            g /= 255;
            b /= 255;
        }
        return [
            r,
            g,
            b
        ];
    };
    const packageRGB = function(r, g, b, o) {
        r *= 255;
        g *= 255;
        b *= 255;
        const rgb = {
            r,
            g,
            b,
            hex: R.rgb(r, g, b),
            toString: rgbtoString
        };
        R.is(o, 'finite') && (rgb.opacity = o);
        return rgb;
    };
    /* \
   * Raphael.color
   [ method ]
   **
   * Parses the color string and returns object with all values for the given color.
   > Parameters
   - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
   = (object) Combined RGB & HSB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #,
   o     error (boolean) `true` if string cant be parsed,
   o     h (number) hue,
   o     s (number) saturation,
   o     v (number) value (brightness),
   o     l (number) lightness
   o }
  \ */ R.color = function(clr) {
        let rgb;
        if (R.is(clr, 'object') && 'h' in clr && 's' in clr && 'b' in clr) {
            rgb = R.hsb2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else if (R.is(clr, 'object') && 'h' in clr && 's' in clr && 'l' in clr) {
            rgb = R.hsl2rgb(clr);
            clr.r = rgb.r;
            clr.g = rgb.g;
            clr.b = rgb.b;
            clr.hex = rgb.hex;
        } else {
            if (R.is(clr, 'string')) clr = R.getRGB(clr);
            if (R.is(clr, 'object') && 'r' in clr && 'g' in clr && 'b' in clr) {
                rgb = R.rgb2hsl(clr);
                clr.h = rgb.h;
                clr.s = rgb.s;
                clr.l = rgb.l;
                rgb = R.rgb2hsb(clr);
                clr.v = rgb.b;
            } else {
                clr = {
                    hex: 'none'
                };
                clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
            }
        }
        clr.toString = rgbtoString;
        return clr;
    };
    /* \
   * Raphael.hsb2rgb
   [ method ]
   **
   * Converts HSB values to RGB object.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - v (number) value or brightness
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #
   o }
  \ */ R.hsb2rgb = function(h, s, v, o) {
        if (this.is(h, 'object') && 'h' in h && 's' in h && 'b' in h) {
            v = h.b;
            s = h.s;
            o = h.o;
            h = h.h;
        }
        h *= 360;
        let R;
        let G;
        let B;
        let X;
        let C;
        h = h % 360 / 60;
        C = v * s;
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = v - C;
        h = ~~h;
        R += [
            C,
            X,
            0,
            0,
            X,
            C
        ][h];
        G += [
            X,
            C,
            C,
            X,
            0,
            0
        ][h];
        B += [
            0,
            0,
            X,
            C,
            C,
            X
        ][h];
        return packageRGB(R, G, B, o);
    };
    /* \
   * Raphael.hsl2rgb
   [ method ]
   **
   * Converts HSL values to RGB object.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - l (number) luminosity
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue,
   o     hex (string) color in HTML/CSS format: #
   o }
  \ */ R.hsl2rgb = function(h, s, l, o) {
        if (this.is(h, 'object') && 'h' in h && 's' in h && 'l' in h) {
            l = h.l;
            s = h.s;
            h = h.h;
        }
        if (h > 1 || s > 1 || l > 1) {
            h /= 360;
            s /= 100;
            l /= 100;
        }
        h *= 360;
        let R;
        let G;
        let B;
        let X;
        let C;
        h = h % 360 / 60;
        C = 2 * s * (l < 0.5 ? l : 1 - l);
        X = C * (1 - abs(h % 2 - 1));
        R = G = B = l - C / 2;
        h = ~~h;
        R += [
            C,
            X,
            0,
            0,
            X,
            C
        ][h];
        G += [
            X,
            C,
            C,
            X,
            0,
            0
        ][h];
        B += [
            0,
            0,
            X,
            C,
            C,
            X
        ][h];
        return packageRGB(R, G, B, o);
    };
    /* \
   * Raphael.rgb2hsb
   [ method ]
   **
   * Converts RGB values to HSB object.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (object) HSB object in format:
   o {
   o     h (number) hue
   o     s (number) saturation
   o     b (number) brightness
   o }
  \ */ R.rgb2hsb = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];
        let H;
        let S;
        let V;
        let C;
        V = mmax(r, g, b);
        C = V - mmin(r, g, b);
        H = C == 0 ? null : V == r ? (g - b) / C : V == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        S = C == 0 ? 0 : C / V;
        return {
            h: H,
            s: S,
            b: V,
            toString: hsbtoString
        };
    };
    /* \
   * Raphael.rgb2hsl
   [ method ]
   **
   * Converts RGB values to HSL object.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (object) HSL object in format:
   o {
   o     h (number) hue
   o     s (number) saturation
   o     l (number) luminosity
   o }
  \ */ R.rgb2hsl = function(r, g, b) {
        b = prepareRGB(r, g, b);
        r = b[0];
        g = b[1];
        b = b[2];
        let H;
        let S;
        let L;
        let M;
        let m;
        let C;
        M = mmax(r, g, b);
        m = mmin(r, g, b);
        C = M - m;
        H = C == 0 ? null : M == r ? (g - b) / C : M == g ? (b - r) / C + 2 : (r - g) / C + 4;
        H = (H + 360) % 6 * 60 / 360;
        L = (M + m) / 2;
        S = C == 0 ? 0 : L < 0.5 ? C / (2 * L) : C / (2 - 2 * L);
        return {
            h: H,
            s: S,
            l: L,
            toString: hsltoString
        };
    };
    R._path2string = function() {
        // 2 decimal precision always...
        return this.map((t)=>[
                t[0],
                ...t.slice(1).map((t)=>Math.round(t * 1e2) / 1e2)
            ]).join(',').replace(p2s, '$1');
    };
    function repush(array, item) {
        for(let i = 0, ii = array.length; i < ii; i++)if (array[i] === item) return array.push(array.splice(i, 1)[0]);
    }
    const CACHE = R.CACHE = {};
    function cacher(name, f, scope, postprocessor) {
        function newf() {
            const arg = Array.prototype.slice.call(arguments, 0);
            const args = arg.join('\u2400');
            if (cache[has](args)) {
                repush(count, args);
                return postprocessor ? postprocessor(cache[args]) : cache[args];
            }
            count.length >= 1e3 && delete cache[count.shift()];
            count.push(args);
            const cached = cache[args] = f[apply](scope, arg);
            return postprocessor ? postprocessor(cached) : cached;
        }
        var cache = newf.cache = {};
        var count = newf.count = [];
        newf.clear = function() {
            cache = newf.cache = {};
            count = newf.count = [];
        };
        CACHE[name] = newf;
        return newf;
    }
    R.clearCaches = function() {
        for(const key in CACHE){
            if (!CACHE.hasOwnProperty(key)) continue;
            CACHE[key].clear();
        }
    };
    const preload = R._preload = function(src, f) {
        const img = g.doc.createElement('img');
        img.style.cssText = 'position:absolute;left:-9999em;top:-9999em';
        img.onload = function() {
            f.call(this);
            this.onload = null;
            g.doc.body.removeChild(this);
        };
        img.onerror = function() {
            g.doc.body.removeChild(this);
        };
        g.doc.body.appendChild(img);
        img.src = src;
    };
    function clrToString() {
        return this.hex;
    }
    /* \
   * Raphael.getRGB
   [ method ]
   **
   * Parses colour string as RGB object
   > Parameters
   - colour (string) colour string in one of formats:
   # <ul>
   #     <li>Colour name (<code>red</code>, <code>green</code>, <code>cornflowerblue</code>, etc)</li>
   #     <li>#  shortened HTML colour: (<code>#000</code>, <code>#fc0</code>, etc)</li>
   #     <li>#  full length HTML colour: (<code>#000000</code>, <code>#bd2300</code>)</li>
   #     <li>rgb(, , )  red, green and blue channels values: (<code>rgb(200,&nbsp;100,&nbsp;0)</code>)</li>
   #     <li>rgb(%, %, %)  same as above, but in %: (<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>)</li>
   #     <li>hsb(, , )  hue, saturation and brightness values: (<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>)</li>
   #     <li>hsb(%, %, %)  same as above, but in %</li>
   #     <li>hsl(, , )  same as hsb</li>
   #     <li>hsl(%, %, %)  same as hsb</li>
   # </ul>
   = (object) RGB object in format:
   o {
   o     r (number) red,
   o     g (number) green,
   o     b (number) blue
   o     hex (string) color in HTML/CSS format: #,
   o     error (boolean) true if string cant be parsed
   o }
  \ */ R.getRGB = cacher('getRGB', (colour)=>{
        if (!colour || !!((colour = Str(colour)).indexOf('-') + 1)) return {
            r: -1,
            g: -1,
            b: -1,
            hex: 'none',
            error: 1,
            toString: clrToString
        };
        if (colour == 'none') return {
            r: -1,
            g: -1,
            b: -1,
            hex: 'none',
            toString: clrToString
        };
        !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == '#') && (colour = toHex(colour));
        let res;
        let red;
        let green;
        let blue;
        let opacity;
        let t;
        let values;
        let rgb = colour.match(colourRegExp);
        if (rgb) {
            if (rgb[2]) {
                blue = toInt(rgb[2].substring(5), 16);
                green = toInt(rgb[2].substring(3, 5), 16);
                red = toInt(rgb[2].substring(1, 3), 16);
            }
            if (rgb[3]) {
                blue = toInt((t = rgb[3].charAt(3)) + t, 16);
                green = toInt((t = rgb[3].charAt(2)) + t, 16);
                red = toInt((t = rgb[3].charAt(1)) + t, 16);
            }
            if (rgb[4]) {
                values = rgb[4][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == '%' && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == '%' && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == '%' && (blue *= 2.55);
                rgb[1].toLowerCase().slice(0, 4) == 'rgba' && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
            }
            if (rgb[5]) {
                values = rgb[5][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == '%' && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == '%' && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == '%' && (blue *= 2.55);
                (values[0].slice(-3) == 'deg' || values[0].slice(-1) == '\xb0') && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == 'hsba' && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
                return R.hsb2rgb(red, green, blue, opacity);
            }
            if (rgb[6]) {
                values = rgb[6][split](commaSpaces);
                red = toFloat(values[0]);
                values[0].slice(-1) == '%' && (red *= 2.55);
                green = toFloat(values[1]);
                values[1].slice(-1) == '%' && (green *= 2.55);
                blue = toFloat(values[2]);
                values[2].slice(-1) == '%' && (blue *= 2.55);
                (values[0].slice(-3) == 'deg' || values[0].slice(-1) == '\xb0') && (red /= 360);
                rgb[1].toLowerCase().slice(0, 4) == 'hsla' && (opacity = toFloat(values[3]));
                values[3] && values[3].slice(-1) == '%' && (opacity /= 100);
                return R.hsl2rgb(red, green, blue, opacity);
            }
            rgb = {
                r: red,
                g: green,
                b: blue,
                toString: clrToString
            };
            rgb.hex = `#${(16777216 | blue | green << 8 | red << 16).toString(16).slice(1)}`;
            R.is(opacity, 'finite') && (rgb.opacity = opacity);
            return rgb;
        }
        return {
            r: -1,
            g: -1,
            b: -1,
            hex: 'none',
            error: 1,
            toString: clrToString
        };
    }, R);
    /* \
   * Raphael.hsb
   [ method ]
   **
   * Converts HSB values to hex representation of the colour.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - b (number) value or brightness
   = (string) hex representation of the colour.
  \ */ R.hsb = cacher('hsb', (h, s, b)=>R.hsb2rgb(h, s, b).hex);
    /* \
   * Raphael.hsl
   [ method ]
   **
   * Converts HSL values to hex representation of the colour.
   > Parameters
   - h (number) hue
   - s (number) saturation
   - l (number) luminosity
   = (string) hex representation of the colour.
  \ */ R.hsl = cacher('hsl', (h, s, l)=>R.hsl2rgb(h, s, l).hex);
    /* \
   * Raphael.rgb
   [ method ]
   **
   * Converts RGB values to hex representation of the colour.
   > Parameters
   - r (number) red
   - g (number) green
   - b (number) blue
   = (string) hex representation of the colour.
  \ */ R.rgb = cacher('rgb', (r, g, b)=>{
        function round(x) {
            return x + 0.5 | 0;
        }
        return `#${(16777216 | round(b) | round(g) << 8 | round(r) << 16).toString(16).slice(1)}`;
    });
    /* \
   * Raphael.getColor
   [ method ]
   **
   * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
   > Parameters
   - value (number) #optional brightness, default is `0.75`
   = (string) hex representation of the colour.
  \ */ R.getColor = function(value) {
        const start = this.getColor.start = this.getColor.start || {
            h: 0,
            s: 1,
            b: value || 0.75
        };
        const rgb = this.hsb2rgb(start.h, start.s, start.b);
        start.h += 0.075;
        if (start.h > 1) {
            start.h = 0;
            start.s -= 0.2;
            start.s <= 0 && (this.getColor.start = {
                h: 0,
                s: 1,
                b: start.b
            });
        }
        return rgb.hex;
    };
    /* \
   * Raphael.getColor.reset
   [ method ]
   **
   * Resets spectrum position for @Raphael.getColor back to red.
  \ */ R.getColor.reset = function() {
        delete this.start;
    };
    // http://schepers.cc/getting-to-the-point
    function catmullRom2bezier(crp, z) {
        const d = [];
        for(let i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2){
            const p = [
                {
                    x: +crp[i - 2],
                    y: +crp[i - 1]
                },
                {
                    x: +crp[i],
                    y: +crp[i + 1]
                },
                {
                    x: +crp[i + 2],
                    y: +crp[i + 3]
                },
                {
                    x: +crp[i + 4],
                    y: +crp[i + 5]
                }
            ];
            if (z) {
                if (!i) p[0] = {
                    x: +crp[iLen - 2],
                    y: +crp[iLen - 1]
                };
                else if (iLen - 4 == i) p[3] = {
                    x: +crp[0],
                    y: +crp[1]
                };
                else if (iLen - 2 == i) {
                    p[2] = {
                        x: +crp[0],
                        y: +crp[1]
                    };
                    p[3] = {
                        x: +crp[2],
                        y: +crp[3]
                    };
                }
            } else if (iLen - 4 == i) p[3] = p[2];
            else if (!i) p[0] = {
                x: +crp[i],
                y: +crp[i + 1]
            };
            d.push([
                'C',
                (-p[0].x + 6 * p[1].x + p[2].x) / 6,
                (-p[0].y + 6 * p[1].y + p[2].y) / 6,
                (p[1].x + 6 * p[2].x - p[3].x) / 6,
                (p[1].y + 6 * p[2].y - p[3].y) / 6,
                p[2].x,
                p[2].y
            ]);
        }
        return d;
    }
    /* \
   * Raphael.parsePathString
   [ method ]
   **
   * Utility method
   **
   * Parses given path string into an array of arrays of path segments.
   > Parameters
   - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
   = (array) array of segments.
  \ */ R.parsePathString = function(pathString) {
        if (!pathString) return null;
        const pth = paths(pathString);
        if (pth.arr) return pathClone(pth.arr);
        const paramCounts = {
            a: 7,
            c: 6,
            h: 1,
            l: 2,
            m: 2,
            r: 4,
            q: 4,
            s: 4,
            t: 2,
            v: 1,
            z: 0
        };
        let data = [];
        if (R.is(pathString, array) && R.is(pathString[0], array)) // rough assumption
        data = pathClone(pathString);
        if (!data.length) Str(pathString).replace(pathCommand, (a, b, c)=>{
            const params = [];
            let name = b.toLowerCase();
            c.replace(pathValues, (a, b)=>{
                b && params.push(+b);
            });
            if (name == 'm' && params.length > 2) {
                data.push([
                    b
                ][concat](params.splice(0, 2)));
                name = 'l';
                b = b == 'm' ? 'l' : 'L';
            }
            if (name == 'r') data.push([
                b
            ][concat](params));
            else while(params.length >= paramCounts[name]){
                data.push([
                    b
                ][concat](params.splice(0, paramCounts[name])));
                if (!paramCounts[name]) break;
            }
        });
        data.toString = R._path2string;
        pth.arr = pathClone(data);
        return data;
    };
    /* \
   * Raphael.parseTransformString
   [ method ]
   **
   * Utility method
   **
   * Parses given path string into an array of transformations.
   > Parameters
   - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
   = (array) array of transformations.
  \ */ R.parseTransformString = cacher('parseTransformString', (TString)=>{
        if (!TString) return null;
        const paramCounts = {
            r: 3,
            s: 4,
            t: 2,
            m: 6
        };
        let data = [];
        if (R.is(TString, array) && R.is(TString[0], array)) // rough assumption
        data = pathClone(TString);
        if (!data.length) Str(TString).replace(tCommand, (a, b, c)=>{
            const params = [];
            const name = lowerCase.call(b);
            c.replace(pathValues, (a, b)=>{
                b && params.push(+b);
            });
            data.push([
                b
            ][concat](params));
        });
        data.toString = R._path2string;
        return data;
    });
    // PATHS
    var paths = function(ps) {
        const p = paths.ps = paths.ps || {};
        if (p[ps]) p[ps].sleep = 100;
        else p[ps] = {
            sleep: 100
        };
        setTimeout(()=>{
            for(const key in p)if (p[has](key) && key != ps) {
                p[key].sleep--;
                !p[key].sleep && delete p[key];
            }
        });
        return p[ps];
    };
    /* \
   * Raphael.findDotsAtSegment
   [ method ]
   **
   * Utility method
   **
   * Find dot coordinates on the given cubic bezier curve at the given t.
   > Parameters
   - p1x (number) x of the first point of the curve
   - p1y (number) y of the first point of the curve
   - c1x (number) x of the first anchor of the curve
   - c1y (number) y of the first anchor of the curve
   - c2x (number) x of the second anchor of the curve
   - c2y (number) y of the second anchor of the curve
   - p2x (number) x of the second point of the curve
   - p2y (number) y of the second point of the curve
   - t (number) position on the curve (0..1)
   = (object) point information in format:
   o {
   o     x: (number) x coordinate of the point
   o     y: (number) y coordinate of the point
   o     m: {
   o         x: (number) x coordinate of the left anchor
   o         y: (number) y coordinate of the left anchor
   o     }
   o     n: {
   o         x: (number) x coordinate of the right anchor
   o         y: (number) y coordinate of the right anchor
   o     }
   o     start: {
   o         x: (number) x coordinate of the start of the curve
   o         y: (number) y coordinate of the start of the curve
   o     }
   o     end: {
   o         x: (number) x coordinate of the end of the curve
   o         y: (number) y coordinate of the end of the curve
   o     }
   o     alpha: (number) angle of the curve derivative at the point
   o }
  \ */ R.findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        const t1 = 1 - t;
        const t13 = t1 ** 3;
        const t12 = t1 ** 2;
        const t2 = t * t;
        const t3 = t2 * t;
        const x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
        const y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
        const mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
        const my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
        const nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
        const ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
        const ax = t1 * p1x + t * c1x;
        const ay = t1 * p1y + t * c1y;
        const cx = t1 * c2x + t * p2x;
        const cy = t1 * c2y + t * p2y;
        let alpha = 90 - math.atan2(mx - nx, my - ny) * 180 / PI;
        (mx > nx || my < ny) && (alpha += 180);
        return {
            x,
            y,
            m: {
                x: mx,
                y: my
            },
            n: {
                x: nx,
                y: ny
            },
            start: {
                x: ax,
                y: ay
            },
            end: {
                x: cx,
                y: cy
            },
            alpha
        };
    };
    /* \
   * Raphael.bezierBBox
   [ method ]
   **
   * Utility method
   **
   * Return bounding box of a given cubic bezier curve
   > Parameters
   - p1x (number) x of the first point of the curve
   - p1y (number) y of the first point of the curve
   - c1x (number) x of the first anchor of the curve
   - c1y (number) y of the first anchor of the curve
   - c2x (number) x of the second anchor of the curve
   - c2y (number) y of the second anchor of the curve
   - p2x (number) x of the second point of the curve
   - p2y (number) y of the second point of the curve
   * or
   - bez (array) array of six points for bezier curve
   = (object) point information in format:
   o {
   o     min: {
   o         x: (number) x coordinate of the left point
   o         y: (number) y coordinate of the top point
   o     }
   o     max: {
   o         x: (number) x coordinate of the right point
   o         y: (number) y coordinate of the bottom point
   o     }
   o }
  \ */ R.bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
        if (!R.is(p1x, 'array')) p1x = [
            p1x,
            p1y,
            c1x,
            c1y,
            c2x,
            c2y,
            p2x,
            p2y
        ];
        const bbox = curveDim.apply(null, p1x);
        return {
            x: bbox.min.x,
            y: bbox.min.y,
            x2: bbox.max.x,
            y2: bbox.max.y,
            width: bbox.max.x - bbox.min.x,
            height: bbox.max.y - bbox.min.y
        };
    };
    /* \
   * Raphael.isPointInsideBBox
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if given point is inside bounding boxes.
   > Parameters
   - bbox (string) bounding box
   - x (string) x coordinate of the point
   - y (string) y coordinate of the point
   = (boolean) `true` if point inside
  \ */ R.isPointInsideBBox = function(bbox, x, y) {
        return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
    };
    /* \
   * Raphael.isBBoxIntersect
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if two bounding boxes intersect
   > Parameters
   - bbox1 (string) first bounding box
   - bbox2 (string) second bounding box
   = (boolean) `true` if they intersect
  \ */ R.isBBoxIntersect = function(bbox1, bbox2) {
        const i = R.isPointInsideBBox;
        return i(bbox2, bbox1.x, bbox1.y) || i(bbox2, bbox1.x2, bbox1.y) || i(bbox2, bbox1.x, bbox1.y2) || i(bbox2, bbox1.x2, bbox1.y2) || i(bbox1, bbox2.x, bbox2.y) || i(bbox1, bbox2.x2, bbox2.y) || i(bbox1, bbox2.x, bbox2.y2) || i(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
    };
    function base3(t, p1, p2, p3, p4) {
        const t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
        const t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
        return t * t2 - 3 * p1 + 3 * p2;
    }
    function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
        if (z == null) z = 1;
        z = z > 1 ? 1 : z < 0 ? 0 : z;
        const z2 = z / 2;
        const n = 12;
        const Tvalues = [
            -0.1252,
            0.1252,
            -0.3678,
            0.3678,
            -0.5873,
            0.5873,
            -0.7699,
            0.7699,
            -0.9041,
            0.9041,
            -0.9816,
            0.9816
        ];
        const Cvalues = [
            0.2491,
            0.2491,
            0.2335,
            0.2335,
            0.2032,
            0.2032,
            0.1601,
            0.1601,
            0.1069,
            0.1069,
            0.0472,
            0.0472
        ];
        let sum = 0;
        for(let i = 0; i < n; i++){
            const ct = z2 * Tvalues[i] + z2;
            const xbase = base3(ct, x1, x2, x3, x4);
            const ybase = base3(ct, y1, y2, y3, y4);
            const comb = xbase * xbase + ybase * ybase;
            sum += Cvalues[i] * math.sqrt(comb);
        }
        return z2 * sum;
    }
    function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
        if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) return;
        const t = 1;
        let step = t / 2;
        let t2 = t - step;
        let l;
        const e = 0.01;
        l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        while(abs(l - ll) > e){
            step /= 2;
            t2 += (l < ll ? 1 : -1) * step;
            l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
        }
        return t2;
    }
    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
        if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) return;
        const nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
        const ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
        const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (!denominator) return;
        const px = nx / denominator;
        const py = ny / denominator;
        const px2 = +px.toFixed(2);
        const py2 = +py.toFixed(2);
        if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) return;
        return {
            x: px,
            y: py
        };
    }
    function inter(bez1, bez2) {
        return interHelper(bez1, bez2);
    }
    function interCount(bez1, bez2) {
        return interHelper(bez1, bez2, 1);
    }
    function interHelper(bez1, bez2, justCount) {
        const bbox1 = R.bezierBBox(bez1);
        const bbox2 = R.bezierBBox(bez2);
        if (!R.isBBoxIntersect(bbox1, bbox2)) return justCount ? 0 : [];
        const l1 = bezlen.apply(0, bez1);
        const l2 = bezlen.apply(0, bez2);
        const n1 = mmax(~~(l1 / 5), 1);
        const n2 = mmax(~~(l2 / 5), 1);
        const dots1 = [];
        const dots2 = [];
        const xy = {};
        let res = justCount ? 0 : [];
        for(var i = 0; i < n1 + 1; i++){
            var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
            dots1.push({
                x: p.x,
                y: p.y,
                t: i / n1
            });
        }
        for(i = 0; i < n2 + 1; i++){
            p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
            dots2.push({
                x: p.x,
                y: p.y,
                t: i / n2
            });
        }
        for(i = 0; i < n1; i++)for(let j = 0; j < n2; j++){
            const di = dots1[i];
            const di1 = dots1[i + 1];
            const dj = dots2[j];
            const dj1 = dots2[j + 1];
            const ci = abs(di1.x - di.x) < 0.001 ? 'y' : 'x';
            const cj = abs(dj1.x - dj.x) < 0.001 ? 'y' : 'x';
            const is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
            if (is) {
                if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) continue;
                xy[is.x.toFixed(4)] = is.y.toFixed(4);
                const t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
                const t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                    if (justCount) res++;
                    else res.push({
                        x: is.x,
                        y: is.y,
                        t1: mmin(t1, 1),
                        t2: mmin(t2, 1)
                    });
                }
            }
        }
        return res;
    }
    /* \
   * Raphael.pathIntersection
   [ method ]
   **
   * Utility method
   **
   * Finds intersections of two paths
   > Parameters
   - path1 (string) path string
   - path2 (string) path string
   = (array) dots of intersection
   o [
   o     {
   o         x: (number) x coordinate of the point
   o         y: (number) y coordinate of the point
   o         t1: (number) t value for segment of path1
   o         t2: (number) t value for segment of path2
   o         segment1: (number) order number for segment of path1
   o         segment2: (number) order number for segment of path2
   o         bez1: (array) eight coordinates representing bezir curve for the segment of path1
   o         bez2: (array) eight coordinates representing bezir curve for the segment of path2
   o     }
   o ]
  \ */ R.pathIntersection = function(path1, path2) {
        return interPathHelper(path1, path2);
    };
    R.pathIntersectionNumber = function(path1, path2) {
        return interPathHelper(path1, path2, 1);
    };
    function interPathHelper(path1, path2, justCount) {
        path1 = R._path2curve(path1);
        path2 = R._path2curve(path2);
        let x1;
        let y1;
        let x2;
        let y2;
        let x1m;
        let y1m;
        let x2m;
        let y2m;
        let bez1;
        let bez2;
        let res = justCount ? 0 : [];
        for(let i = 0, ii = path1.length; i < ii; i++){
            const pi = path1[i];
            if (pi[0] == 'M') {
                x1 = x1m = pi[1];
                y1 = y1m = pi[2];
            } else {
                if (pi[0] == 'C') {
                    bez1 = [
                        x1,
                        y1
                    ].concat(pi.slice(1));
                    x1 = bez1[6];
                    y1 = bez1[7];
                } else {
                    bez1 = [
                        x1,
                        y1,
                        x1,
                        y1,
                        x1m,
                        y1m,
                        x1m,
                        y1m
                    ];
                    x1 = x1m;
                    y1 = y1m;
                }
                for(let j = 0, jj = path2.length; j < jj; j++){
                    const pj = path2[j];
                    if (pj[0] == 'M') {
                        x2 = x2m = pj[1];
                        y2 = y2m = pj[2];
                    } else {
                        if (pj[0] == 'C') {
                            bez2 = [
                                x2,
                                y2
                            ].concat(pj.slice(1));
                            x2 = bez2[6];
                            y2 = bez2[7];
                        } else {
                            bez2 = [
                                x2,
                                y2,
                                x2,
                                y2,
                                x2m,
                                y2m,
                                x2m,
                                y2m
                            ];
                            x2 = x2m;
                            y2 = y2m;
                        }
                        const intr = interHelper(bez1, bez2, justCount);
                        if (justCount) res += intr;
                        else {
                            for(let k = 0, kk = intr.length; k < kk; k++){
                                intr[k].segment1 = i;
                                intr[k].segment2 = j;
                                intr[k].bez1 = bez1;
                                intr[k].bez2 = bez2;
                            }
                            res = res.concat(intr);
                        }
                    }
                }
            }
        }
        return res;
    }
    /* \
   * Raphael.isPointInsidePath
   [ method ]
   **
   * Utility method
   **
   * Returns `true` if given point is inside a given closed path.
   > Parameters
   - path (string) path string
   - x (number) x of the point
   - y (number) y of the point
   = (boolean) true, if point is inside the path
  \ */ R.isPointInsidePath = function(path, x, y) {
        const bbox = R.pathBBox(path);
        return R.isPointInsideBBox(bbox, x, y) && interPathHelper(path, [
            [
                'M',
                x,
                y
            ],
            [
                'H',
                bbox.x2 + 10
            ]
        ], 1) % 2 == 1;
    };
    R._removedFactory = function(methodname) {
        return function() {
            (0, _eveJs.eve)('raphael.log', null, `Rapha\xebl: you are calling to method \u201c${methodname}\u201d of removed object`, methodname);
        };
    };
    /* \
   * Raphael.pathBBox
   [ method ]
   **
   * Utility method
   **
   * Return bounding box of a given path
   > Parameters
   - path (string) path string
   = (object) bounding box
   o {
   o     x: (number) x coordinate of the left top point of the box
   o     y: (number) y coordinate of the left top point of the box
   o     x2: (number) x coordinate of the right bottom point of the box
   o     y2: (number) y coordinate of the right bottom point of the box
   o     width: (number) width of the box
   o     height: (number) height of the box
   o     cx: (number) x coordinate of the center of the box
   o     cy: (number) y coordinate of the center of the box
   o }
  \ */ const pathDimensions = R.pathBBox = function(path) {
        const pth = paths(path);
        if (pth.bbox) return clone(pth.bbox);
        if (!path) return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            x2: 0,
            y2: 0
        };
        path = path2curve(path);
        let x = 0;
        let y = 0;
        let X = [];
        let Y = [];
        let p;
        for(let i = 0, ii = path.length; i < ii; i++){
            p = path[i];
            if (p[0] == 'M') {
                x = p[1];
                y = p[2];
                X.push(x);
                Y.push(y);
            } else {
                const dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                X = X[concat](dim.min.x, dim.max.x);
                Y = Y[concat](dim.min.y, dim.max.y);
                x = p[5];
                y = p[6];
            }
        }
        const xmin = mmin[apply](0, X);
        const ymin = mmin[apply](0, Y);
        const xmax = mmax[apply](0, X);
        const ymax = mmax[apply](0, Y);
        const width = xmax - xmin;
        const height = ymax - ymin;
        const bb = {
            x: xmin,
            y: ymin,
            x2: xmax,
            y2: ymax,
            width,
            height,
            cx: xmin + width / 2,
            cy: ymin + height / 2
        };
        pth.bbox = clone(bb);
        return bb;
    };
    var pathClone = function(pathArray) {
        // var res = clone(pathArray);
        // Array.slice() is faster then clone(pathArray).
        const res = pathArray.slice(0);
        for(let i = 0, ii = pathArray.length; i < ii; ++i)res[i] = pathArray[i].slice(0);
        res.toString = R._path2string;
        return res;
    };
    const pathToRelative = R._pathToRelative = function(pathArray) {
        const pth = paths(pathArray);
        if (pth.rel) return pathClone(pth.rel);
        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) // rough assumption
        pathArray = R.parsePathString(pathArray);
        const res = [];
        let x = 0;
        let y = 0;
        let mx = 0;
        let my = 0;
        let start = 0;
        if (pathArray[0][0] == 'M') {
            x = pathArray[0][1];
            y = pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res.push([
                'M',
                x,
                y
            ]);
        }
        for(let i = start, ii = pathArray.length; i < ii; i++){
            let r = res[i] = [];
            const pa = pathArray[i];
            if (pa[0] != lowerCase.call(pa[0])) {
                r[0] = lowerCase.call(pa[0]);
                switch(r[0]){
                    case 'a':
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] - x).toFixed(3);
                        r[7] = +(pa[7] - y).toFixed(3);
                        break;
                    case 'v':
                        r[1] = +(pa[1] - y).toFixed(3);
                        break;
                    case 'm':
                        mx = pa[1];
                        my = pa[2];
                    default:
                        for(let j = 1, jj = pa.length; j < jj; j++)r[j] = +(pa[j] - (j % 2 ? x : y)).toFixed(3);
                }
            } else {
                r = res[i] = [];
                if (pa[0] == 'm') {
                    mx = pa[1] + x;
                    my = pa[2] + y;
                }
                for(let k = 0, kk = pa.length; k < kk; k++)res[i][k] = pa[k];
            }
            const len = res[i].length;
            switch(res[i][0]){
                case 'z':
                    x = mx;
                    y = my;
                    break;
                case 'h':
                    x += +res[i][len - 1];
                    break;
                case 'v':
                    y += +res[i][len - 1];
                    break;
                default:
                    x += +res[i][len - 2];
                    y += +res[i][len - 1];
            }
        }
        res.toString = R._path2string;
        pth.rel = pathClone(res);
        return res;
    };
    const pathToAbsolute = R._pathToAbsolute = function(pathArray) {
        // return pathArray;
        const pth = paths(pathArray);
        if (pth.abs) return pathClone(pth.abs);
        if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) // rough assumption
        pathArray = R.parsePathString(pathArray);
        if (!pathArray || !pathArray.length) return [
            [
                'M',
                0,
                0
            ]
        ];
        let res = [];
        let x = 0;
        let y = 0;
        let mx = 0;
        let my = 0;
        let start = 0;
        if (pathArray[0][0] == 'M') {
            x = +pathArray[0][1];
            y = +pathArray[0][2];
            mx = x;
            my = y;
            start++;
            res[0] = [
                'M',
                x,
                y
            ];
        }
        const crz = pathArray.length == 3 && pathArray[0][0] == 'M' && pathArray[1][0].toUpperCase() == 'R' && pathArray[2][0].toUpperCase() == 'Z';
        for(var r, pa, i = start, ii = pathArray.length; i < ii; i++){
            res.push(r = []);
            pa = pathArray[i];
            if (pa[0] != upperCase.call(pa[0])) {
                r[0] = upperCase.call(pa[0]);
                switch(r[0]){
                    case 'A':
                        r[1] = pa[1];
                        r[2] = pa[2];
                        r[3] = pa[3];
                        r[4] = pa[4];
                        r[5] = pa[5];
                        r[6] = +(pa[6] + x);
                        r[7] = +(pa[7] + y);
                        break;
                    case 'V':
                        r[1] = +pa[1] + y;
                        break;
                    case 'H':
                        r[1] = +pa[1] + x;
                        break;
                    case 'R':
                        var dots = [
                            x,
                            y
                        ][concat](pa.slice(1));
                        for(var j = 2, jj = dots.length; j < jj; j++){
                            dots[j] = +dots[j] + x;
                            dots[++j] = +dots[j] + y;
                        }
                        res.pop();
                        res = res[concat](catmullRom2bezier(dots, crz));
                        break;
                    case 'M':
                        mx = +pa[1] + x;
                        my = +pa[2] + y;
                    default:
                        for(j = 1, jj = pa.length; j < jj; j++)r[j] = +pa[j] + (j % 2 ? x : y);
                }
            } else if (pa[0] == 'R') {
                dots = [
                    x,
                    y
                ][concat](pa.slice(1));
                res.pop();
                res = res[concat](catmullRom2bezier(dots, crz));
                r = [
                    'R'
                ][concat](pa.slice(-2));
            } else for(let k = 0, kk = pa.length; k < kk; k++)r[k] = pa[k];
            switch(r[0]){
                case 'Z':
                    x = mx;
                    y = my;
                    break;
                case 'H':
                    x = r[1];
                    break;
                case 'V':
                    y = r[1];
                    break;
                case 'M':
                    mx = r[r.length - 2];
                    my = r[r.length - 1];
                default:
                    x = r[r.length - 2];
                    y = r[r.length - 1];
            }
        }
        res.toString = R._path2string;
        pth.abs = pathClone(res);
        return res;
    };
    const l2c = function(x1, y1, x2, y2) {
        return [
            x1,
            y1,
            x2,
            y2,
            x2,
            y2
        ];
    };
    const q2c = function(x1, y1, ax, ay, x2, y2) {
        const _13 = 1 / 3;
        const _23 = 2 / 3;
        return [
            _13 * x1 + _23 * ax,
            _13 * y1 + _23 * ay,
            _13 * x2 + _23 * ax,
            _13 * y2 + _23 * ay,
            x2,
            y2
        ];
    };
    var a2c = function(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
        // for more information of where this math came from visit:
        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
        const _120 = PI * 120 / 180;
        const rad = PI / 180 * (+angle || 0);
        let res = [];
        let xy;
        const rotate = cacher('a2c.rotate', (x, y, rad)=>{
            const X = x * math.cos(rad) - y * math.sin(rad);
            const Y = x * math.sin(rad) + y * math.cos(rad);
            return {
                x: X,
                y: Y
            };
        });
        if (!recursive) {
            xy = rotate(x1, y1, -rad);
            x1 = xy.x;
            y1 = xy.y;
            xy = rotate(x2, y2, -rad);
            x2 = xy.x;
            y2 = xy.y;
            const cos = math.cos(PI / 180 * angle);
            const sin = math.sin(PI / 180 * angle);
            const x = (x1 - x2) / 2;
            const y = (y1 - y2) / 2;
            let h = x * x / (rx * rx) + y * y / (ry * ry);
            if (h > 1) {
                h = math.sqrt(h);
                rx = h * rx;
                ry = h * ry;
            }
            const rx2 = rx * rx;
            const ry2 = ry * ry;
            const k = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
            var cx = k * rx * y / ry + (x1 + x2) / 2;
            var cy = k * -ry * x / rx + (y1 + y2) / 2;
            var f1 = math.asin(((y1 - cy) / ry).toFixed(9));
            var f2 = math.asin(((y2 - cy) / ry).toFixed(9));
            f1 = x1 < cx ? PI - f1 : f1;
            f2 = x2 < cx ? PI - f2 : f2;
            f1 < 0 && (f1 = PI * 2 + f1);
            f2 < 0 && (f2 = PI * 2 + f2);
            if (sweep_flag && f1 > f2) f1 -= PI * 2;
            if (!sweep_flag && f2 > f1) f2 -= PI * 2;
        } else {
            f1 = recursive[0];
            f2 = recursive[1];
            cx = recursive[2];
            cy = recursive[3];
        }
        let df = f2 - f1;
        if (abs(df) > _120) {
            const f2old = f2;
            const x2old = x2;
            const y2old = y2;
            f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
            x2 = cx + rx * math.cos(f2);
            y2 = cy + ry * math.sin(f2);
            res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
                f2,
                f2old,
                cx,
                cy
            ]);
        }
        df = f2 - f1;
        const c1 = math.cos(f1);
        const s1 = math.sin(f1);
        const c2 = math.cos(f2);
        const s2 = math.sin(f2);
        const t = math.tan(df / 4);
        const hx = 4 / 3 * rx * t;
        const hy = 4 / 3 * ry * t;
        const m1 = [
            x1,
            y1
        ];
        const m2 = [
            x1 + hx * s1,
            y1 - hy * c1
        ];
        const m3 = [
            x2 + hx * s2,
            y2 - hy * c2
        ];
        const m4 = [
            x2,
            y2
        ];
        m2[0] = 2 * m1[0] - m2[0];
        m2[1] = 2 * m1[1] - m2[1];
        if (recursive) return [
            m2,
            m3,
            m4
        ][concat](res);
        res = [
            m2,
            m3,
            m4
        ][concat](res).join()[split](',');
        const newres = [];
        for(let i = 0, ii = res.length; i < ii; i++)newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
        return newres;
    };
    const findDotAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
        const t1 = 1 - t;
        return {
            x: t1 ** 3 * p1x + t1 ** 2 * 3 * t * c1x + t1 * 3 * t * t * c2x + t ** 3 * p2x,
            y: t1 ** 3 * p1y + t1 ** 2 * 3 * t * c1y + t1 * 3 * t * t * c2y + t ** 3 * p2y
        };
    };
    var curveDim = cacher('curveDim', (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y)=>{
        let a = c2x - 2 * c1x + p1x - (p2x - 2 * c2x + c1x);
        let b = 2 * (c1x - p1x) - 2 * (c2x - c1x);
        let c = p1x - c1x;
        let t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
        let t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
        const y = [
            p1y,
            p2y
        ];
        const x = [
            p1x,
            p2x
        ];
        let dot;
        abs(t1) > '1e12' && (t1 = 0.5);
        abs(t2) > '1e12' && (t2 = 0.5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        a = c2y - 2 * c1y + p1y - (p2y - 2 * c2y + c1y);
        b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
        c = p1y - c1y;
        t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
        t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
        abs(t1) > '1e12' && (t1 = 0.5);
        abs(t2) > '1e12' && (t2 = 0.5);
        if (t1 > 0 && t1 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
            x.push(dot.x);
            y.push(dot.y);
        }
        if (t2 > 0 && t2 < 1) {
            dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
            x.push(dot.x);
            y.push(dot.y);
        }
        return {
            min: {
                x: mmin[apply](0, x),
                y: mmin[apply](0, y)
            },
            max: {
                x: mmax[apply](0, x),
                y: mmax[apply](0, y)
            }
        };
    });
    var path2curve = R._path2curve = cacher('path2curve', (path, path2)=>{
        const pth = !path2 && paths(path);
        if (!path2 && pth.curve) return pathClone(pth.curve);
        const p = pathToAbsolute(path);
        const p2 = path2 && pathToAbsolute(path2);
        const attrs = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        };
        const attrs2 = {
            x: 0,
            y: 0,
            bx: 0,
            by: 0,
            X: 0,
            Y: 0,
            qx: null,
            qy: null
        };
        const processPath = function(path, d, pcom) {
            let nx;
            let ny;
            const tq = {
                T: 1,
                Q: 1
            };
            if (!path) return [
                'C',
                d.x,
                d.y,
                d.x,
                d.y,
                d.x,
                d.y
            ];
            !(path[0] in tq) && (d.qx = d.qy = null);
            switch(path[0]){
                case 'M':
                    d.X = path[1];
                    d.Y = path[2];
                    break;
                case 'A':
                    path = [
                        'C'
                    ][concat](a2c[apply](0, [
                        d.x,
                        d.y
                    ][concat](path.slice(1))));
                    break;
                case 'S':
                    if (pcom == 'C' || pcom == 'S') {
                        // In "S" case we have to take into account, if the previous command is C/S.
                        nx = d.x * 2 - d.bx // And reflect the previous
                        ;
                        ny = d.y * 2 - d.by // command's control point relative to the current point.
                        ;
                    } else {
                        // or some else or nothing
                        nx = d.x;
                        ny = d.y;
                    }
                    path = [
                        'C',
                        nx,
                        ny
                    ][concat](path.slice(1));
                    break;
                case 'T':
                    if (pcom == 'Q' || pcom == 'T') {
                        // In "T" case we have to take into account, if the previous command is Q/T.
                        d.qx = d.x * 2 - d.qx // And make a reflection similar
                        ;
                        d.qy = d.y * 2 - d.qy // to case "S".
                        ;
                    } else {
                        // or something else or nothing
                        d.qx = d.x;
                        d.qy = d.y;
                    }
                    path = [
                        'C'
                    ][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                    break;
                case 'Q':
                    d.qx = path[1];
                    d.qy = path[2];
                    path = [
                        'C'
                    ][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                    break;
                case 'L':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, path[1], path[2]));
                    break;
                case 'H':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, path[1], d.y));
                    break;
                case 'V':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, d.x, path[1]));
                    break;
                case 'Z':
                    path = [
                        'C'
                    ][concat](l2c(d.x, d.y, d.X, d.Y));
                    break;
            }
            return path;
        };
        const fixArc = function(pp, i) {
            if (pp[i].length > 7) {
                pp[i].shift();
                const pi = pp[i];
                while(pi.length){
                    pcoms1[i] = 'A' // if created multiple C:s, their original seg is saved
                    ;
                    p2 && (pcoms2[i] = 'A' // the same as above
                    );
                    pp.splice(i++, 0, [
                        'C'
                    ][concat](pi.splice(0, 6)));
                }
                pp.splice(i, 1);
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        const fixM = function(path1, path2, a1, a2, i) {
            if (path1 && path2 && path1[i][0] == 'M' && path2[i][0] != 'M') {
                path2.splice(i, 0, [
                    'M',
                    a2.x,
                    a2.y
                ]);
                a1.bx = 0;
                a1.by = 0;
                a1.x = path1[i][1];
                a1.y = path1[i][2];
                ii = mmax(p.length, p2 && p2.length || 0);
            }
        };
        var pcoms1 = [] // path commands of original path p
        ;
        var pcoms2 = [] // path commands of original path p2
        ;
        let pfirst = '' // temporary holder for original path command
        ;
        let pcom = '' // holder for previous path command of original path
        ;
        for(var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++){
            p[i] && (pfirst = p[i][0] // save current path command
            );
            if (pfirst != 'C') {
                // C is not saved yet, because it may be result of conversion
                pcoms1[i] = pfirst // Save current path command
                ;
                i && (pcom = pcoms1[i - 1] // Get previous path command pcom
                );
            }
            p[i] = processPath(p[i], attrs, pcom) // Previous path command is inputted to processPath
            ;
            if (pcoms1[i] != 'A' && pfirst == 'C') pcoms1[i] = 'C' // A is the only command
            ;
            // which may produce multiple C:s
            // so we have to make sure that C is also C in original path
            fixArc(p, i) // fixArc adds also the right amount of A:s to pcoms1
            ;
            if (p2) {
                // the same procedures is done to p2
                p2[i] && (pfirst = p2[i][0]);
                if (pfirst != 'C') {
                    pcoms2[i] = pfirst;
                    i && (pcom = pcoms2[i - 1]);
                }
                p2[i] = processPath(p2[i], attrs2, pcom);
                if (pcoms2[i] != 'A' && pfirst == 'C') pcoms2[i] = 'C';
                fixArc(p2, i);
            }
            fixM(p, p2, attrs, attrs2, i);
            fixM(p2, p, attrs2, attrs, i);
            const seg = p[i];
            const seg2 = p2 && p2[i];
            const seglen = seg.length;
            const seg2len = p2 && seg2.length;
            attrs.x = seg[seglen - 2];
            attrs.y = seg[seglen - 1];
            attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
            attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
            attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
            attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
            attrs2.x = p2 && seg2[seg2len - 2];
            attrs2.y = p2 && seg2[seg2len - 1];
        }
        if (!p2) pth.curve = pathClone(p);
        return p2 ? [
            p,
            p2
        ] : p;
    }, null, pathClone);
    const parseDots = R._parseDots = cacher('parseDots', (gradient)=>{
        const dots = [];
        for(var i = 0, ii = gradient.length; i < ii; i++){
            const dot = {};
            const par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
            dot.color = R.getRGB(par[1]);
            if (dot.color.error) return null;
            dot.opacity = dot.color.opacity;
            dot.color = dot.color.hex;
            par[2] && (dot.offset = `${par[2]}%`);
            dots.push(dot);
        }
        for(i = 1, ii = dots.length - 1; i < ii; i++)if (!dots[i].offset) {
            let start = toFloat(dots[i - 1].offset || 0);
            let end = 0;
            for(var j = i + 1; j < ii; j++)if (dots[j].offset) {
                end = dots[j].offset;
                break;
            }
            if (!end) {
                end = 100;
                j = ii;
            }
            end = toFloat(end);
            const d = (end - start) / (j - i + 1);
            for(; i < j; i++){
                start += d;
                dots[i].offset = `${start}%`;
            }
        }
        return dots;
    });
    const tear = R._tear = function(el, paper) {
        el == paper.top && (paper.top = el.prev);
        el == paper.bottom && (paper.bottom = el.next);
        el.next && (el.next.prev = el.prev);
        el.prev && (el.prev.next = el.next);
    };
    const tofront = R._tofront = function(el, paper) {
        if (paper.top === el) return;
        tear(el, paper);
        el.next = null;
        el.prev = paper.top;
        paper.top.next = el;
        paper.top = el;
    };
    const toback = R._toback = function(el, paper) {
        if (paper.bottom === el) return;
        tear(el, paper);
        el.next = paper.bottom;
        el.prev = null;
        paper.bottom.prev = el;
        paper.bottom = el;
    };
    const insertafter = R._insertafter = function(el, el2, paper) {
        tear(el, paper);
        el2 == paper.top && (paper.top = el);
        el2.next && (el2.next.prev = el);
        el.next = el2.next;
        el.prev = el2;
        el2.next = el;
    };
    const insertbefore = R._insertbefore = function(el, el2, paper) {
        tear(el, paper);
        el2 == paper.bottom && (paper.bottom = el);
        el2.prev && (el2.prev.next = el);
        el.prev = el2.prev;
        el2.prev = el;
        el.next = el2;
    };
    /* \
     * Raphael.toMatrix
     [ method ]
     **
     * Utility method
     **
     * Returns matrix of transformations applied to a given path
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (object) @Matrix
    \ */ const toMatrix = R.toMatrix = function(path, transform) {
        const bb = pathDimensions(path);
        const el = {
            _: {
                transform: E
            },
            getBBox () {
                return bb;
            }
        };
        extractTransform(el, transform);
        return el.matrix;
    };
    /* \
     * Raphael.transformPath
     [ method ]
     **
     * Utility method
     **
     * Returns path transformed by a given transformation
     > Parameters
     - path (string) path string
     - transform (string|array) transformation string
     = (string) path
    \ */ const transformPath = R.transformPath = function(path, transform) {
        return mapPath(path, toMatrix(path, transform));
    };
    var extractTransform = R._extractTransform = function(el, tstr) {
        if (tstr == null) return el._.transform;
        tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
        const tdata = R.parseTransformString(tstr);
        let deg = 0;
        let dx = 0;
        let dy = 0;
        let sx = 1;
        let sy = 1;
        const { _ } = el;
        const m = new Matrix();
        _.transform = tdata || [];
        if (tdata) for(let i = 0, ii = tdata.length; i < ii; i++){
            const t = tdata[i];
            const tlen = t.length;
            const command = Str(t[0]).toLowerCase();
            const absolute = t[0] != command;
            const inver = absolute ? m.invert() : 0;
            var x1;
            var y1;
            var x2;
            var y2;
            var bb;
            if (command == 't' && tlen == 3) {
                if (absolute) {
                    x1 = inver.x(0, 0);
                    y1 = inver.y(0, 0);
                    x2 = inver.x(t[1], t[2]);
                    y2 = inver.y(t[1], t[2]);
                    m.translate(x2 - x1, y2 - y1);
                } else m.translate(t[1], t[2]);
            } else if (command == 'r') {
                if (tlen == 2) {
                    bb = bb || el.getBBox(1);
                    m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    deg += t[1];
                } else if (tlen == 4) {
                    if (absolute) {
                        x2 = inver.x(t[2], t[3]);
                        y2 = inver.y(t[2], t[3]);
                        m.rotate(t[1], x2, y2);
                    } else m.rotate(t[1], t[2], t[3]);
                    deg += t[1];
                }
            } else if (command == 's') {
                if (tlen == 2 || tlen == 3) {
                    bb = bb || el.getBBox(1);
                    m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                    sx *= t[1];
                    sy *= t[tlen - 1];
                } else if (tlen == 5) {
                    if (absolute) {
                        x2 = inver.x(t[3], t[4]);
                        y2 = inver.y(t[3], t[4]);
                        m.scale(t[1], t[2], x2, y2);
                    } else m.scale(t[1], t[2], t[3], t[4]);
                    sx *= t[1];
                    sy *= t[2];
                }
            } else if (command == 'm' && tlen == 7) m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
            _.dirtyT = 1;
            el.matrix = m;
        }
        /* \
       * Element.matrix
       [ property (object) ]
       **
       * Keeps @Matrix object, which represents element transformation
      \ */ el.matrix = m;
        _.sx = sx;
        _.sy = sy;
        _.deg = deg;
        _.dx = dx = m.e;
        _.dy = dy = m.f;
        if (sx == 1 && sy == 1 && !deg && _.bbox) {
            _.bbox.x += +dx;
            _.bbox.y += +dy;
        } else _.dirtyT = 1;
    };
    const getEmpty = function(item) {
        const l = item[0];
        switch(l.toLowerCase()){
            case 't':
                return [
                    l,
                    0,
                    0
                ];
            case 'm':
                return [
                    l,
                    1,
                    0,
                    0,
                    1,
                    0,
                    0
                ];
            case 'r':
                if (item.length == 4) return [
                    l,
                    0,
                    item[2],
                    item[3]
                ];
                return [
                    l,
                    0
                ];
            case 's':
                if (item.length == 5) return [
                    l,
                    1,
                    1,
                    item[3],
                    item[4]
                ];
                if (item.length == 3) return [
                    l,
                    1,
                    1
                ];
                return [
                    l,
                    1
                ];
        }
    };
    const equaliseTransform = R._equaliseTransform = function(t1, t2) {
        t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
        t1 = R.parseTransformString(t1) || [];
        t2 = R.parseTransformString(t2) || [];
        const maxlength = mmax(t1.length, t2.length);
        const from = [];
        const to = [];
        let i = 0;
        let j;
        let jj;
        let tt1;
        let tt2;
        for(; i < maxlength; i++){
            tt1 = t1[i] || getEmpty(t2[i]);
            tt2 = t2[i] || getEmpty(tt1);
            if (tt1[0] != tt2[0] || tt1[0].toLowerCase() == 'r' && (tt1[2] != tt2[2] || tt1[3] != tt2[3]) || tt1[0].toLowerCase() == 's' && (tt1[3] != tt2[3] || tt1[4] != tt2[4])) return;
            from[i] = [];
            to[i] = [];
            for(j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++){
                j in tt1 && (from[i][j] = tt1[j]);
                j in tt2 && (to[i][j] = tt2[j]);
            }
        }
        return {
            from,
            to
        };
    };
    R._getContainer = function(x, y, w, h) {
        let container;
        container = h == null && !R.is(x, 'object') ? g.doc.getElementById(x) : x;
        if (container == null) return;
        if (container.tagName) {
            if (y == null) return {
                container,
                width: container.style.pixelWidth || container.offsetWidth,
                height: container.style.pixelHeight || container.offsetHeight
            };
            return {
                container,
                width: y,
                height: w
            };
        }
        return {
            container: 1,
            x,
            y,
            width: w,
            height: h
        };
    };
    /* \
   * Raphael.pathToRelative
   [ method ]
   **
   * Utility method
   **
   * Converts path to relative form
   > Parameters
   - pathString (string|array) path string or array of segments
   = (array) array of segments.
  \ */ R.pathToRelative = pathToRelative;
    R._engine = {};
    /* \
   * Raphael.path2curve
   [ method ]
   **
   * Utility method
   **
   * Converts path to a new path where all segments are cubic bezier curves.
   > Parameters
   - pathString (string|array) path string or array of segments
   = (array) array of segments.
  \ */ R.path2curve = path2curve;
    /* \
   * Raphael.matrix
   [ method ]
   **
   * Utility method
   **
   * Returns matrix based on given parameters.
   > Parameters
   - a (number)
   - b (number)
   - c (number)
   - d (number)
   - e (number)
   - f (number)
   = (object) @Matrix
  \ */ R.matrix = function(a, b, c, d, e, f) {
        return new Matrix(a, b, c, d, e, f);
    };
    function Matrix(a, b, c, d, e, f) {
        if (a != null) {
            this.a = +a;
            this.b = +b;
            this.c = +c;
            this.d = +d;
            this.e = +e;
            this.f = +f;
        } else {
            this.a = 1;
            this.b = 0;
            this.c = 0;
            this.d = 1;
            this.e = 0;
            this.f = 0;
        }
    }
    (function(matrixproto) {
        /* \
     * Matrix.add
     [ method ]
     **
     * Adds given matrix to existing one.
     > Parameters
     - a (number)
     - b (number)
     - c (number)
     - d (number)
     - e (number)
     - f (number)
     or
     - matrix (object) @Matrix
    \ */ matrixproto.add = function(a, b, c, d, e, f) {
            const out = [
                [],
                [],
                []
            ];
            const m = [
                [
                    this.a,
                    this.c,
                    this.e
                ],
                [
                    this.b,
                    this.d,
                    this.f
                ],
                [
                    0,
                    0,
                    1
                ]
            ];
            let matrix = [
                [
                    a,
                    c,
                    e
                ],
                [
                    b,
                    d,
                    f
                ],
                [
                    0,
                    0,
                    1
                ]
            ];
            let x;
            let y;
            let z;
            let res;
            if (a && a instanceof Matrix) matrix = [
                [
                    a.a,
                    a.c,
                    a.e
                ],
                [
                    a.b,
                    a.d,
                    a.f
                ],
                [
                    0,
                    0,
                    1
                ]
            ];
            for(x = 0; x < 3; x++)for(y = 0; y < 3; y++){
                res = 0;
                for(z = 0; z < 3; z++)res += m[x][z] * matrix[z][y];
                out[x][y] = res;
            }
            this.a = out[0][0];
            this.b = out[1][0];
            this.c = out[0][1];
            this.d = out[1][1];
            this.e = out[0][2];
            this.f = out[1][2];
        };
        /* \
     * Matrix.invert
     [ method ]
     **
     * Returns inverted version of the matrix
     = (object) @Matrix
    \ */ matrixproto.invert = function() {
            const me = this;
            const x = me.a * me.d - me.b * me.c;
            return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
        };
        /* \
     * Matrix.clone
     [ method ]
     **
     * Returns copy of the matrix
     = (object) @Matrix
    \ */ matrixproto.clone = function() {
            return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
        };
        /* \
     * Matrix.translate
     [ method ]
     **
     * Translate the matrix
     > Parameters
     - x (number)
     - y (number)
    \ */ matrixproto.translate = function(x, y) {
            this.add(1, 0, 0, 1, x, y);
        };
        /* \
     * Matrix.scale
     [ method ]
     **
     * Scales the matrix
     > Parameters
     - x (number)
     - y (number) #optional
     - cx (number) #optional
     - cy (number) #optional
    \ */ matrixproto.scale = function(x, y, cx, cy) {
            y == null && (y = x);
            (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
            this.add(x, 0, 0, y, 0, 0);
            (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
        };
        /* \
     * Matrix.rotate
     [ method ]
     **
     * Rotates the matrix
     > Parameters
     - a (number)
     - x (number)
     - y (number)
    \ */ matrixproto.rotate = function(a, x, y) {
            a = R.rad(a);
            x = x || 0;
            y = y || 0;
            const cos = +math.cos(a).toFixed(9);
            const sin = +math.sin(a).toFixed(9);
            this.add(cos, sin, -sin, cos, x, y);
            this.add(1, 0, 0, 1, -x, -y);
        };
        /* \
     * Matrix.x
     [ method ]
     **
     * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
     > Parameters
     - x (number)
     - y (number)
     = (number) x
    \ */ matrixproto.x = function(x, y) {
            return x * this.a + y * this.c + this.e;
        };
        /* \
     * Matrix.y
     [ method ]
     **
     * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
     > Parameters
     - x (number)
     - y (number)
     = (number) y
    \ */ matrixproto.y = function(x, y) {
            return x * this.b + y * this.d + this.f;
        };
        matrixproto.get = function(i) {
            return +this[Str.fromCharCode(97 + i)].toFixed(4);
        };
        matrixproto.toString = function() {
            return R.svg ? `matrix(${[
                this.get(0),
                this.get(1),
                this.get(2),
                this.get(3),
                this.get(4),
                this.get(5)
            ].join()})` : [
                this.get(0),
                this.get(2),
                this.get(1),
                this.get(3),
                0,
                0
            ].join();
        };
        matrixproto.toFilter = function() {
            return `progid:DXImageTransform.Microsoft.Matrix(M11=${this.get(0)}, M12=${this.get(2)}, M21=${this.get(1)}, M22=${this.get(3)}, Dx=${this.get(4)}, Dy=${this.get(5)}, sizingmethod='auto expand')`;
        };
        matrixproto.offset = function() {
            return [
                this.e.toFixed(4),
                this.f.toFixed(4)
            ];
        };
        function norm(a) {
            return a[0] * a[0] + a[1] * a[1];
        }
        function normalize(a) {
            const mag = math.sqrt(norm(a));
            a[0] && (a[0] /= mag);
            a[1] && (a[1] /= mag);
        }
        /* \
     * Matrix.split
     [ method ]
     **
     * Splits matrix into primitive transformations
     = (object) in format:
     o dx (number) translation by x
     o dy (number) translation by y
     o scalex (number) scale by x
     o scaley (number) scale by y
     o shear (number) shear
     o rotate (number) rotation in deg
     o isSimple (boolean) could it be represented via simple transformations
    \ */ matrixproto.split = function() {
            const out = {};
            // translation
            out.dx = this.e;
            out.dy = this.f;
            // scale and shear
            const row = [
                [
                    this.a,
                    this.c
                ],
                [
                    this.b,
                    this.d
                ]
            ];
            out.scalex = math.sqrt(norm(row[0]));
            normalize(row[0]);
            out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
            row[1] = [
                row[1][0] - row[0][0] * out.shear,
                row[1][1] - row[0][1] * out.shear
            ];
            out.scaley = math.sqrt(norm(row[1]));
            normalize(row[1]);
            out.shear /= out.scaley;
            // rotation
            const sin = -row[0][1];
            const cos = row[1][1];
            if (cos < 0) {
                out.rotate = R.deg(math.acos(cos));
                if (sin < 0) out.rotate = 360 - out.rotate;
            } else out.rotate = R.deg(math.asin(sin));
            out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
            out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
            out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
            return out;
        };
        /* \
     * Matrix.toTransformString
     [ method ]
     **
     * Return transform string that represents given matrix
     = (string) transform string
    \ */ matrixproto.toTransformString = function(shorter) {
            const s = shorter || this[split]();
            if (s.isSimple) {
                s.scalex = +s.scalex.toFixed(4);
                s.scaley = +s.scaley.toFixed(4);
                s.rotate = +s.rotate.toFixed(4);
                return (s.dx || s.dy ? `t${[
                    s.dx,
                    s.dy
                ]}` : E) + (s.scalex != 1 || s.scaley != 1 ? `s${[
                    s.scalex,
                    s.scaley,
                    0,
                    0
                ]}` : E) + (s.rotate ? `r${[
                    s.rotate,
                    0,
                    0
                ]}` : E);
            }
            return `m${[
                this.get(0),
                this.get(1),
                this.get(2),
                this.get(3),
                this.get(4),
                this.get(5)
            ]}`;
        };
    })(Matrix.prototype);
    const preventDefault = function() {
        this.returnValue = false;
    };
    const preventTouch = function() {
        return this.originalEvent.preventDefault();
    };
    const stopPropagation = function() {
        this.cancelBubble = true;
    };
    const stopTouch = function() {
        return this.originalEvent.stopPropagation();
    };
    const getEventPosition = function(e) {
        const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
        const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
        return {
            x: e.clientX + scrollX,
            y: e.clientY + scrollY
        };
    };
    const addEvent = function() {
        if (g.doc.addEventListener) return function(obj, type, fn, element) {
            const f = function(e) {
                const pos = getEventPosition(e);
                return fn.call(element, e, pos.x, pos.y);
            };
            obj.addEventListener(type, f, false);
            if (supportsTouch && touchMap[type]) {
                var _f = function(e) {
                    const pos = getEventPosition(e);
                    const olde = e;
                    for(let i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++)if (e.targetTouches[i].target == obj) {
                        e = e.targetTouches[i];
                        e.originalEvent = olde;
                        e.preventDefault = preventTouch;
                        e.stopPropagation = stopTouch;
                        break;
                    }
                    return fn.call(element, e, pos.x, pos.y);
                };
                obj.addEventListener(touchMap[type], _f, false);
            }
            return function() {
                obj.removeEventListener(type, f, false);
                if (supportsTouch && touchMap[type]) obj.removeEventListener(touchMap[type], _f, false);
                return true;
            };
        };
        if (g.doc.attachEvent) return function(obj, type, fn, element) {
            const f = function(e) {
                e = e || g.win.event;
                const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
                const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
                const x = e.clientX + scrollX;
                const y = e.clientY + scrollY;
                e.preventDefault = e.preventDefault || preventDefault;
                e.stopPropagation = e.stopPropagation || stopPropagation;
                return fn.call(element, e, x, y);
            };
            obj.attachEvent(`on${type}`, f);
            const detacher = function() {
                obj.detachEvent(`on${type}`, f);
                return true;
            };
            return detacher;
        };
    }();
    let drag = [];
    const dragMove = function(e) {
        let x = e.clientX;
        let y = e.clientY;
        const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
        const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
        let dragi;
        let j = drag.length;
        while(j--){
            dragi = drag[j];
            if (supportsTouch && e.touches) {
                let i = e.touches.length;
                var touch;
                while(i--){
                    touch = e.touches[i];
                    if (touch.identifier == dragi.el._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        (e.originalEvent ? e.originalEvent : e).preventDefault();
                        break;
                    }
                }
            } else e.preventDefault();
            const { node } = dragi.el;
            var o;
            if (node) {
                const next = node.nextSibling;
                const parent = node.parentNode;
                const { display } = node.style;
                g.win.opera && parent.removeChild(node);
                node.style.display = 'none';
                o = dragi.el.paper.getElementByPoint(x, y);
                node.style.display = display;
                g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
                o && (0, _eveJs.eve)(`raphael.drag.over.${dragi.el.id}`, dragi.el, o);
                x += scrollX;
                y += scrollY;
                (0, _eveJs.eve)(`raphael.drag.move.${dragi.el.id}`, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
            }
        }
    };
    var dragUp = function(e) {
        R.unmousemove(dragMove).unmouseup(dragUp);
        let i = drag.length;
        let dragi;
        while(i--){
            dragi = drag[i];
            dragi.el._drag = {};
            (0, _eveJs.eve)(`raphael.drag.end.${dragi.el.id}`, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
        }
        drag = [];
    };
    /* \
     * Raphael.el
     [ property (object) ]
     **
     * You can add your own method to elements. This is useful when you want to hack default functionality or
     * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
     * you can redefine element method at any time. Expending element methods wouldnt affect set.
     > Usage
     | Raphael.el.red = function () {
     |     this.attr({fill: "#f00"});
     | };
     | // then use it
     | paper.circle(100, 100, 20).red();
    \ */ const elproto = R.el = {};
    /* \
   * Element.click
   [ method ]
   **
   * Adds event handler for click for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unclick
   [ method ]
   **
   * Removes event handler for click for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.dblclick
   [ method ]
   **
   * Adds event handler for double click for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.undblclick
   [ method ]
   **
   * Removes event handler for double click for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mousedown
   [ method ]
   **
   * Adds event handler for mousedown for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmousedown
   [ method ]
   **
   * Removes event handler for mousedown for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mousemove
   [ method ]
   **
   * Adds event handler for mousemove for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmousemove
   [ method ]
   **
   * Removes event handler for mousemove for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseout
   [ method ]
   **
   * Adds event handler for mouseout for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseout
   [ method ]
   **
   * Removes event handler for mouseout for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseover
   [ method ]
   **
   * Adds event handler for mouseover for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseover
   [ method ]
   **
   * Removes event handler for mouseover for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.mouseup
   [ method ]
   **
   * Adds event handler for mouseup for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.unmouseup
   [ method ]
   **
   * Removes event handler for mouseup for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchstart
   [ method ]
   **
   * Adds event handler for touchstart for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchstart
   [ method ]
   **
   * Removes event handler for touchstart for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchmove
   [ method ]
   **
   * Adds event handler for touchmove for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchmove
   [ method ]
   **
   * Removes event handler for touchmove for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchend
   [ method ]
   **
   * Adds event handler for touchend for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchend
   [ method ]
   **
   * Removes event handler for touchend for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ /* \
   * Element.touchcancel
   [ method ]
   **
   * Adds event handler for touchcancel for the element.
   > Parameters
   - handler (function) handler for the event
   = (object) @Element
  \ */ /* \
   * Element.untouchcancel
   [ method ]
   **
   * Removes event handler for touchcancel for the element.
   > Parameters
   - handler (function) #optional handler for the event
   = (object) @Element
  \ */ for(let i = events.length; i--;)(function(eventName) {
        R[eventName] = elproto[eventName] = function(fn, scope) {
            if (R.is(fn, 'function')) {
                this.events = this.events || [];
                this.events.push({
                    name: eventName,
                    f: fn,
                    unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)
                });
            }
            return this;
        };
        R[`un${eventName}`] = elproto[`un${eventName}`] = function(fn) {
            const events = this.events || [];
            let l = events.length;
            while(l--)if (events[l].name == eventName && (R.is(fn, 'undefined') || events[l].f == fn)) {
                events[l].unbind();
                events.splice(l, 1);
                !events.length && delete this.events;
            }
            return this;
        };
    })(events[i]);
    /* \
   * Element.data
   [ method ]
   **
   * Adds or retrieves given value associated with given key.
   **
   * See also @Element.removeData
   > Parameters
   - key (string) key to store data
   - value (any) #optional value to store
   = (object) @Element
   * or, if value is not specified:
   = (any) value
   * or, if key and value are not specified:
   = (object) Key/value pairs for all the data associated with the element.
   > Usage
   | for (var i = 0, i < 5, i++) {
   |     paper.circle(10 + 15 * i, 10, 10)
   |          .attr({fill: "#000"})
   |          .data("i", i)
   |          .click(function () {
   |             alert(this.data("i"));
   |          });
   | }
  \ */ elproto.data = function(key, value) {
        const data = eldata[this.id] = eldata[this.id] || {};
        if (arguments.length == 0) return data;
        if (arguments.length == 1) {
            if (R.is(key, 'object')) {
                for(const i in key)if (key[has](i)) this.data(i, key[i]);
                return this;
            }
            (0, _eveJs.eve)(`raphael.data.get.${this.id}`, this, data[key], key);
            return data[key];
        }
        data[key] = value;
        (0, _eveJs.eve)(`raphael.data.set.${this.id}`, this, value, key);
        return this;
    };
    /* \
   * Element.removeData
   [ method ]
   **
   * Removes value associated with an element by given key.
   * If key is not provided, removes all the data of the element.
   > Parameters
   - key (string) #optional key
   = (object) @Element
  \ */ elproto.removeData = function(key) {
        if (key == null) eldata[this.id] = {};
        else eldata[this.id] && delete eldata[this.id][key];
        return this;
    };
    /* \
    * Element.getData
    [ method ]
    **
    * Retrieves the element data
    = (object) data
  \ */ elproto.getData = function() {
        return clone(eldata[this.id] || {});
    };
    /* \
   * Element.hover
   [ method ]
   **
   * Adds event handlers for hover for the element.
   > Parameters
   - f_in (function) handler for hover in
   - f_out (function) handler for hover out
   - icontext (object) #optional context for hover in handler
   - ocontext (object) #optional context for hover out handler
   = (object) @Element
  \ */ elproto.hover = function(f_in, f_out, scope_in, scope_out) {
        return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
    };
    /* \
   * Element.unhover
   [ method ]
   **
   * Removes event handlers for hover for the element.
   > Parameters
   - f_in (function) handler for hover in
   - f_out (function) handler for hover out
   = (object) @Element
  \ */ elproto.unhover = function(f_in, f_out) {
        return this.unmouseover(f_in).unmouseout(f_out);
    };
    const draggable = [];
    /* \
   * Element.drag
   [ method ]
   **
   * Adds event handlers for drag of the element.
   > Parameters
   - onmove (function) handler for moving
   - onstart (function) handler for drag start
   - onend (function) handler for drag end
   - mcontext (object) #optional context for moving handler
   - scontext (object) #optional context for drag start handler
   - econtext (object) #optional context for drag end handler
   * Additionally following `drag` events will be triggered: `drag.start.<id>` on start,
   * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element
   * `drag.over.<id>` will be fired as well.
   *
   * Start event and start handler will be called in specified context or in context of the element with following parameters:
   o x (number) x position of the mouse
   o y (number) y position of the mouse
   o event (object) DOM event object
   * Move event and move handler will be called in specified context or in context of the element with following parameters:
   o dx (number) shift by x from the start point
   o dy (number) shift by y from the start point
   o x (number) x position of the mouse
   o y (number) y position of the mouse
   o event (object) DOM event object
   * End event and end handler will be called in specified context or in context of the element with following parameters:
   o event (object) DOM event object
   = (object) @Element
  \ */ elproto.drag = function(onmove, onstart, onend, move_scope, start_scope, end_scope) {
        function start(e) {
            (e.originalEvent || e).preventDefault();
            let x = e.clientX;
            let y = e.clientY;
            const scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop;
            const scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
            this._drag.id = e.identifier;
            if (supportsTouch && e.touches) {
                let i = e.touches.length;
                let touch;
                while(i--){
                    touch = e.touches[i];
                    this._drag.id = touch.identifier;
                    if (touch.identifier == this._drag.id) {
                        x = touch.clientX;
                        y = touch.clientY;
                        break;
                    }
                }
            }
            this._drag.x = x + scrollX;
            this._drag.y = y + scrollY;
            !drag.length && R.mousemove(dragMove).mouseup(dragUp);
            drag.push({
                el: this,
                move_scope,
                start_scope,
                end_scope
            });
            onstart && (0, _eveJs.eve).on(`raphael.drag.start.${this.id}`, onstart);
            onmove && (0, _eveJs.eve).on(`raphael.drag.move.${this.id}`, onmove);
            onend && (0, _eveJs.eve).on(`raphael.drag.end.${this.id}`, onend);
            (0, _eveJs.eve)(`raphael.drag.start.${this.id}`, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
        }
        this.start = start // SLATEBOX - makes text draggable
        ;
        this._drag = {};
        draggable.push({
            el: this,
            start
        });
        this.mousedown(start);
        return this;
    };
    /* \
   * Element.onDragOver
   [ method ]
   **
   * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
   > Parameters
   - f (function) handler for event, first argument would be the element you are dragging over
  \ */ elproto.onDragOver = function(f) {
        f ? (0, _eveJs.eve).on(`raphael.drag.over.${this.id}`, f) : (0, _eveJs.eve).unbind(`raphael.drag.over.${this.id}`);
    };
    /* \
   * Element.undrag
   [ method ]
   **
   * Removes all drag event handlers from given element.
  \ */ elproto.undrag = function() {
        let i = draggable.length;
        while(i--)if (draggable[i].el == this) {
            this.unmousedown(draggable[i].start);
            draggable.splice(i, 1);
            (0, _eveJs.eve).unbind(`raphael.drag.*.${this.id}`);
        }
        !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
        drag = [];
    };
    /* \
   * Paper.circle
   [ method ]
   **
   * Draws a circle.
   **
   > Parameters
   **
   - x (number) x coordinate of the centre
   - y (number) y coordinate of the centre
   - r (number) radius
   = (object) Raphal element object with type circle
   **
   > Usage
   | var c = paper.circle(50, 50, 40);
  \ */ paperproto.circle = function(x, y, r) {
        const out = R._engine.circle(this, x || 0, y || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.rect
   [ method ]
   *
   * Draws a rectangle.
   **
   > Parameters
   **
   - x (number) x coordinate of the top left corner
   - y (number) y coordinate of the top left corner
   - width (number) width
   - height (number) height
   - r (number) #optional radius for rounded corners, default is 0
   = (object) Raphal element object with type rect
   **
   > Usage
   | // regular rectangle
   | var c = paper.rect(10, 10, 50, 50);
   | // rectangle with rounded corners
   | var c = paper.rect(40, 40, 50, 50, 10);
  \ */ paperproto.rect = function(x, y, w, h, r) {
        const out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
     * Paper.g
     [ method ]
     *
     * Draws a svg group (g) element.
     **
    \ */ paperproto.g = function() {
        const out = R._engine.g(this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
     * Paper.def
     [ method ]
     *
     * Adds a <def>
     **
    \ */ paperproto.def = function(def) {
        R._engine.def.call(this, def);
    };
    /* \
   * Paper.ellipse
   [ method ]
   **
   * Draws an ellipse.
   **
   > Parameters
   **
   - x (number) x coordinate of the centre
   - y (number) y coordinate of the centre
   - rx (number) horizontal radius
   - ry (number) vertical radius
   = (object) Raphal element object with type ellipse
   **
   > Usage
   | var c = paper.ellipse(50, 50, 40, 20);
  \ */ paperproto.ellipse = function(x, y, rx, ry) {
        const out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.path
   [ method ]
   **
   * Creates a path element by given path data string.
   > Parameters
   - pathString (string) #optional path string in SVG format.
   * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
   | "M10,20L30,40"
   * Here we can see two commands: M, with arguments `(10, 20)` and L with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caserelative.
   *
   # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
   # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
   # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
   # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
   # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
   # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
   # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
   # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
   # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
   # <tr><td>Q</td><td>quadratic Bzier curveto</td><td>(x1 y1 x y)+</td></tr>
   # <tr><td>T</td><td>smooth quadratic Bzier curveto</td><td>(x y)+</td></tr>
   # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
   # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/CatmullRom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
   * * Catmull-Rom curveto is a not standard SVG command and added in 2.0 to make life easier.
   * Note: there is a special case when path consist of just three commands: M10,10Rz. In this case path will smoothly connects to its beginning.
   > Usage
   | var c = paper.path("M10 10L90 90");
   | // draw a diagonal line:
   | // move to 10,10, line to 90,90
   * For example of path strings, check out these icons: http://raphaeljs.com/icons/
  \ */ paperproto.path = function(pathString) {
        pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
        const out = R._engine.path(R.format[apply](R, arguments), this);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.image
   [ method ]
   **
   * Embeds an image into the surface.
   **
   > Parameters
   **
   - src (string) URI of the source image
   - x (number) x coordinate position
   - y (number) y coordinate position
   - width (number) width of the image
   - height (number) height of the image
   = (object) Raphal element object with type image
   **
   > Usage
   | var c = paper.image("apple.png", 10, 10, 80, 80);
  \ */ paperproto.image = function(src, x, y, w, h) {
        const out = R._engine.image(this, src || 'about:blank', x || 0, y || 0, w || 0, h || 0);
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.text
   [ method ]
   **
   * Draws a text string. If you need line breaks, put \n in the string.
   **
   > Parameters
   **
   - x (number) x coordinate position
   - y (number) y coordinate position
   - text (string) The text string to draw
   = (object) Raphal element object with type text
   **
   > Usage
   | var t = paper.text(50, 50, "Raphal\nkicks\nbutt!");
  \ */ paperproto.text = function(x, y, text) {
        const out = R._engine.text(this, x || 0, y || 0, Str(text));
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Paper.set
   [ method ]
   **
   * Creates array-like object to keep and operate several elements at once.
   * Warning: it doesnt create any elements for itself in the page, it just groups existing elements.
   * Sets act as pseudo elements  all methods available to an element can be used on a set.
   = (object) array-like object that represents set of elements
   **
   > Usage
   | var st = paper.set();
   | st.push(
   |     paper.circle(10, 10, 5),
   |     paper.circle(30, 10, 5)
   | );
   | st.attr({fill: "red"}); // changes the fill of both circles
  \ */ paperproto.set = function(itemsArray) {
        !R.is(itemsArray, 'array') && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
        const out = new Set(itemsArray);
        this.__set__ && this.__set__.push(out);
        out.paper = this;
        out.type = 'set';
        return out;
    };
    /* \
   * Paper.setStart
   [ method ]
   **
   * Creates @Paper.set. All elements that will be created after calling this method and before calling
   * @Paper.setFinish will be added to the set.
   **
   > Usage
   | paper.setStart();
   | paper.circle(10, 10, 5),
   | paper.circle(30, 10, 5)
   | var st = paper.setFinish();
   | st.attr({fill: "red"}); // changes the fill of both circles
  \ */ paperproto.setStart = function(set) {
        this.__set__ = set || this.set();
    };
    /* \
   * Paper.setFinish
   [ method ]
   **
   * See @Paper.setStart. This method finishes catching and returns resulting set.
   **
   = (object) set
  \ */ paperproto.setFinish = function(set) {
        const out = this.__set__;
        delete this.__set__;
        return out;
    };
    /* \
   * Paper.getSize
   [ method ]
   **
   * Obtains current paper actual size.
   **
   = (object)
   \ */ paperproto.getSize = function() {
        const container = this.canvas.parentNode;
        return {
            width: container.offsetWidth,
            height: container.offsetHeight
        };
    };
    /* \
   * Paper.setSize
   [ method ]
   **
   * If you need to change dimensions of the canvas call this method
   **
   > Parameters
   **
   - width (number) new width of the canvas
   - height (number) new height of the canvas
  \ */ paperproto.setSize = function(width, height) {
        return R._engine.setSize.call(this, width, height);
    };
    /* \
   * Paper.setViewBox
   [ method ]
   **
   * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by
   * specifying new boundaries.
   **
   > Parameters
   **
   - x (number) new x position, default is `0`
   - y (number) new y position, default is `0`
   - w (number) new width of the canvas
   - h (number) new height of the canvas
   - fit (boolean) `true` if you want graphics to fit into new boundary box
  \ */ paperproto.setViewBox = function(x, y, w, h, fit) {
        return R._engine.setViewBox.call(this, x, y, w, h, fit);
    };
    /* \
   * Paper.top
   [ property ]
   **
   * Points to the topmost element on the paper
  \ */ /* \
   * Paper.bottom
   [ property ]
   **
   * Points to the bottom element on the paper
  \ */ paperproto.top = paperproto.bottom = null;
    /* \
   * Paper.raphael
   [ property ]
   **
   * Points to the @Raphael object/function
  \ */ paperproto.raphael = R;
    const getOffset = function(elem) {
        const box = elem.getBoundingClientRect();
        const doc = elem.ownerDocument;
        const { body } = doc;
        const docElem = doc.documentElement;
        const clientTop = docElem.clientTop || body.clientTop || 0;
        const clientLeft = docElem.clientLeft || body.clientLeft || 0;
        const top = box.top + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop) - clientTop;
        const left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
        return {
            y: top,
            x: left
        };
    };
    /* \
   * Paper.getElementByPoint
   [ method ]
   **
   * Returns you topmost element under given point.
   **
   = (object) Raphal element object
   > Parameters
   **
   - x (number) x coordinate from the top left corner of the window
   - y (number) y coordinate from the top left corner of the window
   > Usage
   | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
  \ */ paperproto.getElementByPoint = function(x, y) {
        const paper = this;
        const svg = paper.canvas;
        let target = g.doc.elementFromPoint(x, y);
        if (g.win.opera && target.tagName == 'svg') {
            const so = getOffset(svg);
            const sr = svg.createSVGRect();
            sr.x = x - so.x;
            sr.y = y - so.y;
            sr.width = sr.height = 1;
            const hits = svg.getIntersectionList(sr, null);
            if (hits.length) target = hits[hits.length - 1];
        }
        if (!target) return null;
        while(target.parentNode && target != svg.parentNode && !target.raphael)target = target.parentNode;
        target == paper.canvas.parentNode && (target = svg);
        target = target && target.raphael ? paper.getById(target.raphaelid) : null;
        return target;
    };
    /* \
   * Paper.getElementsByBBox
   [ method ]
   **
   * Returns set of elements that have an intersecting bounding box
   **
   > Parameters
   **
   - bbox (object) bbox to check with
   = (object) @Set
   \ */ paperproto.getElementsByBBox = function(bbox) {
        const set = this.set();
        this.forEach((el)=>{
            if (R.isBBoxIntersect(el.getBBox(), bbox)) set.push(el);
        });
        return set;
    };
    /* \
   * Paper.getById
   [ method ]
   **
   * Returns you element by its internal ID.
   **
   > Parameters
   **
   - id (number) id
   = (object) Raphal element object
  \ */ paperproto.getById = function(id) {
        let bot = this.bottom;
        while(bot){
            if (bot.id == id) return bot;
            bot = bot.next;
        }
        return null;
    };
    /* \
   * Paper.forEach
   [ method ]
   **
   * Executes given function for each element on the paper
   *
   * If callback function returns `false` it will stop loop running.
   **
   > Parameters
   **
   - callback (function) function to run
   - thisArg (object) context object for the callback
   = (object) Paper object
   > Usage
   | paper.forEach(function (el) {
   |     el.attr({ stroke: "blue" });
   | });
  \ */ paperproto.forEach = function(callback, thisArg) {
        let bot = this.bottom;
        while(bot){
            if (callback.call(thisArg, bot) === false) return this;
            bot = bot.next;
        }
        return this;
    };
    /* \
   * Paper.getElementsByPoint
   [ method ]
   **
   * Returns set of elements that have common point inside
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (object) @Set
  \ */ paperproto.getElementsByPoint = function(x, y) {
        const set = this.set();
        this.forEach((el)=>{
            if (el.isPointInside(x, y)) set.push(el);
        });
        return set;
    };
    function x_y() {
        return this.x + S + this.y;
    }
    function x_y_w_h() {
        return `${this.x + S + this.y + S + this.width} \xd7 ${this.height}`;
    }
    /* \
   * Element.isPointInside
   [ method ]
   **
   * Determine if given point is inside this elements shape
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (boolean) `true` if point inside the shape
  \ */ elproto.isPointInside = function(x, y) {
        let rp = this.realPath = getPath[this.type](this);
        if (this.attr('transform') && this.attr('transform').length) rp = R.transformPath(rp, this.attr('transform'));
        return R.isPointInsidePath(rp, x, y);
    };
    /* \
   * Element.getBBox
   [ method ]
   **
   * Return bounding box for a given element
   **
   > Parameters
   **
   - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
   = (object) Bounding box object:
   o {
   o     x: (number) top left corner x
   o     y: (number) top left corner y
   o     x2: (number) bottom right corner x
   o     y2: (number) bottom right corner y
   o     width: (number) width
   o     height: (number) height
   o }
  \ */ elproto.getBBox = function(isWithoutTransform) {
        if (this.removed) return {};
        const { _ } = this;
        if (isWithoutTransform) {
            if (_.dirty || !_.bboxwt) {
                this.realPath = getPath[this.type](this);
                _.bboxwt = pathDimensions(this.realPath);
                _.bboxwt.toString = x_y_w_h;
                _.dirty = 0;
            }
            return _.bboxwt;
        }
        if (_.dirty || _.dirtyT || !_.bbox) {
            if (_.dirty || !this.realPath) {
                _.bboxwt = 0;
                this.realPath = getPath[this.type](this);
            }
            _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
            _.bbox.toString = x_y_w_h;
            _.dirty = _.dirtyT = 0;
        }
        return _.bbox;
    };
    /* \
   * Element.clone
   [ method ]
   **
   = (object) clone of a given element
   **
  \ */ elproto.clone = function() {
        if (this.removed) return null;
        const out = this.paper[this.type]().attr(this.attr());
        this.__set__ && this.__set__.push(out);
        return out;
    };
    /* \
   * Element.glow
   [ method ]
   **
   * Return set of elements that create glow-like effect around given element. See @Paper.set.
   *
   * Note: Glow is not connected to the element. If you change element attributes it wont adjust itself.
   **
   > Parameters
   **
   - glow (object) #optional parameters object with all properties optional:
   o {
   o     width (number) size of the glow, default is `10`
   o     fill (boolean) will it be filled, default is `false`
   o     opacity (number) opacity, default is `0.5`
   o     offsetx (number) horizontal offset, default is `0`
   o     offsety (number) vertical offset, default is `0`
   o     color (string) glow colour, default is `black`
   o }
   = (object) @Paper.set of elements that represents glow
  \ */ elproto.glow = function(glow) {
        if (this.type == 'text') return null;
        glow = glow || {};
        const s = {
            width: (glow.width || 10) + (+this.attr('stroke-width') || 1),
            fill: glow.fill || false,
            opacity: glow.opacity == null ? 0.5 : glow.opacity,
            offsetx: glow.offsetx || 0,
            offsety: glow.offsety || 0,
            color: glow.color || '#000'
        };
        const c = s.width / 2;
        const r = this.paper;
        const out = r.set();
        let path = this.realPath || getPath[this.type](this);
        path = this.matrix ? mapPath(path, this.matrix) : path;
        for(let i = 1; i < c + 1; i++)out.push(r.path(path).attr({
            stroke: s.color,
            fill: s.fill ? s.color : 'none',
            'stroke-linejoin': 'round',
            'stroke-linecap': 'round',
            'stroke-width': +(s.width / c * i).toFixed(3),
            opacity: +(s.opacity / c).toFixed(3)
        }));
        return out.insertBefore(this).translate(s.offsetx, s.offsety);
    };
    const curveslengths = {};
    const getPointAtSegmentLength = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
        if (length == null) return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
        return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
    };
    const getLengthFactory = function(istotal, subpath) {
        return function(path, length, onlystart) {
            path = path2curve(path);
            let x;
            let y;
            let p;
            let l;
            let sp = '';
            const subpaths = {};
            let point;
            let len = 0;
            for(let i = 0, ii = path.length; i < ii; i++){
                p = path[i];
                if (p[0] == 'M') {
                    x = +p[1];
                    y = +p[2];
                } else {
                    l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                    if (len + l > length) {
                        if (subpath && !subpaths.start) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            sp += [
                                `C${point.start.x}`,
                                point.start.y,
                                point.m.x,
                                point.m.y,
                                point.x,
                                point.y
                            ];
                            if (onlystart) return sp;
                            subpaths.start = sp;
                            sp = [
                                `M${point.x}`,
                                `${point.y}C${point.n.x}`,
                                point.n.y,
                                point.end.x,
                                point.end.y,
                                p[5],
                                p[6]
                            ].join();
                            len += l;
                            x = +p[5];
                            y = +p[6];
                            continue;
                        }
                        if (!istotal && !subpath) {
                            point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                            return {
                                x: point.x,
                                y: point.y,
                                alpha: point.alpha
                            };
                        }
                    }
                    len += l;
                    x = +p[5];
                    y = +p[6];
                }
                sp += p.shift() + p;
            }
            subpaths.end = sp;
            point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
            point.alpha && (point = {
                x: point.x,
                y: point.y,
                alpha: point.alpha
            });
            return point;
        };
    };
    const getTotalLength = getLengthFactory(1);
    const getPointAtLength = getLengthFactory();
    const getSubpathsAtLength = getLengthFactory(0, 1);
    /* \
   * Raphael.getTotalLength
   [ method ]
   **
   * Returns length of the given path in pixels.
   **
   > Parameters
   **
   - path (string) SVG path string.
   **
   = (number) length.
  \ */ R.getTotalLength = getTotalLength;
    /* \
   * Raphael.getPointAtLength
   [ method ]
   **
   * Return coordinates of the point located at the given length on the given path.
   **
   > Parameters
   **
   - path (string) SVG path string
   - length (number)
   **
   = (object) representation of the point:
   o {
   o     x: (number) x coordinate
   o     y: (number) y coordinate
   o     alpha: (number) angle of derivative
   o }
  \ */ R.getPointAtLength = getPointAtLength;
    /* \
   * Raphael.getSubpath
   [ method ]
   **
   * Return subpath of a given path from given length to given length.
   **
   > Parameters
   **
   - path (string) SVG path string
   - from (number) position of the start of the segment
   - to (number) position of the end of the segment
   **
   = (string) pathstring for the segment
  \ */ R.getSubpath = function(path, from, to) {
        if (this.getTotalLength(path) - to < 1e-6) return getSubpathsAtLength(path, from).end;
        const a = getSubpathsAtLength(path, to, 1);
        return from ? getSubpathsAtLength(a, from).end : a;
    };
    /* \
   * Element.getTotalLength
   [ method ]
   **
   * Returns length of the path in pixels. Only works for element of path type.
   = (number) length.
  \ */ elproto.getTotalLength = function() {
        const path = this.getPath();
        if (!path) return;
        if (this.node.getTotalLength) return this.node.getTotalLength();
        return getTotalLength(path);
    };
    /* \
   * Element.getPointAtLength
   [ method ]
   **
   * Return coordinates of the point located at the given length on the given path. Only works for element of path type.
   **
   > Parameters
   **
   - length (number)
   **
   = (object) representation of the point:
   o {
   o     x: (number) x coordinate
   o     y: (number) y coordinate
   o     alpha: (number) angle of derivative
   o }
  \ */ elproto.getPointAtLength = function(length) {
        const path = this.getPath();
        if (!path) return;
        return getPointAtLength(path, length);
    };
    /* \
   * Element.getPath
   [ method ]
   **
   * Returns path of the element. Only works for elements of path type and simple elements like circle.
   = (object) path
   **
  \ */ elproto.getPath = function() {
        let path;
        const getPath = R._getPath[this.type];
        if (this.type == 'text' || this.type == 'set') return;
        if (getPath) path = getPath(this);
        return path;
    };
    /* \
   * Element.getSubpath
   [ method ]
   **
   * Return subpath of a given element from given length to given length. Only works for element of path type.
   **
   > Parameters
   **
   - from (number) position of the start of the segment
   - to (number) position of the end of the segment
   **
   = (string) pathstring for the segment
  \ */ elproto.getSubpath = function(from, to) {
        const path = this.getPath();
        if (!path) return;
        return R.getSubpath(path, from, to);
    };
    /* \
   * Raphael.easing_formulas
   [ property ]
   **
   * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
   # <ul>
   #     <li>linear</li>
   #     <li>&lt; or easeIn or ease-in</li>
   #     <li>> or easeOut or ease-out</li>
   #     <li>&lt;> or easeInOut or ease-in-out</li>
   #     <li>backIn or back-in</li>
   #     <li>backOut or back-out</li>
   #     <li>elastic</li>
   #     <li>bounce</li>
   # </ul>
   # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
  \ */ const ef = R.easing_formulas = {
        linear (n) {
            return n;
        },
        '<': function(n) {
            return n ** 1.7;
        },
        '>': function(n) {
            return n ** 0.48;
        },
        '<>': function(n) {
            const q = 0.48 - n / 1.04;
            const Q = math.sqrt(0.1734 + q * q);
            const x = Q - q;
            const X = abs(x) ** (1 / 3) * (x < 0 ? -1 : 1);
            const y = -Q - q;
            const Y = abs(y) ** (1 / 3) * (y < 0 ? -1 : 1);
            const t = X + Y + 0.5;
            return (1 - t) * 3 * t * t + t * t * t;
        },
        backIn (n) {
            const s = 1.70158;
            return n * n * ((s + 1) * n - s);
        },
        backOut (n) {
            n -= 1;
            const s = 1.70158;
            return n * n * ((s + 1) * n + s) + 1;
        },
        elastic (n) {
            if (n == !!n) return n;
            return 2 ** (-10 * n) * math.sin((n - 0.075) * (2 * PI) / 0.3) + 1;
        },
        bounce (n) {
            const s = 7.5625;
            const p = 2.75;
            let l;
            if (n < 1 / p) l = s * n * n;
            else if (n < 2 / p) {
                n -= 1.5 / p;
                l = s * n * n + 0.75;
            } else if (n < 2.5 / p) {
                n -= 2.25 / p;
                l = s * n * n + 0.9375;
            } else {
                n -= 2.625 / p;
                l = s * n * n + 0.984375;
            }
            return l;
        }
    };
    ef.easeIn = ef['ease-in'] = ef['<'];
    ef.easeOut = ef['ease-out'] = ef['>'];
    ef.easeInOut = ef['ease-in-out'] = ef['<>'];
    ef['back-in'] = ef.backIn;
    ef['back-out'] = ef.backOut;
    const animationElements = [];
    const requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
        setTimeout(callback, 16);
    };
    var animation = function() {
        const Now = +new Date();
        let l = 0;
        for(; l < animationElements.length; l++){
            const e = animationElements[l];
            if (e.el.removed || e.paused) continue;
            let time = Now - e.start;
            var { ms } = e;
            const { easing } = e;
            var { from } = e;
            var { diff } = e;
            const { to } = e;
            const { t } = e;
            const that = e.el;
            const set = {};
            var now;
            const init = {};
            var key;
            if (e.initstatus) {
                time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                e.status = e.initstatus;
                delete e.initstatus;
                e.stop && animationElements.splice(l--, 1);
            } else e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
            if (time < 0) continue;
            if (time < ms) {
                var pos = easing(time / ms);
                for(var attr in from)if (from[has](attr)) {
                    switch(availableAnimAttrs[attr]){
                        case nu:
                            now = +from[attr] + pos * ms * diff[attr];
                            break;
                        case 'colour':
                            now = `rgb(${[
                                upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                upto255(round(from[attr].b + pos * ms * diff[attr].b))
                            ].join(',')})`;
                            break;
                        case 'path':
                            now = [];
                            for(var i = 0, ii = from[attr].length; i < ii; i++){
                                now[i] = [
                                    from[attr][i][0]
                                ];
                                for(var j = 1, jj = from[attr][i].length; j < jj; j++)now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                now[i] = now[i].join(S);
                            }
                            now = now.join(S);
                            break;
                        case 'transform':
                            if (diff[attr].real) {
                                now = [];
                                for(i = 0, ii = from[attr].length; i < ii; i++){
                                    now[i] = [
                                        from[attr][i][0]
                                    ];
                                    for(j = 1, jj = from[attr][i].length; j < jj; j++)now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                }
                            } else {
                                const get = function(i) {
                                    return +from[attr][i] + pos * ms * diff[attr][i];
                                };
                                // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                now = [
                                    [
                                        'm',
                                        get(0),
                                        get(1),
                                        get(2),
                                        get(3),
                                        get(4),
                                        get(5)
                                    ]
                                ];
                            }
                            break;
                        case 'csv':
                            if (attr == 'clip-rect') {
                                now = [];
                                i = 4;
                                while(i--)now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                            }
                            break;
                        default:
                            var from2 = [][concat](from[attr]);
                            now = [];
                            i = that.paper.customAttributes[attr].length;
                            while(i--)now[i] = +from2[i] + pos * ms * diff[attr][i];
                            break;
                    }
                    set[attr] = now;
                }
                that.attr(set);
                (function(id, that, anim) {
                    setTimeout(()=>{
                        (0, _eveJs.eve)(`raphael.anim.frame.${id}`, that, anim);
                    });
                })(that.id, that, e.anim);
            } else {
                (function(f, el, a) {
                    setTimeout(()=>{
                        (0, _eveJs.eve)(`raphael.anim.frame.${el.id}`, el, a);
                        (0, _eveJs.eve)(`raphael.anim.finish.${el.id}`, el, a);
                        R.is(f, 'function') && f.call(el);
                    });
                })(e.callback, that, e.anim);
                that.attr(to);
                animationElements.splice(l--, 1);
                if (e.repeat > 1 && !e.next) {
                    for(key in to)if (to[has](key)) init[key] = e.totalOrigin[key];
                    e.el.attr(init);
                    runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                }
                if (e.next && !e.stop) runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
            }
        }
        animationElements.length && requestAnimFrame(animation);
    };
    var upto255 = function(color) {
        return color > 255 ? 255 : color < 0 ? 0 : color;
    };
    /* \
   * Element.animateWith
   [ method ]
   **
   * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
   **
   > Parameters
   **
   - el (object) element to sync with
   - anim (object) animation to sync with
   - params (object) #optional final attributes for the element, see also @Element.attr
   - ms (number) #optional number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   * or
   - element (object) element to sync with
   - anim (object) animation to sync with
   - animation (object) #optional animation object, see @Raphael.animation
   **
   = (object) original element
  \ */ elproto.animateWith = function(el, anim, params, ms, easing, callback) {
        const element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        const a = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        let x;
        let y;
        runAnimation(a, element, a.percents[0], null, element.attr());
        for(let i = 0, ii = animationElements.length; i < ii; i++)if (animationElements[i].anim == anim && animationElements[i].el == el) {
            animationElements[ii - 1].start = animationElements[i].start;
            break;
        }
        return element;
    //
    //
    // var a = params ? R.animation(params, ms, easing, callback) : anim,
    //     status = element.status(anim);
    // return this.animate(a).status(a, status * anim.ms / a.ms);
    };
    function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
        const cx = 3 * p1x;
        const bx = 3 * (p2x - p1x) - cx;
        const ax = 1 - cx - bx;
        const cy = 3 * p1y;
        const by = 3 * (p2y - p1y) - cy;
        const ay = 1 - cy - by;
        function sampleCurveX(t) {
            return ((ax * t + bx) * t + cx) * t;
        }
        function solve(x, epsilon) {
            const t = solveCurveX(x, epsilon);
            return ((ay * t + by) * t + cy) * t;
        }
        function solveCurveX(x, epsilon) {
            let t0;
            let t1;
            let t2;
            let x2;
            let d2;
            let i;
            for(t2 = x, i = 0; i < 8; i++){
                x2 = sampleCurveX(t2) - x;
                if (abs(x2) < epsilon) return t2;
                d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
                if (abs(d2) < 1e-6) break;
                t2 -= x2 / d2;
            }
            t0 = 0;
            t1 = 1;
            t2 = x;
            if (t2 < t0) return t0;
            if (t2 > t1) return t1;
            while(t0 < t1){
                x2 = sampleCurveX(t2);
                if (abs(x2 - x) < epsilon) return t2;
                if (x > x2) t0 = t2;
                else t1 = t2;
                t2 = (t1 - t0) / 2 + t0;
            }
            return t2;
        }
        return solve(t, 1 / (200 * duration));
    }
    elproto.onAnimation = function(f) {
        f ? (0, _eveJs.eve).on(`raphael.anim.frame.${this.id}`, f) : (0, _eveJs.eve).unbind(`raphael.anim.frame.${this.id}`);
        return this;
    };
    function Animation(anim, ms) {
        const percents = [];
        const newAnim = {};
        this.ms = ms;
        this.times = 1;
        if (anim) {
            for(const attr in anim)if (anim[has](attr)) {
                newAnim[toFloat(attr)] = anim[attr];
                percents.push(toFloat(attr));
            }
            percents.sort(sortByNumber);
        }
        this.anim = newAnim;
        this.top = percents[percents.length - 1];
        this.percents = percents;
    }
    /* \
   * Animation.delay
   [ method ]
   **
   * Creates a copy of existing animation object with given delay.
   **
   > Parameters
   **
   - delay (number) number of ms to pass between animation start and actual animation
   **
   = (object) new altered Animation object
   | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
   | circle1.animate(anim); // run the given animation immediately
   | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
  \ */ Animation.prototype.delay = function(delay) {
        const a = new Animation(this.anim, this.ms);
        a.times = this.times;
        a.del = +delay || 0;
        return a;
    };
    /* \
   * Animation.repeat
   [ method ]
   **
   * Creates a copy of existing animation object with given repetition.
   **
   > Parameters
   **
   - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
   **
   = (object) new altered Animation object
  \ */ Animation.prototype.repeat = function(times) {
        const a = new Animation(this.anim, this.ms);
        a.del = this.del;
        a.times = math.floor(mmax(times, 0)) || 1;
        return a;
    };
    function runAnimation(anim, element, percent, status, totalOrigin, times) {
        percent = toFloat(percent);
        let params;
        let isInAnim;
        let isInAnimSet;
        const percents = [];
        let next;
        let prev;
        let timestamp;
        let { ms } = anim;
        const from = {};
        const to = {};
        const diff = {};
        if (status) for(i = 0, ii = animationElements.length; i < ii; i++){
            var e = animationElements[i];
            if (e.el.id == element.id && e.anim == anim) {
                if (e.percent != percent) {
                    animationElements.splice(i, 1);
                    isInAnimSet = 1;
                } else isInAnim = e;
                element.attr(e.totalOrigin);
                break;
            }
        }
        else status = +to // NaN
        ;
        for(var i = 0, ii = anim.percents.length; i < ii; i++){
            if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
                percent = anim.percents[i];
                prev = anim.percents[i - 1] || 0;
                ms = ms / anim.top * (percent - prev);
                next = anim.percents[i + 1];
                params = anim.anim[percent];
                break;
            } else if (status) element.attr(anim.anim[anim.percents[i]]);
        }
        if (!params) return;
        if (!isInAnim) {
            for(const attr in params)if (params[has](attr)) {
                if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                    from[attr] = element.attr(attr);
                    from[attr] == null && (from[attr] = availableAttrs[attr]);
                    to[attr] = params[attr];
                    switch(availableAnimAttrs[attr]){
                        case nu:
                            diff[attr] = (to[attr] - from[attr]) / ms;
                            break;
                        case 'colour':
                            from[attr] = R.getRGB(from[attr]);
                            var toColour = R.getRGB(to[attr]);
                            diff[attr] = {
                                r: (toColour.r - from[attr].r) / ms,
                                g: (toColour.g - from[attr].g) / ms,
                                b: (toColour.b - from[attr].b) / ms
                            };
                            break;
                        case 'path':
                            var pathes = path2curve(from[attr], to[attr]);
                            var toPath = pathes[1];
                            from[attr] = pathes[0];
                            diff[attr] = [];
                            for(i = 0, ii = from[attr].length; i < ii; i++){
                                diff[attr][i] = [
                                    0
                                ];
                                for(var j = 1, jj = from[attr][i].length; j < jj; j++)diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                            }
                            break;
                        case 'transform':
                            var { _ } = element;
                            var eq = equaliseTransform(_[attr], to[attr]);
                            if (eq) {
                                from[attr] = eq.from;
                                to[attr] = eq.to;
                                diff[attr] = [];
                                diff[attr].real = true;
                                for(i = 0, ii = from[attr].length; i < ii; i++){
                                    diff[attr][i] = [
                                        from[attr][i][0]
                                    ];
                                    for(j = 1, jj = from[attr][i].length; j < jj; j++)diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                }
                            } else {
                                const m = element.matrix || new Matrix();
                                const to2 = {
                                    _: {
                                        transform: _.transform
                                    },
                                    getBBox () {
                                        return element.getBBox(1);
                                    }
                                };
                                from[attr] = [
                                    m.a,
                                    m.b,
                                    m.c,
                                    m.d,
                                    m.e,
                                    m.f
                                ];
                                extractTransform(to2, to[attr]);
                                to[attr] = to2._.transform;
                                diff[attr] = [
                                    (to2.matrix.a - m.a) / ms,
                                    (to2.matrix.b - m.b) / ms,
                                    (to2.matrix.c - m.c) / ms,
                                    (to2.matrix.d - m.d) / ms,
                                    (to2.matrix.e - m.e) / ms,
                                    (to2.matrix.f - m.f) / ms
                                ];
                            // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                            // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                            // extractTransform(to2, to[attr]);
                            // diff[attr] = [
                            //     (to2._.sx - _.sx) / ms,
                            //     (to2._.sy - _.sy) / ms,
                            //     (to2._.deg - _.deg) / ms,
                            //     (to2._.dx - _.dx) / ms,
                            //     (to2._.dy - _.dy) / ms
                            // ];
                            }
                            break;
                        case 'csv':
                            var values = Str(params[attr])[split](separator);
                            var from2 = Str(from[attr])[split](separator);
                            if (attr == 'clip-rect') {
                                from[attr] = from2;
                                diff[attr] = [];
                                i = from2.length;
                                while(i--)diff[attr][i] = (values[i] - from[attr][i]) / ms;
                            }
                            to[attr] = values;
                            break;
                        default:
                            values = [][concat](params[attr]);
                            from2 = [][concat](from[attr]);
                            diff[attr] = [];
                            i = element.paper.customAttributes[attr].length;
                            while(i--)diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                            break;
                    }
                }
            }
            const { easing } = params;
            let easyeasy = R.easing_formulas[easing];
            if (!easyeasy) {
                easyeasy = Str(easing).match(bezierrg);
                if (easyeasy && easyeasy.length == 5) {
                    const curve = easyeasy;
                    easyeasy = function(t) {
                        return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                    };
                } else easyeasy = pipe;
            }
            timestamp = params.start || anim.start || +new Date();
            e = {
                anim,
                percent,
                timestamp,
                start: timestamp + (anim.del || 0),
                status: 0,
                initstatus: status || 0,
                stop: false,
                ms,
                easing: easyeasy,
                from,
                diff,
                to,
                el: element,
                callback: params.callback,
                prev,
                next,
                repeat: times || anim.times,
                origin: element.attr(),
                totalOrigin
            };
            animationElements.push(e);
            if (status && !isInAnim && !isInAnimSet) {
                e.stop = true;
                e.start = new Date() - ms * status;
                if (animationElements.length == 1) return animation();
            }
            if (isInAnimSet) e.start = new Date() - e.ms * status;
            animationElements.length == 1 && requestAnimFrame(animation);
        } else {
            isInAnim.initstatus = status;
            isInAnim.start = new Date() - isInAnim.ms * status;
        }
        (0, _eveJs.eve)(`raphael.anim.start.${element.id}`, element, anim);
    }
    /* \
   * Raphael.animation
   [ method ]
   **
   * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
   * See also @Animation.delay and @Animation.repeat methods.
   **
   > Parameters
   **
   - params (object) final attributes for the element, see also @Element.attr
   - ms (number) number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   **
   = (object) @Animation
  \ */ R.animation = function(params, ms, easing, callback) {
        if (params instanceof Animation) return params;
        if (R.is(easing, 'function') || !easing) {
            callback = callback || easing || null;
            easing = null;
        }
        params = Object(params);
        ms = +ms || 0;
        const p = {};
        let json;
        let attr;
        for(attr in params)if (params[has](attr) && toFloat(attr) != attr && `${toFloat(attr)}%` != attr) {
            json = true;
            p[attr] = params[attr];
        }
        if (!json) {
            // if percent-like syntax is used and end-of-all animation callback used
            if (callback) {
                // find the last one
                let lastKey = 0;
                for(const i in params){
                    const percent = toInt(i);
                    if (params[has](i) && percent > lastKey) lastKey = percent;
                }
                lastKey += '%';
                // if already defined callback in the last keyframe, skip
                !params[lastKey].callback && (params[lastKey].callback = callback);
            }
            return new Animation(params, ms);
        }
        easing && (p.easing = easing);
        callback && (p.callback = callback);
        return new Animation({
            100: p
        }, ms);
    };
    /* \
   * Element.animate
   [ method ]
   **
   * Creates and starts animation for given element.
   **
   > Parameters
   **
   - params (object) final attributes for the element, see also @Element.attr
   - ms (number) number of milliseconds for animation to run
   - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
   - callback (function) #optional callback function. Will be called at the end of animation.
   * or
   - animation (object) animation object, see @Raphael.animation
   **
   = (object) original element
  \ */ elproto.animate = function(params, ms, easing, callback) {
        const element = this;
        if (element.removed) {
            callback && callback.call(element);
            return element;
        }
        const anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
        runAnimation(anim, element, anim.percents[0], null, element.attr());
        return element;
    };
    /* \
   * Element.setTime
   [ method ]
   **
   * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
   **
   > Parameters
   **
   - anim (object) animation object
   - value (number) number of milliseconds from the beginning of the animation
   **
   = (object) original element if `value` is specified
   * Note, that during animation following events are triggered:
   *
   * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
  \ */ elproto.setTime = function(anim, value) {
        if (anim && value != null) this.status(anim, mmin(value, anim.ms) / anim.ms);
        return this;
    };
    /* \
   * Element.status
   [ method ]
   **
   * Gets or sets the status of animation of the element.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   - value (number) #optional 0  1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
   **
   = (number) status
   * or
   = (array) status if `anim` is not specified. Array of objects in format:
   o {
   o     anim: (object) animation object
   o     status: (number) status
   o }
   * or
   = (object) original element if `value` is specified
  \ */ elproto.status = function(anim, value) {
        const out = [];
        let i = 0;
        let len;
        let e;
        if (value != null) {
            runAnimation(anim, this, -1, mmin(value, 1));
            return this;
        }
        len = animationElements.length;
        for(; i < len; i++){
            e = animationElements[i];
            if (e.el.id == this.id && (!anim || e.anim == anim)) {
                if (anim) return e.status;
                out.push({
                    anim: e.anim,
                    status: e.status
                });
            }
        }
        if (anim) return 0;
        return out;
    };
    /* \
   * Element.pause
   [ method ]
   **
   * Stops animation of the element with ability to resume it later on.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.pause = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if ((0, _eveJs.eve)(`raphael.anim.pause.${this.id}`, this, animationElements[i].anim) !== false) animationElements[i].paused = true;
        }
        return this;
    };
    /* \
   * Element.resume
   [ method ]
   **
   * Resumes animation if it was paused with @Element.pause method.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.resume = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            const e = animationElements[i];
            if ((0, _eveJs.eve)(`raphael.anim.resume.${this.id}`, this, e.anim) !== false) {
                delete e.paused;
                this.status(e.anim, e.status);
            }
        }
        return this;
    };
    /* \
   * Element.stop
   [ method ]
   **
   * Stops animation of the element.
   **
   > Parameters
   **
   - anim (object) #optional animation object
   **
   = (object) original element
  \ */ elproto.stop = function(anim) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
            if ((0, _eveJs.eve)(`raphael.anim.stop.${this.id}`, this, animationElements[i].anim) !== false) animationElements.splice(i--, 1);
        }
        return this;
    };
    function stopAnimation(paper) {
        for(let i = 0; i < animationElements.length; i++)if (animationElements[i].el.paper == paper) animationElements.splice(i--, 1);
    }
    (0, _eveJs.eve).on('raphael.remove', stopAnimation);
    (0, _eveJs.eve).on('raphael.clear', stopAnimation);
    elproto.toString = function() {
        return 'Rapha\xebl\u2019s object';
    };
    // Set
    var Set = function(items) {
        this.items = [];
        this.length = 0;
        this.type = 'set';
        if (items) {
            for(let i = 0, ii = items.length; i < ii; i++)if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                this[this.items.length] = this.items[this.items.length] = items[i];
                this.length++;
            }
        }
    };
    const setproto = Set.prototype;
    /* \
   * Set.push
   [ method ]
   **
   * Adds each argument to the current set.
   = (object) original element
  \ */ setproto.push = function() {
        let item;
        let len;
        for(let i = 0, ii = arguments.length; i < ii; i++){
            item = arguments[i];
            if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
                len = this.items.length;
                this[len] = this.items[len] = item;
                this.length++;
            }
        }
        return this;
    };
    /* \
   * Set.pop
   [ method ]
   **
   * Removes last element and returns it.
   = (object) element
  \ */ setproto.pop = function() {
        this.length && delete this[this.length--];
        return this.items.pop();
    };
    /* \
   * Set.forEach
   [ method ]
   **
   * Executes given function for each element in the set.
   *
   * If function returns `false` it will stop loop running.
   **
   > Parameters
   **
   - callback (function) function to run
   - thisArg (object) context object for the callback
   = (object) Set object
  \ */ setproto.forEach = function(callback, thisArg) {
        for(let i = 0, ii = this.items.length; i < ii; i++){
            if (callback.call(thisArg, this.items[i], i) === false) return this;
        }
        return this;
    };
    for(const method in elproto)if (elproto[has](method)) setproto[method] = function(methodname) {
        return function() {
            const arg = arguments;
            return this.forEach((el)=>{
                el[methodname][apply](el, arg);
            });
        };
    }(method);
    setproto.attr = function(name, value) {
        if (name && R.is(name, array) && R.is(name[0], 'object')) for(let j = 0, jj = name.length; j < jj; j++)this.items[j].attr(name[j]);
        else for(let i = 0, ii = this.items.length; i < ii; i++)this.items[i].attr(name, value);
        return this;
    };
    /* \
   * Set.clear
   [ method ]
   **
   * Removes all elements from the set
  \ */ setproto.clear = function() {
        while(this.length)this.pop();
    };
    /* \
   * Set.splice
   [ method ]
   **
   * Removes given element from the set
   **
   > Parameters
   **
   - index (number) position of the deletion
   - count (number) number of element to remove
   - insertion (object) #optional elements to insert
   = (object) set elements that were deleted
  \ */ setproto.splice = function(index, count, insertion) {
        index = index < 0 ? mmax(this.length + index, 0) : index;
        count = mmax(0, mmin(this.length - index, count));
        const tail = [];
        const todel = [];
        const args = [];
        let i;
        for(i = 2; i < arguments.length; i++)args.push(arguments[i]);
        for(i = 0; i < count; i++)todel.push(this[index + i]);
        for(; i < this.length - index; i++)tail.push(this[index + i]);
        const arglen = args.length;
        for(i = 0; i < arglen + tail.length; i++)this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
        i = this.items.length = this.length -= count - arglen;
        while(this[i])delete this[i++];
        return new Set(todel);
    };
    /* \
   * Set.exclude
   [ method ]
   **
   * Removes given element from the set
   **
   > Parameters
   **
   - element (object) element to remove
   = (boolean) `true` if object was found & removed from the set
  \ */ setproto.exclude = function(el) {
        for(let i = 0, ii = this.length; i < ii; i++)if (this[i] == el) {
            this.splice(i, 1);
            return true;
        }
    };
    setproto.animate = function(params, ms, easing, callback) {
        (R.is(easing, 'function') || !easing) && (callback = easing || null);
        let len = this.items.length;
        let i = len;
        let item;
        const set = this;
        let collector;
        if (!len) return this;
        callback && (collector = function() {
            !--len && callback.call(set);
        });
        easing = R.is(easing, string) ? easing : collector;
        const anim = R.animation(params, ms, easing, collector);
        item = this.items[--i].animate(anim);
        while(i--){
            this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
            this.items[i] && !this.items[i].removed || len--;
        }
        return this;
    };
    setproto.insertAfter = function(el) {
        let i = this.items.length;
        while(i--)this.items[i].insertAfter(el);
        return this;
    };
    setproto.getBBox = function() {
        let x = [];
        let y = [];
        let x2 = [];
        let y2 = [];
        for(let i = this.items.length; i--;)if (!this.items[i].removed) {
            const box = this.items[i].getBBox();
            x.push(box.x);
            y.push(box.y);
            x2.push(box.x + box.width);
            y2.push(box.y + box.height);
        }
        x = mmin[apply](0, x);
        y = mmin[apply](0, y);
        x2 = mmax[apply](0, x2);
        y2 = mmax[apply](0, y2);
        return {
            x,
            y,
            x2,
            y2,
            width: x2 - x,
            height: y2 - y
        };
    };
    setproto.clone = function(s) {
        s = this.paper.set();
        for(let i = 0, ii = this.items.length; i < ii; i++)s.push(this.items[i].clone());
        return s;
    };
    setproto.toString = function() {
        return 'Rapha\xebl\u2018s set';
    };
    setproto.glow = function(glowConfig) {
        const ret = this.paper.set();
        this.forEach((shape, index)=>{
            const g = shape.glow(glowConfig);
            if (g != null) g.forEach((shape2, index2)=>{
                ret.push(shape2);
            });
        });
        return ret;
    };
    /* \
   * Set.isPointInside
   [ method ]
   **
   * Determine if given point is inside this sets elements
   **
   > Parameters
   **
   - x (number) x coordinate of the point
   - y (number) y coordinate of the point
   = (boolean) `true` if point is inside any of the set's elements
   \ */ setproto.isPointInside = function(x, y) {
        let isPointInside = false;
        this.forEach((el)=>{
            if (el.isPointInside(x, y)) {
                isPointInside = true;
                return false // stop loop
                ;
            }
        });
        return isPointInside;
    };
    /* \
   * Raphael.registerFont
   [ method ]
   **
   * Adds given font to the registered set of fonts for Raphal. Should be used as an internal call from within Cufns font file.
   * Returns original parameter, so it could be used with chaining.
   # <a href="http://wiki.github.com/sorccu/cufon/about">More about Cufn and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
   **
   > Parameters
   **
   - font (object) the font to register
   = (object) the font you passed in
   > Usage
   | Cufon.registerFont(Raphael.registerFont({}));
  \ */ R.registerFont = function(font) {
        if (!font.face) return font;
        this.fonts = this.fonts || {};
        const fontcopy = {
            w: font.w,
            face: {},
            glyphs: {}
        };
        const family = font.face['font-family'];
        for(const prop in font.face)if (font.face[has](prop)) fontcopy.face[prop] = font.face[prop];
        if (this.fonts[family]) this.fonts[family].push(fontcopy);
        else this.fonts[family] = [
            fontcopy
        ];
        if (!font.svg) {
            fontcopy.face['units-per-em'] = toInt(font.face['units-per-em'], 10);
            for(const glyph in font.glyphs)if (font.glyphs[has](glyph)) {
                const path = font.glyphs[glyph];
                fontcopy.glyphs[glyph] = {
                    w: path.w,
                    k: {},
                    d: path.d && `M${path.d.replace(/[mlcxtrv]/g, (command)=>({
                            l: 'L',
                            c: 'C',
                            x: 'z',
                            t: 'm',
                            r: 'l',
                            v: 'c'
                        })[command] || 'M')}z`
                };
                if (path.k) {
                    for(const k in path.k)if (path[has](k)) fontcopy.glyphs[glyph].k[k] = path.k[k];
                }
            }
        }
        return font;
    };
    /* \
   * Paper.getFont
   [ method ]
   **
   * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like Myriad for Myriad Pro.
   **
   > Parameters
   **
   - family (string) font family name or any word from it
   - weight (string) #optional font weight
   - style (string) #optional font style
   - stretch (string) #optional font stretch
   = (object) the font object
   > Usage
   | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
  \ */ paperproto.getFont = function(family, weight, style, stretch) {
        stretch = stretch || 'normal';
        style = style || 'normal';
        weight = +weight || ({
            normal: 400,
            bold: 700,
            lighter: 300,
            bolder: 800
        })[weight] || 400;
        if (!R.fonts) return;
        let font = R.fonts[family];
        if (!font) {
            const name = new RegExp(`(^|\\s)${family.replace(/[^\w\d\s+!~.:_-]/g, E)}(\\s|$)`, 'i');
            for(const fontName in R.fonts)if (R.fonts[has](fontName)) {
                if (name.test(fontName)) {
                    font = R.fonts[fontName];
                    break;
                }
            }
        }
        let thefont;
        if (font) for(let i = 0, ii = font.length; i < ii; i++){
            thefont = font[i];
            if (thefont.face['font-weight'] == weight && (thefont.face['font-style'] == style || !thefont.face['font-style']) && thefont.face['font-stretch'] == stretch) break;
        }
        return thefont;
    };
    /* \
   * Paper.print
   [ method ]
   **
   * Creates path that represent given text written using given font at given position with given size.
   * Result of the method is path element that contains whole text as a separate path.
   **
   > Parameters
   **
   - x (number) x position of the text
   - y (number) y position of the text
   - string (string) text to print
   - font (object) font object, see @Paper.getFont
   - size (number) #optional size of the font, default is `16`
   - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
   - letter_spacing (number) #optional number in range `-1..1`, default is `0`
   - line_spacing (number) #optional number in range `1..3`, default is `1`
   = (object) resulting path element, which consist of all letters
   > Usage
   | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
  \ */ paperproto.print = function(x, y, string, font, size, origin, letter_spacing, line_spacing) {
        origin = origin || 'middle' // baseline|middle
        ;
        letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
        line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
        const letters = Str(string)[split](E);
        let shift = 0;
        let notfirst = 0;
        let path = E;
        let scale;
        R.is(font, 'string') && (font = this.getFont(font));
        if (font) {
            scale = (size || 16) / font.face['units-per-em'];
            const bb = font.face.bbox[split](separator);
            const top = +bb[0];
            const lineHeight = bb[3] - bb[1];
            let shifty = 0;
            const height = +bb[1] + (origin == 'baseline' ? lineHeight + +font.face.descent : lineHeight / 2);
            for(let i = 0, ii = letters.length; i < ii; i++){
                if (letters[i] == '\n') {
                    shift = 0;
                    curr = 0;
                    notfirst = 0;
                    shifty += lineHeight * line_spacing;
                } else {
                    const prev = notfirst && font.glyphs[letters[i - 1]] || {};
                    var curr = font.glyphs[letters[i]];
                    shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + font.w * letter_spacing : 0;
                    notfirst = 1;
                }
                if (curr && curr.d) path += R.transformPath(curr.d, [
                    't',
                    shift * scale,
                    shifty * scale,
                    's',
                    scale,
                    scale,
                    top,
                    height,
                    't',
                    (x - top) / scale,
                    (y - height) / scale
                ]);
            }
        }
        return this.path(path).attr({
            fill: '#000',
            stroke: 'none'
        });
    };
    /* \
   * Paper.add
   [ method ]
   **
   * Imports elements in JSON array in format `{type: type, <attributes>}`
   **
   > Parameters
   **
   - json (array)
   = (object) resulting set of imported elements
   > Usage
   | paper.add([
   |     {
   |         type: "circle",
   |         cx: 10,
   |         cy: 10,
   |         r: 5
   |     },
   |     {
   |         type: "rect",
   |         x: 10,
   |         y: 10,
   |         width: 10,
   |         height: 10,
   |         fill: "#fc0"
   |     }
   | ]);
  \ */ paperproto.add = function(json) {
        if (R.is(json, 'array')) {
            var res = this.set();
            let i = 0;
            const ii = json.length;
            let j;
            for(; i < ii; i++){
                j = json[i] || {};
                elements[has](j.type) && res.push(this[j.type]().attr(j));
            }
        }
        return res;
    };
    /* \
   * Raphael.format
   [ method ]
   **
   * Simple format function. Replaces construction of type `{<number>}` to the corresponding argument.
   **
   > Parameters
   **
   - token (string) string to format
   -  (string) rest of arguments will be treated as parameters for replacement
   = (string) formated string
   > Usage
   | var x = 10,
   |     y = 20,
   |     width = 40,
   |     height = 50;
   | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
   | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
  \ */ R.format = function(token, params) {
        const args = R.is(params, array) ? [
            0
        ][concat](params) : arguments;
        token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, (str, i)=>args[++i] == null ? E : args[i]));
        return token || E;
    };
    /* \
   * Raphael.fullfill
   [ method ]
   **
   * A little bit more advanced format function than @Raphael.format. Replaces construction of type `{<name>}` to the corresponding argument.
   **
   > Parameters
   **
   - token (string) string to format
   - json (object) object which properties will be used as a replacement
   = (string) formated string
   > Usage
   | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
   | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
   |     x: 10,
   |     y: 20,
   |     dim: {
   |         width: 40,
   |         height: 50,
   |         "negative width": -40
   |     }
   | }));
  \ */ R.fullfill = function() {
        const tokenRegex = /\{([^\}]+)\}/g;
        const objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g // matches .xxxxx or ["xxxxx"] to run over object properties
        ;
        const replacer = function(all, key, obj) {
            let res = obj;
            key.replace(objNotationRegex, (all, name, quote, quotedName, isFunc)=>{
                name = name || quotedName;
                if (res) {
                    if (name in res) res = res[name];
                    typeof res === 'function' && isFunc && (res = res());
                }
            });
            res = `${res == null || res == obj ? all : res}`;
            return res;
        };
        return function(str, obj) {
            return String(str).replace(tokenRegex, (all, key)=>replacer(all, key, obj));
        };
    }();
    /* \
   * Raphael.ninja
   [ method ]
   **
   * If you want to leave no trace of Raphal (Well, Raphal creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
   * Beware, that in this case plugins could stop working, because they are depending on global variable existence.
   **
   = (object) Raphael object
   > Usage
   | (function (local_raphael) {
   |     var paper = local_raphael(10, 10, 320, 200);
   |     
   | })(Raphael.ninja());
  \ */ R.ninja = function() {
        if (oldRaphael.was) g.win.Raphael = oldRaphael.is;
        else {
            // IE8 raises an error when deleting window property
            window.Raphael = undefined;
            try {
                delete window.Raphael;
            } catch (e) {}
        }
        return R;
    };
    /* \
   * Raphael.st
   [ property (object) ]
   **
   * You can add your own method to elements and sets. It is wise to add a set method for each element method
   * you added, so you will be able to call the same method on sets too.
   **
   * See also @Raphael.el.
   > Usage
   | Raphael.el.red = function () {
   |     this.attr({fill: "#f00"});
   | };
   | Raphael.st.red = function () {
   |     this.forEach(function (el) {
   |         el.red();
   |     });
   | };
   | // then use it
   | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
  \ */ R.st = setproto;
    (0, _eveJs.eve).on('raphael.DOMload', ()=>{
        loaded = true;
    });
    (function(doc, loaded, f) {
        if (doc.readyState == null && doc.addEventListener) {
            doc.addEventListener(loaded, f = function() {
                doc.removeEventListener(loaded, f, false);
                doc.readyState = 'complete';
            }, false);
            doc.readyState = 'loading';
        }
        function isLoaded() {
            /in/.test(doc && doc.readyState) ? setTimeout(isLoaded, 9) : R.eve('raphael.DOMload');
        }
        isLoaded();
    })(document, 'DOMContentLoaded');
    return R;
}();

},{"../eve.js":"9FQ0M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6wubb":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getTransformedPath);
var _utils = require("./utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
function getTransformedPath(originalPath, transforms) {
    let transformsArray = transforms;
    let transformedPath = originalPath;
    if (!transforms.find && typeof transforms === 'string') transformsArray = [
        transforms
    ];
    // NOTE: it's safer to apply transforms one by one because this transform string `T${_x * percent}, ${_y * percent}, s${_width/150 * percent}, ${_height/100 * percent}, ${_x}, ${_y}`
    //      would be applied incorrectly - element would be translated using the center of scaling ${_x}, ${_y} which seems to be a bug in raphael.js
    transformsArray.forEach((transform)=>{
        transformedPath = (0, _utilsDefault.default)._transformPath(transformedPath, transform).toString();
    });
    return transformedPath;
}

},{"./utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpLaV":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
var _raphaelFnShapes = require("../deps/raphael/raphael.fn.shapes");
var _raphaelElExtensions = require("../deps/raphael/raphael.el.extensions");
var _embedGoogleFonts = require("../helpers/embedGoogleFonts");
var _embedGoogleFontsDefault = parcelHelpers.interopDefault(_embedGoogleFonts);
var _emile = require("../deps/emile");
class canvas {
    constructor(slate){
        const self = this;
        self.slate = slate;
        let c = slate.options.container;
        if (typeof c === 'string') c = (0, _utilsDefault.default).el(c);
        if (c === undefined || c === null) throw new Error('You must provide a container to initiate the canvas!');
        // customize raphael -- modifies global Raphael for all other imports
        (0, _raphaelFnShapes.shapes)((0, _raphaelSvg.Raphael));
        (0, _raphaelElExtensions.extensions)((0, _raphaelSvg.Raphael));
        self.isDragging = false;
        self.slate.paper = null;
        self.internal = null;
        self.status = null;
        self.imageFolder = null;
        self.dken = null;
        self.eve = {
            init: [
                'onmousedown',
                'ontouchstart'
            ],
            drag: [
                'onmousemove',
                'ontouchmove'
            ],
            up: [
                'onmouseup',
                'ontouchend',
                'onmouseout'
            ],
            gest: [
                'ongesturestart',
                'ongesturechange',
                'ongestureend'
            ]
        };
    }
    init() {
        const self = this;
        const imageFolder = self.slate.options.imageFolder || '/images/';
        const c = self.slate.options.container;
        const { slate } = self;
        self.Canvas = {
            objInitPos: {},
            objInitialMousePos: {
                x: 0,
                y: 0
            },
            initDrag (e) {
                if (slate.isCtrl) slate.multiSelection?.start();
                if (slate.options.allowDrag) {
                    self.isDragging = true;
                    slate.multiSelection?.end();
                    slate.nodes?.closeAllMenus();
                    const m = (0, _utilsDefault.default).mousePos(e);
                    self.Canvas.objInitPos = (0, _utilsDefault.default).positionedOffset(self.internal);
                    const offsets = (0, _utilsDefault.default).positionedOffset(slate.options.container);
                    self.Canvas.objInitialMousePos = {
                        x: m.x + offsets.left,
                        y: m.y + offsets.top
                    };
                    const xy = self.cp(e);
                    if (self.status) self.status.innerHTML = `${Math.abs(xy.x)}, ${Math.abs(xy.y)}`;
                    if (slate.options.showStatus) {
                        if (self.status) self.status.style.display = 'block';
                        slate.multiSelection?.hide();
                    }
                    self.internal.style.cursor = `url(${imageFolder}closedhand.cur), default`;
                    if (m.allTouches) slate.options.lastTouches = m.allTouches;
                    if (slate.removeContextMenus) slate.removeContextMenus();
                    slate.draggingZoom = self.slate.options.viewPort.zoom;
                    // hide filters during dragging
                    slate.toggleFilters(true);
                    (0, _utilsDefault.default).stopEvent(e);
                } else if (slate.onSelectionStart) slate.onSelectionStart.apply(self, [
                    e
                ]);
                else (0, _utilsDefault.default).stopEvent(e);
            },
            setCursor () {
                if (self.isDragging) self.internal.style.cursor = `url(${imageFolder}closedhand.cur), default`;
                else self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
            },
            onDrag (e) {
                requestAnimationFrame(()=>{
                    // broadcast custom collab
                    const mp = (0, _utilsDefault.default).mousePos(e);
                    const curPos = (0, _utilsDefault.default).positionedOffset(self.internal);
                    mp.currentZoom = slate.options.viewPort.zoom.r;
                    mp.left = Math.abs(curPos.left);
                    mp.top = Math.abs(curPos.top);
                    slate.collab?.send({
                        type: 'onMouseMoved',
                        data: mp
                    });
                    if (self.isDragging && slate.options.allowDrag) {
                        const xy = self.cp(e);
                        if (xy.allTouches && xy.allTouches.length > 1) slate.options.lastTouches = xy.allTouches;
                        if (self.status) self.status.innerHTML = `${Math.abs(xy.x)}, ${Math.abs(xy.y)}`;
                        self.internal.style.left = `${xy.x}px`;
                        self.internal.style.top = `${xy.y}px`;
                    }
                });
            },
            endDrag (e) {
                if (self.isDragging && slate.options.allowDrag) {
                    self.isDragging = false;
                    self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
                    if (self.status) self.status.style.display = 'none';
                    slate.multiSelection?.show();
                    const xy = self.cp(e);
                    slate.draggingZoom = null;
                    self.endDrag(xy);
                    // show filters after dragging
                    slate.toggleFilters(false);
                }
            }
        };
        // wipe it clean
        if (!slate.options.preserve) c.innerHTML = '';
        if (self.slate.paper) self.slate.paper.clear();
        if (self.internal) c.removeChild(self.internal);
        // internal
        self.internal = document.createElement('div');
        self.internal.setAttribute('class', `slateboxInternal_${self.slate.options.id} sb_canvas`);
        // console.log("setting slate canvas", `slateboxInternal_${self.slate.options.id}`);
        const _w = slate.options.viewPort.width;
        const _h = slate.options.viewPort.height;
        const _l = slate.options.viewPort.left;
        const _t = slate.options.viewPort.top;
        self.internal.style.width = `${_w + 100000}px`;
        self.internal.style.height = `${_h + 100000}px`;
        self.internal.style.left = `${_l * -1}px`;
        self.internal.style.top = `${_t * -1}px`;
        self.internal.style.position = 'absolute';
        self.internal.style['-webkit-transform'] = `translateZ(0)`;
        self.internal.style.transform = `translateZ(0)` // `translate3d(0,0,0)`; //helps with GPU based rendering
        ;
        c.appendChild(self.internal);
        self.internal.addEventListener('mousedown', ()=>{
            self.slate?.events?.onCanvasClicked?.apply();
        });
        // status
        if (self.slate.options.showStatus) {
            self.status = document.createElement('div');
            self.status.style.position = 'absolute';
            self.status.style.height = '20px';
            self.status.style.left = '5px';
            self.status.style.color = '#000';
            self.status.style.fontSize = '10pt';
            self.status.style.fontFamily = 'trebuchet ms';
            self.status.style.top = '0px';
            self.status.style.display = 'none';
            self.status.style.padding = '5px';
            self.status.style.filter = 'alpha(opacity=80)';
            self.status.style.opacity = '.80';
            self.status.style.backgroundColor = '#ffff99';
            self.status.style.fontWeight = 'bold';
            c.appendChild(self.status);
        }
        // style container
        c.style.position = 'relative';
        c.style.overflow = 'hidden';
        // style internal
        self.internal.style.borderTop = `${slate.borderTop}px`;
        self.internal.style.cursor = `url(${imageFolder}openhand.cur), default`;
        self.slate.paper = (0, _raphaelSvg.Raphael)(self.internal, _w, _h);
        self.refreshBackground();
        if (slate.options.allowDrag) self.wire();
        slate.options.viewPort.originalHeight = _h;
        slate.options.viewPort.originalWidth = _w;
        // set up initial zoom params
        self.resize(_w);
        // show zoom slider
        if (slate.options.showZoom && !slate.options.isEmbedded) {
            if (slate.zoomSlider) slate.zoomSlider.show(slate.options.viewPort.width);
        }
        // show undo redo
        if (slate.options.showUndoRedo && !slate.options.isEmbedded) {
            if (slate.undoRedo) slate.undoRedo.show();
        }
        // show birdsEye -- this is self referential on canvas in loadJSON inside slate, so this must be deferred until canvas constructor is done.
        if (slate.options.showbirdsEye && !slate.options.isEmbedded) {
            if (slate.birdsEye.enabled()) slate.birdsEye.reload(slate.exportJSON());
            else slate.birdsEye.show({
                size: slate.options.sizeOfbirdsEye || 200,
                onHandleMove () {}
            });
        }
        // set up the shareable/branding if need be
        if (!slate.options.isbirdsEye && (slate.options.isSharing || slate.options.isEmbedding)) {
            const _btnSize = 25;
            const _scaleSize = _btnSize - 3;
            const _iframe = document.getElementById('snap_slate');
            const _parent = document.createElement('div');
            _parent.className = 'sb_parent_shareable';
            const _styles = (0, _utilsDefault.default).buildStyle({
                height: _iframe ? `${_scaleSize + 8}px` : `${_scaleSize}px`
            });
            _parent.setAttribute('style', _styles);
            if (slate.options.isEmbedding && !slate.options.nobrand) {
                const _brand = document.createElement('a');
                _brand.className = 'sb_brand';
                _brand.setAttribute('href', 'https://slatebox.com');
                _brand.innerHTML = 'built with slatebox';
                _parent.appendChild(_brand);
            }
            if (!slate.options.isbirdsEye && slate.options.isSharing) {
                const _svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${_btnSize}" height="${_btnSize}"><path fill="#333" stroke="#000" d="{path}" stroke-dasharray="none" stroke-width="1" opacity="1" fill-opacity="1"></path></svg>`;
                [
                    'download',
                    'embed'
                ].forEach((e)=>{
                    const _btn = document.createElement('div');
                    _btn.className = 'sb_share';
                    _btn.setAttribute('data-action', e);
                    const _bstyles = (0, _utilsDefault.default).buildStyle({
                        width: `${_btnSize}px`,
                        height: `${_btnSize}px`
                    });
                    _btn.setAttribute('style', _bstyles);
                    const _new = (0, _utilsDefault.default).centerAndScalePathToFitContainer({
                        containerSize: _btnSize,
                        scaleSize: _scaleSize,
                        path: (0, _sbIconsDefault.default).icons[e]
                    });
                    _btn.innerHTML = _svg.replace(/{path}/gi, _new.path);
                    _parent.appendChild(_btn);
                    (0, _utilsDefault.default).addEvent(_btn, 'click', ()=>{
                        const _act = this.getAttribute('data-action');
                        switch(_act){
                            case 'embed':
                                {
                                    const _et = document.createElement('textarea');
                                    document.body.appendChild(_et);
                                    let _val = '';
                                    if (_iframe) _val = `<iframe id='sb_embed_${slate.options.id}' src='${window.location.href}' width='${_iframe.clientWidth}' height='${_iframe.clientHeight}' frameborder='0' scrolling='no'></iframe>`;
                                    else {
                                        const _ele = slate.options.container.parentElement;
                                        const _raw = _ele.innerHTML;
                                        const _split = _raw.split('<div class="slateboxInternal"');
                                        const _orig = `${_split[0]}<script>${_split[1].split('<script>')[1]}`;
                                        _val = `<div id="sb_embed_${slate.options.id}">${_orig}</div>`;
                                    }
                                    _et.value = _val;
                                    _et.select();
                                    document.execCommand('copy');
                                    document.body.removeChild(_et);
                                    const _note = document.createElement('div');
                                    _note.innerHTML = 'Copied!';
                                    _note.setAttribute('style', (0, _utilsDefault.default).buildStyle({
                                        'font-size': '11pt',
                                        'text-align': 'center',
                                        padding: '4px',
                                        'margin-right': '-1px',
                                        width: '125px',
                                        height: '22px',
                                        position: 'absolute',
                                        right: 0,
                                        bottom: 0,
                                        'background-color': '#333',
                                        color: '#fff'
                                    }));
                                    _parent.appendChild(_note);
                                    window.setTimeout(()=>{
                                        _parent.removeChild(_note);
                                    }, 1500);
                                    break;
                                }
                            case 'download':
                                slate.png();
                                break;
                            default:
                                break;
                        }
                    });
                });
            }
            if (slate.options.isEmbedding && _parent.innerHTML !== '') c.appendChild(_parent);
        }
        self.windowSize = (0, _utilsDefault.default).windowSize();
        self.containerOffset = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        (0, _utilsDefault.default).addEvent(window, 'resize', ()=>{
            self.windowSize = (0, _utilsDefault.default).windowSize();
            self.containerOffset = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
            if (self.dken !== null) {
                self.dken.style.width = `${self.ws.width}px`;
                self.dken.style.height = `${self.ws.height}px`;
            }
        });
        setTimeout(()=>{
            self.slate.birdsEye?.setBe();
            self.slate.birdsEye?.refresh();
        // set init
        // self.Canvas.objInitPos = utils.positionedOffset(self.internal)
        // console.log('init mouse', self.Canvas.objInitPos)
        }, 500);
        // self.cp()
        // self.initDragDefaults()
        self.completeInit = true;
    }
    cp(e) {
        const m = e ? (0, _utilsDefault.default).mousePos(e) : {
            x: 0,
            y: 0
        };
        let difX = this.Canvas.objInitPos.left + (m.x - this.Canvas.objInitialMousePos.x);
        let difY = this.Canvas.objInitPos.top + (m.y - this.Canvas.objInitialMousePos.y);
        return {
            x: difX,
            y: difY
        };
    }
    endDrag(coords) {
        this.slate.options.viewPort.left = Math.abs(coords.x);
        this.slate.options.viewPort.top = Math.abs(coords.y);
        this.internal.style.left = `${coords.x}px`;
        this.internal.style.top = `${coords.y}px`;
        const curPos = (0, _utilsDefault.default).positionedOffset(this.internal);
        const moved = {
            x: this.Canvas.objInitPos.left - curPos.left,
            y: this.Canvas.objInitPos.top - curPos.top
        };
        this.slate.birdsEye?.refresh(true);
        if (this.slate.options.allowCollaboration) this.broadcast(moved);
    }
    broadcast(moved) {
        this.slate.collab?.send({
            type: 'onCanvasMove',
            data: {
                left: this.slate.options.viewPort.left,
                top: this.slate.options.viewPort.top,
                relative: moved,
                orient: this.slate.getOrientation()
            }
        });
    }
    zoom(_opts) {
        const self = this;
        const opts = {
            dur: 500,
            callbacks: {
                after: null,
                during: null
            },
            easing: 'easeFromTo',
            zoomPercent: 100
        };
        Object.assign(opts, _opts);
        self.slate.nodes.closeAllConnectors();
        const _startZoom = self.slate.options.viewPort.zoom.w || 50000;
        const _targetZoom = self.slate.options.viewPort.originalWidth * (100 / parseInt(opts.zoomPercent, 10));
        const _zoomDif = Math.abs(_targetZoom - _startZoom);
        opts.dur = !opts.dur && opts.dur !== 0 ? 500 : opts.dur;
        // eslint-disable-next-line no-undef
        emile(self.internal, 'padding:1px', {
            duration: opts.dur,
            before () {
                self.slate.options.allowDrag = false;
            },
            after () {
                self.slate.options.allowDrag = true;
                self.slate.zoomSlider.set(_targetZoom);
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.after?.apply(self.slate, [
                    _targetZoom
                ]);
            },
            during (pc) {
                const _val = _targetZoom > _startZoom ? _startZoom + _zoomDif * pc : _startZoom - _zoomDif * pc;
                self.slate.zoom(0, 0, _val, _val, false);
                self.slate.canvas.resize(_val);
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.during?.apply(pc);
            },
            easing: (0, _utilsDefault.default).easing[opts.easing]
        });
    }
    move(_opts) {
        const self = this;
        const opts = {
            x: 0,
            y: 0,
            dur: 500,
            callbacks: {
                after: null,
                during: null
            },
            isAbsolute: true,
            easing: 'easeFromTo'
        };
        Object.assign(opts, _opts);
        let { x, y } = opts;
        if (opts.isAbsolute === false) {
            x = self.slate.options.viewPort.left + x;
            y = self.slate.options.viewPort.top + y;
        }
        self.slate.nodes.closeAllConnectors();
        if (opts.dur > 0) // eslint-disable-next-line no-undef
        emile(self.internal, `left:${x * -1}px;top:${y * -1}px`, {
            duration: opts.dur,
            before () {
                self.slate.options.allowDrag = false;
            },
            after () {
                self.slate.options.allowDrag = true;
                self.slate.options.viewPort.left = Math.abs(parseInt(self.internal.style.left.replace('px', ''), 10));
                self.slate.options.viewPort.top = Math.abs(parseInt(self.internal.style.top.replace('px', ''), 10));
                self.slate.birdsEye?.refresh(true);
                opts.callbacks.after?.apply(self.slate);
            },
            during (pc) {
                self.slate.birdsEye?.refresh(true);
                opts.callbacks?.during?.apply(pc);
            },
            easing: (0, _utilsDefault.default).easing[opts.easing]
        });
        else window.requestAnimationFrame(()=>{
            self.internal.style.left = `${x * -1}px`;
            self.internal.style.top = `${y * -1}px`;
            self.slate.options.viewPort.left = Math.abs(x);
            self.slate.options.viewPort.top = Math.abs(y);
            opts.callbacks?.after?.apply(self.slate);
        });
    }
    bbox() {
        const dimen = (0, _utilsDefault.default).getDimensions(this.slate.options.container);
        return {
            x: Math.abs(this.slate.options.viewPort.top),
            y: Math.abs(this.slate.options.viewPort.left),
            width: dimen.width,
            height: dimen.height
        };
    }
    resize(val) {
        const uval = parseInt(val, 10);
        const R = this.slate.options.viewPort.width / uval;
        const dimen = (0, _utilsDefault.default).getDimensions(this.slate.options.container);
        let _top = this.slate.options.viewPort.top * -1 * R;
        let _left = this.slate.options.viewPort.left * -1 * R;
        const _centerY = (dimen.height / 2 * R - dimen.height / 2) * -1;
        const _centerX = (dimen.width / 2 * R - dimen.width / 2) * -1;
        _top += _centerY;
        _left += _centerX;
        const threshold = this.slate.options.viewPort.originalWidth - 1000;
        if (-_top > threshold || -_left > threshold) return false;
        this.internal.style.top = `${_top}px`;
        this.internal.style.left = `${_left}px`;
        this.slate.options.viewPort.zoom = {
            w: uval,
            h: uval,
            l: parseFloat(_left * -1),
            t: parseFloat(_top * -1),
            r: this.slate.options.viewPort.originalWidth / uval
        };
        return true;
    }
    clear() {
        this.slate.options.container.innerHTML = '';
        return this.slate._;
    }
    wire() {
        const self = this;
        self.eve.init.forEach((ee)=>{
            self.internal[ee] = self.Canvas.initDrag;
        });
        self.eve.drag.forEach((ee)=>{
            self.internal[ee] = self.Canvas.onDrag;
        });
        self.eve.up.forEach((ee)=>{
            self.internal[ee] = self.Canvas.endDrag;
        });
    }
    unwire() {
        const self = this;
        self.eve.init.forEach((ee)=>{
            self.internal[ee] = null;
        });
        self.eve.drag.forEach((ee)=>{
            self.internal[ee] = null;
        });
        self.eve.up.forEach((ee)=>{
            self.internal[ee] = null;
        });
    }
    rawSVG({ skipOptimize = false }, cb) {
        const self = this;
        function finalize(svg) {
            // always reposition <image> elements in the svg to be in the top left
            const regImg = /<image\s+x="[^"]+"\s+y="[^"]+"\s+href="data/gi;
            svg = svg.replace(regImg, '<image x="0" y="0" href="data');
            if (self.slate.events.onOptimizeSVG && !skipOptimize) self.slate.events.onOptimizeSVG(svg, (err, optimized)=>{
                if (err) console.error('Unable to optimize slate svg export', err);
                else cb(optimized);
            });
            else cb(svg);
        }
        function extractImages(__svg) {
            let ssvg = __svg;
            const images = (0, _lodashUniqDefault.default)(self.slate.nodes.allNodes.map((n)=>n.options.image).filter((f)=>!!f));
            if (images.length > 0) images.forEach((i, ind)=>{
                if (self.slate.events.onBase64ImageRequested) {
                    // server side gen
                    let imageType = 'png';
                    if (i.indexOf('jpg')) imageType = 'jpeg';
                    else if (i.indexOf('gif')) imageType = 'gif';
                    self.slate.events.onBase64ImageRequested(i, imageType, (err, res)=>{
                        if (err) console.error('Unable to retrieve base64 from image', err);
                        else {
                            const ix = i.replace(/&/gi, '&amp;');
                            while(ssvg.indexOf(ix) > -1)ssvg = ssvg.replace(ix, res);
                        }
                        if (ind + 1 === images.length) finalize(ssvg);
                    });
                } else // client side only -- good luck with CORS - this method should be avoided
                (0, _utilsDefault.default).toDataUrl(i).then((dataUrl)=>{
                    ssvg = ssvg.replace(new RegExp(i, 'gi'), dataUrl);
                }).catch((err)=>{
                    console.error('Unable to get image', err);
                }).finally(()=>{
                    if (ind + 1 === images.length) finalize(ssvg);
                });
            });
            else finalize(ssvg);
        }
        // always embed fonts and fix links -- a style node is always added in the init
        (0, _embedGoogleFontsDefault.default)({
            fonts: (0, _lodashUniqDefault.default)(self.slate.nodes.allNodes.map((n)=>n.options.fontFamily)),
            text: (0, _lodashUniqDefault.default)(self.slate.nodes.allNodes.flatMap((n)=>n.options.text.replace(/ /gi, '').split(''))).join('').trim(),
            styleNode: self.internal.querySelector('svg > defs > style')
        }).then(()=>{
            // need to swap out xlink:href with href for the blob to work w/ the pixelate (or other) filter
            let __svg = self.internal.innerHTML.replace(/xlink:href/gi, 'href');
            const slateBg = self.slate.options.containerStyle.backgroundImage;
            if (slateBg) {
                // server side gen
                let bgImageType = 'png';
                if (slateBg.indexOf('jpg')) bgImageType = 'jpeg';
                else if (slateBg.indexOf('gif')) bgImageType = 'gif';
                self.slate.events.onBase64ImageRequested(slateBg, bgImageType, (err, res)=>{
                    if (err) console.error('Unable to retrieve base64 from image', err);
                    else __svg = __svg.replace(slateBg, res);
                    extractImages(__svg);
                });
            } else extractImages(__svg);
        });
    }
    bgToBack() {
        this._bg?.toBack();
    }
    hideBg(t) {
        const self = this;
        const e = self.slate.options.containerStyle.backgroundEffect;
        self._bg?.remove();
        delete self._bg;
        if (e) {
            if (!self.slate.options.isbirdsEye) {
                clearTimeout(self.showBgTimeout);
                self.showBgTimeout = setTimeout(()=>{
                    if (!(0, _utilsDefault.default).isSafari()) {
                        const attrs = {
                            filter: `url(#${e})`
                        };
                        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile() && self.slate.filters.availableFilters[e]?.fill) attrs.fill = `url(#${self.slate.filters.availableFilters[e]?.fill})`;
                        self._bg = self.slate.paper.rect(0, 0, self.slate.options.viewPort.width, self.slate.options.viewPort.height).attr(attrs).toBack();
                    }
                }, t || 2500);
            }
        }
        self.refreshBackground();
    }
    refreshBackground() {
        const self = this;
        self.internal.style.backgroundColor = '';
        if (self.internal.parentElement) {
            self.internal.parentElement.style.backgroundImage = '';
            self.internal.parentElement.style.backgroundSize = '';
            self.internal.parentElement.style.background = '';
        }
        self.internal.style.backgroundSize = '';
        self.internal.style.backgroundPosition = '';
        if (self.slate.options.containerStyle.backgroundEffect) self.slate.options.containerStyle.backgroundColor = self.slate.filters.availableFilters[self.slate.options.containerStyle.backgroundEffect].backgroundColor;
        if (self.slate.options.containerStyle.backgroundImage) {
            self.slate.options.containerStyle.prevBackgroundColor = self.slate.options.containerStyle.backgroundColor;
            self.slate.options.containerStyle.backgroundColor = 'transparent';
            if (self.internal.parentElement) {
                self.internal.parentElement.style.backgroundImage = `url('${self.slate.options.containerStyle.backgroundImage}')`;
                if (self.slate.options.containerStyle.backgroundSize) self.internal.parentElement.style.backgroundSize = self.slate.options.containerStyle.backgroundSize;
            }
        }
        // show only on first load
        if (!self.initBg && self.slate.options.containerStyle.backgroundEffect) {
            self.initBg = true;
            self.hideBg(1);
        }
        switch(self.slate.options.containerStyle.backgroundColor){
            case 'transparent':
                if (!self.slate.options.isbirdsEye) {
                    if (self.slate.options.isEmbedding) self.internal.style.backgroundColor = '';
                    else if (!self.slate.options.containerStyle.backgroundImage) {
                        self.internal.style.backgroundImage = 'linear-gradient(45deg,rgba(13,26,43,0.1) 25%,transparent 25%,transparent 75%,rgba(13,26,43,0.1) 75%),linear-gradient(45deg,rgba(13,26,43,0.1) 25%,transparent 25%,transparent 75%,rgba(13,26,43,0.1) 75%)';
                        self.internal.style.backgroundSize = '12px 12px';
                        self.internal.style.backgroundPosition = '0 0,6px 6px';
                    }
                }
                break;
            default:
                if (self.slate.options.containerStyle.backgroundColorAsGradient) {
                    self.internal.style.backgroundColor = '';
                    if (self.internal.parentElement) self.internal.parentElement.style.background = self.exportBgStyle();
                } else self.internal.style.backgroundColor = self.exportBgStyle();
                break;
        }
        self.slate.grid?.setGrid();
    }
    exportBgStyle() {
        const self = this;
        if (self.slate.options.containerStyle.backgroundColorAsGradient) return `${self.slate.options.containerStyle.backgroundGradientType}-gradient(${self.slate.options.containerStyle.backgroundGradientColors.join(',')})`;
        else return self.slate.options.containerStyle.backgroundColor || '#fff';
    }
    get() {
        return this.internal;
    }
    draggable() {
        return this.internal;
    }
}
exports.default = canvas;

},{"lodash.uniq":"iDalh","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","../deps/raphael/raphael.svg":"jK21R","../deps/raphael/raphael.fn.shapes":"k1q4m","../deps/raphael/raphael.el.extensions":"7Msrc","../helpers/embedGoogleFonts":"jW8Fw","../deps/emile":"dd61Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5LoVV":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class sbIcons {
    static icons = {
        handle: 'M26.33,15.836l-3.893-1.545l3.136-7.9c0.28-0.705-0.064-1.505-0.771-1.785c-0.707-0.28-1.506,0.065-1.785,0.771l-3.136,7.9l-4.88-1.937l3.135-7.9c0.281-0.706-0.064-1.506-0.77-1.786c-0.706-0.279-1.506,0.065-1.785,0.771l-3.136,7.9L8.554,8.781l-1.614,4.066l2.15,0.854l-2.537,6.391c-0.61,1.54,0.143,3.283,1.683,3.895l1.626,0.646L8.985,26.84c-0.407,1.025,0.095,2.188,1.122,2.596l0.93,0.369c1.026,0.408,2.188-0.095,2.596-1.121l0.877-2.207l1.858,0.737c1.54,0.611,3.284-0.142,3.896-1.682l2.535-6.391l1.918,0.761L26.33,15.836z',
        editor: 'M25.31,2.872l-3.384-2.127c-0.854-0.536-1.979-0.278-2.517,0.576l-1.334,2.123l6.474,4.066l1.335-2.122C26.42,4.533,26.164,3.407,25.31,2.872zM6.555,21.786l6.474,4.066L23.581,9.054l-6.477-4.067L6.555,21.786zM5.566,26.952l-0.143,3.819l3.379-1.787l3.14-1.658l-6.246-3.925L5.566,26.952z',
        deleter: 'M24.778,21.419 19.276,15.917 24.777,10.415 21.949,7.585 16.447,13.087 10.945,7.585 8.117,10.415 13.618,15.917 8.116,21.419 10.946,24.248 16.447,18.746 21.948,24.248z',
        searcher: 'M29.772,26.433l-7.126-7.126c0.96-1.583,1.523-3.435,1.524-5.421C24.169,8.093,19.478,3.401,13.688,3.399C7.897,3.401,3.204,8.093,3.204,13.885c0,5.789,4.693,10.481,10.484,10.481c1.987,0,3.839-0.563,5.422-1.523l7.128,7.127L29.772,26.433zM7.203,13.885c0.006-3.582,2.903-6.478,6.484-6.486c3.579,0.008,6.478,2.904,6.484,6.486c-0.007,3.58-2.905,6.476-6.484,6.484C10.106,20.361,7.209,17.465,7.203,13.885z',
        up: 'M1.67892,15.48059l23.55337,0l-11.37616,-13.92457l-12.17721,13.92457z',
        arrow: 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM13.665,25.725l-3.536-3.539l6.187-6.187l-6.187-6.187l3.536-3.536l9.724,9.723L13.665,25.725z',
        settings: 'M16.015,12.03c-2.156,0-3.903,1.747-3.903,3.903c0,2.155,1.747,3.903,3.903,3.903c0.494,0,0.962-0.102,1.397-0.27l0.836,1.285l1.359-0.885l-0.831-1.276c0.705-0.706,1.142-1.681,1.142-2.757C19.918,13.777,18.171,12.03,16.015,12.03zM16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466zM26.174,20.809c-0.241,0.504-0.513,0.99-0.826,1.45L22.19,21.58c-0.481,0.526-1.029,0.994-1.634,1.385l0.119,3.202c-0.507,0.23-1.028,0.421-1.569,0.57l-1.955-2.514c-0.372,0.051-0.75,0.086-1.136,0.086c-0.356,0-0.706-0.029-1.051-0.074l-1.945,2.5c-0.541-0.151-1.065-0.342-1.57-0.569l0.117-3.146c-0.634-0.398-1.208-0.88-1.712-1.427L6.78,22.251c-0.313-0.456-0.583-0.944-0.826-1.448l2.088-2.309c-0.226-0.703-0.354-1.451-0.385-2.223l-2.768-1.464c0.055-0.563,0.165-1.107,0.301-1.643l3.084-0.427c0.29-0.702,0.675-1.352,1.135-1.942L8.227,7.894c0.399-0.389,0.83-0.744,1.283-1.07l2.663,1.672c0.65-0.337,1.349-0.593,2.085-0.75l0.968-3.001c0.278-0.021,0.555-0.042,0.837-0.042c0.282,0,0.56,0.022,0.837,0.042l0.976,3.028c0.72,0.163,1.401,0.416,2.036,0.75l2.704-1.697c0.455,0.326,0.887,0.681,1.285,1.07l-1.216,2.986c0.428,0.564,0.793,1.181,1.068,1.845l3.185,0.441c0.135,0.535,0.247,1.081,0.302,1.643l-2.867,1.516c-0.034,0.726-0.15,1.43-0.355,2.1L26.174,20.809z',
        sliderHandle: 'M16,3.5c-4.142,0-7.5,3.358-7.5,7.5c0,4.143,7.5,18.121,7.5,18.121S23.5,15.143,23.5,11C23.5,6.858,20.143,3.5,16,3.5z M16,14.584z',
        speechbubble: 'M16,5.333c-7.732,0-14,4.701-14,10.5c0,1.982,0.741,3.833,2.016,5.414L2,25.667l5.613-1.441c2.339,1.317,5.237,2.107,8.387,2.107c7.732,0,14-4.701,14-10.5C30,10.034,23.732,5.333,16,5.333z',
        link: 'M15.667,4.601c-1.684,1.685-2.34,3.985-2.025,6.173l3.122-3.122c0.004-0.005,0.014-0.008,0.016-0.012c0.21-0.403,0.464-0.789,0.802-1.126c1.774-1.776,4.651-1.775,6.428,0c1.775,1.773,1.777,4.652,0.002,6.429c-0.34,0.34-0.727,0.593-1.131,0.804c-0.004,0.002-0.006,0.006-0.01,0.01l-3.123,3.123c2.188,0.316,4.492-0.34,6.176-2.023c2.832-2.832,2.83-7.423,0-10.255C23.09,1.77,18.499,1.77,15.667,4.601zM14.557,22.067c-0.209,0.405-0.462,0.791-0.801,1.131c-1.775,1.774-4.656,1.774-6.431,0c-1.775-1.774-1.775-4.653,0-6.43c0.339-0.338,0.725-0.591,1.128-0.8c0.004-0.006,0.005-0.012,0.011-0.016l3.121-3.123c-2.187-0.316-4.489,0.342-6.172,2.024c-2.831,2.831-2.83,7.423,0,10.255c2.833,2.831,7.424,2.831,10.257,0c1.684-1.684,2.342-3.986,2.023-6.175l-3.125,3.123C14.565,22.063,14.561,22.065,14.557,22.067zM9.441,18.885l2.197,2.197c0.537,0.537,1.417,0.537,1.953,0l8.302-8.302c0.539-0.536,0.539-1.417,0.002-1.952l-2.199-2.197c-0.536-0.539-1.416-0.539-1.952-0.002l-8.302,8.303C8.904,17.469,8.904,18.349,9.441,18.885z',
        copy: 'M 20.48 7.28 H 9.92 c -0.968 0 -1.76 0.792 -1.76 1.76 v 12.32 h 1.76 V 9.04 h 10.56 V 7.28 z m 2.64 3.52 H 13.44 c -0.968 0 -1.76 0.792 -1.76 1.76 v 12.32 c 0 0.968 0.792 1.76 1.76 1.76 h 9.68 c 0.968 0 1.76 -0.792 1.76 -1.76 V 12.56 c 0 -0.968 -0.792 -1.76 -1.76 -1.76 z m 0 14.08 H 13.44 V 12.56 h 9.68 v 12.32 z',
        plus: 'M25.979,12.896 19.312,12.896 19.312,6.229 12.647,6.229 12.647,12.896 5.979,12.896 5.979,19.562 12.647,19.562 12.647,26.229 19.312,26.229 19.312,19.562 25.979,19.562z',
        minus: 'M25.979,12.896,5.979,12.896,5.979,19.562,25.979,19.562z',
        arrowHead: 'M15.834,29.084 15.834,16.166 2.917,16.166 29.083,2.917z',
        undo: 'M12.981,9.073V6.817l-12.106,6.99l12.106,6.99v-2.422c3.285-0.002,9.052,0.28,9.052,2.269c0,2.78-6.023,4.263-6.023,4.263v2.132c0,0,13.53,0.463,13.53-9.823C29.54,9.134,17.952,8.831,12.981,9.073z',
        lockClosed: 'M24.875,15.334v-4.876c0-4.894-3.981-8.875-8.875-8.875s-8.875,3.981-8.875,8.875v4.876H5.042v15.083h21.916V15.334H24.875zM10.625,10.458c0-2.964,2.411-5.375,5.375-5.375s5.375,2.411,5.375,5.375v4.876h-10.75V10.458zM18.272,26.956h-4.545l1.222-3.667c-0.782-0.389-1.324-1.188-1.324-2.119c0-1.312,1.063-2.375,2.375-2.375s2.375,1.062,2.375,2.375c0,0.932-0.542,1.73-1.324,2.119L18.272,26.956z',
        lockOpen: 'M24.875,15.334v-4.876c0-4.894-3.981-8.875-8.875-8.875s-8.875,3.981-8.875,8.875v0.375h3.5v-0.375c0-2.964,2.411-5.375,5.375-5.375s5.375,2.411,5.375,5.375v4.876H5.042v15.083h21.916V15.334H24.875zM18.272,26.956h-4.545l1.222-3.667c-0.782-0.389-1.324-1.188-1.324-2.119c0-1.312,1.063-2.375,2.375-2.375s2.375,1.062,2.375,2.375c0,0.932-0.542,1.73-1.324,2.119L18.272,26.956z',
        download: 'M62.498910964222794,5C30.742627701282224,5,5,30.744805772836607,5,62.498910964222794C5,94.25519422716337,30.744805772836607,120,62.498910964222794,120C94.25519422716337,120,120,94.2551942271634,120,62.49891096422281C120,30.742627701282238,94.2551942271634,5.000000000000014,62.49891096422281,5.000000000000014C62.49891096422281,5.000000000000014,62.498910964222794,5,62.498910964222794,5M62.50108903577718,90.76374552548342C62.50108903577718,90.76374552548342,43.81105702759522,62.498910964222794,43.81105702759522,62.498910964222794C43.81105702759522,62.498910964222794,51.6085531922953,62.498910964222794,51.6085531922953,62.498910964222794C51.6085531922953,62.498910964222794,51.6085531922953,36.362052311596806,51.6085531922953,36.362052311596806C51.6085531922953,36.362052311596806,71.21119718176479,36.362052311596806,71.21119718176479,36.362052311596806C71.21119718176479,36.362052311596806,71.21119718176479,62.498910964222794,71.21119718176479,62.498910964222794C71.21119718176479,62.498910964222794,81.18676490085039,62.498910964222794,81.18676490085039,62.498910964222794C81.18676490085039,62.498910964222794,62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342C62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342,62.50108903577718,90.76374552548342',
        embed: 'M62.49999999999999,5C30.759999999999998,5,5,30.759999999999998,5,62.49999999999999C5,94.23999999999998,30.759999999999998,120,62.49999999999999,120C94.23999999999998,120,120,94.23999999999998,120,62.49999999999999C120,30.760000000000005,94.23999999999998,5,62.49999999999999,5C62.49999999999999,5,62.49999999999999,5,62.49999999999999,5M46.285,74.57499999999999C47.894999999999996,76.41499999999999,47.665,79.28999999999999,45.824999999999996,80.9C43.98499999999999,82.51000000000002,41.10999999999999,82.28,39.5,80.44C39.5,80.44,26.505,65.375,26.505,65.375C25.009999999999998,63.65,25.009999999999998,61.23499999999999,26.505,59.50999999999999C26.505,59.50999999999999,39.385,44.44499999999999,39.385,44.44499999999999C40.19,43.41,41.455,42.834999999999994,42.834999999999994,42.834999999999994C43.86999999999999,42.834999999999994,44.904999999999994,43.17999999999999,45.709999999999994,43.86999999999999C46.62999999999999,44.675,47.20499999999999,45.709999999999994,47.20499999999999,46.974999999999994C47.31999999999999,48.125,46.85999999999999,49.275,46.169999999999995,50.19499999999999C46.169999999999995,50.19499999999999,35.81999999999999,62.49999999999999,35.81999999999999,62.49999999999999C35.81999999999999,62.49999999999999,46.285,74.57499999999999,46.285,74.57499999999999C46.285,74.57499999999999,46.285,74.57499999999999,46.285,74.57499999999999M73.08,49.275C73.08,49.275,60.199999999999996,79.28999999999999,60.199999999999996,79.28999999999999C59.28,81.475,56.519999999999996,82.625,54.334999999999994,81.59C53.184999999999995,81.13,52.37999999999999,80.20999999999998,51.919999999999995,79.17500000000001C51.459999999999994,78.025,51.459999999999994,76.875,51.919999999999995,75.725C51.919999999999995,75.725,64.8,45.709999999999994,64.8,45.709999999999994C65.49,44.099999999999994,67.1,42.949999999999996,68.94,42.949999999999996C69.515,42.949999999999996,70.09,43.065,70.66499999999999,43.294999999999995C71.815,43.754999999999995,72.62,44.675,73.08,45.709999999999994C73.53999999999999,46.974999999999994,73.53999999999999,48.125,73.08,49.275C73.08,49.275,73.08,49.275,73.08,49.275M98.495,65.375C98.495,65.375,85.61499999999998,80.44,85.61499999999998,80.44C84.005,82.28,81.13,82.50999999999999,79.28999999999999,80.9C77.44999999999999,79.29000000000002,77.22,76.41499999999999,78.82999999999998,74.57499999999999C78.82999999999998,74.57499999999999,89.17999999999998,62.49999999999999,89.17999999999998,62.49999999999999C89.17999999999998,62.49999999999999,78.715,50.425,78.715,50.425C77.91,49.505,77.565,48.355,77.68,47.205C77.79499999999999,46.055,78.37,44.905,79.17500000000001,44.099999999999994C79.98000000000002,43.41,81.01499999999999,43.065,82.05000000000001,43.065C83.315,43.065,84.58000000000001,43.64,85.5,44.675C85.5,44.675,98.495,59.739999999999995,98.495,59.739999999999995C99.98999999999998,61.23499999999999,99.98999999999998,63.765,98.495,65.375C98.495,65.375,98.495,65.375,98.495,65.375',
        trash: 'M 13.56 8.28 h 5.28 v -1.54 c 0 -0.0581 -0.0229 -0.1144 -0.0642 -0.1558 c -0.0414 -0.0414 -0.0977 -0.0642 -0.1558 -0.0642 h -4.84 c -0.0581 0 -0.1144 0.0229 -0.1558 0.0642 c -0.0414 0.0414 -0.0642 0.0977 -0.0642 0.1558 v 1.54 z m 9.68 0.88 h -14.08 v 15.84 c 0 0.4858 0.3942 0.88 0.88 0.88 h 12.32 c 0.4858 0 0.88 -0.3942 0.88 -0.88 v -15.84 z m -8.8 3.08 c 0 -0.2429 -0.1971 -0.44 -0.44 -0.44 s -0.44 0.1971 -0.44 0.44 v 10.56 c 0 0.2429 0.1971 0.44 0.44 0.44 s 0.44 -0.1971 0.44 -0.44 v -10.56 z m 4.4 0 c 0 -0.2429 -0.1971 -0.44 -0.44 -0.44 s -0.44 0.1971 -0.44 0.44 v 10.56 c 0 0.2429 0.1971 0.44 0.44 0.44 s 0.44 -0.1971 0.44 -0.44 v -10.56 z m 7.04 -3.96 v 0.88 h -1.76 v 15.84 c 0 0.9724 -0.7876 1.76 -1.76 1.76 h -12.32 c -0.9724 0 -1.76 -0.7876 -1.76 -1.76 v -15.84 h -1.76 v -0.88 h 6.16 v -1.76 c 0 -0.4858 0.3942 -0.88 0.88 -0.88 h 5.28 c 0.4858 0 0.88 0.3942 0.88 0.88 v 1.76 h 6.16 z',
        resize: 'M24 10.999v-10.999h-11l3.379 3.379-13.001 13-3.378-3.378v10.999h11l-3.379-3.379 13.001-13z'
    };
}
exports.default = sbIcons;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1q4m":[function(require,module,exports,__globalThis) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shapes", ()=>shapes);
var _sbIconsJs = require("../../helpers/sbIcons.js");
var _sbIconsJsDefault = parcelHelpers.interopDefault(_sbIconsJs);
const shapes = function(R) {
    const c = 'M16,1.466C7.973,1.466,1.466,7.973,1.466,16c0,8.027,6.507,14.534,14.534,14.534c8.027,0,14.534-6.507,14.534-14.534C30.534,7.973,24.027,1.466,16,1.466z';
    const { icons } = (0, _sbIconsJsDefault.default);
    R.fn.handle = function(x, y) {
        return this.path(icons.handle + c);
    };
    R.fn.editor = function(x, y) {
        return this.path(icons.editor + c);
    };
    R.fn.deleter = function(x, y) {
        return this.path(icons.deleter + c);
    };
    R.fn.trash = function() {
        return this.path(icons.trash + c).attr({
            fill: '#000'
        });
    };
    R.fn.searcher = function(x, y) {
        return this.path(icons.searcher + c);
    };
    R.fn.plus = function(x, y) {
        return this.path(icons.plus + c);
    };
    R.fn.merge = function(x, y) {
        return this.path(icons.plus + c);
    };
    R.fn.copy = function(x, y) {
        return this.path(icons.copy + c);
    };
    R.fn.minus = function(x, y) {
        return this.path(icons.minus + c);
    };
    R.fn.link = function(x, y) {
        return this.path(icons.link + c);
    };
    R.fn.up = function(x, y) {
        return this.path(icons.up);
    };
    R.fn.down = function(x, y) {
        return this.path(icons.up).transform('r180');
    };
    R.fn.setting = function(x, y) {
        return this.path(icons.settings + c).transform('s,.9,.9');
    };
    R.fn.arrow = function() {
        return this.path(icons.arrow + c);
    };
    R.fn.arrowHead = function() {
        return this.path(icons.arrowHead).attr({
            fill: '#648CB2'
        }).transform('s0.7');
    };
    R.fn.linkArrow = function() {
        return this.path(icons.arrow + c).attr({
            fill: '#648CB2'
        });
    };
    R.fn.lockClosed = function() {
        return this.path(icons.lockClosed);
    };
    R.fn.lockOpen = function() {
        return this.path(icons.lockOpen);
    };
    R.fn.speechbubble = function(x, y, txt) {
        const _bubble = this.set();
        _bubble.push(this.path(icons.speechbubble).transform([
            't',
            x,
            ',',
            y
        ].join()).scale(6, 4).scale(-1, 1)).attr({
            fill: '#fff',
            stroke: '#000',
            'stroke-width': 3
        });
        _bubble.push(this.text(x + 10, y + 10, txt).attr({
            'font-size': 12
        }));
        return _bubble;
    };
    R.fn.undo = function(path) {
        return this.path(icons.undo);
    };
    R.fn.redo = function(path) {
        return this.path(icons.undo).transform('s-1,1');
    };
    R.fn.resize = function() {
        return this.path(`M24 10.999v-10.999h-11l3.379 3.379-13.001 13-3.378-3.378v10.999h11l-3.379-3.379 13.001-13z`);
    };
    R.fn.resizeLines = function() {
        return this.image('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAXCAYAAAAP6L+eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAEBJREFUeNpiYKAuYAPijUD8n1aGVowaOmoo/QyNpYWh+UB8g1aGSowaOmroqKEEAE0MZaCVoQxEFH3e5BgKEGAAnnVBs4ro6nUAAAAASUVORK5CYII=', 0, 0, 22, 23);
    };
};

},{"../../helpers/sbIcons.js":"5LoVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Msrc":[function(require,module,exports,__globalThis) {
/* eslint-disable */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "extensions", ()=>extensions);
const extensions = function(R) {
    R.el.loop = function(_options) {
        const _self = this;
        const options = {
            pkg: [
                {
                    'stroke-width': 3
                },
                {
                    'stroke-width': 1
                }
            ],
            duration: 200,
            repeat: false
        };
        Object.assign(options, _options);
        function loop() {
            _self.animate(options.pkg[0], options.duration, ()=>{
                _self.animate(options.pkg[1], options.duration, ()=>{
                    if (options.repeat) loop();
                });
            });
        }
        loop();
        return _self;
    };
    R.el.tooltip = function(obj, w, h) {
        if (w === undefined) w = 80;
        if (h === undefined) h = 20;
        const _tt = this.paper.set();
        const pos = this.getBBox();
        if (obj.type === 'text') {
            // text tooltip
            _tt.push(this.paper.rect(pos.x, pos.y + h * -1 - 10, w, h, 5).attr({
                fill: '#fff'
            }));
            _tt.push(this.paper.text(pos.x + 5, pos.y - 20, '').attr({
                'text-anchor': 'start',
                stroke: '#fff',
                'font-size': 13,
                fill: '#fff'
            }));
        } else {
            // image tooltip
            const xpad = w * -1 - 5;
            _tt.push(this.paper.rect(pos.x + xpad, pos.y + h / 2 * -1, w, h, 15).attr({
                'stroke-width': 2,
                stroke: '#fff',
                'z-index': 9999
            }));
            _tt.push(this.paper.rect(pos.x + xpad, pos.y + (h / 2 - 45), w, 47, 15)).attr({
                'stroke-width': 2,
                fill: '90-#333-#000',
                'z-index': 9999
            });
            _tt.push(this.paper.text(pos.x + xpad + w / 2, pos.y + (h / 2 - 20), '').attr({
                'text-anchor': 'middle',
                stroke: '#fff',
                'font-weight': 'normal',
                'font-family': 'Verdana',
                'font-size': 11,
                'z-index': 999
            }));
        }
        const s = this;
        if (!s.removed) {
            s.tt = _tt;
            if (obj.type === 'text') s.tt[0].animate({
                stroke: '#000',
                fill: '#333'
            }, 200, ()=>{
                s.tt[1].attr({
                    text: obj.msg
                });
            });
            else s.tt[0].animate({
                stroke: '#000',
                fill: '#333'
            }, 200, ()=>{
                // s.tt[1].attr({  });
                s.tt[2].attr({
                    text: obj.msg
                });
            });
        }
        return s.tt;
    };
    R.el.untooltip = function() {
        this.tt && this.tt.remove();
        return this;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jW8Fw":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const kCSSFontFacePattern = /(@font\-face {[\s\S]*?})/g;
const kCSSUrlPattern = /url\((https.+?)\)/;
function fontToDataURLViaBlob(fontUrl) {
    return fetch(fontUrl).then((fontResponse)=>fontResponse.blob()).then((fontBlob)=>new Promise((resolve)=>{
            const reader = new FileReader();
            reader.onload = ()=>{
                resolve(reader.result);
            };
            reader.readAsDataURL(fontBlob);
        }));
}
function fontToDataURLViaBuffer(fontUrl) {
    return fetch(fontUrl).then((fontResponse)=>Promise.all([
            Promise.resolve(fontResponse.headers.get('content-type')),
            fontResponse.buffer()
        ])).then((fontBuffer)=>{
        const b64 = fontBuffer[1].toString('base64');
        return `data:${fontBuffer[0]};base64,${b64}`;
    });
}
function embedFont(fontFace) {
    const fontUrlMatch = kCSSUrlPattern.exec(fontFace);
    let promise;
    if (typeof FileReader !== 'undefined') promise = fontToDataURLViaBlob(fontUrlMatch[1]);
    else promise = fontToDataURLViaBuffer(fontUrlMatch[1]);
    return promise.then((dataURL)=>fontFace.replace(fontUrlMatch[1], dataURL));
}
function embedGoogleFonts({ fonts, text, styleNode }) {
    const snode = styleNode;
    const fontQuery = fonts.join('|').replace(/ /g, '+');
    const googleFontUrl = `https://fonts.googleapis.com/css?family=${fontQuery}&text=${text}`;
    if (fonts.length > 0) return fetch(googleFontUrl).then((cssResponse)=>cssResponse.text()).catch((error)=>{
        console.error('Failed to load Google font CSS:', error);
        return false;
    }).then((cssText)=>{
        let fontFaces = kCSSFontFacePattern.exec(cssText);
        const embedFontPromises = [];
        while(fontFaces != null){
            embedFontPromises.push(embedFont(fontFaces[1]));
            fontFaces = kCSSFontFacePattern.exec(cssText);
        }
        return Promise.all(embedFontPromises);
    }).catch((error)=>{
        console.error('Failed to load Google font CSS:', error);
        return false;
    }).then((results)=>{
        snode.innerHTML += results.join('\n');
        return true;
    });
    return Promise.resolve(true);
}
exports.default = embedGoogleFonts;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dd61Y":[function(require,module,exports,__globalThis) {
/* eslint-disable */ // emile.js (c) 2009 Thomas Fuchs
// Licensed under the terms of the MIT license.
(function(emile, container) {
    const parseEl = document.createElement('div');
    const props = "backgroundColor borderBottomColor borderBottomWidth borderLeftColor borderLeftWidth borderRightColor borderRightWidth borderSpacing borderTopColor borderTopWidth bottom color fontSize fontWeight height left letterSpacing lineHeight marginBottom marginLeft marginRight marginTop maxHeight maxWidth minHeight minWidth opacity outlineColor outlineOffset outlineWidth paddingBottom paddingLeft paddingRight paddingTop right textIndent top width wordSpacing zIndex".split(' ');
    function interpolate(source, target, pos) {
        return parseFloat(source + (target - source) * pos).toFixed(3);
    }
    function s(str, p, c) {
        return str.substr(p, c || 1);
    }
    function color(source, target, pos) {
        let i = 2;
        let j;
        let c;
        let tmp;
        const v = [];
        const r = [];
        while(j = 3, c = arguments[i - 1], i--)if (s(c, 0) == 'r') {
            c = c.match(/\d+/g);
            while(j--)v.push(~~c[j]);
        } else {
            if (c.length == 4) c = `#${s(c, 1)}${s(c, 1)}${s(c, 2)}${s(c, 2)}${s(c, 3)}${s(c, 3)}`;
            while(j--)v.push(parseInt(s(c, 1 + j * 2, 2), 16));
        }
        while(j--){
            tmp = ~~(v[j + 3] + (v[j] - v[j + 3]) * pos);
            r.push(tmp < 0 ? 0 : tmp > 255 ? 255 : tmp);
        }
        return `rgb(${r.join(',')})`;
    }
    function parse(prop) {
        const p = parseFloat(prop);
        const q = prop.replace(/^[\-\d\.]+/, '');
        return Number.isNaN(p) ? {
            v: q,
            f: color,
            u: ''
        } : {
            v: p,
            f: interpolate,
            u: q
        };
    }
    function normalize(style) {
        let css;
        const rules = {};
        let i = props.length;
        let v;
        parseEl.innerHTML = `<div style="${style}"></div>`;
        css = parseEl.childNodes[0].style;
        while(i--)if (v = css[props[i]]) rules[props[i]] = parse(v);
        return rules;
    }
    container[emile] = function(el, style, opts) {
        el = typeof el === 'string' ? document.getElementById(el) : el;
        opts = opts || {};
        const target = normalize(style);
        const comp = el.currentStyle ? el.currentStyle : getComputedStyle(el, null);
        let prop;
        const current = {};
        const start = +new Date();
        const dur = opts.duration || 200;
        const finish = start + dur;
        let interval;
        const easing = opts.easing || function(pos) {
            return -Math.cos(pos * Math.PI) / 2 + 0.5;
        };
        for(prop in target)current[prop] = parse(comp[prop]);
        interval = setInterval(function() {
            window.requestAnimationFrame(()=>{
                const time = +new Date();
                const pos = time > finish ? 1 : (time - start) / dur;
                for(prop in target){
                    const tv = opts.onMove ? opts.onMove(prop) : target[prop].f(current[prop].v, target[prop].v, easing(pos));
                    el.style[prop] = tv + target[prop].u;
                }
                if (time > finish) {
                    clearInterval(interval);
                    opts.after && opts.after();
                } else opts.during && opts.during.apply(this, [
                    (time - start) / dur
                ]);
            });
        }, 10);
    };
})('emile', window);

},{}],"eYgJm":[function(require,module,exports,__globalThis) {
/* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _yjs = require("yjs");
var _yWebsocket = require("y-websocket");
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class collab {
    constructor(slate){
        this.slate = slate;
        this.invoker = null;
        this.constants = {
            mapName: 'collabPackages',
            lastMapDocName: 'last',
            ommittableUserData: [
                'websocketUrl',
                'websocketParams'
            ],
            onCollaborationUserCustomDataChanged: 'onCollaborationUserCustomDataChanged',
            onNodeAITextChanged: 'onNodeAITextChanged'
        };
        if (!(0, _utilsDefault.default).localRecipients) (0, _utilsDefault.default).localRecipients = [];
        this.xyMap = {};
        this.wire();
    }
    exe(pkg) {
        const self = this;
        if (!Array.isArray(pkg)) pkg = [
            pkg
        ];
        pkg.forEach((p)=>{
            // for local...
            self.invoke(p);
            // for remote...
            self.send(p);
        });
    }
    wire() {
        const self = this;
        function resetMultiSelect() {
            self.slate.multiSelection?.end();
        }
        self.invoker = {
            onZoom (pkg) {
                if (self.slate.options.followMe) {
                    resetMultiSelect();
                    const zoomPercent = self.slate.options.viewPort.originalWidth / pkg.data.zoomLevel * 100;
                    self.slate.canvas.zoom({
                        dur: pkg.data.duration || 500,
                        zoomPercent,
                        callbacks: {
                            during () {
                            // additional calcs
                            },
                            after () {}
                        }
                    });
                }
            },
            onNodePositioned (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.position(pkg.data.location, ()=>{}, pkg.data.easing, pkg.data.duration || 500);
                self.closeNodeSpecifics(pkg);
            },
            onNodeLinkRemoved (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.links?.unset(false);
                self.closeNodeSpecifics(pkg);
            },
            onNodeLinkAdded (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.links?.set(pkg, false);
                self.closeNodeSpecifics(pkg);
            },
            onNodeUnlocked (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    cn.options.allowDrag = true;
                    cn.options.isLocked = false;
                    cn.hideLock();
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeLocked (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    cn.options.allowDrag = false;
                    cn.options.isLocked = true;
                    cn?.showLock();
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeBehaviorChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    pkg.data.behaviorChanges.forEach((b)=>{
                        if (typeof b.value === 'object') {
                            cn.options[b.name] = b.value.val;
                            Object.keys(b.value).forEach((k)=>{
                                if (k !== 'val') cn.options[k] = b.value[k];
                            });
                        } else cn.options[b.name] = b.value;
                    });
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeToBack (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.toBack();
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeToFront (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.toFront();
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeShapeChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.shapes.set(pkg.data);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeAdded (pkg) {
                resetMultiSelect();
                if (pkg.data?.multiSelectCopy) // this is a multiSelection copy
                self.slate.multiSelection.createCopiedNodes(pkg.data.nodeOptions, pkg.data.assocDetails);
                else if (pkg.data.id) {
                    const exists = self.slate.nodes.one(pkg.data.options.id);
                    if (!exists) {
                        // by design: the id is the parent of the node being created
                        const cn = self.slate.nodes.one(pkg.data.id);
                        cn?.connectors.createNode(pkg.data.skipCenter, pkg.data.options, pkg.data.targetXPos, pkg.data.targetYPos);
                    } else console.log('node id already existed, caught dup', pkg.data.options.id);
                } else {
                    // straight up node addition
                    let nodesToCreate = pkg.data.nodeOptions;
                    if (!Array.isArray(nodesToCreate)) nodesToCreate = [
                        nodesToCreate
                    ];
                    nodesToCreate.forEach((nOpts)=>{
                        // sanity check
                        const exists = self.slate.nodes.one(nOpts.id);
                        if (!exists) {
                            const n = new (0, _nodeDefault.default)(nOpts);
                            self.slate.nodes.add(n);
                        }
                    });
                }
            },
            onNodeImageChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.images.set(pkg.data.img, pkg.data.w, pkg.data.h);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeDeleted (pkg) {
                resetMultiSelect();
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.del();
                self.slate.birdsEye?.nodeDeleted(pkg);
            },
            onNodeResized (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.hideOwnMenus();
                const opts = {
                    associations: pkg.data.associations,
                    animate: true
                };
                Object.assign(cn.options, (0, _lodashOmitDefault.default)(pkg.data, [
                    'associations',
                    'textPosition'
                ]));
                cn?.resize.animateSet(pkg.data, opts);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeRotated (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) {
                    // needs to be updated
                    cn.options.textOffset = pkg.data.textOffset;
                    cn?.hideOwnMenus();
                    const previousRotationAngle = cn.options.rotate.rotationAngle;
                    const opts = {
                        associations: pkg.data.associations,
                        animate: true
                    };
                    Object.assign(cn.options, (0, _lodashOmitDefault.default)(pkg.data, 'associations'));
                    cn?.rotate.animateSet({
                        ...pkg.data,
                        rotationAngle: pkg.data.rotate.rotationAngle - previousRotationAngle
                    }, opts);
                    self.slate.birdsEye?.nodeChanged(pkg);
                    self.closeNodeSpecifics(pkg);
                }
            },
            onNodeColorChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.colorPicker.set(pkg.data);
                self.slate.birdsEye?.nodeChanged(pkg);
            },
            onNodeTextChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.editor.set(pkg.data.text, pkg.data.fontSize, pkg.data.fontFamily, pkg.data.fontColor, pkg.data.textOpacity, pkg.data.textXAlign, pkg.data.textYAlign);
                self.slate.birdsEye?.nodeChanged(pkg);
                self.slate.loadAllFonts();
            },
            onNodeAITextChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                if (cn) cn.options.ai = {
                    ...pkg.data.ai,
                    ...cn.options.ai
                };
            },
            addRelationship (pkg) {
                resetMultiSelect();
                self.slate.nodes.addRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
            },
            removeRelationship (pkg) {
                resetMultiSelect();
                self.slate.nodes.removeRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
            },
            onNodesMove (pkg) {
                resetMultiSelect();
                self.slate.toggleFilters(true, null, true);
                self.slate.nodes.moveNodes(pkg, {
                    animate: pkg.data.dur > 0
                });
                self.slate.birdsEye?.nodeChanged(pkg);
                self.closeNodeSpecifics(pkg);
            },
            onNodeEffectChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.applyFilters(pkg.data.filter);
            },
            onNodeBorderPropertiesChanged (pkg) {
                const cn = self.slate.nodes.one(pkg.data.id);
                cn?.applyBorder(pkg.data);
            },
            onLinePropertiesChanged (pkg) {
                const upkg = pkg;
                self.slate.toggleFilters(true, null, true);
                if (!upkg.data.forEach) upkg.data = [
                    upkg.data
                ];
                upkg.data.forEach((p)=>{
                    const cn = self.slate.nodes.one(p.id);
                    Object.assign(cn?.options, p.options);
                    cn?.lineOptions.set(p);
                });
            },
            onFollowMeChanged (pkg) {
                self.slate.options.followMe = pkg.data?.followMe;
            },
            onCanvasMove (pkg) {
                if (self.slate.options.followMe) {
                    self.slate.toggleFilters(true, null, true);
                    const opts = {
                        x: pkg.data.left,
                        y: pkg.data.top,
                        dur: pkg.data.duration || 500,
                        callback: {
                            after () {
                                self.slate.birdsEye?.refresh(true);
                            }
                        },
                        isAbsolute: !pkg.isRelative
                    };
                    self.slate.canvas.move(opts);
                }
            },
            onSlateThemeChanged (pkg) {
                self.slate.options.themeId = pkg.data?.theme?._id;
                if (pkg.data?.theme) self.slate.applyTheme(pkg.data.theme, pkg.data.syncWithTheme);
            },
            onSlateLayoutTypeChanged (pkg) {
                if (pkg.data.layoutType != null) self.slate.options.layoutType = pkg.data.layoutType;
                if (pkg.data.disableAutoLayoutOfManuallyPositionedNodes != null) self.slate.options.disableAutoLayoutOfManuallyPositionedNodes = pkg.data.disableAutoLayoutOfManuallyPositionedNodes;
            },
            onSlateBackgroundEffectChanged (pkg) {
                self.slate.options.containerStyle.backgroundEffect = pkg.data.effect;
                self.slate.canvas.hideBg(1);
            // self.slate.png({ backgroundOnly: true, base64: true }, (base64) => {
            //   self.slate.canvas.internal.style.background = base64;
            //   self.slate.canvas._bg?.remove();
            // });
            },
            onSlateBackgroundImageChanged (pkg) {
                if (pkg.data.bg) {
                    self.slate.options.containerStyle.backgroundImage = pkg.data.bg.url;
                    self.slate.options.containerStyle.backgroundSize = pkg.data.bg.size;
                } else {
                    const c = self.slate.options.containerStyle.prevBackgroundColor || '#fff';
                    self.slate.options.containerStyle.backgroundColor = c;
                    self.slate.options.containerStyle.backgroundImage = null;
                    self.slate.options.containerStyle.backgroundEffect = null;
                }
                self.slate.canvas.hideBg(1);
            },
            onSlateBackgroundColorChanged (pkg) {
                self.slate.options.containerStyle.backgroundColor = pkg.data.color;
                self.slate.options.containerStyle.backgroundColorAsGradient = pkg.data.asGradient;
                self.slate.options.containerStyle.backgroundGradientType = pkg.data.gradientType;
                self.slate.options.containerStyle.backgroundGradientColors = pkg.data.gradientColors;
                self.slate.options.containerStyle.backgroundGradientStrategy = pkg.data.gradientStrategy;
                self.slate.options.containerStyle.backgroundImage = null;
                self.slate.options.containerStyle.backgroundEffect = null;
                self.slate.canvas.hideBg(1);
            },
            onLineColorChanged (pkg) {
                self.slate.options.defaultLineColor = pkg.data.color;
                self.slate.nodes.allNodes.forEach((n)=>{
                    n.options.lineColor = pkg.data.color;
                    n.relationships.associations.forEach((a)=>{
                        a.lineColor = pkg.data.color;
                    });
                    n.relationships.refreshOwnRelationships();
                });
            },
            onSlateAISet (pkg) {
                self.slate.options.ai = {
                    ...self.slate.options.ai || {},
                    ...pkg.data
                };
            },
            onSlateNameChanged (pkg) {
                self.slate.options.name = pkg.data.name;
            },
            onSlateDescriptionChanged (pkg) {
                self.slate.options.description = pkg.data.description;
            },
            onSlateShowGridChanged (pkg) {
                self.slate.options.viewPort.showGrid = pkg.data.showGrid;
                if (pkg.data.showGrid) self.slate.grid.show();
                else self.slate.grid.destroy();
            },
            onSlateMindMapModeChanged (pkg) {
                self.slate.options.mindMapMode = pkg.data.mindMapMode;
            },
            onSlateAutoResizeNodesBasedOnTextChanged (pkg) {
                self.slate.options.autoResizeNodesBasedOnText = pkg.data.autoResizeNodesBasedOnText;
            },
            onSlateTagsAndTemplateMarkdownChanged (pkg) {
                self.slate.options.tags = pkg.data.tags;
                self.slate.options.templateMarkdown = pkg.data.templateMarkdown;
                self.slate.options.templatePrompt = pkg.data.templatePrompt;
            },
            onSlateTemplateChanged (pkg) {
                self.slate.options.isTemplate = pkg.data.isTemplate;
            },
            onSlateSnapToObjectsChanged (pkg) {
                self.slate.options.viewPort.snapToObjects = pkg.data.snapToObjects;
            },
            onSlateFollowMeChanged (pkg) {
                self.slate.options.followMe = pkg.data.followMe;
            },
            onSlateHuddleChanged (pkg) {
                if (pkg.data.huddleType != null) self.slate.options.huddleType = pkg.data.huddleType;
                if (pkg.data.huddleEnabled != null) self.slate.options.huddleEnabled = pkg.data.huddleEnabled;
            }
        } // this invoker
        ;
    }
    _process(pkg) {
        const self = this;
        if ((0, _utilsDefault.default).localRecipients.length > 1) {
            let _time = 0;
            (0, _utilsDefault.default).localRecipients.forEach((s)=>{
                _time += 10;
                ((rec, t)=>{
                    setTimeout(()=>{
                        rec.collab.invoke(pkg);
                    }, t);
                })((0, _utilsDefault.default).localRecipients[s], _time);
            });
        } else if (self.invoker[pkg.type]) self.invoker[pkg.type](pkg);
    // else if (self.pc.onCollaboration) {
    //   self.pc.onCollaboration({ type: 'custom', slate: self.slate, pkg })
    // }
    }
    invoke(pkg) {
        const self = this;
        let packages = pkg;
        if (!Array.isArray(packages)) packages = [
            packages
        ];
        for (let pkg of packages)if (self.invoker[pkg.type]) self.invoker[pkg.type](pkg);
    }
    closeNodeSpecifics(pkg) {
        const self = this;
        const all = pkg.data.nodeOptions ? pkg.data.nodeOptions : [
            pkg.data
        ];
        all.forEach((n)=>{
            // close self node's marker if open
            const nx = self.slate.nodes.one(n.id);
            if (nx) {
                nx.menu?.hide();
                nx.connectors?.remove();
                nx.resize?.hide();
                nx.rotate?.hide();
                nx.relationships.associations.forEach((association)=>{
                    nx.lineOptions?.hide(association.id);
                });
            } else console.error('Unable to find node with id', n.id, 'currentIds', self.slate.nodes.allNodes.map((nx)=>nx.options.id));
        });
        // remove any context menus
        self.slate.removeContextMenus();
        self.slate.untooltip();
    }
    async init() {
        const self = this;
        if (self.slate.options.isbirdsEye) // not allowed
        return;
        // go get the server url here
        if (self.collabPackage) {
            console.error('Unable to collaborate - collabPackage already created');
            return;
        }
        // ALL yjs depenencies are nested under the collabPackage
        const mainYDoc = new _yjs.Doc();
        self.collabPackage = {
            provider: null,
            users: [],
            /*
      return {
        websocketUrl: collaboratorDetails.wsUrl,
        websocketParams: collaboratorDetails.wsParams,
        color: collaboratorDetails.color,
        userName: getUserName(Meteor.userId()),
        x: 0,
        y: 0,
      }
      */ userBaseData: await self.slate.events.onInitCollaboration(mainYDoc.clientID),
            doc: mainYDoc,
            map: null
        };
        if (!self.collabPackage.userBaseData) console.error('Unable to collaborate - no self.collabPackage retrieved from the onInitCollaboration event');
        // attach clientID to the package for downstream reference
        self.collabPackage.userBaseData.clientID = self.collabPackage.doc.clientID;
        self.collabPackage.provider = new (0, _yWebsocket.WebsocketProvider)(self.collabPackage.userBaseData.websocketUrl, self.slate.options.id, self.collabPackage.doc, {
            connect: true,
            params: self.collabPackage.userBaseData.websocketParams
        });
        // a single map with a nodeId as the key and the last collab event as its value
        self.collabPackage.map = self.collabPackage.doc.getMap(self.constants.mapName);
        self.collabPackage.map.observe((e)=>{
            e.changes.keys.forEach((change, key)=>{
                if (change.action === 'add' || change.action === 'update') {
                    const p = self.collabPackage.map.get(key);
                    if (p.type === self.constants.onCollaborationUserCustomDataChanged) // for both local and remote - call this function so users are updated
                    self.slate.events.onCollaborationUsersChanged?.(self.collabPackage.users);
                    else {
                        // conflicts here are already resolved...
                        // but collab only have to fire if there
                        // is more than one user on the slate
                        if (// self.collabPackage.users.length > 1 &&
                        self.collabPackage.init && p.data.clientID !== self.collabPackage?.doc?.clientID) self.slate.collab.invoke(p);
                        // broadcast change so slate is saved
                        // not needed for ai events because only one can be the "host"
                        // and propogate the changes to the other slates -- so do not invoke the save command
                        // for other slates
                        if (p.data.clientID === self.collabPackage?.doc?.clientID) {
                            const isNodeAIType = [
                                self.constants.onNodeAITextChanged
                            ].includes(p.type);
                            if (!isNodeAIType || isNodeAIType && p.data.clientID === self.collabPackage?.doc?.clientID) self.slate.events?.onSlateChanged?.apply(self, [
                                p,
                                self.collabPackage.users
                            ]);
                        }
                        self.collabPackage.init = true;
                    }
                }
            });
        });
        self.collabPackage.provider.awareness.on('update', ({ added, updated, removed })=>{
            const awarenessStates = Array.from(self.collabPackage.provider.awareness.getStates().values());
            self.collabPackage.users = awarenessStates.filter((ux)=>!!ux.user).map((u)=>u.user);
            if (added.length > 0) {
                const users = self.collabPackage.users.filter((u)=>{
                    return added.includes(u.clientID);
                });
                self.slate.events.onCollaborationUsersAdded?.(users);
            }
            if (removed.length > 0) {
                const users = self.collabPackage.users.filter((u)=>{
                    return removed.includes(u.clientID);
                });
                self.slate.events.onCollaborationUsersRemoved?.(users);
                self.collabPackage.users = self.collabPackage.users.filter((u)=>{
                    return !removed.includes(u.clientID);
                });
            }
            if (added.length > 0 || removed.length > 0) self.slate.events.onCollaborationUsersChanged?.(self.collabPackage.users);
        });
        // monitors for cursor locations - the change event runs when the mouse moves, but the upate event
        // resolves when it settles (so no real-time view)
        self.collabPackage.provider.awareness.on('change', ({ added, updated, removed })=>{
            const awarenessStates = Array.from(self.collabPackage.provider.awareness.getStates().values());
            awarenessStates.forEach((u)=>{
                if (updated.includes(u.user?.clientID) && u.user?.clientID !== self.collabPackage?.doc?.clientID) self.slate.cursor(u.user);
            });
        });
        // this sends the cursor locations to the other clients
        if (!self.collabPackage.userBaseData.suppressCursor) self.collabPackage.provider.awareness.setLocalStateField('user', {
            ...(0, _lodashOmitDefault.default)(self.collabPackage.userBaseData, self.constants.ommittableUserData)
        });
        // for newly init clients, this will send the users immediately
        self.send({
            type: self.constants.onCollaborationUserCustomDataChanged,
            data: {}
        });
        // this auto destroys the connection so others immediately know the client is gone
        window.addEventListener('beforeunload', ()=>{
            self.destroy();
        });
    }
    destroy() {
        const self = this;
        self.collabPackage?.provider?.awareness?.destroy();
        self.collabPackage?.provider?.destroy();
    }
    currentCollaborators() {
        const self = this;
        return self.collabPackage?.users || [];
    }
    updateUserData(pkg) {
        const self = this;
        if (self.collabPackage) {
            // this will cause the onUsersChanged to fire
            // and also change the baseData so that this is not overridden
            // by any other setLocaLStateField calls
            self.collabPackage.userBaseData = {
                ...self.collabPackage.userBaseData,
                ...pkg
            };
            self.collabPackage.provider.awareness?.setLocalStateField('user', {
                ...(0, _lodashOmitDefault.default)(self.collabPackage.userBaseData, self.constants.ommittableUserData),
                ...pkg
            });
            // will broadcast that the users have changed
            self.send({
                type: self.constants.onCollaborationUserCustomDataChanged,
                data: {}
            });
        }
    }
    send(pkg) {
        const self = this;
        let packages = pkg;
        if (!Array.isArray(packages)) packages = [
            packages
        ];
        if (packages[0].type === 'onMouseMoved') {
            if (self.collabPackage?.userBaseData && !self.collabPackage.userBaseData.suppressCursor) // broadcast the mouse cursors
            self.collabPackage?.provider.awareness?.setLocalStateField('user', {
                ...(0, _lodashOmitDefault.default)(self.collabPackage.userBaseData, self.constants.ommittableUserData),
                ...packages[0].data
            });
        } else {
            if (self.slate.undoRedo && self.slate.options.showUndoRedo) self.slate.undoRedo.snap();
            // these will only exist if allowCollaboration: true on the slate
            if (self.collabPackage?.doc && self.collabPackage?.map) packages.forEach((p)=>{
                p.data.clientID = self.collabPackage.doc.clientID;
                if (p.data?.nodeOptions) {
                    // to ensure each node is correctly CRDT-resolved
                    // with yJS independently, the moveNodes must be broken up so
                    // each node id is set directly on the YMap.
                    let asSingle = false;
                    if (!Array.isArray(p.data.nodeOptions)) {
                        asSingle = true;
                        p.data.nodeOptions = [
                            p.data.nodeOptions
                        ];
                    }
                    p.data.nodeOptions.forEach((nx, ind)=>{
                        const indivCollab = (0, _lodashClonedeepDefault.default)(p);
                        // in the onNodeAdded, the data.id !== nx.options.id (737... vs 22C...)
                        indivCollab.data.id = nx.id;
                        indivCollab.data.nodeOptions = asSingle ? nx : [
                            nx
                        ] // repackage it back the way it originally came in
                        ;
                        if (p.data?.textPositions) indivCollab.data.textPositions = [
                            p.data?.textPositions[ind]
                        ];
                        if (p.data?.associations) {
                            const indivAssocs = p.data?.associations.filter((a)=>a.childId === nx.id || a.parentId === nx.id);
                            indivCollab.data.associations = indivAssocs;
                        }
                        self.collabPackage.map.set(nx.id, indivCollab);
                    });
                } else // none nodeOptions based collaborations
                self.collabPackage.map.set(p.data.id || 'slate', p);
            });
        }
    }
}
exports.default = collab;

},{"yjs":"gj9M9","y-websocket":"g8NHk","lodash.omit":"82TGT","lodash.clonedeep":"i3u1q","../helpers/utils":"8QI6M","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gj9M9":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "AbsolutePosition", ()=>AbsolutePosition);
parcelHelpers.export(exports, "AbstractConnector", ()=>AbstractConnector);
parcelHelpers.export(exports, "AbstractStruct", ()=>AbstractStruct);
parcelHelpers.export(exports, "AbstractType", ()=>AbstractType);
parcelHelpers.export(exports, "Array", ()=>YArray);
parcelHelpers.export(exports, "ContentAny", ()=>ContentAny);
parcelHelpers.export(exports, "ContentBinary", ()=>ContentBinary);
parcelHelpers.export(exports, "ContentDeleted", ()=>ContentDeleted);
parcelHelpers.export(exports, "ContentDoc", ()=>ContentDoc);
parcelHelpers.export(exports, "ContentEmbed", ()=>ContentEmbed);
parcelHelpers.export(exports, "ContentFormat", ()=>ContentFormat);
parcelHelpers.export(exports, "ContentJSON", ()=>ContentJSON);
parcelHelpers.export(exports, "ContentString", ()=>ContentString);
parcelHelpers.export(exports, "ContentType", ()=>ContentType);
parcelHelpers.export(exports, "Doc", ()=>Doc);
parcelHelpers.export(exports, "GC", ()=>GC);
parcelHelpers.export(exports, "ID", ()=>ID);
parcelHelpers.export(exports, "Item", ()=>Item);
parcelHelpers.export(exports, "Map", ()=>YMap);
parcelHelpers.export(exports, "PermanentUserData", ()=>PermanentUserData);
parcelHelpers.export(exports, "RelativePosition", ()=>RelativePosition);
parcelHelpers.export(exports, "Skip", ()=>Skip);
parcelHelpers.export(exports, "Snapshot", ()=>Snapshot);
parcelHelpers.export(exports, "Text", ()=>YText);
parcelHelpers.export(exports, "Transaction", ()=>Transaction);
parcelHelpers.export(exports, "UndoManager", ()=>UndoManager);
parcelHelpers.export(exports, "UpdateDecoderV1", ()=>UpdateDecoderV1);
parcelHelpers.export(exports, "UpdateDecoderV2", ()=>UpdateDecoderV2);
parcelHelpers.export(exports, "UpdateEncoderV1", ()=>UpdateEncoderV1);
parcelHelpers.export(exports, "UpdateEncoderV2", ()=>UpdateEncoderV2);
parcelHelpers.export(exports, "XmlElement", ()=>YXmlElement);
parcelHelpers.export(exports, "XmlFragment", ()=>YXmlFragment);
parcelHelpers.export(exports, "XmlHook", ()=>YXmlHook);
parcelHelpers.export(exports, "XmlText", ()=>YXmlText);
parcelHelpers.export(exports, "YArrayEvent", ()=>YArrayEvent);
parcelHelpers.export(exports, "YEvent", ()=>YEvent);
parcelHelpers.export(exports, "YMapEvent", ()=>YMapEvent);
parcelHelpers.export(exports, "YTextEvent", ()=>YTextEvent);
parcelHelpers.export(exports, "YXmlEvent", ()=>YXmlEvent);
parcelHelpers.export(exports, "applyUpdate", ()=>applyUpdate);
parcelHelpers.export(exports, "applyUpdateV2", ()=>applyUpdateV2);
parcelHelpers.export(exports, "cleanupYTextFormatting", ()=>cleanupYTextFormatting);
parcelHelpers.export(exports, "compareIDs", ()=>compareIDs);
parcelHelpers.export(exports, "compareRelativePositions", ()=>compareRelativePositions);
parcelHelpers.export(exports, "convertUpdateFormatV1ToV2", ()=>convertUpdateFormatV1ToV2);
parcelHelpers.export(exports, "convertUpdateFormatV2ToV1", ()=>convertUpdateFormatV2ToV1);
parcelHelpers.export(exports, "createAbsolutePositionFromRelativePosition", ()=>createAbsolutePositionFromRelativePosition);
parcelHelpers.export(exports, "createDeleteSet", ()=>createDeleteSet);
parcelHelpers.export(exports, "createDeleteSetFromStructStore", ()=>createDeleteSetFromStructStore);
parcelHelpers.export(exports, "createDocFromSnapshot", ()=>createDocFromSnapshot);
parcelHelpers.export(exports, "createID", ()=>createID);
parcelHelpers.export(exports, "createRelativePositionFromJSON", ()=>createRelativePositionFromJSON);
parcelHelpers.export(exports, "createRelativePositionFromTypeIndex", ()=>createRelativePositionFromTypeIndex);
parcelHelpers.export(exports, "createSnapshot", ()=>createSnapshot);
parcelHelpers.export(exports, "decodeRelativePosition", ()=>decodeRelativePosition);
parcelHelpers.export(exports, "decodeSnapshot", ()=>decodeSnapshot);
parcelHelpers.export(exports, "decodeSnapshotV2", ()=>decodeSnapshotV2);
parcelHelpers.export(exports, "decodeStateVector", ()=>decodeStateVector);
parcelHelpers.export(exports, "decodeUpdate", ()=>decodeUpdate);
parcelHelpers.export(exports, "decodeUpdateV2", ()=>decodeUpdateV2);
parcelHelpers.export(exports, "diffUpdate", ()=>diffUpdate);
parcelHelpers.export(exports, "diffUpdateV2", ()=>diffUpdateV2);
parcelHelpers.export(exports, "emptySnapshot", ()=>emptySnapshot);
parcelHelpers.export(exports, "encodeRelativePosition", ()=>encodeRelativePosition);
parcelHelpers.export(exports, "encodeSnapshot", ()=>encodeSnapshot);
parcelHelpers.export(exports, "encodeSnapshotV2", ()=>encodeSnapshotV2);
parcelHelpers.export(exports, "encodeStateAsUpdate", ()=>encodeStateAsUpdate);
parcelHelpers.export(exports, "encodeStateAsUpdateV2", ()=>encodeStateAsUpdateV2);
parcelHelpers.export(exports, "encodeStateVector", ()=>encodeStateVector);
parcelHelpers.export(exports, "encodeStateVectorFromUpdate", ()=>encodeStateVectorFromUpdate);
parcelHelpers.export(exports, "encodeStateVectorFromUpdateV2", ()=>encodeStateVectorFromUpdateV2);
parcelHelpers.export(exports, "equalDeleteSets", ()=>equalDeleteSets);
parcelHelpers.export(exports, "equalSnapshots", ()=>equalSnapshots);
parcelHelpers.export(exports, "findIndexSS", ()=>findIndexSS);
parcelHelpers.export(exports, "findRootTypeKey", ()=>findRootTypeKey);
parcelHelpers.export(exports, "getItem", ()=>getItem);
parcelHelpers.export(exports, "getState", ()=>getState);
parcelHelpers.export(exports, "getTypeChildren", ()=>getTypeChildren);
parcelHelpers.export(exports, "isDeleted", ()=>isDeleted);
parcelHelpers.export(exports, "isParentOf", ()=>isParentOf);
parcelHelpers.export(exports, "iterateDeletedStructs", ()=>iterateDeletedStructs);
parcelHelpers.export(exports, "logType", ()=>logType);
parcelHelpers.export(exports, "logUpdate", ()=>logUpdate);
parcelHelpers.export(exports, "logUpdateV2", ()=>logUpdateV2);
parcelHelpers.export(exports, "mergeDeleteSets", ()=>mergeDeleteSets);
parcelHelpers.export(exports, "mergeUpdates", ()=>mergeUpdates);
parcelHelpers.export(exports, "mergeUpdatesV2", ()=>mergeUpdatesV2);
parcelHelpers.export(exports, "obfuscateUpdate", ()=>obfuscateUpdate);
parcelHelpers.export(exports, "obfuscateUpdateV2", ()=>obfuscateUpdateV2);
parcelHelpers.export(exports, "parseUpdateMeta", ()=>parseUpdateMeta);
parcelHelpers.export(exports, "parseUpdateMetaV2", ()=>parseUpdateMetaV2);
parcelHelpers.export(exports, "readUpdate", ()=>readUpdate);
parcelHelpers.export(exports, "readUpdateV2", ()=>readUpdateV2);
parcelHelpers.export(exports, "relativePositionToJSON", ()=>relativePositionToJSON);
parcelHelpers.export(exports, "snapshot", ()=>snapshot);
parcelHelpers.export(exports, "snapshotContainsUpdate", ()=>snapshotContainsUpdate);
parcelHelpers.export(exports, "transact", ()=>transact);
parcelHelpers.export(exports, "tryGc", ()=>tryGc);
parcelHelpers.export(exports, "typeListToArraySnapshot", ()=>typeListToArraySnapshot);
parcelHelpers.export(exports, "typeMapGetAllSnapshot", ()=>typeMapGetAllSnapshot);
parcelHelpers.export(exports, "typeMapGetSnapshot", ()=>typeMapGetSnapshot);
var _observable = require("lib0/observable");
var _array = require("lib0/array");
var _math = require("lib0/math");
var _map = require("lib0/map");
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _random = require("lib0/random");
var _promise = require("lib0/promise");
var _buffer = require("lib0/buffer");
var _error = require("lib0/error");
var _binary = require("lib0/binary");
var _function = require("lib0/function");
var _set = require("lib0/set");
var _logging = require("lib0/logging");
var _time = require("lib0/time");
var _string = require("lib0/string");
var _iterator = require("lib0/iterator");
var _object = require("lib0/object");
var _environment = require("lib0/environment");
var global = arguments[3];
/**
 * This is an abstract interface that all Connectors should implement to keep them interchangeable.
 *
 * @note This interface is experimental and it is not advised to actually inherit this class.
 *       It just serves as typing information.
 *
 * @extends {ObservableV2<any>}
 */ class AbstractConnector extends (0, _observable.ObservableV2) {
    /**
   * @param {Doc} ydoc
   * @param {any} awareness
   */ constructor(ydoc, awareness){
        super();
        this.doc = ydoc;
        this.awareness = awareness;
    }
}
class DeleteItem {
    /**
   * @param {number} clock
   * @param {number} len
   */ constructor(clock, len){
        /**
     * @type {number}
     */ this.clock = clock;
        /**
     * @type {number}
     */ this.len = len;
    }
}
/**
 * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.
 * - When created in a transaction, it must only be accessed after sorting, and merging
 *   - This DeleteSet is send to other clients
 * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore
 * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.
 */ class DeleteSet {
    constructor(){
        /**
     * @type {Map<number,Array<DeleteItem>>}
     */ this.clients = new Map();
    }
}
/**
 * Iterate over all structs that the DeleteSet gc's.
 *
 * @param {Transaction} transaction
 * @param {DeleteSet} ds
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateDeletedStructs = (transaction, ds, f)=>ds.clients.forEach((deletes, clientid)=>{
        const structs = /** @type {Array<GC|Item>} */ transaction.doc.store.clients.get(clientid);
        for(let i = 0; i < deletes.length; i++){
            const del = deletes[i];
            iterateStructs(transaction, structs, del.clock, del.len, f);
        }
    });
/**
 * @param {Array<DeleteItem>} dis
 * @param {number} clock
 * @return {number|null}
 *
 * @private
 * @function
 */ const findIndexDS = (dis, clock)=>{
    let left = 0;
    let right = dis.length - 1;
    while(left <= right){
        const midindex = _math.floor((left + right) / 2);
        const mid = dis[midindex];
        const midclock = mid.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.len) return midindex;
            left = midindex + 1;
        } else right = midindex - 1;
    }
    return null;
};
/**
 * @param {DeleteSet} ds
 * @param {ID} id
 * @return {boolean}
 *
 * @private
 * @function
 */ const isDeleted = (ds, id)=>{
    const dis = ds.clients.get(id.client);
    return dis !== undefined && findIndexDS(dis, id.clock) !== null;
};
/**
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const sortAndMergeDeleteSet = (ds)=>{
    ds.clients.forEach((dels)=>{
        dels.sort((a, b)=>a.clock - b.clock);
        // merge items without filtering or splicing the array
        // i is the current pointer
        // j refers to the current insert position for the pointed item
        // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
        let i, j;
        for(i = 1, j = 1; i < dels.length; i++){
            const left = dels[j - 1];
            const right = dels[i];
            if (left.clock + left.len >= right.clock) left.len = _math.max(left.len, right.clock + right.len - left.clock);
            else {
                if (j < i) dels[j] = right;
                j++;
            }
        }
        dels.length = j;
    });
};
/**
 * @param {Array<DeleteSet>} dss
 * @return {DeleteSet} A fresh DeleteSet
 */ const mergeDeleteSets = (dss)=>{
    const merged = new DeleteSet();
    for(let dssI = 0; dssI < dss.length; dssI++)dss[dssI].clients.forEach((delsLeft, client)=>{
        if (!merged.clients.has(client)) {
            // Write all missing keys from current ds and all following.
            // If merged already contains `client` current ds has already been added.
            /**
         * @type {Array<DeleteItem>}
         */ const dels = delsLeft.slice();
            for(let i = dssI + 1; i < dss.length; i++)_array.appendTo(dels, dss[i].clients.get(client) || []);
            merged.clients.set(client, dels);
        }
    });
    sortAndMergeDeleteSet(merged);
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {number} client
 * @param {number} clock
 * @param {number} length
 *
 * @private
 * @function
 */ const addToDeleteSet = (ds, client, clock, length)=>{
    _map.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []).push(new DeleteItem(clock, length));
};
const createDeleteSet = ()=>new DeleteSet();
/**
 * @param {StructStore} ss
 * @return {DeleteSet} Merged and sorted DeleteSet
 *
 * @private
 * @function
 */ const createDeleteSetFromStructStore = (ss)=>{
    const ds = createDeleteSet();
    ss.clients.forEach((structs, client)=>{
        /**
     * @type {Array<DeleteItem>}
     */ const dsitems = [];
        for(let i = 0; i < structs.length; i++){
            const struct = structs[i];
            if (struct.deleted) {
                const clock = struct.id.clock;
                let len = struct.length;
                if (i + 1 < structs.length) for(let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1])len += next.length;
                dsitems.push(new DeleteItem(clock, len));
            }
        }
        if (dsitems.length > 0) ds.clients.set(client, dsitems);
    });
    return ds;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {DeleteSet} ds
 *
 * @private
 * @function
 */ const writeDeleteSet = (encoder, ds)=>{
    _encoding.writeVarUint(encoder.restEncoder, ds.clients.size);
    // Ensure that the delete set is written in a deterministic order
    _array.from(ds.clients.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, dsitems])=>{
        encoder.resetDsCurVal();
        _encoding.writeVarUint(encoder.restEncoder, client);
        const len = dsitems.length;
        _encoding.writeVarUint(encoder.restEncoder, len);
        for(let i = 0; i < len; i++){
            const item = dsitems[i];
            encoder.writeDsClock(item.clock);
            encoder.writeDsLen(item.len);
        }
    });
};
/**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {DeleteSet}
 *
 * @private
 * @function
 */ const readDeleteSet = (decoder)=>{
    const ds = new DeleteSet();
    const numClients = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = _decoding.readVarUint(decoder.restDecoder);
        const numberOfDeletes = _decoding.readVarUint(decoder.restDecoder);
        if (numberOfDeletes > 0) {
            const dsField = _map.setIfUndefined(ds.clients, client, ()=>/** @type {Array<DeleteItem>} */ []);
            for(let i = 0; i < numberOfDeletes; i++)dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
        }
    }
    return ds;
};
/**
 * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..
 */ /**
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.
 *
 * @private
 * @function
 */ const readAndApplyDeleteSet = (decoder, transaction, store)=>{
    const unappliedDS = new DeleteSet();
    const numClients = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numClients; i++){
        decoder.resetDsCurVal();
        const client = _decoding.readVarUint(decoder.restDecoder);
        const numberOfDeletes = _decoding.readVarUint(decoder.restDecoder);
        const structs = store.clients.get(client) || [];
        const state = getState(store, client);
        for(let i = 0; i < numberOfDeletes; i++){
            const clock = decoder.readDsClock();
            const clockEnd = clock + decoder.readDsLen();
            if (clock < state) {
                if (state < clockEnd) addToDeleteSet(unappliedDS, client, state, clockEnd - state);
                let index = findIndexSS(structs, clock);
                /**
         * We can ignore the case of GC and Delete structs, because we are going to skip them
         * @type {Item}
         */ // @ts-ignore
                let struct = structs[index];
                // split the first item if necessary
                if (!struct.deleted && struct.id.clock < clock) {
                    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
                    index++; // increase we now want to use the next struct
                }
                while(index < structs.length){
                    // @ts-ignore
                    struct = structs[index++];
                    if (struct.id.clock < clockEnd) {
                        if (!struct.deleted) {
                            if (clockEnd < struct.id.clock + struct.length) structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
                            struct.delete(transaction);
                        }
                    } else break;
                }
            } else addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
        }
    }
    if (unappliedDS.clients.size > 0) {
        const ds = new UpdateEncoderV2();
        _encoding.writeVarUint(ds.restEncoder, 0); // encode 0 structs
        writeDeleteSet(ds, unappliedDS);
        return ds.toUint8Array();
    }
    return null;
};
/**
 * @param {DeleteSet} ds1
 * @param {DeleteSet} ds2
 */ const equalDeleteSets = (ds1, ds2)=>{
    if (ds1.clients.size !== ds2.clients.size) return false;
    for (const [client, deleteItems1] of ds1.clients.entries()){
        const deleteItems2 = /** @type {Array<import('../internals.js').DeleteItem>} */ ds2.clients.get(client);
        if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false;
        for(let i = 0; i < deleteItems1.length; i++){
            const di1 = deleteItems1[i];
            const di2 = deleteItems2[i];
            if (di1.clock !== di2.clock || di1.len !== di2.len) return false;
        }
    }
    return true;
};
/**
 * @module Y
 */ const generateNewClientId = _random.uint32;
/**
 * @typedef {Object} DocOpts
 * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)
 * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.
 * @property {string} [DocOpts.guid] Define a globally unique identifier for this document
 * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.
 * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.
 * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.
 * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()
 */ /**
 * @typedef {Object} DocEvents
 * @property {function(Doc):void} DocEvents.destroy
 * @property {function(Doc):void} DocEvents.load
 * @property {function(boolean, Doc):void} DocEvents.sync
 * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.update
 * @property {function(Uint8Array, any, Doc, Transaction):void} DocEvents.updateV2
 * @property {function(Doc):void} DocEvents.beforeAllTransactions
 * @property {function(Transaction, Doc):void} DocEvents.beforeTransaction
 * @property {function(Transaction, Doc):void} DocEvents.beforeObserverCalls
 * @property {function(Transaction, Doc):void} DocEvents.afterTransaction
 * @property {function(Transaction, Doc):void} DocEvents.afterTransactionCleanup
 * @property {function(Doc, Array<Transaction>):void} DocEvents.afterAllTransactions
 * @property {function({ loaded: Set<Doc>, added: Set<Doc>, removed: Set<Doc> }, Doc, Transaction):void} DocEvents.subdocs
 */ /**
 * A Yjs instance handles the state of shared data.
 * @extends ObservableV2<DocEvents>
 */ class Doc extends (0, _observable.ObservableV2) {
    /**
   * @param {DocOpts} opts configuration
   */ constructor({ guid = _random.uuidv4(), collectionid = null, gc = true, gcFilter = ()=>true, meta = null, autoLoad = false, shouldLoad = true } = {}){
        super();
        this.gc = gc;
        this.gcFilter = gcFilter;
        this.clientID = generateNewClientId();
        this.guid = guid;
        this.collectionid = collectionid;
        /**
     * @type {Map<string, AbstractType<YEvent<any>>>}
     */ this.share = new Map();
        this.store = new StructStore();
        /**
     * @type {Transaction | null}
     */ this._transaction = null;
        /**
     * @type {Array<Transaction>}
     */ this._transactionCleanups = [];
        /**
     * @type {Set<Doc>}
     */ this.subdocs = new Set();
        /**
     * If this document is a subdocument - a document integrated into another document - then _item is defined.
     * @type {Item?}
     */ this._item = null;
        this.shouldLoad = shouldLoad;
        this.autoLoad = autoLoad;
        this.meta = meta;
        /**
     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
     *
     * @type {boolean}
     */ this.isLoaded = false;
        /**
     * This is set to true when the connection provider has successfully synced with a backend.
     * Note that when using peer-to-peer providers this event may not provide very useful.
     * Also note that not all providers implement this feature. Provider authors are encouraged to fire
     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
     * lost (with false as a parameter).
     */ this.isSynced = false;
        this.isDestroyed = false;
        /**
     * Promise that resolves once the document has been loaded from a presistence provider.
     */ this.whenLoaded = _promise.create((resolve)=>{
            this.on('load', ()=>{
                this.isLoaded = true;
                resolve(this);
            });
        });
        const provideSyncedPromise = ()=>_promise.create((resolve)=>{
                /**
       * @param {boolean} isSynced
       */ const eventHandler = (isSynced)=>{
                    if (isSynced === undefined || isSynced === true) {
                        this.off('sync', eventHandler);
                        resolve();
                    }
                };
                this.on('sync', eventHandler);
            });
        this.on('sync', (isSynced)=>{
            if (isSynced === false && this.isSynced) this.whenSynced = provideSyncedPromise();
            this.isSynced = isSynced === undefined || isSynced === true;
            if (this.isSynced && !this.isLoaded) this.emit('load', [
                this
            ]);
        });
        /**
     * Promise that resolves once the document has been synced with a backend.
     * This promise is recreated when the connection is lost.
     * Note the documentation about the `isSynced` property.
     */ this.whenSynced = provideSyncedPromise();
    }
    /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */ load() {
        const item = this._item;
        if (item !== null && !this.shouldLoad) transact(/** @type {any} */ item.parent.doc, (transaction)=>{
            transaction.subdocsLoaded.add(this);
        }, null, true);
        this.shouldLoad = true;
    }
    getSubdocs() {
        return this.subdocs;
    }
    getSubdocGuids() {
        return new Set(_array.from(this.subdocs).map((doc)=>doc.guid));
    }
    /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */ transact(f, origin = null) {
        return transact(this, f, origin);
    }
    /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */ get(name, TypeConstructor = /** @type {any} */ AbstractType) {
        const type = _map.setIfUndefined(this.share, name, ()=>{
            // @ts-ignore
            const t = new TypeConstructor();
            t._integrate(this, null);
            return t;
        });
        const Constr = type.constructor;
        if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
            if (Constr === AbstractType) {
                // @ts-ignore
                const t = new TypeConstructor();
                t._map = type._map;
                type._map.forEach(/** @param {Item?} n */ (n)=>{
                    for(; n !== null; n = n.left)// @ts-ignore
                    n.parent = t;
                });
                t._start = type._start;
                for(let n = t._start; n !== null; n = n.right)n.parent = t;
                t._length = type._length;
                this.share.set(name, t);
                t._integrate(this, null);
                return /** @type {InstanceType<Type>} */ t;
            } else throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
        }
        return /** @type {InstanceType<Type>} */ type;
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */ getArray(name = '') {
        return /** @type {YArray<T>} */ this.get(name, YArray);
    }
    /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */ getText(name = '') {
        return this.get(name, YText);
    }
    /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */ getMap(name = '') {
        return /** @type {YMap<T>} */ this.get(name, YMap);
    }
    /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */ getXmlElement(name = '') {
        return /** @type {YXmlElement<{[key:string]:string}>} */ this.get(name, YXmlElement);
    }
    /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */ getXmlFragment(name = '') {
        return this.get(name, YXmlFragment);
    }
    /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */ toJSON() {
        /**
     * @type {Object<string, any>}
     */ const doc = {};
        this.share.forEach((value, key)=>{
            doc[key] = value.toJSON();
        });
        return doc;
    }
    /**
   * Emit `destroy` event and unregister all event handlers.
   */ destroy() {
        this.isDestroyed = true;
        _array.from(this.subdocs).forEach((subdoc)=>subdoc.destroy());
        const item = this._item;
        if (item !== null) {
            this._item = null;
            const content = /** @type {ContentDoc} */ item.content;
            content.doc = new Doc({
                guid: this.guid,
                ...content.opts,
                shouldLoad: false
            });
            content.doc._item = item;
            transact(/** @type {any} */ item.parent.doc, (transaction)=>{
                const doc = content.doc;
                if (!item.deleted) transaction.subdocsAdded.add(doc);
                transaction.subdocsRemoved.add(this);
            }, null, true);
        }
        // @ts-ignore
        this.emit('destroyed', [
            true
        ]); // DEPRECATED!
        this.emit('destroy', [
            this
        ]);
        super.destroy();
    }
}
class DSDecoderV1 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @return {number}
   */ readDsClock() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {number}
   */ readDsLen() {
        return _decoding.readVarUint(this.restDecoder);
    }
}
class UpdateDecoderV1 extends DSDecoderV1 {
    /**
   * @return {ID}
   */ readLeftID() {
        return createID(_decoding.readVarUint(this.restDecoder), _decoding.readVarUint(this.restDecoder));
    }
    /**
   * @return {ID}
   */ readRightID() {
        return createID(_decoding.readVarUint(this.restDecoder), _decoding.readVarUint(this.restDecoder));
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return _decoding.readUint8(this.restDecoder);
    }
    /**
   * @return {string}
   */ readString() {
        return _decoding.readVarString(this.restDecoder);
    }
    /**
   * @return {boolean} isKey
   */ readParentInfo() {
        return _decoding.readVarUint(this.restDecoder) === 1;
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readTypeRef() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */ readLen() {
        return _decoding.readVarUint(this.restDecoder);
    }
    /**
   * @return {any}
   */ readAny() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return _buffer.copyUint8Array(_decoding.readVarUint8Array(this.restDecoder));
    }
    /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */ readJSON() {
        return JSON.parse(_decoding.readVarString(this.restDecoder));
    }
    /**
   * @return {string}
   */ readKey() {
        return _decoding.readVarString(this.restDecoder);
    }
}
class DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        /**
     * @private
     */ this.dsCurrVal = 0;
        this.restDecoder = decoder;
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @return {number}
   */ readDsClock() {
        this.dsCurrVal += _decoding.readVarUint(this.restDecoder);
        return this.dsCurrVal;
    }
    /**
   * @return {number}
   */ readDsLen() {
        const diff = _decoding.readVarUint(this.restDecoder) + 1;
        this.dsCurrVal += diff;
        return diff;
    }
}
class UpdateDecoderV2 extends DSDecoderV2 {
    /**
   * @param {decoding.Decoder} decoder
   */ constructor(decoder){
        super(decoder);
        /**
     * List of cached keys. If the keys[id] does not exist, we read a new key
     * from stringEncoder and push it to keys.
     *
     * @type {Array<string>}
     */ this.keys = [];
        _decoding.readVarUint(decoder); // read feature flag - currently unused
        this.keyClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.clientDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.leftClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.rightClockDecoder = new _decoding.IntDiffOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.infoDecoder = new _decoding.RleDecoder(_decoding.readVarUint8Array(decoder), _decoding.readUint8);
        this.stringDecoder = new _decoding.StringDecoder(_decoding.readVarUint8Array(decoder));
        this.parentInfoDecoder = new _decoding.RleDecoder(_decoding.readVarUint8Array(decoder), _decoding.readUint8);
        this.typeRefDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
        this.lenDecoder = new _decoding.UintOptRleDecoder(_decoding.readVarUint8Array(decoder));
    }
    /**
   * @return {ID}
   */ readLeftID() {
        return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
    }
    /**
   * @return {ID}
   */ readRightID() {
        return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
    }
    /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */ readClient() {
        return this.clientDecoder.read();
    }
    /**
   * @return {number} info An unsigned 8-bit integer
   */ readInfo() {
        return /** @type {number} */ this.infoDecoder.read();
    }
    /**
   * @return {string}
   */ readString() {
        return this.stringDecoder.read();
    }
    /**
   * @return {boolean}
   */ readParentInfo() {
        return this.parentInfoDecoder.read() === 1;
    }
    /**
   * @return {number} An unsigned 8-bit integer
   */ readTypeRef() {
        return this.typeRefDecoder.read();
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */ readLen() {
        return this.lenDecoder.read();
    }
    /**
   * @return {any}
   */ readAny() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {Uint8Array}
   */ readBuf() {
        return _decoding.readVarUint8Array(this.restDecoder);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */ readJSON() {
        return _decoding.readAny(this.restDecoder);
    }
    /**
   * @return {string}
   */ readKey() {
        const keyClock = this.keyClockDecoder.read();
        if (keyClock < this.keys.length) return this.keys[keyClock];
        else {
            const key = this.stringDecoder.read();
            this.keys.push(key);
            return key;
        }
    }
}
class DSEncoderV1 {
    constructor(){
        this.restEncoder = _encoding.createEncoder();
    }
    toUint8Array() {
        return _encoding.toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
    // nop
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        _encoding.writeVarUint(this.restEncoder, clock);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        _encoding.writeVarUint(this.restEncoder, len);
    }
}
class UpdateEncoderV1 extends DSEncoderV1 {
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        _encoding.writeVarUint(this.restEncoder, id.client);
        _encoding.writeVarUint(this.restEncoder, id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        _encoding.writeVarUint(this.restEncoder, id.client);
        _encoding.writeVarUint(this.restEncoder, id.clock);
    }
    /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */ writeClient(client) {
        _encoding.writeVarUint(this.restEncoder, client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        _encoding.writeUint8(this.restEncoder, info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        _encoding.writeVarString(this.restEncoder, s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        _encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        _encoding.writeVarUint(this.restEncoder, info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        _encoding.writeVarUint(this.restEncoder, len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        _encoding.writeAny(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        _encoding.writeVarUint8Array(this.restEncoder, buf);
    }
    /**
   * @param {any} embed
   */ writeJSON(embed) {
        _encoding.writeVarString(this.restEncoder, JSON.stringify(embed));
    }
    /**
   * @param {string} key
   */ writeKey(key) {
        _encoding.writeVarString(this.restEncoder, key);
    }
}
class DSEncoderV2 {
    constructor(){
        this.restEncoder = _encoding.createEncoder(); // encodes all the rest / non-optimized
        this.dsCurrVal = 0;
    }
    toUint8Array() {
        return _encoding.toUint8Array(this.restEncoder);
    }
    resetDsCurVal() {
        this.dsCurrVal = 0;
    }
    /**
   * @param {number} clock
   */ writeDsClock(clock) {
        const diff = clock - this.dsCurrVal;
        this.dsCurrVal = clock;
        _encoding.writeVarUint(this.restEncoder, diff);
    }
    /**
   * @param {number} len
   */ writeDsLen(len) {
        if (len === 0) _error.unexpectedCase();
        _encoding.writeVarUint(this.restEncoder, len - 1);
        this.dsCurrVal += len;
    }
}
class UpdateEncoderV2 extends DSEncoderV2 {
    constructor(){
        super();
        /**
     * @type {Map<string,number>}
     */ this.keyMap = new Map();
        /**
     * Refers to the next uniqe key-identifier to me used.
     * See writeKey method for more information.
     *
     * @type {number}
     */ this.keyClock = 0;
        this.keyClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.clientEncoder = new _encoding.UintOptRleEncoder();
        this.leftClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.rightClockEncoder = new _encoding.IntDiffOptRleEncoder();
        this.infoEncoder = new _encoding.RleEncoder(_encoding.writeUint8);
        this.stringEncoder = new _encoding.StringEncoder();
        this.parentInfoEncoder = new _encoding.RleEncoder(_encoding.writeUint8);
        this.typeRefEncoder = new _encoding.UintOptRleEncoder();
        this.lenEncoder = new _encoding.UintOptRleEncoder();
    }
    toUint8Array() {
        const encoder = _encoding.createEncoder();
        _encoding.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future
        _encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, _encoding.toUint8Array(this.infoEncoder));
        _encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, _encoding.toUint8Array(this.parentInfoEncoder));
        _encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
        _encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
        // @note The rest encoder is appended! (note the missing var)
        _encoding.writeUint8Array(encoder, _encoding.toUint8Array(this.restEncoder));
        return _encoding.toUint8Array(encoder);
    }
    /**
   * @param {ID} id
   */ writeLeftID(id) {
        this.clientEncoder.write(id.client);
        this.leftClockEncoder.write(id.clock);
    }
    /**
   * @param {ID} id
   */ writeRightID(id) {
        this.clientEncoder.write(id.client);
        this.rightClockEncoder.write(id.clock);
    }
    /**
   * @param {number} client
   */ writeClient(client) {
        this.clientEncoder.write(client);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeInfo(info) {
        this.infoEncoder.write(info);
    }
    /**
   * @param {string} s
   */ writeString(s) {
        this.stringEncoder.write(s);
    }
    /**
   * @param {boolean} isYKey
   */ writeParentInfo(isYKey) {
        this.parentInfoEncoder.write(isYKey ? 1 : 0);
    }
    /**
   * @param {number} info An unsigned 8-bit integer
   */ writeTypeRef(info) {
        this.typeRefEncoder.write(info);
    }
    /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */ writeLen(len) {
        this.lenEncoder.write(len);
    }
    /**
   * @param {any} any
   */ writeAny(any) {
        _encoding.writeAny(this.restEncoder, any);
    }
    /**
   * @param {Uint8Array} buf
   */ writeBuf(buf) {
        _encoding.writeVarUint8Array(this.restEncoder, buf);
    }
    /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */ writeJSON(embed) {
        _encoding.writeAny(this.restEncoder, embed);
    }
    /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */ writeKey(key) {
        const clock = this.keyMap.get(key);
        if (clock === undefined) {
            /**
       * @todo uncomment to introduce this feature finally
       *
       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.
       * Furthermore, I forgot to set the keyclock. So everything was working fine.
       *
       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).
       *
       * I don't know yet how to reintroduce this feature..
       *
       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.
       *
       */ // this.keyMap.set(key, this.keyClock)
            this.keyClockEncoder.write(this.keyClock++);
            this.stringEncoder.write(key);
        } else this.keyClockEncoder.write(clock);
    }
}
/**
 * @module encoding
 */ /*
 * We use the first five bits in the info flag for determining the type of the struct.
 *
 * 0: GC
 * 1: Item with Deleted content
 * 2: Item with JSON content
 * 3: Item with Binary content
 * 4: Item with String content
 * 5: Item with Embed content (for richtext content)
 * 6: Item with Format content (a formatting marker for richtext content)
 * 7: Item with Type
 */ /**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Array<GC|Item>} structs All structs by `client`
 * @param {number} client
 * @param {number} clock write structs starting with `ID(client,clock)`
 *
 * @function
 */ const writeStructs = (encoder, structs, client, clock)=>{
    // write first id
    clock = _math.max(clock, structs[0].id.clock); // make sure the first id exists
    const startNewStructs = findIndexSS(structs, clock);
    // write # encoded structs
    _encoding.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
    encoder.writeClient(client);
    _encoding.writeVarUint(encoder.restEncoder, clock);
    const firstStruct = structs[startNewStructs];
    // write first struct with an offset
    firstStruct.write(encoder, clock - firstStruct.id.clock);
    for(let i = startNewStructs + 1; i < structs.length; i++)structs[i].write(encoder, 0);
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {StructStore} store
 * @param {Map<number,number>} _sm
 *
 * @private
 * @function
 */ const writeClientsStructs = (encoder, store, _sm)=>{
    // we filter all valid _sm entries into sm
    const sm = new Map();
    _sm.forEach((clock, client)=>{
        // only write if new structs are available
        if (getState(store, client) > clock) sm.set(client, clock);
    });
    getStateVector(store).forEach((_clock, client)=>{
        if (!_sm.has(client)) sm.set(client, 0);
    });
    // write # states that were updated
    _encoding.writeVarUint(encoder.restEncoder, sm.size);
    // Write items with higher client ids first
    // This heavily improves the conflict algorithm.
    _array.from(sm.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        writeStructs(encoder, /** @type {Array<GC|Item>} */ store.clients.get(client), client, clock);
    });
};
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.
 * @param {Doc} doc
 * @return {Map<number, { i: number, refs: Array<Item | GC> }>}
 *
 * @private
 * @function
 */ const readClientsStructRefs = (decoder, doc)=>{
    /**
   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}
   */ const clientRefs = _map.create();
    const numOfStateUpdates = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = _decoding.readVarUint(decoder.restDecoder);
        /**
     * @type {Array<GC|Item>}
     */ const refs = new Array(numberOfStructs);
        const client = decoder.readClient();
        let clock = _decoding.readVarUint(decoder.restDecoder);
        // const start = performance.now()
        clientRefs.set(client, {
            i: 0,
            refs
        });
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            switch(_binary.BITS5 & info){
                case 0:
                    {
                        const len = decoder.readLen();
                        refs[i] = new GC(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                case 10:
                    {
                        // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.
                        const len = _decoding.readVarUint(decoder.restDecoder);
                        refs[i] = new Skip(createID(client, clock), len);
                        clock += len;
                        break;
                    }
                default:
                    {
                        /**
           * The optimized implementation doesn't use any variables because inlining variables is faster.
           * Below a non-optimized version is shown that implements the basic algorithm with
           * a few comments
           */ const cantCopyParentInfo = (info & (_binary.BIT7 | _binary.BIT8)) === 0;
                        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                        // and we read the next string as parentYKey.
                        // It indicates how we store/retrieve parent from `y.share`
                        // @type {string|null}
                        const struct = new Item(createID(client, clock), null, (info & _binary.BIT8) === _binary.BIT8 ? decoder.readLeftID() : null, null, (info & _binary.BIT7) === _binary.BIT7 ? decoder.readRightID() : null, cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null, cantCopyParentInfo && (info & _binary.BIT6) === _binary.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content
                        );
                        /* A non-optimized implementation of the above algorithm:

          // The item that was originally to the left of this item.
          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null
          // The item that was originally to the right of this item.
          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null
          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0
          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false
          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
          // and we read the next string as parentYKey.
          // It indicates how we store/retrieve parent from `y.share`
          // @type {string|null}
          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null

          const struct = new Item(
            createID(client, clock),
            null, // left
            origin, // origin
            null, // right
            rightOrigin, // right origin
            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent
            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub
            readItemContent(decoder, info) // item content
          )
          */ refs[i] = struct;
                        clock += struct.length;
                    }
            }
        }
    // console.log('time to read: ', performance.now() - start) // @todo remove
    }
    return clientRefs;
};
/**
 * Resume computing structs generated by struct readers.
 *
 * While there is something to do, we integrate structs in this order
 * 1. top element on stack, if stack is not empty
 * 2. next element from current struct reader (if empty, use next struct reader)
 *
 * If struct causally depends on another struct (ref.missing), we put next reader of
 * `ref.id.client` on top of stack.
 *
 * At some point we find a struct that has no causal dependencies,
 * then we start emptying the stack.
 *
 * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)
 * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.
 *
 * This method is implemented in a way so that we can resume computation if this update
 * causally depends on another update.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs
 * @return { null | { update: Uint8Array, missing: Map<number,number> } }
 *
 * @private
 * @function
 */ const integrateStructs = (transaction, store, clientsStructRefs)=>{
    /**
   * @type {Array<Item | GC>}
   */ const stack = [];
    // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.
    let clientsStructRefsIds = _array.from(clientsStructRefs.keys()).sort((a, b)=>a - b);
    if (clientsStructRefsIds.length === 0) return null;
    const getNextStructTarget = ()=>{
        if (clientsStructRefsIds.length === 0) return null;
        let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
        while(nextStructsTarget.refs.length === nextStructsTarget.i){
            clientsStructRefsIds.pop();
            if (clientsStructRefsIds.length > 0) nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
            else return null;
        }
        return nextStructsTarget;
    };
    let curStructsTarget = getNextStructTarget();
    if (curStructsTarget === null) return null;
    /**
   * @type {StructStore}
   */ const restStructs = new StructStore();
    const missingSV = new Map();
    /**
   * @param {number} client
   * @param {number} clock
   */ const updateMissingSv = (client, clock)=>{
        const mclock = missingSV.get(client);
        if (mclock == null || mclock > clock) missingSV.set(client, clock);
    };
    /**
   * @type {GC|Item}
   */ let stackHead = /** @type {any} */ curStructsTarget.refs[/** @type {any} */ curStructsTarget.i++];
    // caching the state because it is used very often
    const state = new Map();
    const addStackToRestSS = ()=>{
        for (const item of stack){
            const client = item.id.client;
            const unapplicableItems = clientsStructRefs.get(client);
            if (unapplicableItems) {
                // decrement because we weren't able to apply previous operation
                unapplicableItems.i--;
                restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
                clientsStructRefs.delete(client);
                unapplicableItems.i = 0;
                unapplicableItems.refs = [];
            } else // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue
            restStructs.clients.set(client, [
                item
            ]);
            // remove client from clientsStructRefsIds to prevent users from applying the same update again
            clientsStructRefsIds = clientsStructRefsIds.filter((c)=>c !== client);
        }
        stack.length = 0;
    };
    // iterate over all struct readers until we are done
    while(true){
        if (stackHead.constructor !== Skip) {
            const localClock = _map.setIfUndefined(state, stackHead.id.client, ()=>getState(store, stackHead.id.client));
            const offset = localClock - stackHead.id.clock;
            if (offset < 0) {
                // update from the same client is missing
                stack.push(stackHead);
                updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
                // hid a dead wall, add all items from stack to restSS
                addStackToRestSS();
            } else {
                const missing = stackHead.getMissing(transaction, store);
                if (missing !== null) {
                    stack.push(stackHead);
                    // get the struct reader that has the missing struct
                    /**
           * @type {{ refs: Array<GC|Item>, i: number }}
           */ const structRefs = clientsStructRefs.get(/** @type {number} */ missing) || {
                        refs: [],
                        i: 0
                    };
                    if (structRefs.refs.length === structRefs.i) {
                        // This update message causally depends on another update message that doesn't exist yet
                        updateMissingSv(/** @type {number} */ missing, getState(store, missing));
                        addStackToRestSS();
                    } else {
                        stackHead = structRefs.refs[structRefs.i++];
                        continue;
                    }
                } else if (offset === 0 || offset < stackHead.length) {
                    // all fine, apply the stackhead
                    stackHead.integrate(transaction, offset);
                    state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
                }
            }
        }
        // iterate to next stackHead
        if (stack.length > 0) stackHead = /** @type {GC|Item} */ stack.pop();
        else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];
        else {
            curStructsTarget = getNextStructTarget();
            if (curStructsTarget === null) break;
            else stackHead = /** @type {GC|Item} */ curStructsTarget.refs[curStructsTarget.i++];
        }
    }
    if (restStructs.clients.size > 0) {
        const encoder = new UpdateEncoderV2();
        writeClientsStructs(encoder, restStructs, new Map());
        // write empty deleteset
        // writeDeleteSet(encoder, new DeleteSet())
        _encoding.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes
        return {
            missing: missingSV,
            update: encoder.toUint8Array()
        };
    }
    return null;
};
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 *
 * @private
 * @function
 */ const writeStructsFromTransaction = (encoder, transaction)=>writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts a decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]
 *
 * @function
 */ const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder))=>transact(ydoc, (transaction)=>{
        // force that transaction.local is set to non-local
        transaction.local = false;
        let retry = false;
        const doc = transaction.doc;
        const store = doc.store;
        // let start = performance.now()
        const ss = readClientsStructRefs(structDecoder, doc);
        // console.log('time to read structs: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to merge: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const restStructs = integrateStructs(transaction, store, ss);
        const pending = store.pendingStructs;
        if (pending) {
            // check if we can apply something
            for (const [client, clock] of pending.missing)if (clock < getState(store, client)) {
                retry = true;
                break;
            }
            if (restStructs) {
                // merge restStructs into store.pending
                for (const [client, clock] of restStructs.missing){
                    const mclock = pending.missing.get(client);
                    if (mclock == null || mclock > clock) pending.missing.set(client, clock);
                }
                pending.update = mergeUpdatesV2([
                    pending.update,
                    restStructs.update
                ]);
            }
        } else store.pendingStructs = restStructs;
        // console.log('time to integrate: ', performance.now() - start) // @todo remove
        // start = performance.now()
        const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
        if (store.pendingDs) {
            // @todo we could make a lower-bound state-vector check as we do above
            const pendingDSUpdate = new UpdateDecoderV2(_decoding.createDecoder(store.pendingDs));
            _decoding.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate
            const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
            if (dsRest && dsRest2) // case 1: ds1 != null && ds2 != null
            store.pendingDs = mergeUpdatesV2([
                dsRest,
                dsRest2
            ]);
            else // case 2: ds1 != null
            // case 3: ds2 != null
            // case 4: ds1 == null && ds2 == null
            store.pendingDs = dsRest || dsRest2;
        } else // Either dsRest == null && pendingDs == null OR dsRest != null
        store.pendingDs = dsRest;
        // console.log('time to cleanup: ', performance.now() - start) // @todo remove
        // start = performance.now()
        // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove
        // start = performance.now()
        if (retry) {
            const update = /** @type {{update: Uint8Array}} */ store.pendingStructs.update;
            store.pendingStructs = null;
            applyUpdateV2(transaction.doc, update);
        }
    }, transactionOrigin, false);
/**
 * Read and apply a document update.
 *
 * This function has the same effect as `applyUpdate` but accepts a decoder.
 *
 * @param {decoding.Decoder} decoder
 * @param {Doc} ydoc
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const readUpdate = (decoder, ydoc, transactionOrigin)=>readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 *
 * @function
 */ const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2)=>{
    const decoder = _decoding.createDecoder(update);
    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
/**
 * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
 *
 * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
 *
 * @param {Doc} ydoc
 * @param {Uint8Array} update
 * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
 *
 * @function
 */ const applyUpdate = (ydoc, update, transactionOrigin)=>applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
/**
 * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will
 * only write the operations that are missing.
 *
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Doc} doc
 * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 *
 * @function
 */ const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map())=>{
    writeClientsStructs(encoder, doc.store, targetStateVector);
    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([
    0
]), encoder = new UpdateEncoderV2())=>{
    const targetStateVector = decodeStateVector(encodedTargetStateVector);
    writeStateAsUpdate(encoder, doc, targetStateVector);
    const updates = [
        encoder.toUint8Array()
    ];
    // also add the pending updates (if there are any)
    if (doc.store.pendingDs) updates.push(doc.store.pendingDs);
    if (doc.store.pendingStructs) updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));
    if (updates.length > 1) {
        if (encoder.constructor === UpdateEncoderV1) return mergeUpdates(updates.map((update, i)=>i === 0 ? update : convertUpdateFormatV2ToV1(update)));
        else if (encoder.constructor === UpdateEncoderV2) return mergeUpdatesV2(updates);
    }
    return updates[0];
};
/**
 * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
 * only write the operations that are missing.
 *
 * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
 *
 * @param {Doc} doc
 * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateAsUpdate = (doc, encodedTargetStateVector)=>encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());
/**
 * Read state vector from Decoder and return as Map
 *
 * @param {DSDecoderV1 | DSDecoderV2} decoder
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const readStateVector = (decoder)=>{
    const ss = new Map();
    const ssLength = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < ssLength; i++){
        const client = _decoding.readVarUint(decoder.restDecoder);
        const clock = _decoding.readVarUint(decoder.restDecoder);
        ss.set(client, clock);
    }
    return ss;
};
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ // export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))
/**
 * Read decodedState and return State as Map.
 *
 * @param {Uint8Array} decodedState
 * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
 *
 * @function
 */ const decodeStateVector = (decodedState)=>readStateVector(new DSDecoderV1(_decoding.createDecoder(decodedState)));
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Map<number,number>} sv
 * @function
 */ const writeStateVector = (encoder, sv)=>{
    _encoding.writeVarUint(encoder.restEncoder, sv.size);
    _array.from(sv.entries()).sort((a, b)=>b[0] - a[0]).forEach(([client, clock])=>{
        _encoding.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping
        _encoding.writeVarUint(encoder.restEncoder, clock);
    });
    return encoder;
};
/**
 * @param {DSEncoderV1 | DSEncoderV2} encoder
 * @param {Doc} doc
 *
 * @function
 */ const writeDocumentStateVector = (encoder, doc)=>writeStateVector(encoder, getStateVector(doc.store));
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2())=>{
    if (doc instanceof Map) writeStateVector(encoder, doc);
    else writeDocumentStateVector(encoder, doc);
    return encoder.toUint8Array();
};
/**
 * Encode State as Uint8Array.
 *
 * @param {Doc|Map<number,number>} doc
 * @return {Uint8Array}
 *
 * @function
 */ const encodeStateVector = (doc)=>encodeStateVectorV2(doc, new DSEncoderV1());
/**
 * General event handler implementation.
 *
 * @template ARG0, ARG1
 *
 * @private
 */ class EventHandler {
    constructor(){
        /**
     * @type {Array<function(ARG0, ARG1):void>}
     */ this.l = [];
    }
}
/**
 * @template ARG0,ARG1
 * @returns {EventHandler<ARG0,ARG1>}
 *
 * @private
 * @function
 */ const createEventHandler = ()=>new EventHandler();
/**
 * Adds an event listener that is called when
 * {@link EventHandler#callEventListeners} is called.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler.
 *
 * @private
 * @function
 */ const addEventHandlerListener = (eventHandler, f)=>eventHandler.l.push(f);
/**
 * Removes an event listener.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {function(ARG0,ARG1):void} f The event handler that was added with
 *                     {@link EventHandler#addEventListener}
 *
 * @private
 * @function
 */ const removeEventHandlerListener = (eventHandler, f)=>{
    const l = eventHandler.l;
    const len = l.length;
    eventHandler.l = l.filter((g)=>f !== g);
    if (len === eventHandler.l.length) console.error('[yjs] Tried to remove event handler that doesn\'t exist.');
};
/**
 * Call all event listeners that were added via
 * {@link EventHandler#addEventListener}.
 *
 * @template ARG0,ARG1
 * @param {EventHandler<ARG0,ARG1>} eventHandler
 * @param {ARG0} arg0
 * @param {ARG1} arg1
 *
 * @private
 * @function
 */ const callEventHandlerListeners = (eventHandler, arg0, arg1)=>_function.callAll(eventHandler.l, [
        arg0,
        arg1
    ]);
class ID {
    /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */ constructor(client, clock){
        /**
     * Client id
     * @type {number}
     */ this.client = client;
        /**
     * unique per client id, continuous number
     * @type {number}
     */ this.clock = clock;
    }
}
/**
 * @param {ID | null} a
 * @param {ID | null} b
 * @return {boolean}
 *
 * @function
 */ const compareIDs = (a, b)=>a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
/**
 * @param {number} client
 * @param {number} clock
 *
 * @private
 * @function
 */ const createID = (client, clock)=>new ID(client, clock);
/**
 * @param {encoding.Encoder} encoder
 * @param {ID} id
 *
 * @private
 * @function
 */ const writeID = (encoder, id)=>{
    _encoding.writeVarUint(encoder, id.client);
    _encoding.writeVarUint(encoder, id.clock);
};
/**
 * Read ID.
 * * If first varUint read is 0xFFFFFF a RootID is returned.
 * * Otherwise an ID is returned
 *
 * @param {decoding.Decoder} decoder
 * @return {ID}
 *
 * @private
 * @function
 */ const readID = (decoder)=>createID(_decoding.readVarUint(decoder), _decoding.readVarUint(decoder));
/**
 * The top types are mapped from y.share.get(keyname) => type.
 * `type` does not store any information about the `keyname`.
 * This function finds the correct `keyname` for `type` and throws otherwise.
 *
 * @param {AbstractType<any>} type
 * @return {string}
 *
 * @private
 * @function
 */ const findRootTypeKey = (type)=>{
    // @ts-ignore _y must be defined, otherwise unexpected case
    for (const [key, value] of type.doc.share.entries()){
        if (value === type) return key;
    }
    throw _error.unexpectedCase();
};
/**
 * Check if `parent` is a parent of `child`.
 *
 * @param {AbstractType<any>} parent
 * @param {Item|null} child
 * @return {Boolean} Whether `parent` is a parent of `child`.
 *
 * @private
 * @function
 */ const isParentOf = (parent, child)=>{
    while(child !== null){
        if (child.parent === parent) return true;
        child = /** @type {AbstractType<any>} */ child.parent._item;
    }
    return false;
};
/**
 * Convenient helper to log type information.
 *
 * Do not use in productive systems as the output can be immense!
 *
 * @param {AbstractType<any>} type
 */ const logType = (type)=>{
    const res = [];
    let n = type._start;
    while(n){
        res.push(n);
        n = n.right;
    }
    console.log('Children: ', res);
    console.log('Children content: ', res.filter((m)=>!m.deleted).map((m)=>m.content));
};
class PermanentUserData {
    /**
   * @param {Doc} doc
   * @param {YMap<any>} [storeType]
   */ constructor(doc, storeType = doc.getMap('users')){
        /**
     * @type {Map<string,DeleteSet>}
     */ const dss = new Map();
        this.yusers = storeType;
        this.doc = doc;
        /**
     * Maps from clientid to userDescription
     *
     * @type {Map<number,string>}
     */ this.clients = new Map();
        this.dss = dss;
        /**
     * @param {YMap<any>} user
     * @param {string} userDescription
     */ const initUser = (user, userDescription)=>{
            /**
       * @type {YArray<Uint8Array>}
       */ const ds = user.get('ds');
            const ids = user.get('ids');
            const addClientId = /** @param {number} clientid */ (clientid)=>this.clients.set(clientid, userDescription);
            ds.observe(/** @param {YArrayEvent<any>} event */ (event)=>{
                event.changes.added.forEach((item)=>{
                    item.content.getContent().forEach((encodedDs)=>{
                        if (encodedDs instanceof Uint8Array) this.dss.set(userDescription, mergeDeleteSets([
                            this.dss.get(userDescription) || createDeleteSet(),
                            readDeleteSet(new DSDecoderV1(_decoding.createDecoder(encodedDs)))
                        ]));
                    });
                });
            });
            this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs)=>readDeleteSet(new DSDecoderV1(_decoding.createDecoder(encodedDs))))));
            ids.observe(/** @param {YArrayEvent<any>} event */ (event)=>event.changes.added.forEach((item)=>item.content.getContent().forEach(addClientId)));
            ids.forEach(addClientId);
        };
        // observe users
        storeType.observe((event)=>{
            event.keysChanged.forEach((userDescription)=>initUser(storeType.get(userDescription), userDescription));
        });
        // add intial data
        storeType.forEach(initUser);
    }
    /**
   * @param {Doc} doc
   * @param {number} clientid
   * @param {string} userDescription
   * @param {Object} conf
   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
   */ setUserMapping(doc, clientid, userDescription, { filter = ()=>true } = {}) {
        const users = this.yusers;
        let user = users.get(userDescription);
        if (!user) {
            user = new YMap();
            user.set('ids', new YArray());
            user.set('ds', new YArray());
            users.set(userDescription, user);
        }
        user.get('ids').push([
            clientid
        ]);
        users.observe((_event)=>{
            setTimeout(()=>{
                const userOverwrite = users.get(userDescription);
                if (userOverwrite !== user) {
                    // user was overwritten, port all data over to the next user object
                    // @todo Experiment with Y.Sets here
                    user = userOverwrite;
                    // @todo iterate over old type
                    this.clients.forEach((_userDescription, clientid)=>{
                        if (userDescription === _userDescription) user.get('ids').push([
                            clientid
                        ]);
                    });
                    const encoder = new DSEncoderV1();
                    const ds = this.dss.get(userDescription);
                    if (ds) {
                        writeDeleteSet(encoder, ds);
                        user.get('ds').push([
                            encoder.toUint8Array()
                        ]);
                    }
                }
            }, 0);
        });
        doc.on('afterTransaction', /** @param {Transaction} transaction */ (transaction)=>{
            setTimeout(()=>{
                const yds = user.get('ds');
                const ds = transaction.deleteSet;
                if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {
                    const encoder = new DSEncoderV1();
                    writeDeleteSet(encoder, ds);
                    yds.push([
                        encoder.toUint8Array()
                    ]);
                }
            });
        });
    }
    /**
   * @param {number} clientid
   * @return {any}
   */ getUserByClientId(clientid) {
        return this.clients.get(clientid) || null;
    }
    /**
   * @param {ID} id
   * @return {string | null}
   */ getUserByDeletedId(id) {
        for (const [userDescription, ds] of this.dss.entries()){
            if (isDeleted(ds, id)) return userDescription;
        }
        return null;
    }
}
/**
 * A relative position is based on the Yjs model and is not affected by document changes.
 * E.g. If you place a relative position before a certain character, it will always point to this character.
 * If you place a relative position at the end of a type, it will always point to the end of the type.
 *
 * A numeric position is often unsuited for user selections, because it does not change when content is inserted
 * before or after.
 *
 * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.
 *
 * One of the properties must be defined.
 *
 * @example
 *   // Current cursor position is at position 10
 *   const relativePosition = createRelativePositionFromIndex(yText, 10)
 *   // modify yText
 *   yText.insert(0, 'abc')
 *   yText.delete(3, 10)
 *   // Compute the cursor position
 *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)
 *   absolutePosition.type === yText // => true
 *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3
 *
 */ class RelativePosition {
    /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */ constructor(type, tname, item, assoc = 0){
        /**
     * @type {ID|null}
     */ this.type = type;
        /**
     * @type {string|null}
     */ this.tname = tname;
        /**
     * @type {ID | null}
     */ this.item = item;
        /**
     * A relative position is associated to a specific character. By default
     * assoc >= 0, the relative position is associated to the character
     * after the meant position.
     * I.e. position 1 in 'ab' is associated to character 'b'.
     *
     * If assoc < 0, then the relative position is associated to the caharacter
     * before the meant position.
     *
     * @type {number}
     */ this.assoc = assoc;
    }
}
/**
 * @param {RelativePosition} rpos
 * @return {any}
 */ const relativePositionToJSON = (rpos)=>{
    const json = {};
    if (rpos.type) json.type = rpos.type;
    if (rpos.tname) json.tname = rpos.tname;
    if (rpos.item) json.item = rpos.item;
    if (rpos.assoc != null) json.assoc = rpos.assoc;
    return json;
};
/**
 * @param {any} json
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromJSON = (json)=>new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
class AbsolutePosition {
    /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */ constructor(type, index, assoc = 0){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
        /**
     * @type {number}
     */ this.index = index;
        this.assoc = assoc;
    }
}
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @param {number} [assoc]
 *
 * @function
 */ const createAbsolutePosition = (type, index, assoc = 0)=>new AbsolutePosition(type, index, assoc);
/**
 * @param {AbstractType<any>} type
 * @param {ID|null} item
 * @param {number} [assoc]
 *
 * @function
 */ const createRelativePosition = (type, item, assoc)=>{
    let typeid = null;
    let tname = null;
    if (type._item === null) tname = findRootTypeKey(type);
    else typeid = createID(type._item.id.client, type._item.id.clock);
    return new RelativePosition(typeid, tname, item, assoc);
};
/**
 * Create a relativePosition based on a absolute position.
 *
 * @param {AbstractType<any>} type The base type (e.g. YText or YArray).
 * @param {number} index The absolute position.
 * @param {number} [assoc]
 * @return {RelativePosition}
 *
 * @function
 */ const createRelativePositionFromTypeIndex = (type, index, assoc = 0)=>{
    let t = type._start;
    if (assoc < 0) {
        // associated to the left character or the beginning of a type, increment index if possible.
        if (index === 0) return createRelativePosition(type, null, assoc);
        index--;
    }
    while(t !== null){
        if (!t.deleted && t.countable) {
            if (t.length > index) // case 1: found position somewhere in the linked list
            return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);
            index -= t.length;
        }
        if (t.right === null && assoc < 0) // left-associated position, return last available id
        return createRelativePosition(type, t.lastId, assoc);
        t = t.right;
    }
    return createRelativePosition(type, null, assoc);
};
/**
 * @param {encoding.Encoder} encoder
 * @param {RelativePosition} rpos
 *
 * @function
 */ const writeRelativePosition = (encoder, rpos)=>{
    const { type, tname, item, assoc } = rpos;
    if (item !== null) {
        _encoding.writeVarUint(encoder, 0);
        writeID(encoder, item);
    } else if (tname !== null) {
        // case 2: found position at the end of the list and type is stored in y.share
        _encoding.writeUint8(encoder, 1);
        _encoding.writeVarString(encoder, tname);
    } else if (type !== null) {
        // case 3: found position at the end of the list and type is attached to an item
        _encoding.writeUint8(encoder, 2);
        writeID(encoder, type);
    } else throw _error.unexpectedCase();
    _encoding.writeVarInt(encoder, assoc);
    return encoder;
};
/**
 * @param {RelativePosition} rpos
 * @return {Uint8Array}
 */ const encodeRelativePosition = (rpos)=>{
    const encoder = _encoding.createEncoder();
    writeRelativePosition(encoder, rpos);
    return _encoding.toUint8Array(encoder);
};
/**
 * @param {decoding.Decoder} decoder
 * @return {RelativePosition}
 *
 * @function
 */ const readRelativePosition = (decoder)=>{
    let type = null;
    let tname = null;
    let itemID = null;
    switch(_decoding.readVarUint(decoder)){
        case 0:
            // case 1: found position somewhere in the linked list
            itemID = readID(decoder);
            break;
        case 1:
            // case 2: found position at the end of the list and type is stored in y.share
            tname = _decoding.readVarString(decoder);
            break;
        case 2:
            // case 3: found position at the end of the list and type is attached to an item
            type = readID(decoder);
    }
    const assoc = _decoding.hasContent(decoder) ? _decoding.readVarInt(decoder) : 0;
    return new RelativePosition(type, tname, itemID, assoc);
};
/**
 * @param {Uint8Array} uint8Array
 * @return {RelativePosition}
 */ const decodeRelativePosition = (uint8Array)=>readRelativePosition(_decoding.createDecoder(uint8Array));
/**
 * @param {StructStore} store
 * @param {ID} id
 */ const getItemWithOffset = (store, id)=>{
    const item = getItem(store, id);
    const diff = id.clock - item.id.clock;
    return {
        item,
        diff
    };
};
/**
 * Transform a relative position to an absolute position.
 *
 * If you want to share the relative position with other users, you should set
 * `followUndoneDeletions` to false to get consistent results across all clients.
 *
 * When calculating the absolute position, we try to follow the "undone deletions". This yields
 * better results for the user who performed undo. However, only the user who performed the undo
 * will get the better results, the other users don't know which operations recreated a deleted
 * range of content. There is more information in this ticket: https://github.com/yjs/yjs/issues/638
 *
 * @param {RelativePosition} rpos
 * @param {Doc} doc
 * @param {boolean} followUndoneDeletions - whether to follow undone deletions - see https://github.com/yjs/yjs/issues/638
 * @return {AbsolutePosition|null}
 *
 * @function
 */ const createAbsolutePositionFromRelativePosition = (rpos, doc, followUndoneDeletions = true)=>{
    const store = doc.store;
    const rightID = rpos.item;
    const typeID = rpos.type;
    const tname = rpos.tname;
    const assoc = rpos.assoc;
    let type = null;
    let index = 0;
    if (rightID !== null) {
        if (getState(store, rightID.client) <= rightID.clock) return null;
        const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);
        const right = res.item;
        if (!(right instanceof Item)) return null;
        type = /** @type {AbstractType<any>} */ right.parent;
        if (type._item === null || !type._item.deleted) {
            index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1); // adjust position based on left association if necessary
            let n = right.left;
            while(n !== null){
                if (!n.deleted && n.countable) index += n.length;
                n = n.left;
            }
        }
    } else {
        if (tname !== null) type = doc.get(tname);
        else if (typeID !== null) {
            if (getState(store, typeID.client) <= typeID.clock) // type does not exist yet
            return null;
            const { item } = followUndoneDeletions ? followRedone(store, typeID) : {
                item: getItem(store, typeID)
            };
            if (item instanceof Item && item.content instanceof ContentType) type = item.content.type;
            else // struct is garbage collected
            return null;
        } else throw _error.unexpectedCase();
        if (assoc >= 0) index = type._length;
        else index = 0;
    }
    return createAbsolutePosition(type, index, rpos.assoc);
};
/**
 * @param {RelativePosition|null} a
 * @param {RelativePosition|null} b
 * @return {boolean}
 *
 * @function
 */ const compareRelativePositions = (a, b)=>a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
class Snapshot {
    /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */ constructor(ds, sv){
        /**
     * @type {DeleteSet}
     */ this.ds = ds;
        /**
     * State Map
     * @type {Map<number,number>}
     */ this.sv = sv;
    }
}
/**
 * @param {Snapshot} snap1
 * @param {Snapshot} snap2
 * @return {boolean}
 */ const equalSnapshots = (snap1, snap2)=>{
    const ds1 = snap1.ds.clients;
    const ds2 = snap2.ds.clients;
    const sv1 = snap1.sv;
    const sv2 = snap2.sv;
    if (sv1.size !== sv2.size || ds1.size !== ds2.size) return false;
    for (const [key, value] of sv1.entries()){
        if (sv2.get(key) !== value) return false;
    }
    for (const [client, dsitems1] of ds1.entries()){
        const dsitems2 = ds2.get(client) || [];
        if (dsitems1.length !== dsitems2.length) return false;
        for(let i = 0; i < dsitems1.length; i++){
            const dsitem1 = dsitems1[i];
            const dsitem2 = dsitems2[i];
            if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) return false;
        }
    }
    return true;
};
/**
 * @param {Snapshot} snapshot
 * @param {DSEncoderV1 | DSEncoderV2} [encoder]
 * @return {Uint8Array}
 */ const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2())=>{
    writeDeleteSet(encoder, snapshot.ds);
    writeStateVector(encoder, snapshot.sv);
    return encoder.toUint8Array();
};
/**
 * @param {Snapshot} snapshot
 * @return {Uint8Array}
 */ const encodeSnapshot = (snapshot)=>encodeSnapshotV2(snapshot, new DSEncoderV1());
/**
 * @param {Uint8Array} buf
 * @param {DSDecoderV1 | DSDecoderV2} [decoder]
 * @return {Snapshot}
 */ const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(_decoding.createDecoder(buf)))=>{
    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));
};
/**
 * @param {Uint8Array} buf
 * @return {Snapshot}
 */ const decodeSnapshot = (buf)=>decodeSnapshotV2(buf, new DSDecoderV1(_decoding.createDecoder(buf)));
/**
 * @param {DeleteSet} ds
 * @param {Map<number,number>} sm
 * @return {Snapshot}
 */ const createSnapshot = (ds, sm)=>new Snapshot(ds, sm);
const emptySnapshot = createSnapshot(createDeleteSet(), new Map());
/**
 * @param {Doc} doc
 * @return {Snapshot}
 */ const snapshot = (doc)=>createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));
/**
 * @param {Item} item
 * @param {Snapshot|undefined} snapshot
 *
 * @protected
 * @function
 */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
/**
 * @param {Transaction} transaction
 * @param {Snapshot} snapshot
 */ const splitSnapshotAffectedStructs = (transaction, snapshot)=>{
    const meta = _map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, _set.create);
    const store = transaction.doc.store;
    // check if we already split for this snapshot
    if (!meta.has(snapshot)) {
        snapshot.sv.forEach((clock, client)=>{
            if (clock < getState(store, client)) getItemCleanStart(transaction, createID(client, clock));
        });
        iterateDeletedStructs(transaction, snapshot.ds, (_item)=>{});
        meta.add(snapshot);
    }
};
/**
 * @example
 *  const ydoc = new Y.Doc({ gc: false })
 *  ydoc.getText().insert(0, 'world!')
 *  const snapshot = Y.snapshot(ydoc)
 *  ydoc.getText().insert(0, 'hello ')
 *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)
 *  assert(restored.getText().toString() === 'world!')
 *
 * @param {Doc} originDoc
 * @param {Snapshot} snapshot
 * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc
 * @return {Doc}
 */ const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc())=>{
    if (originDoc.gc) // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted
    throw new Error('Garbage-collection must be disabled in `originDoc`!');
    const { sv, ds } = snapshot;
    const encoder = new UpdateEncoderV2();
    originDoc.transact((transaction)=>{
        let size = 0;
        sv.forEach((clock)=>{
            if (clock > 0) size++;
        });
        _encoding.writeVarUint(encoder.restEncoder, size);
        // splitting the structs before writing them to the encoder
        for (const [client, clock] of sv){
            if (clock === 0) continue;
            if (clock < getState(originDoc.store, client)) getItemCleanStart(transaction, createID(client, clock));
            const structs = originDoc.store.clients.get(client) || [];
            const lastStructIndex = findIndexSS(structs, clock - 1);
            // write # encoded structs
            _encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1);
            encoder.writeClient(client);
            // first clock written is 0
            _encoding.writeVarUint(encoder.restEncoder, 0);
            for(let i = 0; i <= lastStructIndex; i++)structs[i].write(encoder, 0);
        }
        writeDeleteSet(encoder, ds);
    });
    applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');
    return newDoc;
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 */ const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2)=>{
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()){
        if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) return false;
    }
    const mergedDS = mergeDeleteSets([
        snapshot.ds,
        readDeleteSet(updateDecoder)
    ]);
    return equalDeleteSets(snapshot.ds, mergedDS);
};
/**
 * @param {Snapshot} snapshot
 * @param {Uint8Array} update
 */ const snapshotContainsUpdate = (snapshot, update)=>snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);
class StructStore {
    constructor(){
        /**
     * @type {Map<number,Array<GC|Item>>}
     */ this.clients = new Map();
        /**
     * @type {null | { missing: Map<number, number>, update: Uint8Array }}
     */ this.pendingStructs = null;
        /**
     * @type {null | Uint8Array}
     */ this.pendingDs = null;
    }
}
/**
 * Return the states as a Map<client,clock>.
 * Note that clock refers to the next expected clock id.
 *
 * @param {StructStore} store
 * @return {Map<number,number>}
 *
 * @public
 * @function
 */ const getStateVector = (store)=>{
    const sm = new Map();
    store.clients.forEach((structs, client)=>{
        const struct = structs[structs.length - 1];
        sm.set(client, struct.id.clock + struct.length);
    });
    return sm;
};
/**
 * @param {StructStore} store
 * @param {number} client
 * @return {number}
 *
 * @public
 * @function
 */ const getState = (store, client)=>{
    const structs = store.clients.get(client);
    if (structs === undefined) return 0;
    const lastStruct = structs[structs.length - 1];
    return lastStruct.id.clock + lastStruct.length;
};
/**
 * @param {StructStore} store
 * @param {GC|Item} struct
 *
 * @private
 * @function
 */ const addStruct = (store, struct)=>{
    let structs = store.clients.get(struct.id.client);
    if (structs === undefined) {
        structs = [];
        store.clients.set(struct.id.client, structs);
    } else {
        const lastStruct = structs[structs.length - 1];
        if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) throw _error.unexpectedCase();
    }
    structs.push(struct);
};
/**
 * Perform a binary search on a sorted array
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 * @return {number}
 *
 * @private
 * @function
 */ const findIndexSS = (structs, clock)=>{
    let left = 0;
    let right = structs.length - 1;
    let mid = structs[right];
    let midclock = mid.id.clock;
    if (midclock === clock) return right;
    // @todo does it even make sense to pivot the search?
    // If a good split misses, it might actually increase the time to find the correct item.
    // Currently, the only advantage is that search with pivoting might find the item on the first try.
    let midindex = _math.floor(clock / (midclock + mid.length - 1) * right); // pivoting the search
    while(left <= right){
        mid = structs[midindex];
        midclock = mid.id.clock;
        if (midclock <= clock) {
            if (clock < midclock + mid.length) return midindex;
            left = midindex + 1;
        } else right = midindex - 1;
        midindex = _math.floor((left + right) / 2);
    }
    // Always check state before looking for a struct in StructStore
    // Therefore the case of not finding a struct is unexpected
    throw _error.unexpectedCase();
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {GC|Item}
 *
 * @private
 * @function
 */ const find = (store, id)=>{
    /**
   * @type {Array<GC|Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    return structs[findIndexSS(structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 * @private
 * @function
 */ const getItem = /** @type {function(StructStore,ID):Item} */ find;
/**
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clock
 */ const findIndexCleanStart = (transaction, structs, clock)=>{
    const index = findIndexSS(structs, clock);
    const struct = structs[index];
    if (struct.id.clock < clock && struct instanceof Item) {
        structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
        return index + 1;
    }
    return index;
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanStart = (transaction, id)=>{
    const structs = /** @type {Array<Item>} */ transaction.doc.store.clients.get(id.client);
    return structs[findIndexCleanStart(transaction, structs, id.clock)];
};
/**
 * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
 *
 * @param {Transaction} transaction
 * @param {StructStore} store
 * @param {ID} id
 * @return {Item}
 *
 * @private
 * @function
 */ const getItemCleanEnd = (transaction, store, id)=>{
    /**
   * @type {Array<Item>}
   */ // @ts-ignore
    const structs = store.clients.get(id.client);
    const index = findIndexSS(structs, id.clock);
    const struct = structs[index];
    if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
    return struct;
};
/**
 * Replace `item` with `newitem` in store
 * @param {StructStore} store
 * @param {GC|Item} struct
 * @param {GC|Item} newStruct
 *
 * @private
 * @function
 */ const replaceStruct = (store, struct, newStruct)=>{
    const structs = /** @type {Array<GC|Item>} */ store.clients.get(struct.id.client);
    structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
/**
 * Iterate over a range of structs
 *
 * @param {Transaction} transaction
 * @param {Array<Item|GC>} structs
 * @param {number} clockStart Inclusive start
 * @param {number} len
 * @param {function(GC|Item):void} f
 *
 * @function
 */ const iterateStructs = (transaction, structs, clockStart, len, f)=>{
    if (len === 0) return;
    const clockEnd = clockStart + len;
    let index = findIndexCleanStart(transaction, structs, clockStart);
    let struct;
    do {
        struct = structs[index++];
        if (clockEnd < struct.id.clock + struct.length) findIndexCleanStart(transaction, structs, clockEnd);
        f(struct);
    }while (index < structs.length && structs[index].id.clock < clockEnd);
};
/**
 * A transaction is created for every change on the Yjs model. It is possible
 * to bundle changes on the Yjs model in a single transaction to
 * minimize the number on messages sent and the number of observer calls.
 * If possible the user of this library should bundle as many changes as
 * possible. Here is an example to illustrate the advantages of bundling:
 *
 * @example
 * const ydoc = new Y.Doc()
 * const map = ydoc.getMap('map')
 * // Log content when change is triggered
 * map.observe(() => {
 *   console.log('change triggered')
 * })
 * // Each change on the map type triggers a log message:
 * map.set('a', 0) // => "change triggered"
 * map.set('b', 0) // => "change triggered"
 * // When put in a transaction, it will trigger the log after the transaction:
 * ydoc.transact(() => {
 *   map.set('a', 1)
 *   map.set('b', 1)
 * }) // => "change triggered"
 *
 * @public
 */ class Transaction {
    /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */ constructor(doc, origin, local){
        /**
     * The Yjs instance.
     * @type {Doc}
     */ this.doc = doc;
        /**
     * Describes the set of deleted items by ids
     * @type {DeleteSet}
     */ this.deleteSet = new DeleteSet();
        /**
     * Holds the state before the transaction started.
     * @type {Map<Number,Number>}
     */ this.beforeState = getStateVector(doc.store);
        /**
     * Holds the state after the transaction.
     * @type {Map<Number,Number>}
     */ this.afterState = new Map();
        /**
     * All types that were directly modified (property added or child
     * inserted/deleted). New types are not included in this Set.
     * Maps from type to parentSubs (`item.parentSub = null` for YArray)
     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}
     */ this.changed = new Map();
        /**
     * Stores the events for the types that observe also child elements.
     * It is mainly used by `observeDeep`.
     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}
     */ this.changedParentTypes = new Map();
        /**
     * @type {Array<AbstractStruct>}
     */ this._mergeStructs = [];
        /**
     * @type {any}
     */ this.origin = origin;
        /**
     * Stores meta information on the transaction
     * @type {Map<any,any>}
     */ this.meta = new Map();
        /**
     * Whether this change originates from this doc.
     * @type {boolean}
     */ this.local = local;
        /**
     * @type {Set<Doc>}
     */ this.subdocsAdded = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsRemoved = new Set();
        /**
     * @type {Set<Doc>}
     */ this.subdocsLoaded = new Set();
        /**
     * @type {boolean}
     */ this._needFormattingCleanup = false;
    }
}
/**
 * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
 * @param {Transaction} transaction
 * @return {boolean} Whether data was written.
 */ const writeUpdateMessageFromTransaction = (encoder, transaction)=>{
    if (transaction.deleteSet.clients.size === 0 && !_map.any(transaction.afterState, (clock, client)=>transaction.beforeState.get(client) !== clock)) return false;
    sortAndMergeDeleteSet(transaction.deleteSet);
    writeStructsFromTransaction(encoder, transaction);
    writeDeleteSet(encoder, transaction.deleteSet);
    return true;
};
/**
 * If `type.parent` was added in current transaction, `type` technically
 * did not change, it was just added and we should not fire events for `type`.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<YEvent<any>>} type
 * @param {string|null} parentSub
 */ const addChangedTypeToTransaction = (transaction, type, parentSub)=>{
    const item = type._item;
    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) _map.setIfUndefined(transaction.changed, type, _set.create).add(parentSub);
};
/**
 * @param {Array<AbstractStruct>} structs
 * @param {number} pos
 * @return {number} # of merged structs
 */ const tryToMergeWithLefts = (structs, pos)=>{
    let right = structs[pos];
    let left = structs[pos - 1];
    let i = pos;
    for(; i > 0; right = left, left = structs[--i - 1]){
        if (left.deleted === right.deleted && left.constructor === right.constructor) {
            if (left.mergeWith(right)) {
                if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ right.parent._map.get(right.parentSub) === right) /** @type {AbstractType<any>} */ right.parent._map.set(right.parentSub, /** @type {Item} */ left);
                continue;
            }
        }
        break;
    }
    const merged = pos - i;
    if (merged) // remove all merged structs from the array
    structs.splice(pos + 1 - merged, merged);
    return merged;
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGcDeleteSet = (ds, store, gcFilter)=>{
    for (const [client, deleteItems] of ds.clients.entries()){
        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            const endDeleteItemClock = deleteItem.clock + deleteItem.len;
            for(let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]){
                const struct = structs[si];
                if (deleteItem.clock + deleteItem.len <= struct.id.clock) break;
                if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) struct.gc(store, false);
            }
        }
    }
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 */ const tryMergeDeleteSet = (ds, store)=>{
    // try to merge deleted / gc'd items
    // merge from right to left for better efficiency and so we don't miss any merge targets
    ds.clients.forEach((deleteItems, client)=>{
        const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
        for(let di = deleteItems.length - 1; di >= 0; di--){
            const deleteItem = deleteItems[di];
            // start with merging the item next to the last deleted item
            const mostRightIndexToCheck = _math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
            for(let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si])si -= 1 + tryToMergeWithLefts(structs, si);
        }
    });
};
/**
 * @param {DeleteSet} ds
 * @param {StructStore} store
 * @param {function(Item):boolean} gcFilter
 */ const tryGc = (ds, store, gcFilter)=>{
    tryGcDeleteSet(ds, store, gcFilter);
    tryMergeDeleteSet(ds, store);
};
/**
 * @param {Array<Transaction>} transactionCleanups
 * @param {number} i
 */ const cleanupTransactions = (transactionCleanups, i)=>{
    if (i < transactionCleanups.length) {
        const transaction = transactionCleanups[i];
        const doc = transaction.doc;
        const store = doc.store;
        const ds = transaction.deleteSet;
        const mergeStructs = transaction._mergeStructs;
        try {
            sortAndMergeDeleteSet(ds);
            transaction.afterState = getStateVector(transaction.doc.store);
            doc.emit('beforeObserverCalls', [
                transaction,
                doc
            ]);
            /**
       * An array of event callbacks.
       *
       * Each callback is called even if the other ones throw errors.
       *
       * @type {Array<function():void>}
       */ const fs = [];
            // observe events on changed types
            transaction.changed.forEach((subs, itemtype)=>fs.push(()=>{
                    if (itemtype._item === null || !itemtype._item.deleted) itemtype._callObserver(transaction, subs);
                }));
            fs.push(()=>{
                // deep observe events
                transaction.changedParentTypes.forEach((events, type)=>{
                    // We need to think about the possibility that the user transforms the
                    // Y.Doc in the event.
                    if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
                        events = events.filter((event)=>event.target._item === null || !event.target._item.deleted);
                        events.forEach((event)=>{
                            event.currentTarget = type;
                            // path is relative to the current target
                            event._path = null;
                        });
                        // sort events by path length so that top-level events are fired first.
                        events.sort((event1, event2)=>event1.path.length - event2.path.length);
                        // We don't need to check for events.length
                        // because we know it has at least one element
                        callEventHandlerListeners(type._dEH, events, transaction);
                    }
                });
            });
            fs.push(()=>doc.emit('afterTransaction', [
                    transaction,
                    doc
                ]));
            (0, _function.callAll)(fs, []);
            if (transaction._needFormattingCleanup) cleanupYTextAfterTransaction(transaction);
        } finally{
            // Replace deleted items with ItemDeleted / GC.
            // This is where content is actually remove from the Yjs Doc.
            if (doc.gc) tryGcDeleteSet(ds, store, doc.gcFilter);
            tryMergeDeleteSet(ds, store);
            // on all affected store.clients props, try to merge
            transaction.afterState.forEach((clock, client)=>{
                const beforeClock = transaction.beforeState.get(client) || 0;
                if (beforeClock !== clock) {
                    const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
                    // we iterate from right to left so we can safely remove entries
                    const firstChangePos = _math.max(findIndexSS(structs, beforeClock), 1);
                    for(let i = structs.length - 1; i >= firstChangePos;)i -= 1 + tryToMergeWithLefts(structs, i);
                }
            });
            // try to merge mergeStructs
            // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left
            //        but at the moment DS does not handle duplicates
            for(let i = mergeStructs.length - 1; i >= 0; i--){
                const { client, clock } = mergeStructs[i].id;
                const structs = /** @type {Array<GC|Item>} */ store.clients.get(client);
                const replacedStructPos = findIndexSS(structs, clock);
                if (replacedStructPos + 1 < structs.length) {
                    if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) continue; // no need to perform next check, both are already merged
                }
                if (replacedStructPos > 0) tryToMergeWithLefts(structs, replacedStructPos);
            }
            if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {
                _logging.print(_logging.ORANGE, _logging.BOLD, '[yjs] ', _logging.UNBOLD, _logging.RED, 'Changed the client-id because another client seems to be using it.');
                doc.clientID = generateNewClientId();
            }
            // @todo Merge all the transactions into one and provide send the data as a single update message
            doc.emit('afterTransactionCleanup', [
                transaction,
                doc
            ]);
            if (doc._observers.has('update')) {
                const encoder = new UpdateEncoderV1();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) doc.emit('update', [
                    encoder.toUint8Array(),
                    transaction.origin,
                    doc,
                    transaction
                ]);
            }
            if (doc._observers.has('updateV2')) {
                const encoder = new UpdateEncoderV2();
                const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
                if (hasContent) doc.emit('updateV2', [
                    encoder.toUint8Array(),
                    transaction.origin,
                    doc,
                    transaction
                ]);
            }
            const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
            if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
                subdocsAdded.forEach((subdoc)=>{
                    subdoc.clientID = doc.clientID;
                    if (subdoc.collectionid == null) subdoc.collectionid = doc.collectionid;
                    doc.subdocs.add(subdoc);
                });
                subdocsRemoved.forEach((subdoc)=>doc.subdocs.delete(subdoc));
                doc.emit('subdocs', [
                    {
                        loaded: subdocsLoaded,
                        added: subdocsAdded,
                        removed: subdocsRemoved
                    },
                    doc,
                    transaction
                ]);
                subdocsRemoved.forEach((subdoc)=>subdoc.destroy());
            }
            if (transactionCleanups.length <= i + 1) {
                doc._transactionCleanups = [];
                doc.emit('afterAllTransactions', [
                    doc,
                    transactionCleanups
                ]);
            } else cleanupTransactions(transactionCleanups, i + 1);
        }
    }
};
/**
 * Implements the functionality of `y.transact(()=>{..})`
 *
 * @template T
 * @param {Doc} doc
 * @param {function(Transaction):T} f
 * @param {any} [origin=true]
 * @return {T}
 *
 * @function
 */ const transact = (doc, f, origin = null, local = true)=>{
    const transactionCleanups = doc._transactionCleanups;
    let initialCall = false;
    /**
   * @type {any}
   */ let result = null;
    if (doc._transaction === null) {
        initialCall = true;
        doc._transaction = new Transaction(doc, origin, local);
        transactionCleanups.push(doc._transaction);
        if (transactionCleanups.length === 1) doc.emit('beforeAllTransactions', [
            doc
        ]);
        doc.emit('beforeTransaction', [
            doc._transaction,
            doc
        ]);
    }
    try {
        result = f(doc._transaction);
    } finally{
        if (initialCall) {
            const finishCleanup = doc._transaction === transactionCleanups[0];
            doc._transaction = null;
            if (finishCleanup) // The first transaction ended, now process observer calls.
            // Observer call may create new transactions for which we need to call the observers and do cleanup.
            // We don't want to nest these calls, so we execute these calls one after
            // another.
            // Also we need to ensure that all cleanups are called, even if the
            // observes throw errors.
            // This file is full of hacky try {} finally {} blocks to ensure that an
            // event can throw errors and also that the cleanup is called.
            cleanupTransactions(transactionCleanups, 0);
        }
    }
    return result;
};
class StackItem {
    /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */ constructor(deletions, insertions){
        this.insertions = insertions;
        this.deletions = deletions;
        /**
     * Use this to save and restore metadata like selection range
     */ this.meta = new Map();
    }
}
/**
 * @param {Transaction} tr
 * @param {UndoManager} um
 * @param {StackItem} stackItem
 */ const clearUndoManagerStackItem = (tr, um, stackItem)=>{
    iterateDeletedStructs(tr, stackItem.deletions, (item)=>{
        if (item instanceof Item && um.scope.some((type)=>isParentOf(type, item))) keepItem(item, false);
    });
};
/**
 * @param {UndoManager} undoManager
 * @param {Array<StackItem>} stack
 * @param {'undo'|'redo'} eventType
 * @return {StackItem?}
 */ const popStackItem = (undoManager, stack, eventType)=>{
    /**
   * Keep a reference to the transaction so we can fire the event with the changedParentTypes
   * @type {any}
   */ let _tr = null;
    const doc = undoManager.doc;
    const scope = undoManager.scope;
    transact(doc, (transaction)=>{
        while(stack.length > 0 && undoManager.currStackItem === null){
            const store = doc.store;
            const stackItem = /** @type {StackItem} */ stack.pop();
            /**
       * @type {Set<Item>}
       */ const itemsToRedo = new Set();
            /**
       * @type {Array<Item>}
       */ const itemsToDelete = [];
            let performedChange = false;
            iterateDeletedStructs(transaction, stackItem.insertions, (struct)=>{
                if (struct instanceof Item) {
                    if (struct.redone !== null) {
                        let { item, diff } = followRedone(store, struct.id);
                        if (diff > 0) item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
                        struct = item;
                    }
                    if (!struct.deleted && scope.some((type)=>isParentOf(type, /** @type {Item} */ struct))) itemsToDelete.push(struct);
                }
            });
            iterateDeletedStructs(transaction, stackItem.deletions, (struct)=>{
                if (struct instanceof Item && scope.some((type)=>isParentOf(type, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
                !isDeleted(stackItem.insertions, struct.id)) itemsToRedo.add(struct);
            });
            itemsToRedo.forEach((struct)=>{
                performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
            });
            // We want to delete in reverse order so that children are deleted before
            // parents, so we have more information available when items are filtered.
            for(let i = itemsToDelete.length - 1; i >= 0; i--){
                const item = itemsToDelete[i];
                if (undoManager.deleteFilter(item)) {
                    item.delete(transaction);
                    performedChange = true;
                }
            }
            undoManager.currStackItem = performedChange ? stackItem : null;
        }
        transaction.changed.forEach((subProps, type)=>{
            // destroy search marker if necessary
            if (subProps.has(null) && type._searchMarker) type._searchMarker.length = 0;
        });
        _tr = transaction;
    }, undoManager);
    const res = undoManager.currStackItem;
    if (res != null) {
        const changedParentTypes = _tr.changedParentTypes;
        undoManager.emit('stack-item-popped', [
            {
                stackItem: res,
                type: eventType,
                changedParentTypes,
                origin: undoManager
            },
            undoManager
        ]);
        undoManager.currStackItem = null;
    }
    return res;
};
/**
 * @typedef {Object} UndoManagerOptions
 * @property {number} [UndoManagerOptions.captureTimeout=500]
 * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.
 * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes
 * it is necessary to filter what an Undo/Redo operation can delete. If this
 * filter returns false, the type/item won't be deleted even it is in the
 * undo/redo scope.
 * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]
 * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).
 * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.
 */ /**
 * @typedef {Object} StackItemEvent
 * @property {StackItem} StackItemEvent.stackItem
 * @property {any} StackItemEvent.origin
 * @property {'undo'|'redo'} StackItemEvent.type
 * @property {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>} StackItemEvent.changedParentTypes
 */ /**
 * Fires 'stack-item-added' event when a stack item was added to either the undo- or
 * the redo-stack. You may store additional stack information via the
 * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).
 * Fires 'stack-item-popped' event when a stack item was popped from either the
 * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.
 *
 * @extends {ObservableV2<{'stack-item-added':function(StackItemEvent, UndoManager):void, 'stack-item-popped': function(StackItemEvent, UndoManager):void, 'stack-cleared': function({ undoStackCleared: boolean, redoStackCleared: boolean }):void, 'stack-item-updated': function(StackItemEvent, UndoManager):void }>}
 */ class UndoManager extends (0, _observable.ObservableV2) {
    /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */ constructor(typeScope, { captureTimeout = 500, captureTransaction = (_tr)=>true, deleteFilter = ()=>true, trackedOrigins = new Set([
        null
    ]), ignoreRemoteMapChanges = false, doc = /** @type {Doc} */ _array.isArray(typeScope) ? typeScope[0].doc : typeScope.doc } = {}){
        super();
        /**
     * @type {Array<AbstractType<any>>}
     */ this.scope = [];
        this.doc = doc;
        this.addToScope(typeScope);
        this.deleteFilter = deleteFilter;
        trackedOrigins.add(this);
        this.trackedOrigins = trackedOrigins;
        this.captureTransaction = captureTransaction;
        /**
     * @type {Array<StackItem>}
     */ this.undoStack = [];
        /**
     * @type {Array<StackItem>}
     */ this.redoStack = [];
        /**
     * Whether the client is currently undoing (calling UndoManager.undo)
     *
     * @type {boolean}
     */ this.undoing = false;
        this.redoing = false;
        /**
     * The currently popped stack item if UndoManager.undoing or UndoManager.redoing
     *
     * @type {StackItem|null}
     */ this.currStackItem = null;
        this.lastChange = 0;
        this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
        this.captureTimeout = captureTimeout;
        /**
     * @param {Transaction} transaction
     */ this.afterTransactionHandler = (transaction)=>{
            // Only track certain transactions
            if (!this.captureTransaction(transaction) || !this.scope.some((type)=>transaction.changedParentTypes.has(type)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) return;
            const undoing = this.undoing;
            const redoing = this.redoing;
            const stack = undoing ? this.redoStack : this.undoStack;
            if (undoing) this.stopCapturing(); // next undo should not be appended to last stack item
            else if (!redoing) // neither undoing nor redoing: delete redoStack
            this.clear(false, true);
            const insertions = new DeleteSet();
            transaction.afterState.forEach((endClock, client)=>{
                const startClock = transaction.beforeState.get(client) || 0;
                const len = endClock - startClock;
                if (len > 0) addToDeleteSet(insertions, client, startClock, len);
            });
            const now = _time.getUnixTime();
            let didAdd = false;
            if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
                // append change to last stack op
                const lastOp = stack[stack.length - 1];
                lastOp.deletions = mergeDeleteSets([
                    lastOp.deletions,
                    transaction.deleteSet
                ]);
                lastOp.insertions = mergeDeleteSets([
                    lastOp.insertions,
                    insertions
                ]);
            } else {
                // create a new stack op
                stack.push(new StackItem(transaction.deleteSet, insertions));
                didAdd = true;
            }
            if (!undoing && !redoing) this.lastChange = now;
            // make sure that deleted structs are not gc'd
            iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ (item)=>{
                if (item instanceof Item && this.scope.some((type)=>isParentOf(type, item))) keepItem(item, true);
            });
            /**
       * @type {[StackItemEvent, UndoManager]}
       */ const changeEvent = [
                {
                    stackItem: stack[stack.length - 1],
                    origin: transaction.origin,
                    type: undoing ? 'redo' : 'undo',
                    changedParentTypes: transaction.changedParentTypes
                },
                this
            ];
            if (didAdd) this.emit('stack-item-added', changeEvent);
            else this.emit('stack-item-updated', changeEvent);
        };
        this.doc.on('afterTransaction', this.afterTransactionHandler);
        this.doc.on('destroy', ()=>{
            this.destroy();
        });
    }
    /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */ addToScope(ytypes) {
        ytypes = _array.isArray(ytypes) ? ytypes : [
            ytypes
        ];
        ytypes.forEach((ytype)=>{
            if (this.scope.every((yt)=>yt !== ytype)) {
                if (ytype.doc !== this.doc) _logging.warn('[yjs#509] Not same Y.Doc'); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509
                this.scope.push(ytype);
            }
        });
    }
    /**
   * @param {any} origin
   */ addTrackedOrigin(origin) {
        this.trackedOrigins.add(origin);
    }
    /**
   * @param {any} origin
   */ removeTrackedOrigin(origin) {
        this.trackedOrigins.delete(origin);
    }
    clear(clearUndoStack = true, clearRedoStack = true) {
        if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) this.doc.transact((tr)=>{
            if (clearUndoStack) {
                this.undoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                this.undoStack = [];
            }
            if (clearRedoStack) {
                this.redoStack.forEach((item)=>clearUndoManagerStackItem(tr, this, item));
                this.redoStack = [];
            }
            this.emit('stack-cleared', [
                {
                    undoStackCleared: clearUndoStack,
                    redoStackCleared: clearRedoStack
                }
            ]);
        });
    }
    /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */ stopCapturing() {
        this.lastChange = 0;
    }
    /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ undo() {
        this.undoing = true;
        let res;
        try {
            res = popStackItem(this, this.undoStack, 'undo');
        } finally{
            this.undoing = false;
        }
        return res;
    }
    /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */ redo() {
        this.redoing = true;
        let res;
        try {
            res = popStackItem(this, this.redoStack, 'redo');
        } finally{
            this.redoing = false;
        }
        return res;
    }
    /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */ canUndo() {
        return this.undoStack.length > 0;
    }
    /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */ canRedo() {
        return this.redoStack.length > 0;
    }
    destroy() {
        this.trackedOrigins.delete(this);
        this.doc.off('afterTransaction', this.afterTransactionHandler);
        super.destroy();
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 */ function* lazyStructReaderGenerator(decoder) {
    const numOfStateUpdates = _decoding.readVarUint(decoder.restDecoder);
    for(let i = 0; i < numOfStateUpdates; i++){
        const numberOfStructs = _decoding.readVarUint(decoder.restDecoder);
        const client = decoder.readClient();
        let clock = _decoding.readVarUint(decoder.restDecoder);
        for(let i = 0; i < numberOfStructs; i++){
            const info = decoder.readInfo();
            // @todo use switch instead of ifs
            if (info === 10) {
                const len = _decoding.readVarUint(decoder.restDecoder);
                yield new Skip(createID(client, clock), len);
                clock += len;
            } else if ((_binary.BITS5 & info) !== 0) {
                const cantCopyParentInfo = (info & (_binary.BIT7 | _binary.BIT8)) === 0;
                // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                // and we read the next string as parentYKey.
                // It indicates how we store/retrieve parent from `y.share`
                // @type {string|null}
                const struct = new Item(createID(client, clock), null, (info & _binary.BIT8) === _binary.BIT8 ? decoder.readLeftID() : null, null, (info & _binary.BIT7) === _binary.BIT7 ? decoder.readRightID() : null, // @ts-ignore Force writing a string here.
                cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null, cantCopyParentInfo && (info & _binary.BIT6) === _binary.BIT6 ? decoder.readString() : null, readItemContent(decoder, info) // item content
                );
                yield struct;
                clock += struct.length;
            } else {
                const len = decoder.readLen();
                yield new GC(createID(client, clock), len);
                clock += len;
            }
        }
    }
}
class LazyStructReader {
    /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */ constructor(decoder, filterSkips){
        this.gen = lazyStructReaderGenerator(decoder);
        /**
     * @type {null | Item | Skip | GC}
     */ this.curr = null;
        this.done = false;
        this.filterSkips = filterSkips;
        this.next();
    }
    /**
   * @return {Item | GC | Skip |null}
   */ next() {
        // ignore "Skip" structs
        do this.curr = this.gen.next().value || null;
        while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
        return this.curr;
    }
}
/**
 * @param {Uint8Array} update
 *
 */ const logUpdate = (update)=>logUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const logUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())structs.push(curr);
    _logging.print('Structs: ', structs);
    const ds = readDeleteSet(updateDecoder);
    _logging.print('DeleteSet: ', ds);
};
/**
 * @param {Uint8Array} update
 *
 */ const decodeUpdate = (update)=>decodeUpdateV2(update, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
 *
 */ const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2)=>{
    const structs = [];
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())structs.push(curr);
    return {
        structs,
        ds: readDeleteSet(updateDecoder)
    };
};
class LazyStructWriter {
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ constructor(encoder){
        this.currClient = 0;
        this.startClock = 0;
        this.written = 0;
        this.encoder = encoder;
        /**
     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.
     *
     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.
     *
     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.
     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.
     *
     * @type {Array<{ written: number, restEncoder: Uint8Array }>}
     */ this.clientStructs = [];
    }
}
/**
 * @param {Array<Uint8Array>} updates
 * @return {Uint8Array}
 */ const mergeUpdates = (updates)=>mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2)=>{
    const encoder = new YEncoder();
    const updateDecoder = new LazyStructReader(new YDecoder(_decoding.createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let size = 0;
        let currClient = curr.id.client;
        let stopCounting = curr.id.clock !== 0; // must start at 0
        let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                if (currClock !== 0) {
                    size++;
                    // We found a new client
                    // write what we have to the encoder
                    _encoding.writeVarUint(encoder.restEncoder, currClient);
                    _encoding.writeVarUint(encoder.restEncoder, currClock);
                }
                currClient = curr.id.client;
                currClock = 0;
                stopCounting = curr.id.clock !== 0;
            }
            // we ignore skips
            if (curr.constructor === Skip) stopCounting = true;
            if (!stopCounting) currClock = curr.id.clock + curr.length;
        }
        // write what we have
        if (currClock !== 0) {
            size++;
            _encoding.writeVarUint(encoder.restEncoder, currClient);
            _encoding.writeVarUint(encoder.restEncoder, currClock);
        }
        // prepend the size of the state vector
        const enc = _encoding.createEncoder();
        _encoding.writeVarUint(enc, size);
        _encoding.writeBinaryEncoder(enc, encoder.restEncoder);
        encoder.restEncoder = enc;
        return encoder.toUint8Array();
    } else {
        _encoding.writeVarUint(encoder.restEncoder, 0);
        return encoder.toUint8Array();
    }
};
/**
 * @param {Uint8Array} update
 * @return {Uint8Array}
 */ const encodeStateVectorFromUpdate = (update)=>encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);
/**
 * @param {Uint8Array} update
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2)=>{
    /**
   * @type {Map<number, number>}
   */ const from = new Map();
    /**
   * @type {Map<number, number>}
   */ const to = new Map();
    const updateDecoder = new LazyStructReader(new YDecoder(_decoding.createDecoder(update)), false);
    let curr = updateDecoder.curr;
    if (curr !== null) {
        let currClient = curr.id.client;
        let currClock = curr.id.clock;
        // write the beginning to `from`
        from.set(currClient, currClock);
        for(; curr !== null; curr = updateDecoder.next()){
            if (currClient !== curr.id.client) {
                // We found a new client
                // write the end to `to`
                to.set(currClient, currClock);
                // write the beginning to `from`
                from.set(curr.id.client, curr.id.clock);
                // update currClient
                currClient = curr.id.client;
            }
            currClock = curr.id.clock + curr.length;
        }
        // write the end to `to`
        to.set(currClient, currClock);
    }
    return {
        from,
        to
    };
};
/**
 * @param {Uint8Array} update
 * @return {{ from: Map<number,number>, to: Map<number,number> }}
 */ const parseUpdateMeta = (update)=>parseUpdateMetaV2(update, UpdateDecoderV1);
/**
 * This method is intended to slice any kind of struct and retrieve the right part.
 * It does not handle side-effects, so it should only be used by the lazy-encoder.
 *
 * @param {Item | GC | Skip} left
 * @param {number} diff
 * @return {Item | GC}
 */ const sliceStruct = (left, diff)=>{
    if (left.constructor === GC) {
        const { client, clock } = left.id;
        return new GC(createID(client, clock + diff), left.length - diff);
    } else if (left.constructor === Skip) {
        const { client, clock } = left.id;
        return new Skip(createID(client, clock + diff), left.length - diff);
    } else {
        const leftItem = /** @type {Item} */ left;
        const { client, clock } = leftItem.id;
        return new Item(createID(client, clock + diff), null, createID(client, clock + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    }
};
/**
 *
 * This function works similarly to `readUpdateV2`.
 *
 * @param {Array<Uint8Array>} updates
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 * @return {Uint8Array}
 */ const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    if (updates.length === 1) return updates[0];
    const updateDecoders = updates.map((update)=>new YDecoder(_decoding.createDecoder(update)));
    let lazyStructDecoders = updateDecoders.map((decoder)=>new LazyStructReader(decoder, true));
    /**
   * @todo we don't need offset because we always slice before
   * @type {null | { struct: Item | GC | Skip, offset: number }}
   */ let currWrite = null;
    const updateEncoder = new YEncoder();
    // write structs lazily
    const lazyStructEncoder = new LazyStructWriter(updateEncoder);
    // Note: We need to ensure that all lazyStructDecoders are fully consumed
    // Note: Should merge document updates whenever possible - even from different updates
    // Note: Should handle that some operations cannot be applied yet ()
    while(true){
        // Write higher clients first  sort by clientID & clock and remove decoders without content
        lazyStructDecoders = lazyStructDecoders.filter((dec)=>dec.curr !== null);
        lazyStructDecoders.sort(/** @type {function(any,any):number} */ (dec1, dec2)=>{
            if (dec1.curr.id.client === dec2.curr.id.client) {
                const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
                if (clockDiff === 0) // @todo remove references to skip since the structDecoders must filter Skips.
                return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.
                ;
                else return clockDiff;
            } else return dec2.curr.id.client - dec1.curr.id.client;
        });
        if (lazyStructDecoders.length === 0) break;
        const currDecoder = lazyStructDecoders[0];
        // write from currDecoder until the next operation is from another client or if filler-struct
        // then we need to reorder the decoders and find the next operation to write
        const firstClient = /** @type {Item | GC} */ currDecoder.curr.id.client;
        if (currWrite !== null) {
            let curr = /** @type {Item | GC | null} */ currDecoder.curr;
            let iterated = false;
            // iterate until we find something that we haven't written already
            // remember: first the high client-ids are written
            while(curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client){
                curr = currDecoder.next();
                iterated = true;
            }
            if (curr === null || // current decoder is empty
            curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
            iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length // the above while loop was used and we are potentially missing updates
            ) continue;
            if (firstClient !== currWrite.struct.id.client) {
                writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                currWrite = {
                    struct: curr,
                    offset: 0
                };
                currDecoder.next();
            } else if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
                // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)
                if (currWrite.struct.constructor === Skip) // extend existing skip
                currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
                else {
                    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                    const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
                    /**
             * @type {Skip}
             */ const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
                    currWrite = {
                        struct,
                        offset: 0
                    };
                }
            } else {
                const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
                if (diff > 0) {
                    if (currWrite.struct.constructor === Skip) // prefer to slice Skip because the other struct might contain more information
                    currWrite.struct.length -= diff;
                    else curr = sliceStruct(curr, diff);
                }
                if (!currWrite.struct.mergeWith(/** @type {any} */ curr)) {
                    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                    currWrite = {
                        struct: curr,
                        offset: 0
                    };
                    currDecoder.next();
                }
            }
        } else {
            currWrite = {
                struct: /** @type {Item | GC} */ currDecoder.curr,
                offset: 0
            };
            currDecoder.next();
        }
        for(let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()){
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = {
                struct: next,
                offset: 0
            };
        }
    }
    if (currWrite !== null) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = null;
    }
    finishLazyStructWriting(lazyStructEncoder);
    const dss = updateDecoders.map((decoder)=>readDeleteSet(decoder));
    const ds = mergeDeleteSets(dss);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
 * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
 */ const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2)=>{
    const state = decodeStateVector(sv);
    const encoder = new YEncoder();
    const lazyStructWriter = new LazyStructWriter(encoder);
    const decoder = new YDecoder(_decoding.createDecoder(update));
    const reader = new LazyStructReader(decoder, false);
    while(reader.curr){
        const curr = reader.curr;
        const currClient = curr.id.client;
        const svClock = state.get(currClient) || 0;
        if (reader.curr.constructor === Skip) {
            // the first written struct shouldn't be a skip
            reader.next();
            continue;
        }
        if (curr.id.clock + curr.length > svClock) {
            writeStructToLazyStructWriter(lazyStructWriter, curr, _math.max(svClock - curr.id.clock, 0));
            reader.next();
            while(reader.curr && reader.curr.id.client === currClient){
                writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
                reader.next();
            }
        } else // read until something new comes up
        while(reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock)reader.next();
    }
    finishLazyStructWriting(lazyStructWriter);
    // write ds
    const ds = readDeleteSet(decoder);
    writeDeleteSet(encoder, ds);
    return encoder.toUint8Array();
};
/**
 * @param {Uint8Array} update
 * @param {Uint8Array} sv
 */ const diffUpdate = (update, sv)=>diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {LazyStructWriter} lazyWriter
 */ const flushLazyStructWriter = (lazyWriter)=>{
    if (lazyWriter.written > 0) {
        lazyWriter.clientStructs.push({
            written: lazyWriter.written,
            restEncoder: _encoding.toUint8Array(lazyWriter.encoder.restEncoder)
        });
        lazyWriter.encoder.restEncoder = _encoding.createEncoder();
        lazyWriter.written = 0;
    }
};
/**
 * @param {LazyStructWriter} lazyWriter
 * @param {Item | GC} struct
 * @param {number} offset
 */ const writeStructToLazyStructWriter = (lazyWriter, struct, offset)=>{
    // flush curr if we start another client
    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) flushLazyStructWriter(lazyWriter);
    if (lazyWriter.written === 0) {
        lazyWriter.currClient = struct.id.client;
        // write next client
        lazyWriter.encoder.writeClient(struct.id.client);
        // write startClock
        _encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
    }
    struct.write(lazyWriter.encoder, offset);
    lazyWriter.written++;
};
/**
 * Call this function when we collected all parts and want to
 * put all the parts together. After calling this method,
 * you can continue using the UpdateEncoder.
 *
 * @param {LazyStructWriter} lazyWriter
 */ const finishLazyStructWriting = (lazyWriter)=>{
    flushLazyStructWriter(lazyWriter);
    // this is a fresh encoder because we called flushCurr
    const restEncoder = lazyWriter.encoder.restEncoder;
    /**
   * Now we put all the fragments together.
   * This works similarly to `writeClientsStructs`
   */ // write # states that were updated - i.e. the clients
    _encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length);
    for(let i = 0; i < lazyWriter.clientStructs.length; i++){
        const partStructs = lazyWriter.clientStructs[i];
        /**
     * Works similarly to `writeStructs`
     */ // write # encoded structs
        _encoding.writeVarUint(restEncoder, partStructs.written);
        // write the rest of the fragment
        _encoding.writeUint8Array(restEncoder, partStructs.restEncoder);
    }
};
/**
 * @param {Uint8Array} update
 * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer
 * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder
 * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder
 */ const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder)=>{
    const updateDecoder = new YDecoder(_decoding.createDecoder(update));
    const lazyDecoder = new LazyStructReader(updateDecoder, false);
    const updateEncoder = new YEncoder();
    const lazyWriter = new LazyStructWriter(updateEncoder);
    for(let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next())writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
    finishLazyStructWriting(lazyWriter);
    const ds = readDeleteSet(updateDecoder);
    writeDeleteSet(updateEncoder, ds);
    return updateEncoder.toUint8Array();
};
/**
 * @typedef {Object} ObfuscatorOptions
 * @property {boolean} [ObfuscatorOptions.formatting=true]
 * @property {boolean} [ObfuscatorOptions.subdocs=true]
 * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName
 */ /**
 * @param {ObfuscatorOptions} obfuscator
 */ const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {})=>{
    let i = 0;
    const mapKeyCache = _map.create();
    const nodeNameCache = _map.create();
    const formattingKeyCache = _map.create();
    const formattingValueCache = _map.create();
    formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range
    /**
   * @param {Item|GC|Skip} block
   * @return {Item|GC|Skip}
   */ return (block)=>{
        switch(block.constructor){
            case GC:
            case Skip:
                return block;
            case Item:
                {
                    const item = /** @type {Item} */ block;
                    const content = item.content;
                    switch(content.constructor){
                        case ContentDeleted:
                            break;
                        case ContentType:
                            if (yxml) {
                                const type = /** @type {ContentType} */ content.type;
                                if (type instanceof YXmlElement) type.nodeName = _map.setIfUndefined(nodeNameCache, type.nodeName, ()=>'node-' + i);
                                if (type instanceof YXmlHook) type.hookName = _map.setIfUndefined(nodeNameCache, type.hookName, ()=>'hook-' + i);
                            }
                            break;
                        case ContentAny:
                            {
                                const c = /** @type {ContentAny} */ content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentBinary:
                            {
                                const c = /** @type {ContentBinary} */ content;
                                c.content = new Uint8Array([
                                    i
                                ]);
                                break;
                            }
                        case ContentDoc:
                            {
                                const c = /** @type {ContentDoc} */ content;
                                if (subdocs) {
                                    c.opts = {};
                                    c.doc.guid = i + '';
                                }
                                break;
                            }
                        case ContentEmbed:
                            {
                                const c = /** @type {ContentEmbed} */ content;
                                c.embed = {};
                                break;
                            }
                        case ContentFormat:
                            {
                                const c = /** @type {ContentFormat} */ content;
                                if (formatting) {
                                    c.key = _map.setIfUndefined(formattingKeyCache, c.key, ()=>i + '');
                                    c.value = _map.setIfUndefined(formattingValueCache, c.value, ()=>({
                                            i
                                        }));
                                }
                                break;
                            }
                        case ContentJSON:
                            {
                                const c = /** @type {ContentJSON} */ content;
                                c.arr = c.arr.map(()=>i);
                                break;
                            }
                        case ContentString:
                            {
                                const c = /** @type {ContentString} */ content;
                                c.str = _string.repeat(i % 10 + '', c.str.length);
                                break;
                            }
                        default:
                            // unknown content type
                            _error.unexpectedCase();
                    }
                    if (item.parentSub) item.parentSub = _map.setIfUndefined(mapKeyCache, item.parentSub, ()=>i + '');
                    i++;
                    return block;
                }
            default:
                // unknown block-type
                _error.unexpectedCase();
        }
    };
};
/**
 * This function obfuscates the content of a Yjs update. This is useful to share
 * buggy Yjs documents while significantly limiting the possibility that a
 * developer can on the user. Note that it might still be possible to deduce
 * some information by analyzing the "structure" of the document or by analyzing
 * the typing behavior using the CRDT-related metadata that is still kept fully
 * intact.
 *
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdate = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);
/**
 * @param {Uint8Array} update
 * @param {ObfuscatorOptions} [opts]
 */ const obfuscateUpdateV2 = (update, opts)=>convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV1ToV2 = (update)=>convertUpdateFormat(update, _function.id, UpdateDecoderV1, UpdateEncoderV2);
/**
 * @param {Uint8Array} update
 */ const convertUpdateFormatV2ToV1 = (update)=>convertUpdateFormat(update, _function.id, UpdateDecoderV2, UpdateEncoderV1);
const errorComputeChanges = 'You must not compute changes after the event-handler fired.';
/**
 * @template {AbstractType<any>} T
 * YEvent describes the changes on a YType.
 */ class YEvent {
    /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */ constructor(target, transaction){
        /**
     * The type on which this event was created on.
     * @type {T}
     */ this.target = target;
        /**
     * The current target on which the observe callback is called.
     * @type {AbstractType<any>}
     */ this.currentTarget = target;
        /**
     * The transaction that triggered this event.
     * @type {Transaction}
     */ this.transaction = transaction;
        /**
     * @type {Object|null}
     */ this._changes = null;
        /**
     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
     */ this._keys = null;
        /**
     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}
     */ this._delta = null;
        /**
     * @type {Array<string|number>|null}
     */ this._path = null;
    }
    /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */ get path() {
        return this._path || (this._path = getPathTo(this.currentTarget, this.target));
    }
    /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ deletes(struct) {
        return isDeleted(this.transaction.deleteSet, struct.id);
    }
    /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */ get keys() {
        if (this._keys === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) throw _error.create(errorComputeChanges);
            const keys = new Map();
            const target = this.target;
            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);
            changed.forEach((key)=>{
                if (key !== null) {
                    const item = /** @type {Item} */ target._map.get(key);
                    /**
           * @type {'delete' | 'add' | 'update'}
           */ let action;
                    let oldValue;
                    if (this.adds(item)) {
                        let prev = item.left;
                        while(prev !== null && this.adds(prev))prev = prev.left;
                        if (this.deletes(item)) {
                            if (prev !== null && this.deletes(prev)) {
                                action = 'delete';
                                oldValue = _array.last(prev.content.getContent());
                            } else return;
                        } else if (prev !== null && this.deletes(prev)) {
                            action = 'update';
                            oldValue = _array.last(prev.content.getContent());
                        } else {
                            action = 'add';
                            oldValue = undefined;
                        }
                    } else {
                        if (this.deletes(item)) {
                            action = 'delete';
                            oldValue = _array.last(/** @type {Item} */ item.content.getContent());
                        } else return; // nop
                    }
                    keys.set(key, {
                        action,
                        oldValue
                    });
                }
            });
            this._keys = keys;
        }
        return this._keys;
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */ get delta() {
        return this.changes.delta;
    }
    /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */ adds(struct) {
        return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
    }
    /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        let changes = this._changes;
        if (changes === null) {
            if (this.transaction.doc._transactionCleanups.length === 0) throw _error.create(errorComputeChanges);
            const target = this.target;
            const added = _set.create();
            const deleted = _set.create();
            /**
       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}
       */ const delta = [];
            changes = {
                added,
                deleted,
                delta,
                keys: this.keys
            };
            const changed = /** @type Set<string|null> */ this.transaction.changed.get(target);
            if (changed.has(null)) {
                /**
         * @type {any}
         */ let lastOp = null;
                const packOp = ()=>{
                    if (lastOp) delta.push(lastOp);
                };
                for(let item = target._start; item !== null; item = item.right){
                    if (item.deleted) {
                        if (this.deletes(item) && !this.adds(item)) {
                            if (lastOp === null || lastOp.delete === undefined) {
                                packOp();
                                lastOp = {
                                    delete: 0
                                };
                            }
                            lastOp.delete += item.length;
                            deleted.add(item);
                        } // else nop
                    } else if (this.adds(item)) {
                        if (lastOp === null || lastOp.insert === undefined) {
                            packOp();
                            lastOp = {
                                insert: []
                            };
                        }
                        lastOp.insert = lastOp.insert.concat(item.content.getContent());
                        added.add(item);
                    } else {
                        if (lastOp === null || lastOp.retain === undefined) {
                            packOp();
                            lastOp = {
                                retain: 0
                            };
                        }
                        lastOp.retain += item.length;
                    }
                }
                if (lastOp !== null && lastOp.retain === undefined) packOp();
            }
            this._changes = changes;
        }
        return /** @type {any} */ changes;
    }
}
/**
 * Compute the path from this type to the specified target.
 *
 * @example
 *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`
 *   const path = type.getPathTo(child)
 *   // assuming `type instanceof YArray`
 *   console.log(path) // might look like => [2, 'key1']
 *   child === type.get(path[0]).get(path[1])
 *
 * @param {AbstractType<any>} parent
 * @param {AbstractType<any>} child target
 * @return {Array<string|number>} Path to the target
 *
 * @private
 * @function
 */ const getPathTo = (parent, child)=>{
    const path = [];
    while(child._item !== null && child !== parent){
        if (child._item.parentSub !== null) // parent is map-ish
        path.unshift(child._item.parentSub);
        else {
            // parent is array-ish
            let i = 0;
            let c = /** @type {AbstractType<any>} */ child._item.parent._start;
            while(c !== child._item && c !== null){
                if (!c.deleted && c.countable) i += c.length;
                c = c.right;
            }
            path.unshift(i);
        }
        child = /** @type {AbstractType<any>} */ child._item.parent;
    }
    return path;
};
/**
 * https://docs.yjs.dev/getting-started/working-with-shared-types#caveats
 */ const warnPrematureAccess = ()=>{
    _logging.warn('Invalid access: Add Yjs type to a document before reading data.');
};
const maxSearchMarker = 80;
/**
 * A unique timestamp that identifies each marker.
 *
 * Time is relative,.. this is more like an ever-increasing clock.
 *
 * @type {number}
 */ let globalSearchMarkerTimestamp = 0;
class ArraySearchMarker {
    /**
   * @param {Item} p
   * @param {number} index
   */ constructor(p, index){
        p.marker = true;
        this.p = p;
        this.index = index;
        this.timestamp = globalSearchMarkerTimestamp++;
    }
}
/**
 * @param {ArraySearchMarker} marker
 */ const refreshMarkerTimestamp = (marker)=>{
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * This is rather complex so this function is the only thing that should overwrite a marker
 *
 * @param {ArraySearchMarker} marker
 * @param {Item} p
 * @param {number} index
 */ const overwriteMarker = (marker, p, index)=>{
    marker.p.marker = false;
    marker.p = p;
    p.marker = true;
    marker.index = index;
    marker.timestamp = globalSearchMarkerTimestamp++;
};
/**
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {Item} p
 * @param {number} index
 */ const markPosition = (searchMarker, p, index)=>{
    if (searchMarker.length >= maxSearchMarker) {
        // override oldest marker (we don't want to create more objects)
        const marker = searchMarker.reduce((a, b)=>a.timestamp < b.timestamp ? a : b);
        overwriteMarker(marker, p, index);
        return marker;
    } else {
        // create new marker
        const pm = new ArraySearchMarker(p, index);
        searchMarker.push(pm);
        return pm;
    }
};
/**
 * Search marker help us to find positions in the associative array faster.
 *
 * They speed up the process of finding a position without much bookkeeping.
 *
 * A maximum of `maxSearchMarker` objects are created.
 *
 * This function always returns a refreshed marker (updated timestamp)
 *
 * @param {AbstractType<any>} yarray
 * @param {number} index
 */ const findMarker = (yarray, index)=>{
    if (yarray._start === null || index === 0 || yarray._searchMarker === null) return null;
    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b)=>_math.abs(index - a.index) < _math.abs(index - b.index) ? a : b);
    let p = yarray._start;
    let pindex = 0;
    if (marker !== null) {
        p = marker.p;
        pindex = marker.index;
        refreshMarkerTimestamp(marker); // we used it, we might need to use it again
    }
    // iterate to right if possible
    while(p.right !== null && pindex < index){
        if (!p.deleted && p.countable) {
            if (index < pindex + p.length) break;
            pindex += p.length;
        }
        p = p.right;
    }
    // iterate to left if necessary (might be that pindex > index)
    while(p.left !== null && pindex > index){
        p = p.left;
        if (!p.deleted && p.countable) pindex -= p.length;
    }
    // we want to make sure that p can't be merged with left, because that would screw up everything
    // in that cas just return what we have (it is most likely the best marker anyway)
    // iterate to left until p can't be merged with left
    while(p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock){
        p = p.left;
        if (!p.deleted && p.countable) pindex -= p.length;
    }
    // @todo remove!
    // assure position
    // {
    //   let start = yarray._start
    //   let pos = 0
    //   while (start !== p) {
    //     if (!start.deleted && start.countable) {
    //       pos += start.length
    //     }
    //     start = /** @type {Item} */ (start.right)
    //   }
    //   if (pos !== pindex) {
    //     debugger
    //     throw new Error('Gotcha position fail!')
    //   }
    // }
    // if (marker) {
    //   if (window.lengthes == null) {
    //     window.lengthes = []
    //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)
    //   }
    //   window.lengthes.push(marker.index - pindex)
    //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)
    // }
    if (marker !== null && _math.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ p.parent.length / maxSearchMarker) {
        // adjust existing marker
        overwriteMarker(marker, p, pindex);
        return marker;
    } else // create new marker
    return markPosition(yarray._searchMarker, p, pindex);
};
/**
 * Update markers when a change happened.
 *
 * This should be called before doing a deletion!
 *
 * @param {Array<ArraySearchMarker>} searchMarker
 * @param {number} index
 * @param {number} len If insertion, len is positive. If deletion, len is negative.
 */ const updateMarkerChanges = (searchMarker, index, len)=>{
    for(let i = searchMarker.length - 1; i >= 0; i--){
        const m = searchMarker[i];
        if (len > 0) {
            /**
       * @type {Item|null}
       */ let p = m.p;
            p.marker = false;
            // Ideally we just want to do a simple position comparison, but this will only work if
            // search markers don't point to deleted items for formats.
            // Iterate marker to prev undeleted countable position so we know what to do when updating a position
            while(p && (p.deleted || !p.countable)){
                p = p.left;
                if (p && !p.deleted && p.countable) // adjust position. the loop should break now
                m.index -= p.length;
            }
            if (p === null || p.marker === true) {
                // remove search marker if updated position is null or if position is already marked
                searchMarker.splice(i, 1);
                continue;
            }
            m.p = p;
            p.marker = true;
        }
        if (index < m.index || len > 0 && index === m.index) m.index = _math.max(index, m.index + len);
    }
};
/**
 * Accumulate all (list) children of a type and return them as an Array.
 *
 * @param {AbstractType<any>} t
 * @return {Array<Item>}
 */ const getTypeChildren = (t)=>{
    t.doc ?? warnPrematureAccess();
    let s = t._start;
    const arr = [];
    while(s){
        arr.push(s);
        s = s.right;
    }
    return arr;
};
/**
 * Call event listeners with an event. This will also add an event to all
 * parents (for `.observeDeep` handlers).
 *
 * @template EventType
 * @param {AbstractType<EventType>} type
 * @param {Transaction} transaction
 * @param {EventType} event
 */ const callTypeObservers = (type, transaction, event)=>{
    const changedType = type;
    const changedParentTypes = transaction.changedParentTypes;
    while(true){
        // @ts-ignore
        _map.setIfUndefined(changedParentTypes, type, ()=>[]).push(event);
        if (type._item === null) break;
        type = /** @type {AbstractType<any>} */ type._item.parent;
    }
    callEventHandlerListeners(changedType._eH, event, transaction);
};
/**
 * @template EventType
 * Abstract Yjs Type class
 */ class AbstractType {
    constructor(){
        /**
     * @type {Item|null}
     */ this._item = null;
        /**
     * @type {Map<string,Item>}
     */ this._map = new Map();
        /**
     * @type {Item|null}
     */ this._start = null;
        /**
     * @type {Doc|null}
     */ this.doc = null;
        this._length = 0;
        /**
     * Event handlers
     * @type {EventHandler<EventType,Transaction>}
     */ this._eH = createEventHandler();
        /**
     * Deep event handlers
     * @type {EventHandler<Array<YEvent<any>>,Transaction>}
     */ this._dEH = createEventHandler();
        /**
     * @type {null | Array<ArraySearchMarker>}
     */ this._searchMarker = null;
    }
    /**
   * @return {AbstractType<any>|null}
   */ get parent() {
        return this._item ? /** @type {AbstractType<any>} */ this._item.parent : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */ _integrate(y, item) {
        this.doc = y;
        this._item = item;
    }
    /**
   * @return {AbstractType<EventType>}
   */ _copy() {
        throw _error.methodUnimplemented();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */ clone() {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */ _write(_encoder) {}
    /**
   * The first non-deleted item
   */ get _first() {
        let n = this._start;
        while(n !== null && n.deleted)n = n.right;
        return n;
    }
    /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, _parentSubs) {
        if (!transaction.local && this._searchMarker) this._searchMarker.length = 0;
    }
    /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */ observe(f) {
        addEventHandlerListener(this._eH, f);
    }
    /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ observeDeep(f) {
        addEventHandlerListener(this._dEH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */ unobserve(f) {
        removeEventHandlerListener(this._eH, f);
    }
    /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */ unobserveDeep(f) {
        removeEventHandlerListener(this._dEH, f);
    }
    /**
   * @abstract
   * @return {any}
   */ toJSON() {}
}
/**
 * @param {AbstractType<any>} type
 * @param {number} start
 * @param {number} end
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListSlice = (type, start, end)=>{
    type.doc ?? warnPrematureAccess();
    if (start < 0) start = type._length + start;
    if (end < 0) end = type._length + end;
    let len = end - start;
    const cs = [];
    let n = type._start;
    while(n !== null && len > 0){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            if (c.length <= start) start -= c.length;
            else {
                for(let i = start; i < c.length && len > 0; i++){
                    cs.push(c[i]);
                    len--;
                }
                start = 0;
            }
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArray = (type)=>{
    type.doc ?? warnPrematureAccess();
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)cs.push(c[i]);
        }
        n = n.right;
    }
    return cs;
};
/**
 * @param {AbstractType<any>} type
 * @param {Snapshot} snapshot
 * @return {Array<any>}
 *
 * @private
 * @function
 */ const typeListToArraySnapshot = (type, snapshot)=>{
    const cs = [];
    let n = type._start;
    while(n !== null){
        if (n.countable && isVisible(n, snapshot)) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)cs.push(c[i]);
        }
        n = n.right;
    }
    return cs;
};
/**
 * Executes a provided function on once on every element of this YArray.
 *
 * @param {AbstractType<any>} type
 * @param {function(any,number,any):void} f A function to execute on every element of this YArray.
 *
 * @private
 * @function
 */ const typeListForEach = (type, f)=>{
    let index = 0;
    let n = type._start;
    type.doc ?? warnPrematureAccess();
    while(n !== null){
        if (n.countable && !n.deleted) {
            const c = n.content.getContent();
            for(let i = 0; i < c.length; i++)f(c[i], index++, type);
        }
        n = n.right;
    }
};
/**
 * @template C,R
 * @param {AbstractType<any>} type
 * @param {function(C,number,AbstractType<any>):R} f
 * @return {Array<R>}
 *
 * @private
 * @function
 */ const typeListMap = (type, f)=>{
    /**
   * @type {Array<any>}
   */ const result = [];
    typeListForEach(type, (c, i)=>{
        result.push(f(c, i, type));
    });
    return result;
};
/**
 * @param {AbstractType<any>} type
 * @return {IterableIterator<any>}
 *
 * @private
 * @function
 */ const typeListCreateIterator = (type)=>{
    let n = type._start;
    /**
   * @type {Array<any>|null}
   */ let currentContent = null;
    let currentContentIndex = 0;
    return {
        [Symbol.iterator] () {
            return this;
        },
        next: ()=>{
            // find some content
            if (currentContent === null) {
                while(n !== null && n.deleted)n = n.right;
                // check if we reached the end, no need to check currentContent, because it does not exist
                if (n === null) return {
                    done: true,
                    value: undefined
                };
                // we found n, so we can set currentContent
                currentContent = n.content.getContent();
                currentContentIndex = 0;
                n = n.right; // we used the content of n, now iterate to next
            }
            const value = currentContent[currentContentIndex++];
            // check if we need to empty currentContent
            if (currentContent.length <= currentContentIndex) currentContent = null;
            return {
                done: false,
                value
            };
        }
    };
};
/**
 * @param {AbstractType<any>} type
 * @param {number} index
 * @return {any}
 *
 * @private
 * @function
 */ const typeListGet = (type, index)=>{
    type.doc ?? warnPrematureAccess();
    const marker = findMarker(type, index);
    let n = type._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    for(; n !== null; n = n.right)if (!n.deleted && n.countable) {
        if (index < n.length) return n.content.getContent()[index];
        index -= n.length;
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Item?} referenceItem
 * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content)=>{
    let left = referenceItem;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const store = doc.store;
    const right = referenceItem === null ? parent._start : referenceItem.right;
    /**
   * @type {Array<Object|Array<any>|number|null>}
   */ let jsonContent = [];
    const packJsonContent = ()=>{
        if (jsonContent.length > 0) {
            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
            left.integrate(transaction, 0);
            jsonContent = [];
        }
    };
    content.forEach((c)=>{
        if (c === null) jsonContent.push(c);
        else switch(c.constructor){
            case Number:
            case Object:
            case Boolean:
            case Array:
            case String:
                jsonContent.push(c);
                break;
            default:
                packJsonContent();
                switch(c.constructor){
                    case Uint8Array:
                    case ArrayBuffer:
                        left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ c)));
                        left.integrate(transaction, 0);
                        break;
                    case Doc:
                        left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ c));
                        left.integrate(transaction, 0);
                        break;
                    default:
                        if (c instanceof AbstractType) {
                            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                            left.integrate(transaction, 0);
                        } else throw new Error('Unexpected content type in insert operation');
                }
        }
    });
    packJsonContent();
};
const lengthExceeded = ()=>_error.create('Length exceeded!');
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListInsertGenerics = (transaction, parent, index, content)=>{
    if (index > parent._length) throw lengthExceeded();
    if (index === 0) {
        if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, index, content.length);
        return typeListInsertGenericsAfter(transaction, parent, null, content);
    }
    const startIndex = index;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
        // we need to iterate one to the left so that the algorithm works
        if (index === 0) {
            // @todo refactor this as it actually doesn't consider formats
            n = n.prev; // important! get the left undeleted item so that we can actually decrease index
            index += n && n.countable && !n.deleted ? n.length : 0;
        }
    }
    for(; n !== null; n = n.right)if (!n.deleted && n.countable) {
        if (index <= n.length) {
            if (index < n.length) // insert in-between
            getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
            break;
        }
        index -= n.length;
    }
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, startIndex, content.length);
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * Pushing content is special as we generally want to push after the last item. So we don't have to update
 * the serach marker.
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
 *
 * @private
 * @function
 */ const typeListPushGenerics = (transaction, parent, content)=>{
    // Use the marker with the highest index and iterate to the right.
    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker)=>currMarker.index > maxMarker.index ? currMarker : maxMarker, {
        index: 0,
        p: parent._start
    });
    let n = marker.p;
    if (n) while(n.right)n = n.right;
    return typeListInsertGenericsAfter(transaction, parent, n, content);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {number} length
 *
 * @private
 * @function
 */ const typeListDelete = (transaction, parent, index, length)=>{
    if (length === 0) return;
    const startIndex = index;
    const startLength = length;
    const marker = findMarker(parent, index);
    let n = parent._start;
    if (marker !== null) {
        n = marker.p;
        index -= marker.index;
    }
    // compute the first item to be deleted
    for(; n !== null && index > 0; n = n.right)if (!n.deleted && n.countable) {
        if (index < n.length) getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        index -= n.length;
    }
    // delete all items until done
    while(length > 0 && n !== null){
        if (!n.deleted) {
            if (length < n.length) getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));
            n.delete(transaction);
            length -= n.length;
        }
        n = n.right;
    }
    if (length > 0) throw lengthExceeded();
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */ );
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 *
 * @private
 * @function
 */ const typeMapDelete = (transaction, parent, key)=>{
    const c = parent._map.get(key);
    if (c !== undefined) c.delete(transaction);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value
 *
 * @private
 * @function
 */ const typeMapSet = (transaction, parent, key, value)=>{
    const left = parent._map.get(key) || null;
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    let content;
    if (value == null) content = new ContentAny([
        value
    ]);
    else switch(value.constructor){
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
            content = new ContentAny([
                value
            ]);
            break;
        case Uint8Array:
            content = new ContentBinary(/** @type {Uint8Array} */ value);
            break;
        case Doc:
            content = new ContentDoc(/** @type {Doc} */ value);
            break;
        default:
            if (value instanceof AbstractType) content = new ContentType(value);
            else throw new Error('Unexpected content type');
    }
    new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGet = (parent, key)=>{
    parent.doc ?? warnPrematureAccess();
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;
};
/**
 * @param {AbstractType<any>} parent
 * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
 *
 * @private
 * @function
 */ const typeMapGetAll = (parent)=>{
    /**
   * @type {Object<string,any>}
   */ const res = {};
    parent.doc ?? warnPrematureAccess();
    parent._map.forEach((value, key)=>{
        if (!value.deleted) res[key] = value.content.getContent()[value.length - 1];
    });
    return res;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @return {boolean}
 *
 * @private
 * @function
 */ const typeMapHas = (parent, key)=>{
    parent.doc ?? warnPrematureAccess();
    const val = parent._map.get(key);
    return val !== undefined && !val.deleted;
};
/**
 * @param {AbstractType<any>} parent
 * @param {string} key
 * @param {Snapshot} snapshot
 * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
 *
 * @private
 * @function
 */ const typeMapGetSnapshot = (parent, key, snapshot)=>{
    let v = parent._map.get(key) || null;
    while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0)))v = v.left;
    return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined;
};
/**
 * @param {AbstractType<any>} parent
 * @param {Snapshot} snapshot
 * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
 *
 * @private
 * @function
 */ const typeMapGetAllSnapshot = (parent, snapshot)=>{
    /**
   * @type {Object<string,any>}
   */ const res = {};
    parent._map.forEach((value, key)=>{
        /**
     * @type {Item|null}
     */ let v = value;
        while(v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0)))v = v.left;
        if (v !== null && isVisible(v, snapshot)) res[key] = v.content.getContent()[v.length - 1];
    });
    return res;
};
/**
 * @param {AbstractType<any> & { _map: Map<string, Item> }} type
 * @return {IterableIterator<Array<any>>}
 *
 * @private
 * @function
 */ const createMapIterator = (type)=>{
    type.doc ?? warnPrematureAccess();
    return _iterator.iteratorFilter(type._map.entries(), /** @param {any} entry */ (entry)=>!entry[1].deleted);
};
/**
 * @module YArray
 */ /**
 * Event that describes the changes on a YArray
 * @template T
 * @extends YEvent<YArray<T>>
 */ class YArrayEvent extends YEvent {
}
/**
 * A shared Array implementation.
 * @template T
 * @extends AbstractType<YArrayEvent<T>>
 * @implements {Iterable<T>}
 */ class YArray extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>?}
     * @private
     */ this._prelimContent = [];
        /**
     * @type {Array<ArraySearchMarker>}
     */ this._searchMarker = [];
    }
    /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */ static from(items) {
        /**
     * @type {YArray<T>}
     */ const a = new YArray();
        a.push(items);
        return a;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, /** @type {Array<any>} */ this._prelimContent);
        this._prelimContent = null;
    }
    /**
   * @return {YArray<T>}
   */ _copy() {
        return new YArray();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */ clone() {
        /**
     * @type {YArray<T>}
     */ const arr = new YArray();
        arr.insert(0, this.toArray().map((el)=>el instanceof AbstractType ? /** @type {typeof el} */ el.clone() : el));
        return arr;
    }
    get length() {
        this.doc ?? warnPrematureAccess();
        return this._length;
    }
    /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
    }
    /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListInsertGenerics(transaction, this, index, /** @type {any} */ content);
        });
        else /** @type {Array<any>} */ this._prelimContent.splice(index, 0, ...content);
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */ push(content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListPushGenerics(transaction, this, /** @type {any} */ content);
        });
        else /** @type {Array<any>} */ this._prelimContent.push(...content);
    }
    /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListDelete(transaction, this, index, length);
        });
        else /** @type {Array<any>} */ this._prelimContent.splice(index, length);
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */ toJSON() {
        return this.map((c)=>c instanceof AbstractType ? c.toJSON() : c);
    }
    /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */ map(f) {
        return typeListMap(this, /** @type {any} */ f);
    }
    /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator]() {
        return typeListCreateIterator(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YArrayRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYArray = (_decoder)=>new YArray();
/**
 * @module YMap
 */ /**
 * @template T
 * @extends YEvent<YMap<T>>
 * Event that describes the changes on a YMap.
 */ class YMapEvent extends YEvent {
    /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */ constructor(ymap, transaction, subs){
        super(ymap, transaction);
        this.keysChanged = subs;
    }
}
/**
 * @template MapType
 * A shared Map implementation.
 *
 * @extends AbstractType<YMapEvent<MapType>>
 * @implements {Iterable<[string, MapType]>}
 */ class YMap extends AbstractType {
    /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */ constructor(entries){
        super();
        /**
     * @type {Map<string,any>?}
     * @private
     */ this._prelimContent = null;
        if (entries === undefined) this._prelimContent = new Map();
        else this._prelimContent = new Map(entries);
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item); /** @type {Map<string, any>} */ 
        this._prelimContent.forEach((value, key)=>{
            this.set(key, value);
        });
        this._prelimContent = null;
    }
    /**
   * @return {YMap<MapType>}
   */ _copy() {
        return new YMap();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */ clone() {
        /**
     * @type {YMap<MapType>}
     */ const map = new YMap();
        this.forEach((value, key)=>{
            map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ value.clone() : value);
        });
        return map;
    }
    /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
    }
    /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */ toJSON() {
        this.doc ?? warnPrematureAccess();
        /**
     * @type {Object<string,MapType>}
     */ const map = {};
        this._map.forEach((item, key)=>{
            if (!item.deleted) {
                const v = item.content.getContent()[item.length - 1];
                map[key] = v instanceof AbstractType ? v.toJSON() : v;
            }
        });
        return map;
    }
    /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */ get size() {
        return [
            ...createMapIterator(this)
        ].length;
    }
    /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */ keys() {
        return _iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ (v)=>v[0]);
    }
    /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */ values() {
        return _iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ (v)=>v[1].content.getContent()[v[1].length - 1]);
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */ entries() {
        return _iterator.iteratorMap(createMapIterator(this), /** @param {any} v */ (v)=>/** @type {any} */ [
                v[0],
                v[1].content.getContent()[v[1].length - 1]
            ]);
    }
    /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        this.doc ?? warnPrematureAccess();
        this._map.forEach((item, key)=>{
            if (!item.deleted) f(item.content.getContent()[item.length - 1], key, this);
        });
    }
    /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */ [Symbol.iterator]() {
        return this.entries();
    }
    /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */ delete(key) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, key);
        });
        else /** @type {Map<string, any>} */ this._prelimContent.delete(key);
    }
    /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */ set(key, value) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, key, /** @type {any} */ value);
        });
        else /** @type {Map<string, any>} */ this._prelimContent.set(key, value);
        return value;
    }
    /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */ get(key) {
        return /** @type {any} */ typeMapGet(this, key);
    }
    /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */ has(key) {
        return typeMapHas(this, key);
    }
    /**
   * Removes all elements from this YMap.
   */ clear() {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            this.forEach(function(_value, key, map) {
                typeMapDelete(transaction, map, key);
            });
        });
        else /** @type {Map<string, any>} */ this._prelimContent.clear();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YMapRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 *
 * @private
 * @function
 */ const readYMap = (_decoder)=>new YMap();
/**
 * @module YText
 */ /**
 * @param {any} a
 * @param {any} b
 * @return {boolean}
 */ const equalAttrs = (a, b)=>a === b || typeof a === 'object' && typeof b === 'object' && a && b && _object.equalFlat(a, b);
class ItemTextListPosition {
    /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */ constructor(left, right, index, currentAttributes){
        this.left = left;
        this.right = right;
        this.index = index;
        this.currentAttributes = currentAttributes;
    }
    /**
   * Only call this if you know that this.right is defined
   */ forward() {
        if (this.right === null) _error.unexpectedCase();
        switch(this.right.content.constructor){
            case ContentFormat:
                if (!this.right.deleted) updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ this.right.content);
                break;
            default:
                if (!this.right.deleted) this.index += this.right.length;
                break;
        }
        this.left = this.right;
        this.right = this.right.right;
    }
}
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} pos
 * @param {number} count steps to move forward
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findNextPosition = (transaction, pos, count)=>{
    while(pos.right !== null && count > 0){
        switch(pos.right.content.constructor){
            case ContentFormat:
                if (!pos.right.deleted) updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ pos.right.content);
                break;
            default:
                if (!pos.right.deleted) {
                    if (count < pos.right.length) // split right
                    getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));
                    pos.index += pos.right.length;
                    count -= pos.right.length;
                }
                break;
        }
        pos.left = pos.right;
        pos.right = pos.right.right;
    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above
    }
    return pos;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {number} index
 * @param {boolean} useSearchMarker
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const findPosition = (transaction, parent, index, useSearchMarker)=>{
    const currentAttributes = new Map();
    const marker = useSearchMarker ? findMarker(parent, index) : null;
    if (marker) {
        const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
        return findNextPosition(transaction, pos, index - marker.index);
    } else {
        const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
        return findNextPosition(transaction, pos, index);
    }
};
/**
 * Negate applied formats
 *
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Map<string,any>} negatedAttributes
 *
 * @private
 * @function
 */ const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes)=>{
    // check if we really need to remove attributes
    while(currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ currPos.right.content.key), /** @type {ContentFormat} */ currPos.right.content.value))){
        if (!currPos.right.deleted) negatedAttributes.delete(/** @type {ContentFormat} */ currPos.right.content.key);
        currPos.forward();
    }
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    negatedAttributes.forEach((val, key)=>{
        const left = currPos.left;
        const right = currPos.right;
        const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
        nextFormat.integrate(transaction, 0);
        currPos.right = nextFormat;
        currPos.forward();
    });
};
/**
 * @param {Map<string,any>} currentAttributes
 * @param {ContentFormat} format
 *
 * @private
 * @function
 */ const updateCurrentAttributes = (currentAttributes, format)=>{
    const { key, value } = format;
    if (value === null) currentAttributes.delete(key);
    else currentAttributes.set(key, value);
};
/**
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const minimizeAttributeChanges = (currPos, attributes)=>{
    // go right while attributes[right.key] === right.value (or right is deleted)
    while(true){
        if (currPos.right === null) break;
        else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[/** @type {ContentFormat} */ currPos.right.content.key] ?? null, /** @type {ContentFormat} */ currPos.right.content.value)) ;
        else break;
        currPos.forward();
    }
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {Object<string,any>} attributes
 * @return {Map<string,any>}
 *
 * @private
 * @function
 **/ const insertAttributes = (transaction, parent, currPos, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    const negatedAttributes = new Map();
    // insert format-start items
    for(const key in attributes){
        const val = attributes[key];
        const currentVal = currPos.currentAttributes.get(key) ?? null;
        if (!equalAttrs(currentVal, val)) {
            // save negated attribute (set null if currentVal undefined)
            negatedAttributes.set(key, currentVal);
            const { left, right } = currPos;
            currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
            currPos.right.integrate(transaction, 0);
            currPos.forward();
        }
    }
    return negatedAttributes;
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {string|object|AbstractType<any>} text
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 **/ const insertText = (transaction, parent, currPos, text, attributes)=>{
    currPos.currentAttributes.forEach((_val, key)=>{
        if (attributes[key] === undefined) attributes[key] = null;
    });
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // insert content
    const content = text.constructor === String ? new ContentString(/** @type {string} */ text) : text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text);
    let { left, right, index } = currPos;
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
    right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
    right.integrate(transaction, 0);
    currPos.right = right;
    currPos.index = index;
    currPos.forward();
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * @param {Transaction} transaction
 * @param {AbstractType<any>} parent
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @param {Object<string,any>} attributes
 *
 * @private
 * @function
 */ const formatText = (transaction, parent, currPos, length, attributes)=>{
    const doc = transaction.doc;
    const ownClientId = doc.clientID;
    minimizeAttributeChanges(currPos, attributes);
    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
    // iterate until first non-format or null is found
    // delete all formats with attributes[format.key] != null
    // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there
    // eslint-disable-next-line no-labels
    iterationLoop: while(currPos.right !== null && (length > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))){
        if (!currPos.right.deleted) switch(currPos.right.content.constructor){
            case ContentFormat:
                {
                    const { key, value } = /** @type {ContentFormat} */ currPos.right.content;
                    const attr = attributes[key];
                    if (attr !== undefined) {
                        if (equalAttrs(attr, value)) negatedAttributes.delete(key);
                        else {
                            if (length === 0) break iterationLoop;
                            negatedAttributes.set(key, value);
                        }
                        currPos.right.delete(transaction);
                    } else currPos.currentAttributes.set(key, value);
                    break;
                }
            default:
                if (length < currPos.right.length) getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                length -= currPos.right.length;
                break;
        }
        currPos.forward();
    }
    // Quill just assumes that the editor starts with a newline and that it always
    // ends with a newline. We only insert that newline when a new newline is
    // inserted - i.e when length is bigger than type.length
    if (length > 0) {
        let newlines = '';
        for(; length > 0; length--)newlines += '\n';
        currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
        currPos.right.integrate(transaction, 0);
        currPos.forward();
    }
    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
/**
 * Call this function after string content has been deleted in order to
 * clean up formatting Items.
 *
 * @param {Transaction} transaction
 * @param {Item} start
 * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item
 * @param {Map<string,any>} startAttributes
 * @param {Map<string,any>} currAttributes
 * @return {number} The amount of formatting Items deleted.
 *
 * @function
 */ const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes)=>{
    /**
   * @type {Item|null}
   */ let end = start;
    /**
   * @type {Map<string,ContentFormat>}
   */ const endFormats = _map.create();
    while(end && (!end.countable || end.deleted)){
        if (!end.deleted && end.content.constructor === ContentFormat) {
            const cf = /** @type {ContentFormat} */ end.content;
            endFormats.set(cf.key, cf);
        }
        end = end.right;
    }
    let cleanups = 0;
    let reachedCurr = false;
    while(start !== end){
        if (curr === start) reachedCurr = true;
        if (!start.deleted) {
            const content = start.content;
            switch(content.constructor){
                case ContentFormat:
                    {
                        const { key, value } = /** @type {ContentFormat} */ content;
                        const startAttrValue = startAttributes.get(key) ?? null;
                        if (endFormats.get(key) !== content || startAttrValue === value) {
                            // Either this format is overwritten or it is not necessary because the attribute already existed.
                            start.delete(transaction);
                            cleanups++;
                            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {
                                if (startAttrValue === null) currAttributes.delete(key);
                                else currAttributes.set(key, startAttrValue);
                            }
                        }
                        if (!reachedCurr && !start.deleted) updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ content);
                        break;
                    }
            }
        }
        start = /** @type {Item} */ start.right;
    }
    return cleanups;
};
/**
 * @param {Transaction} transaction
 * @param {Item | null} item
 */ const cleanupContextlessFormattingGap = (transaction, item)=>{
    // iterate until item.right is null or content
    while(item && item.right && (item.right.deleted || !item.right.countable))item = item.right;
    const attrs = new Set();
    // iterate back until a content item is found
    while(item && (item.deleted || !item.countable)){
        if (!item.deleted && item.content.constructor === ContentFormat) {
            const key = /** @type {ContentFormat} */ item.content.key;
            if (attrs.has(key)) item.delete(transaction);
            else attrs.add(key);
        }
        item = item.left;
    }
};
/**
 * This function is experimental and subject to change / be removed.
 *
 * Ideally, we don't need this function at all. Formatting attributes should be cleaned up
 * automatically after each change. This function iterates twice over the complete YText type
 * and removes unnecessary formatting attributes. This is also helpful for testing.
 *
 * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.
 *
 * @param {YText} type
 * @return {number} How many formatting attributes have been cleaned up.
 */ const cleanupYTextFormatting = (type)=>{
    let res = 0;
    transact(/** @type {Doc} */ type.doc, (transaction)=>{
        let start = /** @type {Item} */ type._start;
        let end = type._start;
        let startAttributes = _map.create();
        const currentAttributes = _map.copy(startAttributes);
        while(end){
            if (end.deleted === false) switch(end.content.constructor){
                case ContentFormat:
                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ end.content);
                    break;
                default:
                    res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
                    startAttributes = _map.copy(currentAttributes);
                    start = end;
                    break;
            }
            end = end.right;
        }
    });
    return res;
};
/**
 * This will be called by the transction once the event handlers are called to potentially cleanup
 * formatting attributes.
 *
 * @param {Transaction} transaction
 */ const cleanupYTextAfterTransaction = (transaction)=>{
    /**
   * @type {Set<YText>}
   */ const needFullCleanup = new Set();
    // check if another formatting item was inserted
    const doc = transaction.doc;
    for (const [client, afterClock] of transaction.afterState.entries()){
        const clock = transaction.beforeState.get(client) || 0;
        if (afterClock === clock) continue;
        iterateStructs(transaction, /** @type {Array<Item|GC>} */ doc.store.clients.get(client), clock, afterClock, (item)=>{
            if (!item.deleted && /** @type {Item} */ item.content.constructor === ContentFormat && item.constructor !== GC) needFullCleanup.add(/** @type {any} */ item.parent);
        });
    }
    // cleanup in a new transaction
    transact(doc, (t)=>{
        iterateDeletedStructs(transaction, transaction.deleteSet, (item)=>{
            if (item instanceof GC || !/** @type {YText} */ item.parent._hasFormatting || needFullCleanup.has(/** @type {YText} */ item.parent)) return;
            const parent = /** @type {YText} */ item.parent;
            if (item.content.constructor === ContentFormat) needFullCleanup.add(parent);
            else // If no formatting attribute was inserted or deleted, we can make due with contextless
            // formatting cleanups.
            // Contextless: it is not necessary to compute currentAttributes for the affected position.
            cleanupContextlessFormattingGap(t, item);
        });
        // If a formatting item was inserted, we simply clean the whole type.
        // We need to compute currentAttributes for the current position anyway.
        for (const yText of needFullCleanup)cleanupYTextFormatting(yText);
    });
};
/**
 * @param {Transaction} transaction
 * @param {ItemTextListPosition} currPos
 * @param {number} length
 * @return {ItemTextListPosition}
 *
 * @private
 * @function
 */ const deleteText = (transaction, currPos, length)=>{
    const startLength = length;
    const startAttrs = _map.copy(currPos.currentAttributes);
    const start = currPos.right;
    while(length > 0 && currPos.right !== null){
        if (currPos.right.deleted === false) switch(currPos.right.content.constructor){
            case ContentType:
            case ContentEmbed:
            case ContentString:
                if (length < currPos.right.length) getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));
                length -= currPos.right.length;
                currPos.right.delete(transaction);
                break;
        }
        currPos.forward();
    }
    if (start) cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
    const parent = /** @type {AbstractType<any>} */ /** @type {Item} */ (currPos.left || currPos.right).parent;
    if (parent._searchMarker) updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);
    return currPos;
};
/**
 * The Quill Delta format represents changes on a text document with
 * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
 *
 * @example
 *   {
 *     ops: [
 *       { insert: 'Gandalf', attributes: { bold: true } },
 *       { insert: ' the ' },
 *       { insert: 'Grey', attributes: { color: '#cccccc' } }
 *     ]
 *   }
 *
 */ /**
  * Attributes that can be assigned to a selection of text.
  *
  * @example
  *   {
  *     bold: true,
  *     font-size: '40px'
  *   }
  *
  * @typedef {Object} TextAttributes
  */ /**
 * @extends YEvent<YText>
 * Event that describes the changes on a YText type.
 */ class YTextEvent extends YEvent {
    /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */ constructor(ytext, transaction, subs){
        super(ytext, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.keysChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) this.childListChanged = true;
            else this.keysChanged.add(sub);
        });
    }
    /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */ get changes() {
        if (this._changes === null) {
            /**
       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}
       */ const changes = {
                keys: this.keys,
                delta: this.delta,
                added: new Set(),
                deleted: new Set()
            };
            this._changes = changes;
        }
        return /** @type {any} */ this._changes;
    }
    /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */ get delta() {
        if (this._delta === null) {
            const y = /** @type {Doc} */ this.target.doc;
            /**
       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
       */ const delta = [];
            transact(y, (transaction)=>{
                const currentAttributes = new Map(); // saves all current attributes for insert
                const oldAttributes = new Map();
                let item = this.target._start;
                /**
         * @type {string?}
         */ let action = null;
                /**
         * @type {Object<string,any>}
         */ const attributes = {}; // counts added or removed new attributes for retain
                /**
         * @type {string|object}
         */ let insert = '';
                let retain = 0;
                let deleteLen = 0;
                const addOp = ()=>{
                    if (action !== null) {
                        /**
             * @type {any}
             */ let op = null;
                        switch(action){
                            case 'delete':
                                if (deleteLen > 0) op = {
                                    delete: deleteLen
                                };
                                deleteLen = 0;
                                break;
                            case 'insert':
                                if (typeof insert === 'object' || insert.length > 0) {
                                    op = {
                                        insert
                                    };
                                    if (currentAttributes.size > 0) {
                                        op.attributes = {};
                                        currentAttributes.forEach((value, key)=>{
                                            if (value !== null) op.attributes[key] = value;
                                        });
                                    }
                                }
                                insert = '';
                                break;
                            case 'retain':
                                if (retain > 0) {
                                    op = {
                                        retain
                                    };
                                    if (!_object.isEmpty(attributes)) op.attributes = _object.assign({}, attributes);
                                }
                                retain = 0;
                                break;
                        }
                        if (op) delta.push(op);
                        action = null;
                    }
                };
                while(item !== null){
                    switch(item.content.constructor){
                        case ContentType:
                        case ContentEmbed:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    addOp();
                                    action = 'insert';
                                    insert = item.content.getContent()[0];
                                    addOp();
                                }
                            } else if (this.deletes(item)) {
                                if (action !== 'delete') {
                                    addOp();
                                    action = 'delete';
                                }
                                deleteLen += 1;
                            } else if (!item.deleted) {
                                if (action !== 'retain') {
                                    addOp();
                                    action = 'retain';
                                }
                                retain += 1;
                            }
                            break;
                        case ContentString:
                            if (this.adds(item)) {
                                if (!this.deletes(item)) {
                                    if (action !== 'insert') {
                                        addOp();
                                        action = 'insert';
                                    }
                                    insert += /** @type {ContentString} */ item.content.str;
                                }
                            } else if (this.deletes(item)) {
                                if (action !== 'delete') {
                                    addOp();
                                    action = 'delete';
                                }
                                deleteLen += item.length;
                            } else if (!item.deleted) {
                                if (action !== 'retain') {
                                    addOp();
                                    action = 'retain';
                                }
                                retain += item.length;
                            }
                            break;
                        case ContentFormat:
                            {
                                const { key, value } = /** @type {ContentFormat} */ item.content;
                                if (this.adds(item)) {
                                    if (!this.deletes(item)) {
                                        const curVal = currentAttributes.get(key) ?? null;
                                        if (!equalAttrs(curVal, value)) {
                                            if (action === 'retain') addOp();
                                            if (equalAttrs(value, oldAttributes.get(key) ?? null)) delete attributes[key];
                                            else attributes[key] = value;
                                        } else if (value !== null) item.delete(transaction);
                                    }
                                } else if (this.deletes(item)) {
                                    oldAttributes.set(key, value);
                                    const curVal = currentAttributes.get(key) ?? null;
                                    if (!equalAttrs(curVal, value)) {
                                        if (action === 'retain') addOp();
                                        attributes[key] = curVal;
                                    }
                                } else if (!item.deleted) {
                                    oldAttributes.set(key, value);
                                    const attr = attributes[key];
                                    if (attr !== undefined) {
                                        if (!equalAttrs(attr, value)) {
                                            if (action === 'retain') addOp();
                                            if (value === null) delete attributes[key];
                                            else attributes[key] = value;
                                        } else if (attr !== null) item.delete(transaction);
                                    }
                                }
                                if (!item.deleted) {
                                    if (action === 'insert') addOp();
                                    updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ item.content);
                                }
                                break;
                            }
                    }
                    item = item.right;
                }
                addOp();
                while(delta.length > 0){
                    const lastOp = delta[delta.length - 1];
                    if (lastOp.retain !== undefined && lastOp.attributes === undefined) // retain delta's if they don't assign attributes
                    delta.pop();
                    else break;
                }
            });
            this._delta = delta;
        }
        return /** @type {any} */ this._delta;
    }
}
/**
 * Type that represents text with formatting information.
 *
 * This type replaces y-richtext as this implementation is able to handle
 * block formats (format information on a paragraph), embeds (complex elements
 * like pictures and videos), and text formats (**bold**, *italic*).
 *
 * @extends AbstractType<YTextEvent>
 */ class YText extends AbstractType {
    /**
   * @param {String} [string] The initial value of the YText.
   */ constructor(string){
        super();
        /**
     * Array of pending operations on this type
     * @type {Array<function():void>?}
     */ this._pending = string !== undefined ? [
            ()=>this.insert(0, string)
        ] : [];
        /**
     * @type {Array<ArraySearchMarker>|null}
     */ this._searchMarker = [];
        /**
     * Whether this YText contains formatting attributes.
     * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)
     */ this._hasFormatting = false;
    }
    /**
   * Number of characters of this text type.
   *
   * @type {number}
   */ get length() {
        this.doc ?? warnPrematureAccess();
        return this._length;
    }
    /**
   * @param {Doc} y
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        try {
            /** @type {Array<function>} */ this._pending.forEach((f)=>f());
        } catch (e) {
            console.error(e);
        }
        this._pending = null;
    }
    _copy() {
        return new YText();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */ clone() {
        const text = new YText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        super._callObserver(transaction, parentSubs);
        const event = new YTextEvent(this, transaction, parentSubs);
        callTypeObservers(this, transaction, event);
        // If a remote change happened, we try to cleanup potential formatting duplicates.
        if (!transaction.local && this._hasFormatting) transaction._needFormattingCleanup = true;
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */ toString() {
        this.doc ?? warnPrematureAccess();
        let str = '';
        /**
     * @type {Item|null}
     */ let n = this._start;
        while(n !== null){
            if (!n.deleted && n.countable && n.content.constructor === ContentString) str += /** @type {ContentString} */ n.content.str;
            n = n.right;
        }
        return str;
    }
    /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */ toJSON() {
        return this.toString();
    }
    /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */ applyDelta(delta, { sanitize = true } = {}) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            const currPos = new ItemTextListPosition(null, this._start, 0, new Map());
            for(let i = 0; i < delta.length; i++){
                const op = delta[i];
                if (op.insert !== undefined) {
                    // Quill assumes that the content starts with an empty paragraph.
                    // Yjs/Y.Text assumes that it starts empty. We always hide that
                    // there is a newline at the end of the content.
                    // If we omit this step, clients will see a different number of
                    // paragraphs, but nothing bad will happen.
                    const ins = !sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\n' ? op.insert.slice(0, -1) : op.insert;
                    if (typeof ins !== 'string' || ins.length > 0) insertText(transaction, this, currPos, ins, op.attributes || {});
                } else if (op.retain !== undefined) formatText(transaction, this, currPos, op.retain, op.attributes || {});
                else if (op.delete !== undefined) deleteText(transaction, currPos, op.delete);
            }
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.applyDelta(delta));
    }
    /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */ toDelta(snapshot, prevSnapshot, computeYChange) {
        this.doc ?? warnPrematureAccess();
        /**
     * @type{Array<any>}
     */ const ops = [];
        const currentAttributes = new Map();
        const doc = /** @type {Doc} */ this.doc;
        let str = '';
        let n = this._start;
        function packStr() {
            if (str.length > 0) {
                // pack str with attributes to ops
                /**
         * @type {Object<string,any>}
         */ const attributes = {};
                let addAttributes = false;
                currentAttributes.forEach((value, key)=>{
                    addAttributes = true;
                    attributes[key] = value;
                });
                /**
         * @type {Object<string,any>}
         */ const op = {
                    insert: str
                };
                if (addAttributes) op.attributes = attributes;
                ops.push(op);
                str = '';
            }
        }
        const computeDelta = ()=>{
            while(n !== null){
                if (isVisible(n, snapshot) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) switch(n.content.constructor){
                    case ContentString:
                        {
                            const cur = currentAttributes.get('ychange');
                            if (snapshot !== undefined && !isVisible(n, snapshot)) {
                                if (cur === undefined || cur.user !== n.id.client || cur.type !== 'removed') {
                                    packStr();
                                    currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : {
                                        type: 'removed'
                                    });
                                }
                            } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {
                                if (cur === undefined || cur.user !== n.id.client || cur.type !== 'added') {
                                    packStr();
                                    currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : {
                                        type: 'added'
                                    });
                                }
                            } else if (cur !== undefined) {
                                packStr();
                                currentAttributes.delete('ychange');
                            }
                            str += /** @type {ContentString} */ n.content.str;
                            break;
                        }
                    case ContentType:
                    case ContentEmbed:
                        {
                            packStr();
                            /**
               * @type {Object<string,any>}
               */ const op = {
                                insert: n.content.getContent()[0]
                            };
                            if (currentAttributes.size > 0) {
                                const attrs = /** @type {Object<string,any>} */ {};
                                op.attributes = attrs;
                                currentAttributes.forEach((value, key)=>{
                                    attrs[key] = value;
                                });
                            }
                            ops.push(op);
                            break;
                        }
                    case ContentFormat:
                        if (isVisible(n, snapshot)) {
                            packStr();
                            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ n.content);
                        }
                        break;
                }
                n = n.right;
            }
            packStr();
        };
        if (snapshot || prevSnapshot) // snapshots are merged again after the transaction, so we need to keep the
        // transaction alive until we are done
        transact(doc, (transaction)=>{
            if (snapshot) splitSnapshotAffectedStructs(transaction, snapshot);
            if (prevSnapshot) splitSnapshotAffectedStructs(transaction, prevSnapshot);
            computeDelta();
        }, 'cleanup');
        else computeDelta();
        return ops;
    }
    /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */ insert(index, text, attributes) {
        if (text.length <= 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index, !attributes);
            if (!attributes) {
                attributes = {};
                // @ts-ignore
                pos.currentAttributes.forEach((v, k)=>{
                    attributes[k] = v;
                });
            }
            insertText(transaction, this, pos, text, attributes);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.insert(index, text, attributes));
    }
    /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */ insertEmbed(index, embed, attributes) {
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index, !attributes);
            insertText(transaction, this, pos, embed, attributes || {});
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.insertEmbed(index, embed, attributes || {}));
    }
    /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */ delete(index, length) {
        if (length === 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            deleteText(transaction, findPosition(transaction, this, index, true), length);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.delete(index, length));
    }
    /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */ format(index, length, attributes) {
        if (length === 0) return;
        const y = this.doc;
        if (y !== null) transact(y, (transaction)=>{
            const pos = findPosition(transaction, this, index, false);
            if (pos.right === null) return;
            formatText(transaction, this, pos, length, attributes);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.format(index, length, attributes));
    }
    /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, attributeName);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.removeAttribute(attributeName));
    }
    /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, attributeName, attributeValue);
        });
        else /** @type {Array<function>} */ this._pending.push(()=>this.setAttribute(attributeName, attributeValue));
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return /** @type {any} */ typeMapGet(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes() {
        return typeMapGetAll(this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YText}
 *
 * @private
 * @function
 */ const readYText = (_decoder)=>new YText();
/**
 * @module YXml
 */ /**
 * Define the elements to which a set of CSS queries apply.
 * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
 *
 * @example
 *   query = '.classSelector'
 *   query = 'nodeSelector'
 *   query = '#idSelector'
 *
 * @typedef {string} CSS_Selector
 */ /**
 * Dom filter function.
 *
 * @callback domFilter
 * @param {string} nodeName The nodeName of the element
 * @param {Map} attributes The map of attributes.
 * @return {boolean} Whether to include the Dom node in the YXmlElement.
 */ /**
 * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
 * position within them.
 *
 * Can be created with {@link YXmlFragment#createTreeWalker}
 *
 * @public
 * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}
 */ class YXmlTreeWalker {
    /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */ constructor(root, f = ()=>true){
        this._filter = f;
        this._root = root;
        /**
     * @type {Item}
     */ this._currentNode = /** @type {Item} */ root._start;
        this._firstCall = true;
        root.doc ?? warnPrematureAccess();
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */ next() {
        /**
     * @type {Item|null}
     */ let n = this._currentNode;
        let type = n && n.content && /** @type {any} */ n.content.type;
        if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) do {
            type = /** @type {any} */ n.content.type;
            if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) // walk down in the tree
            n = type._start;
            else // walk right or up in the tree
            while(n !== null){
                if (n.right !== null) {
                    n = n.right;
                    break;
                } else if (n.parent === this._root) n = null;
                else n = /** @type {AbstractType<any>} */ n.parent._item;
            }
        }while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ n.content.type)));
        this._firstCall = false;
        if (n === null) // @ts-ignore
        return {
            value: undefined,
            done: true
        };
        this._currentNode = n;
        return {
            value: /** @type {any} */ n.content.type,
            done: false
        };
    }
}
/**
 * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
 * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
 * nodeName and it does not have attributes. Though it can be bound to a DOM
 * element - in this case the attributes and the nodeName are not shared.
 *
 * @public
 * @extends AbstractType<YXmlEvent>
 */ class YXmlFragment extends AbstractType {
    constructor(){
        super();
        /**
     * @type {Array<any>|null}
     */ this._prelimContent = [];
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get firstChild() {
        const first = this._first;
        return first ? first.content.getContent()[0] : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        this.insert(0, /** @type {Array<any>} */ this._prelimContent);
        this._prelimContent = null;
    }
    _copy() {
        return new YXmlFragment();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */ clone() {
        const el = new YXmlFragment();
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    get length() {
        this.doc ?? warnPrematureAccess();
        return this._prelimContent === null ? this._length : this._prelimContent.length;
    }
    /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */ createTreeWalker(filter) {
        return new YXmlTreeWalker(this, filter);
    }
    /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */ querySelector(query) {
        query = query.toUpperCase();
        // @ts-ignore
        const iterator = new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query);
        const next = iterator.next();
        if (next.done) return null;
        else return next.value;
    }
    /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */ querySelectorAll(query) {
        query = query.toUpperCase();
        // @ts-ignore
        return _array.from(new YXmlTreeWalker(this, (element)=>element.nodeName && element.nodeName.toUpperCase() === query));
    }
    /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */ _callObserver(transaction, parentSubs) {
        callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
    }
    /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */ toString() {
        return typeListMap(this, (xml)=>xml.toString()).join('');
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const fragment = _document.createDocumentFragment();
        if (binding !== undefined) binding._createAssociation(fragment, this);
        typeListForEach(this, (xmlType)=>{
            fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
        });
        return fragment;
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insert(index, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListInsertGenerics(transaction, this, index, content);
        });
        else // @ts-ignore _prelimContent is defined because this is not yet integrated
        this._prelimContent.splice(index, 0, ...content);
    }
    /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */ insertAfter(ref, content) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
            typeListInsertGenericsAfter(transaction, this, refItem, content);
        });
        else {
            const pc = /** @type {Array<any>} */ this._prelimContent;
            const index = ref === null ? 0 : pc.findIndex((el)=>el === ref) + 1;
            if (index === 0 && ref !== null) throw _error.create('Reference item not found');
            pc.splice(index, 0, ...content);
        }
    }
    /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */ delete(index, length = 1) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeListDelete(transaction, this, index, length);
        });
        else // @ts-ignore _prelimContent is defined because this is not yet integrated
        this._prelimContent.splice(index, length);
    }
    /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */ toArray() {
        return typeListToArray(this);
    }
    /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */ push(content) {
        this.insert(this.length, content);
    }
    /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */ unshift(content) {
        this.insert(0, content);
    }
    /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */ get(index) {
        return typeListGet(this, index);
    }
    /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */ slice(start = 0, end = this.length) {
        return typeListSlice(this, start, end);
    }
    /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */ forEach(f) {
        typeListForEach(this, f);
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlFragmentRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
 * @return {YXmlFragment}
 *
 * @private
 * @function
 */ const readYXmlFragment = (_decoder)=>new YXmlFragment();
/**
 * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes
 */ /**
 * An YXmlElement imitates the behavior of a
 * https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element
 *
 * * An YXmlElement has attributes (key value pairs)
 * * An YXmlElement has childElements that must inherit from YXmlElement
 *
 * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]
 */ class YXmlElement extends YXmlFragment {
    constructor(nodeName = 'UNDEFINED'){
        super();
        this.nodeName = nodeName;
        /**
     * @type {Map<string, any>|null}
     */ this._prelimAttrs = new Map();
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */ _integrate(y, item) {
        super._integrate(y, item);
        /** @type {Map<string, any>} */ this._prelimAttrs.forEach((value, key)=>{
            this.setAttribute(key, value);
        });
        this._prelimAttrs = null;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */ _copy() {
        return new YXmlElement(this.nodeName);
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */ clone() {
        /**
     * @type {YXmlElement<KV>}
     */ const el = new YXmlElement(this.nodeName);
        const attrs = this.getAttributes();
        _object.forEach(attrs, (value, key)=>{
            if (typeof value === 'string') el.setAttribute(key, value);
        });
        // @ts-ignore
        el.insert(0, this.toArray().map((item)=>item instanceof AbstractType ? item.clone() : item));
        return el;
    }
    /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */ toString() {
        const attrs = this.getAttributes();
        const stringBuilder = [];
        const keys = [];
        for(const key in attrs)keys.push(key);
        keys.sort();
        const keysLen = keys.length;
        for(let i = 0; i < keysLen; i++){
            const key = keys[i];
            stringBuilder.push(key + '="' + attrs[key] + '"');
        }
        const nodeName = this.nodeName.toLocaleLowerCase();
        const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';
        return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
    }
    /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */ removeAttribute(attributeName) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapDelete(transaction, this, attributeName);
        });
        else /** @type {Map<string,any>} */ this._prelimAttrs.delete(attributeName);
    }
    /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */ setAttribute(attributeName, attributeValue) {
        if (this.doc !== null) transact(this.doc, (transaction)=>{
            typeMapSet(transaction, this, attributeName, attributeValue);
        });
        else /** @type {Map<string, any>} */ this._prelimAttrs.set(attributeName, attributeValue);
    }
    /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */ getAttribute(attributeName) {
        return /** @type {any} */ typeMapGet(this, attributeName);
    }
    /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */ hasAttribute(attributeName) {
        return /** @type {any} */ typeMapHas(this, attributeName);
    }
    /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */ getAttributes(snapshot) {
        return /** @type {any} */ snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this);
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const dom = _document.createElement(this.nodeName);
        const attrs = this.getAttributes();
        for(const key in attrs){
            const value = attrs[key];
            if (typeof value === 'string') dom.setAttribute(key, value);
        }
        typeListForEach(this, (yxml)=>{
            dom.appendChild(yxml.toDOM(_document, hooks, binding));
        });
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlElementRefID);
        encoder.writeKey(this.nodeName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlElement}
 *
 * @function
 */ const readYXmlElement = (decoder)=>new YXmlElement(decoder.readKey());
/**
 * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>
 * An Event that describes changes on a YXml Element or Yxml Fragment
 */ class YXmlEvent extends YEvent {
    /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */ constructor(target, subs, transaction){
        super(target, transaction);
        /**
     * Whether the children changed.
     * @type {Boolean}
     * @private
     */ this.childListChanged = false;
        /**
     * Set of all changed attributes.
     * @type {Set<string>}
     */ this.attributesChanged = new Set();
        subs.forEach((sub)=>{
            if (sub === null) this.childListChanged = true;
            else this.attributesChanged.add(sub);
        });
    }
}
/**
 * You can manage binding to a custom type with YXmlHook.
 *
 * @extends {YMap<any>}
 */ class YXmlHook extends YMap {
    /**
   * @param {string} hookName nodeName of the Dom Node.
   */ constructor(hookName){
        super();
        /**
     * @type {string}
     */ this.hookName = hookName;
    }
    /**
   * Creates an Item with the same effect as this Item (without position effect)
   */ _copy() {
        return new YXmlHook(this.hookName);
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */ clone() {
        const el = new YXmlHook(this.hookName);
        this.forEach((value, key)=>{
            el.set(key, value);
        });
        return el;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks = {}, binding) {
        const hook = hooks[this.hookName];
        let dom;
        if (hook !== undefined) dom = hook.createDom(this);
        else dom = document.createElement(this.hookName);
        dom.setAttribute('data-yjs-hook', this.hookName);
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlHookRefID);
        encoder.writeKey(this.hookName);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlHook}
 *
 * @private
 * @function
 */ const readYXmlHook = (decoder)=>new YXmlHook(decoder.readKey());
/**
 * Represents text in a Dom Element. In the future this type will also handle
 * simple formatting information like bold and italic.
 */ class YXmlText extends YText {
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get nextSibling() {
        const n = this._item ? this._item.next : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    /**
   * @type {YXmlElement|YXmlText|null}
   */ get prevSibling() {
        const n = this._item ? this._item.prev : null;
        return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */ n.content.type : null;
    }
    _copy() {
        return new YXmlText();
    }
    /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */ clone() {
        const text = new YXmlText();
        text.applyDelta(this.toDelta());
        return text;
    }
    /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */ toDOM(_document = document, hooks, binding) {
        const dom = _document.createTextNode(this.toString());
        if (binding !== undefined) binding._createAssociation(dom, this);
        return dom;
    }
    toString() {
        // @ts-ignore
        return this.toDelta().map((delta)=>{
            const nestedNodes = [];
            for(const nodeName in delta.attributes){
                const attrs = [];
                for(const key in delta.attributes[nodeName])attrs.push({
                    key,
                    value: delta.attributes[nodeName][key]
                });
                // sort attributes to get a unique order
                attrs.sort((a, b)=>a.key < b.key ? -1 : 1);
                nestedNodes.push({
                    nodeName,
                    attrs
                });
            }
            // sort node order to get a unique order
            nestedNodes.sort((a, b)=>a.nodeName < b.nodeName ? -1 : 1);
            // now convert to dom string
            let str = '';
            for(let i = 0; i < nestedNodes.length; i++){
                const node = nestedNodes[i];
                str += `<${node.nodeName}`;
                for(let j = 0; j < node.attrs.length; j++){
                    const attr = node.attrs[j];
                    str += ` ${attr.key}="${attr.value}"`;
                }
                str += '>';
            }
            str += delta.insert;
            for(let i = nestedNodes.length - 1; i >= 0; i--)str += `</${nestedNodes[i].nodeName}>`;
            return str;
        }).join('');
    }
    /**
   * @return {string}
   */ toJSON() {
        return this.toString();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */ _write(encoder) {
        encoder.writeTypeRef(YXmlTextRefID);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {YXmlText}
 *
 * @private
 * @function
 */ const readYXmlText = (decoder)=>new YXmlText();
class AbstractStruct {
    /**
   * @param {ID} id
   * @param {number} length
   */ constructor(id, length){
        this.id = id;
        this.length = length;
    }
    /**
   * @type {boolean}
   */ get deleted() {
        throw _error.methodUnimplemented();
    }
    /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */ write(encoder, offset, encodingRef) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        throw _error.methodUnimplemented();
    }
}
const structGCRefNumber = 0;
/**
 * @private
 */ class GC extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {GC} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) return false;
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.length -= offset;
        }
        addStruct(transaction.doc.store, this);
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structGCRefNumber);
        encoder.writeLen(this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
class ContentBinary {
    /**
   * @param {Uint8Array} content
   */ constructor(content){
        this.content = content;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.content
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentBinary}
   */ copy() {
        return new ContentBinary(this.content);
    }
    /**
   * @param {number} offset
   * @return {ContentBinary}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentBinary} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeBuf(this.content);
    }
    /**
   * @return {number}
   */ getRef() {
        return 3;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentBinary}
 */ const readContentBinary = (decoder)=>new ContentBinary(decoder.readBuf());
class ContentDeleted {
    /**
   * @param {number} len
   */ constructor(len){
        this.len = len;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.len;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentDeleted}
   */ copy() {
        return new ContentDeleted(this.len);
    }
    /**
   * @param {number} offset
   * @return {ContentDeleted}
   */ splice(offset) {
        const right = new ContentDeleted(this.len - offset);
        this.len = offset;
        return right;
    }
    /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */ mergeWith(right) {
        this.len += right.len;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
        item.markDeleted();
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeLen(this.len - offset);
    }
    /**
   * @return {number}
   */ getRef() {
        return 1;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
 * @return {ContentDeleted}
 */ const readContentDeleted = (decoder)=>new ContentDeleted(decoder.readLen());
/**
 * @param {string} guid
 * @param {Object<string, any>} opts
 */ const createDocFromOpts = (guid, opts)=>new Doc({
        guid,
        ...opts,
        shouldLoad: opts.shouldLoad || opts.autoLoad || false
    });
/**
 * @private
 */ class ContentDoc {
    /**
   * @param {Doc} doc
   */ constructor(doc){
        if (doc._item) console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');
        /**
     * @type {Doc}
     */ this.doc = doc;
        /**
     * @type {any}
     */ const opts = {};
        this.opts = opts;
        if (!doc.gc) opts.gc = false;
        if (doc.autoLoad) opts.autoLoad = true;
        if (doc.meta !== null) opts.meta = doc.meta;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.doc
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentDoc}
   */ copy() {
        return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
    }
    /**
   * @param {number} offset
   * @return {ContentDoc}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentDoc} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        // this needs to be reflected in doc.destroy as well
        this.doc._item = item;
        transaction.subdocsAdded.add(this.doc);
        if (this.doc.shouldLoad) transaction.subdocsLoaded.add(this.doc);
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (transaction.subdocsAdded.has(this.doc)) transaction.subdocsAdded.delete(this.doc);
        else transaction.subdocsRemoved.add(this.doc);
    }
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(this.doc.guid);
        encoder.writeAny(this.opts);
    }
    /**
   * @return {number}
   */ getRef() {
        return 9;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentDoc}
 */ const readContentDoc = (decoder)=>new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
/**
 * @private
 */ class ContentEmbed {
    /**
   * @param {Object} embed
   */ constructor(embed){
        this.embed = embed;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.embed
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentEmbed}
   */ copy() {
        return new ContentEmbed(this.embed);
    }
    /**
   * @param {number} offset
   * @return {ContentEmbed}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeJSON(this.embed);
    }
    /**
   * @return {number}
   */ getRef() {
        return 5;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentEmbed}
 */ const readContentEmbed = (decoder)=>new ContentEmbed(decoder.readJSON());
/**
 * @private
 */ class ContentFormat {
    /**
   * @param {string} key
   * @param {Object} value
   */ constructor(key, value){
        this.key = key;
        this.value = value;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return false;
    }
    /**
   * @return {ContentFormat}
   */ copy() {
        return new ContentFormat(this.key, this.value);
    }
    /**
   * @param {number} _offset
   * @return {ContentFormat}
   */ splice(_offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */ mergeWith(_right) {
        return false;
    }
    /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */ integrate(_transaction, item) {
        // @todo searchmarker are currently unsupported for rich text documents
        const p = /** @type {YText} */ item.parent;
        p._searchMarker = null;
        p._hasFormatting = true;
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeKey(this.key);
        encoder.writeJSON(this.value);
    }
    /**
   * @return {number}
   */ getRef() {
        return 6;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentFormat}
 */ const readContentFormat = (decoder)=>new ContentFormat(decoder.readKey(), decoder.readJSON());
/**
 * @private
 */ class ContentJSON {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentJSON}
   */ copy() {
        return new ContentJSON(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentJSON}
   */ splice(offset) {
        const right = new ContentJSON(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentJSON} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 2;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentJSON}
 */ const readContentJSON = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++){
        const c = decoder.readString();
        if (c === 'undefined') cs.push(undefined);
        else cs.push(JSON.parse(c));
    }
    return new ContentJSON(cs);
};
const isDevMode = _environment.getVariable('node_env') === 'development';
class ContentAny {
    /**
   * @param {Array<any>} arr
   */ constructor(arr){
        /**
     * @type {Array<any>}
     */ this.arr = arr;
        isDevMode && _object.deepFreeze(arr);
    }
    /**
   * @return {number}
   */ getLength() {
        return this.arr.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.arr;
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentAny}
   */ copy() {
        return new ContentAny(this.arr);
    }
    /**
   * @param {number} offset
   * @return {ContentAny}
   */ splice(offset) {
        const right = new ContentAny(this.arr.slice(offset));
        this.arr = this.arr.slice(0, offset);
        return right;
    }
    /**
   * @param {ContentAny} right
   * @return {boolean}
   */ mergeWith(right) {
        this.arr = this.arr.concat(right.arr);
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        const len = this.arr.length;
        encoder.writeLen(len - offset);
        for(let i = offset; i < len; i++){
            const c = this.arr[i];
            encoder.writeAny(c);
        }
    }
    /**
   * @return {number}
   */ getRef() {
        return 8;
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentAny}
 */ const readContentAny = (decoder)=>{
    const len = decoder.readLen();
    const cs = [];
    for(let i = 0; i < len; i++)cs.push(decoder.readAny());
    return new ContentAny(cs);
};
/**
 * @private
 */ class ContentString {
    /**
   * @param {string} str
   */ constructor(str){
        /**
     * @type {string}
     */ this.str = str;
    }
    /**
   * @return {number}
   */ getLength() {
        return this.str.length;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return this.str.split('');
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentString}
   */ copy() {
        return new ContentString(this.str);
    }
    /**
   * @param {number} offset
   * @return {ContentString}
   */ splice(offset) {
        const right = new ContentString(this.str.slice(offset));
        this.str = this.str.slice(0, offset);
        // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248
        const firstCharCode = this.str.charCodeAt(offset - 1);
        if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {
            // Last character of the left split is the start of a surrogate utf16/ucs2 pair.
            // We don't support splitting of surrogate pairs because this may lead to invalid documents.
            // Replace the invalid character with a unicode replacement character ( / U+FFFD)
            this.str = this.str.slice(0, offset - 1) + "\uFFFD";
            // replace right as well
            right.str = "\uFFFD" + right.str.slice(1);
        }
        return right;
    }
    /**
   * @param {ContentString} right
   * @return {boolean}
   */ mergeWith(right) {
        this.str += right.str;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {}
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {}
    /**
   * @param {StructStore} store
   */ gc(store) {}
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
    }
    /**
   * @return {number}
   */ getRef() {
        return 4;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentString}
 */ const readContentString = (decoder)=>new ContentString(decoder.readString());
/**
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}
 * @private
 */ const typeRefs = [
    readYArray,
    readYMap,
    readYText,
    readYXmlElement,
    readYXmlFragment,
    readYXmlHook,
    readYXmlText
];
const YArrayRefID = 0;
const YMapRefID = 1;
const YTextRefID = 2;
const YXmlElementRefID = 3;
const YXmlFragmentRefID = 4;
const YXmlHookRefID = 5;
const YXmlTextRefID = 6;
/**
 * @private
 */ class ContentType {
    /**
   * @param {AbstractType<any>} type
   */ constructor(type){
        /**
     * @type {AbstractType<any>}
     */ this.type = type;
    }
    /**
   * @return {number}
   */ getLength() {
        return 1;
    }
    /**
   * @return {Array<any>}
   */ getContent() {
        return [
            this.type
        ];
    }
    /**
   * @return {boolean}
   */ isCountable() {
        return true;
    }
    /**
   * @return {ContentType}
   */ copy() {
        return new ContentType(this.type._copy());
    }
    /**
   * @param {number} offset
   * @return {ContentType}
   */ splice(offset) {
        throw _error.methodUnimplemented();
    }
    /**
   * @param {ContentType} right
   * @return {boolean}
   */ mergeWith(right) {
        return false;
    }
    /**
   * @param {Transaction} transaction
   * @param {Item} item
   */ integrate(transaction, item) {
        this.type._integrate(transaction.doc, item);
    }
    /**
   * @param {Transaction} transaction
   */ delete(transaction) {
        let item = this.type._start;
        while(item !== null){
            if (!item.deleted) item.delete(transaction);
            else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) // This will be gc'd later and we want to merge it if possible
            // We try to merge all deleted items after each transaction,
            // but we have no knowledge about that this needs to be merged
            // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs
            transaction._mergeStructs.push(item);
            item = item.right;
        }
        this.type._map.forEach((item)=>{
            if (!item.deleted) item.delete(transaction);
            else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) // same as above
            transaction._mergeStructs.push(item);
        });
        transaction.changed.delete(this.type);
    }
    /**
   * @param {StructStore} store
   */ gc(store) {
        let item = this.type._start;
        while(item !== null){
            item.gc(store, true);
            item = item.right;
        }
        this.type._start = null;
        this.type._map.forEach(/** @param {Item | null} item */ (item)=>{
            while(item !== null){
                item.gc(store, true);
                item = item.left;
            }
        });
        this.type._map = new Map();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        this.type._write(encoder);
    }
    /**
   * @return {number}
   */ getRef() {
        return 7;
    }
}
/**
 * @private
 *
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @return {ContentType}
 */ const readContentType = (decoder)=>new ContentType(typeRefs[decoder.readTypeRef()](decoder));
/**
 * @todo This should return several items
 *
 * @param {StructStore} store
 * @param {ID} id
 * @return {{item:Item, diff:number}}
 */ const followRedone = (store, id)=>{
    /**
   * @type {ID|null}
   */ let nextID = id;
    let diff = 0;
    let item;
    do {
        if (diff > 0) nextID = createID(nextID.client, nextID.clock + diff);
        item = getItem(store, nextID);
        diff = nextID.clock - item.id.clock;
        nextID = item.redone;
    }while (nextID !== null && item instanceof Item);
    return {
        item,
        diff
    };
};
/**
 * Make sure that neither item nor any of its parents is ever deleted.
 *
 * This property does not persist when storing it into a database or when
 * sending it to other peers
 *
 * @param {Item|null} item
 * @param {boolean} keep
 */ const keepItem = (item, keep)=>{
    while(item !== null && item.keep !== keep){
        item.keep = keep;
        item = /** @type {AbstractType<any>} */ item.parent._item;
    }
};
/**
 * Split leftItem into two items
 * @param {Transaction} transaction
 * @param {Item} leftItem
 * @param {number} diff
 * @return {Item}
 *
 * @function
 * @private
 */ const splitItem = (transaction, leftItem, diff)=>{
    // create rightItem
    const { client, clock } = leftItem.id;
    const rightItem = new Item(createID(client, clock + diff), leftItem, createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
    if (leftItem.deleted) rightItem.markDeleted();
    if (leftItem.keep) rightItem.keep = true;
    if (leftItem.redone !== null) rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
    // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)
    leftItem.right = rightItem;
    // update right
    if (rightItem.right !== null) rightItem.right.left = rightItem;
    // right is more specific.
    transaction._mergeStructs.push(rightItem);
    // update parent._map
    if (rightItem.parentSub !== null && rightItem.right === null) /** @type {AbstractType<any>} */ rightItem.parent._map.set(rightItem.parentSub, rightItem);
    leftItem.length = diff;
    return rightItem;
};
/**
 * @param {Array<StackItem>} stack
 * @param {ID} id
 */ const isDeletedByUndoStack = (stack, id)=>_array.some(stack, /** @param {StackItem} s */ (s)=>isDeleted(s.deletions, id));
/**
 * Redoes the effect of this operation.
 *
 * @param {Transaction} transaction The Yjs instance.
 * @param {Item} item
 * @param {Set<Item>} redoitems
 * @param {DeleteSet} itemsToDelete
 * @param {boolean} ignoreRemoteMapChanges
 * @param {import('../utils/UndoManager.js').UndoManager} um
 *
 * @return {Item|null}
 *
 * @private
 */ const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um)=>{
    const doc = transaction.doc;
    const store = doc.store;
    const ownClientID = doc.clientID;
    const redone = item.redone;
    if (redone !== null) return getItemCleanStart(transaction, redone);
    let parentItem = /** @type {AbstractType<any>} */ item.parent._item;
    /**
   * @type {Item|null}
   */ let left = null;
    /**
   * @type {Item|null}
   */ let right;
    // make sure that parent is redone
    if (parentItem !== null && parentItem.deleted === true) {
        // try to undo parent if it will be undone anyway
        if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) return null;
        while(parentItem.redone !== null)parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
    const parentType = parentItem === null ? /** @type {AbstractType<any>} */ item.parent : /** @type {ContentType} */ parentItem.content.type;
    if (item.parentSub === null) {
        // Is an array item. Insert at the old position
        left = item.left;
        right = item;
        // find next cloned_redo items
        while(left !== null){
            /**
       * @type {Item|null}
       */ let leftTrace = left;
            // trace redone until parent matches
            while(leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item !== parentItem)leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
            if (leftTrace !== null && /** @type {AbstractType<any>} */ leftTrace.parent._item === parentItem) {
                left = leftTrace;
                break;
            }
            left = left.left;
        }
        while(right !== null){
            /**
       * @type {Item|null}
       */ let rightTrace = right;
            // trace redone until parent matches
            while(rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item !== parentItem)rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
            if (rightTrace !== null && /** @type {AbstractType<any>} */ rightTrace.parent._item === parentItem) {
                right = rightTrace;
                break;
            }
            right = right.right;
        }
    } else {
        right = null;
        if (item.right && !ignoreRemoteMapChanges) {
            left = item;
            // Iterate right while right is in itemsToDelete
            // If it is intended to delete right while item is redone, we can expect that item should replace right.
            while(left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))){
                left = left.right;
                // follow redone
                while(left.redone)left = getItemCleanStart(transaction, left.redone);
            }
            if (left && left.right !== null) // It is not possible to redo this item because it conflicts with a
            // change from another client
            return null;
        } else left = parentType._map.get(item.parentSub) || null;
    }
    const nextClock = getState(store, ownClientID);
    const nextId = createID(ownClientID, nextClock);
    const redoneItem = new Item(nextId, left, left && left.lastId, right, right && right.id, parentType, item.parentSub, item.content.copy());
    item.redone = nextId;
    keepItem(redoneItem, true);
    redoneItem.integrate(transaction, 0);
    return redoneItem;
};
/**
 * Abstract class that represents any content.
 */ class Item extends AbstractStruct {
    /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */ constructor(id, left, origin, right, rightOrigin, parent, parentSub, content){
        super(id, content.getLength());
        /**
     * The item that was originally to the left of this item.
     * @type {ID | null}
     */ this.origin = origin;
        /**
     * The item that is currently to the left of this item.
     * @type {Item | null}
     */ this.left = left;
        /**
     * The item that is currently to the right of this item.
     * @type {Item | null}
     */ this.right = right;
        /**
     * The item that was originally to the right of this item.
     * @type {ID | null}
     */ this.rightOrigin = rightOrigin;
        /**
     * @type {AbstractType<any>|ID|null}
     */ this.parent = parent;
        /**
     * If the parent refers to this item with some kind of key (e.g. YMap, the
     * key is specified here. The key is then used to refer to the list in which
     * to insert this item. If `parentSub = null` type._start is the list in
     * which to insert to. Otherwise it is `parent._map`.
     * @type {String | null}
     */ this.parentSub = parentSub;
        /**
     * If this type's effect is redone this type refers to the type that undid
     * this operation.
     * @type {ID | null}
     */ this.redone = null;
        /**
     * @type {AbstractContent}
     */ this.content = content;
        /**
     * bit1: keep
     * bit2: countable
     * bit3: deleted
     * bit4: mark - mark node as fast-search-marker
     * @type {number} byte
     */ this.info = this.content.isCountable() ? _binary.BIT2 : 0;
    }
    /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */ set marker(isMarked) {
        if ((this.info & _binary.BIT4) > 0 !== isMarked) this.info ^= _binary.BIT4;
    }
    get marker() {
        return (this.info & _binary.BIT4) > 0;
    }
    /**
   * If true, do not garbage collect this Item.
   */ get keep() {
        return (this.info & _binary.BIT1) > 0;
    }
    set keep(doKeep) {
        if (this.keep !== doKeep) this.info ^= _binary.BIT1;
    }
    get countable() {
        return (this.info & _binary.BIT2) > 0;
    }
    /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */ get deleted() {
        return (this.info & _binary.BIT3) > 0;
    }
    set deleted(doDelete) {
        if (this.deleted !== doDelete) this.info ^= _binary.BIT3;
    }
    markDeleted() {
        this.info |= _binary.BIT3;
    }
    /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) return this.origin.client;
        if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) return this.rightOrigin.client;
        if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) return this.parent.client;
        // We have all missing ids, now find the items
        if (this.origin) {
            this.left = getItemCleanEnd(transaction, store, this.origin);
            this.origin = this.left.lastId;
        }
        if (this.rightOrigin) {
            this.right = getItemCleanStart(transaction, this.rightOrigin);
            this.rightOrigin = this.right.id;
        }
        if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) this.parent = null;
        else if (!this.parent) {
            // only set parent if this shouldn't be garbage collected
            if (this.left && this.left.constructor === Item) {
                this.parent = this.left.parent;
                this.parentSub = this.left.parentSub;
            }
            if (this.right && this.right.constructor === Item) {
                this.parent = this.right.parent;
                this.parentSub = this.right.parentSub;
            }
        } else if (this.parent.constructor === ID) {
            const parentItem = getItem(store, this.parent);
            if (parentItem.constructor === GC) this.parent = null;
            else this.parent = /** @type {ContentType} */ parentItem.content.type;
        }
        return null;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        if (offset > 0) {
            this.id.clock += offset;
            this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
            this.origin = this.left.lastId;
            this.content = this.content.splice(offset);
            this.length -= offset;
        }
        if (this.parent) {
            if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
                /**
         * @type {Item|null}
         */ let left = this.left;
                /**
         * @type {Item|null}
         */ let o;
                // set o to the first conflicting item
                if (left !== null) o = left.right;
                else if (this.parentSub !== null) {
                    o = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(o !== null && o.left !== null)o = o.left;
                } else o = /** @type {AbstractType<any>} */ this.parent._start;
                // TODO: use something like DeleteSet here (a tree implementation would be best)
                // @todo use global set definitions
                /**
         * @type {Set<Item>}
         */ const conflictingItems = new Set();
                /**
         * @type {Set<Item>}
         */ const itemsBeforeOrigin = new Set();
                // Let c in conflictingItems, b in itemsBeforeOrigin
                // ***{origin}bbbb{this}{c,b}{c,b}{o}***
                // Note that conflictingItems is a subset of itemsBeforeOrigin
                while(o !== null && o !== this.right){
                    itemsBeforeOrigin.add(o);
                    conflictingItems.add(o);
                    if (compareIDs(this.origin, o.origin)) {
                        // case 1
                        if (o.id.client < this.id.client) {
                            left = o;
                            conflictingItems.clear();
                        } else if (compareIDs(this.rightOrigin, o.rightOrigin)) break;
                         // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations
                    } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) // case 2
                    {
                        if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
                            left = o;
                            conflictingItems.clear();
                        }
                    } else break;
                    o = o.right;
                }
                this.left = left;
            }
            // reconnect left/right + update parent map/start if necessary
            if (this.left !== null) {
                const right = this.left.right;
                this.right = right;
                this.left.right = this;
            } else {
                let r;
                if (this.parentSub !== null) {
                    r = /** @type {AbstractType<any>} */ this.parent._map.get(this.parentSub) || null;
                    while(r !== null && r.left !== null)r = r.left;
                } else {
                    r = /** @type {AbstractType<any>} */ this.parent._start; /** @type {AbstractType<any>} */ 
                    this.parent._start = this;
                }
                this.right = r;
            }
            if (this.right !== null) this.right.left = this;
            else if (this.parentSub !== null) {
                // set as current parent value if right === null and this is parentSub
                /** @type {AbstractType<any>} */ this.parent._map.set(this.parentSub, this);
                if (this.left !== null) // this is the current attribute value of parent. delete right
                this.left.delete(transaction);
            }
            // adjust length of parent
            if (this.parentSub === null && this.countable && !this.deleted) /** @type {AbstractType<any>} */ this.parent._length += this.length;
            addStruct(transaction.doc.store, this);
            this.content.integrate(transaction, this);
            // add parent to transaction.changed
            addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ this.parent, this.parentSub);
            if (/** @type {AbstractType<any>} */ this.parent._item !== null && /** @type {AbstractType<any>} */ this.parent._item.deleted || this.parentSub !== null && this.right !== null) // delete if parent is deleted or if this is not the current attribute value of parent
            this.delete(transaction);
        } else // parent is not defined. Integrate GC struct instead
        new GC(this.id, this.length).integrate(transaction, 0);
    }
    /**
   * Returns the next non-deleted item
   */ get next() {
        let n = this.right;
        while(n !== null && n.deleted)n = n.right;
        return n;
    }
    /**
   * Returns the previous non-deleted item
   */ get prev() {
        let n = this.left;
        while(n !== null && n.deleted)n = n.left;
        return n;
    }
    /**
   * Computes the last content address of this Item.
   */ get lastId() {
        // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible
        return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
    }
    /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
            const searchMarker = /** @type {AbstractType<any>} */ this.parent._searchMarker;
            if (searchMarker) searchMarker.forEach((marker)=>{
                if (marker.p === right) {
                    // right is going to be "forgotten" so we need to update the marker
                    marker.p = this;
                    // adjust marker index
                    if (!this.deleted && this.countable) marker.index -= this.length;
                }
            });
            if (right.keep) this.keep = true;
            this.right = right.right;
            if (this.right !== null) this.right.left = this;
            this.length += right.length;
            return true;
        }
        return false;
    }
    /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */ delete(transaction) {
        if (!this.deleted) {
            const parent = /** @type {AbstractType<any>} */ this.parent;
            // adjust the length of parent
            if (this.countable && this.parentSub === null) parent._length -= this.length;
            this.markDeleted();
            addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
            addChangedTypeToTransaction(transaction, parent, this.parentSub);
            this.content.delete(transaction);
        }
    }
    /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */ gc(store, parentGCd) {
        if (!this.deleted) throw _error.unexpectedCase();
        this.content.gc(store);
        if (parentGCd) replaceStruct(store, this, new GC(this.id, this.length));
        else this.content = new ContentDeleted(this.length);
    }
    /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */ write(encoder, offset) {
        const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
        const rightOrigin = this.rightOrigin;
        const parentSub = this.parentSub;
        const info = this.content.getRef() & _binary.BITS5 | (origin === null ? 0 : _binary.BIT8) | // origin is defined
        (rightOrigin === null ? 0 : _binary.BIT7) | // right origin is defined
        (parentSub === null ? 0 : _binary.BIT6); // parentSub is non-null
        encoder.writeInfo(info);
        if (origin !== null) encoder.writeLeftID(origin);
        if (rightOrigin !== null) encoder.writeRightID(rightOrigin);
        if (origin === null && rightOrigin === null) {
            const parent = /** @type {AbstractType<any>} */ this.parent;
            if (parent._item !== undefined) {
                const parentItem = parent._item;
                if (parentItem === null) {
                    // parent type on y._map
                    // find the correct key
                    const ykey = findRootTypeKey(parent);
                    encoder.writeParentInfo(true); // write parentYKey
                    encoder.writeString(ykey);
                } else {
                    encoder.writeParentInfo(false); // write parent id
                    encoder.writeLeftID(parentItem.id);
                }
            } else if (parent.constructor === String) {
                encoder.writeParentInfo(true); // write parentYKey
                encoder.writeString(parent);
            } else if (parent.constructor === ID) {
                encoder.writeParentInfo(false); // write parent id
                encoder.writeLeftID(parent);
            } else _error.unexpectedCase();
            if (parentSub !== null) encoder.writeString(parentSub);
        }
        this.content.write(encoder, offset);
    }
}
/**
 * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
 * @param {number} info
 */ const readItemContent = (decoder, info)=>contentRefs[info & _binary.BITS5](decoder);
/**
 * A lookup map for reading Item content.
 *
 * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}
 */ const contentRefs = [
    ()=>{
        _error.unexpectedCase();
    },
    readContentDeleted,
    readContentJSON,
    readContentBinary,
    readContentString,
    readContentEmbed,
    readContentFormat,
    readContentType,
    readContentAny,
    readContentDoc,
    ()=>{
        _error.unexpectedCase();
    } // 10 - Skip is not ItemContent
];
const structSkipRefNumber = 10;
/**
 * @private
 */ class Skip extends AbstractStruct {
    get deleted() {
        return true;
    }
    delete() {}
    /**
   * @param {Skip} right
   * @return {boolean}
   */ mergeWith(right) {
        if (this.constructor !== right.constructor) return false;
        this.length += right.length;
        return true;
    }
    /**
   * @param {Transaction} transaction
   * @param {number} offset
   */ integrate(transaction, offset) {
        // skip structs cannot be integrated
        _error.unexpectedCase();
    }
    /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */ write(encoder, offset) {
        encoder.writeInfo(structSkipRefNumber);
        // write as VarUint because Skips can't make use of predictable length-encoding
        _encoding.writeVarUint(encoder.restEncoder, this.length - offset);
    }
    /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */ getMissing(transaction, store) {
        return null;
    }
}
/** eslint-env browser */ const glo = /** @type {any} */ typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {};
const importIdentifier = '__ $YJS$ __';
if (glo[importIdentifier] === true) /**
   * Dear reader of this message. Please take this seriously.
   *
   * If you see this message, make sure that you only import one version of Yjs. In many cases,
   * your package manager installs two versions of Yjs that are used by different packages within your project.
   * Another reason for this message is that some parts of your project use the commonjs version of Yjs
   * and others use the EcmaScript version of Yjs.
   *
   * This often leads to issues that are hard to debug. We often need to perform constructor checks,
   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to
   * do the constructor checks anymore - which might break the CRDT algorithm.
   *
   * https://github.com/yjs/yjs/issues/438
   */ console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438');
glo[importIdentifier] = true;

},{"lib0/observable":"20Rfd","lib0/array":"ef0AT","lib0/math":"jhXHz","lib0/map":"eE1vX","lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","lib0/random":"6PBGY","lib0/promise":"6ECaa","lib0/buffer":"3bzhu","lib0/error":"fYL2z","lib0/binary":"g6CPb","lib0/function":"1O0Qj","lib0/set":"iWXeP","lib0/logging":"klpvH","lib0/time":"gZsVK","lib0/string":"cA9Az","lib0/iterator":"aFgMm","lib0/object":"4uXcx","lib0/environment":"h8wYT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"20Rfd":[function(require,module,exports,__globalThis) {
/**
 * Observable class prototype.
 *
 * @module observable
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Handles named events.
 * @experimental
 *
 * This is basically a (better typed) duplicate of Observable, which will replace Observable in the
 * next release.
 *
 * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS
 */ parcelHelpers.export(exports, "ObservableV2", ()=>ObservableV2);
/* c8 ignore start */ /**
 * Handles named events.
 *
 * @deprecated
 * @template N
 */ parcelHelpers.export(exports, "Observable", ()=>Observable) /* c8 ignore end */ ;
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
var _arrayJs = require("./array.js");
class ObservableV2 {
    constructor(){
        /**
     * Some desc.
     * @type {Map<string, Set<any>>}
     */ this._observers = _mapJs.create();
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ on(name, f) {
        _mapJs.setIfUndefined(this._observers, /** @type {string} */ name, _setJs.create).add(f);
        return f;
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, /** @type {any} */ _f);
            f(...args);
        };
        this.on(name, /** @type {any} */ _f);
    }
    /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) this._observers.delete(name);
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return _arrayJs.from((this._observers.get(name) || _mapJs.create()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = _mapJs.create();
    }
}
class Observable {
    constructor(){
        /**
     * Some desc.
     * @type {Map<N, any>}
     */ this._observers = _mapJs.create();
    }
    /**
   * @param {N} name
   * @param {function} f
   */ on(name, f) {
        _mapJs.setIfUndefined(this._observers, name, _setJs.create).add(f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ once(name, f) {
        /**
     * @param  {...any} args
     */ const _f = (...args)=>{
            this.off(name, _f);
            f(...args);
        };
        this.on(name, _f);
    }
    /**
   * @param {N} name
   * @param {function} f
   */ off(name, f) {
        const observers = this._observers.get(name);
        if (observers !== undefined) {
            observers.delete(f);
            if (observers.size === 0) this._observers.delete(name);
        }
    }
    /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */ emit(name, args) {
        // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
        return _arrayJs.from((this._observers.get(name) || _mapJs.create()).values()).forEach((f)=>f(...args));
    }
    destroy() {
        this._observers = _mapJs.create();
    }
}

},{"./map.js":"eE1vX","./set.js":"iWXeP","./array.js":"ef0AT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eE1vX":[function(require,module,exports,__globalThis) {
/**
 * Utility module to work with key-value stores.
 *
 * @module map
 */ /**
 * Creates a new Map instance.
 *
 * @function
 * @return {Map<any, any>}
 *
 * @function
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "copy", ()=>copy);
parcelHelpers.export(exports, "setIfUndefined", ()=>setIfUndefined);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "any", ()=>any);
parcelHelpers.export(exports, "all", ()=>all);
const create = ()=>new Map();
const copy = (m)=>{
    const r = create();
    m.forEach((v, k)=>{
        r.set(k, v);
    });
    return r;
};
const setIfUndefined = (map, key, createT)=>{
    let set = map.get(key);
    if (set === undefined) map.set(key, set = createT());
    return set;
};
const map = (m, f)=>{
    const res = [];
    for (const [key, value] of m)res.push(f(value, key));
    return res;
};
const any = (m, f)=>{
    for (const [key, value] of m){
        if (f(value, key)) return true;
    }
    return false;
};
const all = (m, f)=>{
    for (const [key, value] of m){
        if (!f(value, key)) return false;
    }
    return true;
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iWXeP":[function(require,module,exports,__globalThis) {
/**
 * Utility module to work with sets.
 *
 * @module set
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "toArray", ()=>toArray);
parcelHelpers.export(exports, "first", ()=>first);
parcelHelpers.export(exports, "from", ()=>from);
const create = ()=>new Set();
const toArray = (set)=>Array.from(set);
const first = (set)=>set.values().next().value ?? undefined;
const from = (entries)=>new Set(entries);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ef0AT":[function(require,module,exports,__globalThis) {
/**
 * Utility module to work with Arrays.
 *
 * @module array
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "last", ()=>last);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "copy", ()=>copy);
parcelHelpers.export(exports, "appendTo", ()=>appendTo);
parcelHelpers.export(exports, "from", ()=>from);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "equalFlat", ()=>equalFlat);
parcelHelpers.export(exports, "flatten", ()=>flatten);
parcelHelpers.export(exports, "unfold", ()=>unfold);
parcelHelpers.export(exports, "fold", ()=>fold);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "unique", ()=>unique);
parcelHelpers.export(exports, "uniqueBy", ()=>uniqueBy);
parcelHelpers.export(exports, "map", ()=>map);
var _setJs = require("./set.js");
const last = (arr)=>arr[arr.length - 1];
const create = ()=>/** @type {Array<C>} */ [];
const copy = (a)=>/** @type {Array<D>} */ a.slice();
const appendTo = (dest, src)=>{
    for(let i = 0; i < src.length; i++)dest.push(src[i]);
};
const from = Array.from;
const every = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (!f(arr[i], i, arr)) return false;
    }
    return true;
};
const some = (arr, f)=>{
    for(let i = 0; i < arr.length; i++){
        if (f(arr[i], i, arr)) return true;
    }
    return false;
};
const equalFlat = (a, b)=>a.length === b.length && every(a, (item, index)=>item === b[index]);
const flatten = (arr)=>fold(arr, /** @type {Array<ELEM>} */ [], (acc, val)=>acc.concat(val));
const unfold = (len, f)=>{
    const array = new Array(len);
    for(let i = 0; i < len; i++)array[i] = f(i, array);
    return array;
};
const fold = (arr, seed, folder)=>arr.reduce(folder, seed);
const isArray = Array.isArray;
const unique = (arr)=>from(_setJs.from(arr));
const uniqueBy = (arr, mapper)=>{
    /**
   * @type {Set<M>}
   */ const happened = _setJs.create();
    /**
   * @type {Array<T>}
   */ const result = [];
    for(let i = 0; i < arr.length; i++){
        const el = arr[i];
        const mapped = mapper(el);
        if (!happened.has(mapped)) {
            happened.add(mapped);
            result.push(el);
        }
    }
    return result;
};
const map = (arr, mapper)=>{
    /**
   * @type {Array<any>}
   */ const res = Array(arr.length);
    for(let i = 0; i < arr.length; i++)res[i] = mapper(/** @type {any} */ arr[i], i, /** @type {any} */ arr);
    return /** @type {any} */ res;
};

},{"./set.js":"iWXeP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhXHz":[function(require,module,exports,__globalThis) {
/**
 * Common Math expressions.
 *
 * @module math
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "floor", ()=>floor);
parcelHelpers.export(exports, "ceil", ()=>ceil);
parcelHelpers.export(exports, "abs", ()=>abs);
parcelHelpers.export(exports, "imul", ()=>imul);
parcelHelpers.export(exports, "round", ()=>round);
parcelHelpers.export(exports, "log10", ()=>log10);
parcelHelpers.export(exports, "log2", ()=>log2);
parcelHelpers.export(exports, "log", ()=>log);
parcelHelpers.export(exports, "sqrt", ()=>sqrt);
parcelHelpers.export(exports, "add", ()=>add);
parcelHelpers.export(exports, "min", ()=>min);
parcelHelpers.export(exports, "max", ()=>max);
parcelHelpers.export(exports, "isNaN", ()=>isNaN);
parcelHelpers.export(exports, "pow", ()=>pow);
parcelHelpers.export(exports, "exp10", ()=>exp10);
parcelHelpers.export(exports, "sign", ()=>sign);
parcelHelpers.export(exports, "isNegativeZero", ()=>isNegativeZero);
const floor = Math.floor;
const ceil = Math.ceil;
const abs = Math.abs;
const imul = Math.imul;
const round = Math.round;
const log10 = Math.log10;
const log2 = Math.log2;
const log = Math.log;
const sqrt = Math.sqrt;
const add = (a, b)=>a + b;
const min = (a, b)=>a < b ? a : b;
const max = (a, b)=>a > b ? a : b;
const isNaN = Number.isNaN;
const pow = Math.pow;
const exp10 = (exp)=>Math.pow(10, exp);
const sign = Math.sign;
const isNegativeZero = (n)=>n !== 0 ? n < 0 : 1 / n < 0;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9yVNx":[function(require,module,exports,__globalThis) {
/**
 * Efficient schema-less binary encoding with support for variable length encoding.
 *
 * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module encoding
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A BinaryEncoder handles the encoding to an Uint8Array.
 */ parcelHelpers.export(exports, "Encoder", ()=>Encoder);
parcelHelpers.export(exports, "createEncoder", ()=>createEncoder);
parcelHelpers.export(exports, "encode", ()=>encode);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "hasContent", ()=>hasContent);
parcelHelpers.export(exports, "toUint8Array", ()=>toUint8Array);
parcelHelpers.export(exports, "verifyLen", ()=>verifyLen);
parcelHelpers.export(exports, "write", ()=>write);
parcelHelpers.export(exports, "set", ()=>set);
parcelHelpers.export(exports, "writeUint8", ()=>writeUint8);
parcelHelpers.export(exports, "setUint8", ()=>setUint8);
parcelHelpers.export(exports, "writeUint16", ()=>writeUint16);
parcelHelpers.export(exports, "setUint16", ()=>setUint16);
parcelHelpers.export(exports, "writeUint32", ()=>writeUint32);
parcelHelpers.export(exports, "writeUint32BigEndian", ()=>writeUint32BigEndian);
parcelHelpers.export(exports, "setUint32", ()=>setUint32);
parcelHelpers.export(exports, "writeVarUint", ()=>writeVarUint);
parcelHelpers.export(exports, "writeVarInt", ()=>writeVarInt);
parcelHelpers.export(exports, "_writeVarStringNative", ()=>_writeVarStringNative);
parcelHelpers.export(exports, "_writeVarStringPolyfill", ()=>_writeVarStringPolyfill);
parcelHelpers.export(exports, "writeVarString", ()=>writeVarString);
parcelHelpers.export(exports, "writeTerminatedString", ()=>writeTerminatedString);
parcelHelpers.export(exports, "writeTerminatedUint8Array", ()=>writeTerminatedUint8Array);
parcelHelpers.export(exports, "writeBinaryEncoder", ()=>writeBinaryEncoder);
parcelHelpers.export(exports, "writeUint8Array", ()=>writeUint8Array);
parcelHelpers.export(exports, "writeVarUint8Array", ()=>writeVarUint8Array);
parcelHelpers.export(exports, "writeOnDataView", ()=>writeOnDataView);
parcelHelpers.export(exports, "writeFloat32", ()=>writeFloat32);
parcelHelpers.export(exports, "writeFloat64", ()=>writeFloat64);
parcelHelpers.export(exports, "writeBigInt64", ()=>writeBigInt64);
parcelHelpers.export(exports, "writeBigUint64", ()=>writeBigUint64);
parcelHelpers.export(exports, "writeAny", ()=>writeAny);
/**
 * Now come a few stateful encoder that have their own classes.
 */ /**
 * Basic Run Length Encoder - a basic compression implementation.
 *
 * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.
 *
 * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf
 *
 * @note T must not be null!
 *
 * @template T
 */ parcelHelpers.export(exports, "RleEncoder", ()=>RleEncoder);
/**
 * Basic diff decoder using variable length encoding.
 *
 * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.
 */ parcelHelpers.export(exports, "IntDiffEncoder", ()=>IntDiffEncoder);
/**
 * A combination of IntDiffEncoder and RleEncoder.
 *
 * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.
 *
 * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])
 */ parcelHelpers.export(exports, "RleIntDiffEncoder", ()=>RleIntDiffEncoder);
/**
 * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.
 *
 * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write
 * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.
 *
 * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)
 */ parcelHelpers.export(exports, "UintOptRleEncoder", ()=>UintOptRleEncoder);
/**
 * Increasing Uint Optimized RLE Encoder
 *
 * The RLE encoder counts the number of same occurences of the same value.
 * The IncUintOptRle encoder counts if the value increases.
 * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded
 * as [1, 3, 5].
 */ parcelHelpers.export(exports, "IncUintOptRleEncoder", ()=>IncUintOptRleEncoder);
/**
 * A combination of the IntDiffEncoder and the UintOptRleEncoder.
 *
 * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes
 * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!
 *
 * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])
 *
 * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:
 * * 1 bit that denotes whether the next value is a count (LSB)
 * * 1 bit that denotes whether this value is negative (MSB - 1)
 * * 1 bit that denotes whether to continue reading the variable length integer (MSB)
 *
 * Therefore, only five bits remain to encode diff ranges.
 *
 * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.
 */ parcelHelpers.export(exports, "IntDiffOptRleEncoder", ()=>IntDiffOptRleEncoder);
/**
 * Optimized String Encoder.
 *
 * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.
 * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).
 *
 * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.
 *
 * The lengths are encoded using a UintOptRleEncoder.
 */ parcelHelpers.export(exports, "StringEncoder", ()=>StringEncoder);
var _mathJs = require("./math.js");
var _numberJs = require("./number.js");
var _binaryJs = require("./binary.js");
var _stringJs = require("./string.js");
var _arrayJs = require("./array.js");
class Encoder {
    constructor(){
        this.cpos = 0;
        this.cbuf = new Uint8Array(100);
        /**
     * @type {Array<Uint8Array>}
     */ this.bufs = [];
    }
}
const createEncoder = ()=>new Encoder();
const encode = (f)=>{
    const encoder = createEncoder();
    f(encoder);
    return toUint8Array(encoder);
};
const length = (encoder)=>{
    let len = encoder.cpos;
    for(let i = 0; i < encoder.bufs.length; i++)len += encoder.bufs[i].length;
    return len;
};
const hasContent = (encoder)=>encoder.cpos > 0 || encoder.bufs.length > 0;
const toUint8Array = (encoder)=>{
    const uint8arr = new Uint8Array(length(encoder));
    let curPos = 0;
    for(let i = 0; i < encoder.bufs.length; i++){
        const d = encoder.bufs[i];
        uint8arr.set(d, curPos);
        curPos += d.length;
    }
    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
    return uint8arr;
};
const verifyLen = (encoder, len)=>{
    const bufferLen = encoder.cbuf.length;
    if (bufferLen - encoder.cpos < len) {
        encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
        encoder.cbuf = new Uint8Array(_mathJs.max(bufferLen, len) * 2);
        encoder.cpos = 0;
    }
};
const write = (encoder, num)=>{
    const bufferLen = encoder.cbuf.length;
    if (encoder.cpos === bufferLen) {
        encoder.bufs.push(encoder.cbuf);
        encoder.cbuf = new Uint8Array(bufferLen * 2);
        encoder.cpos = 0;
    }
    encoder.cbuf[encoder.cpos++] = num;
};
const set = (encoder, pos, num)=>{
    let buffer = null;
    // iterate all buffers and adjust position
    for(let i = 0; i < encoder.bufs.length && buffer === null; i++){
        const b = encoder.bufs[i];
        if (pos < b.length) buffer = b // found buffer
        ;
        else pos -= b.length;
    }
    if (buffer === null) // use current buffer
    buffer = encoder.cbuf;
    buffer[pos] = num;
};
const writeUint8 = write;
const setUint8 = set;
const writeUint16 = (encoder, num)=>{
    write(encoder, num & _binaryJs.BITS8);
    write(encoder, num >>> 8 & _binaryJs.BITS8);
};
const setUint16 = (encoder, pos, num)=>{
    set(encoder, pos, num & _binaryJs.BITS8);
    set(encoder, pos + 1, num >>> 8 & _binaryJs.BITS8);
};
const writeUint32 = (encoder, num)=>{
    for(let i = 0; i < 4; i++){
        write(encoder, num & _binaryJs.BITS8);
        num >>>= 8;
    }
};
const writeUint32BigEndian = (encoder, num)=>{
    for(let i = 3; i >= 0; i--)write(encoder, num >>> 8 * i & _binaryJs.BITS8);
};
const setUint32 = (encoder, pos, num)=>{
    for(let i = 0; i < 4; i++){
        set(encoder, pos + i, num & _binaryJs.BITS8);
        num >>>= 8;
    }
};
const writeVarUint = (encoder, num)=>{
    while(num > _binaryJs.BITS7){
        write(encoder, _binaryJs.BIT8 | _binaryJs.BITS7 & num);
        num = _mathJs.floor(num / 128) // shift >>> 7
        ;
    }
    write(encoder, _binaryJs.BITS7 & num);
};
const writeVarInt = (encoder, num)=>{
    const isNegative = _mathJs.isNegativeZero(num);
    if (isNegative) num = -num;
    //             |- whether to continue reading         |- whether is negative     |- number
    write(encoder, (num > _binaryJs.BITS6 ? _binaryJs.BIT8 : 0) | (isNegative ? _binaryJs.BIT7 : 0) | _binaryJs.BITS6 & num);
    num = _mathJs.floor(num / 64) // shift >>> 6
    ;
    // We don't need to consider the case of num === 0 so we can use a different
    // pattern here than above.
    while(num > 0){
        write(encoder, (num > _binaryJs.BITS7 ? _binaryJs.BIT8 : 0) | _binaryJs.BITS7 & num);
        num = _mathJs.floor(num / 128) // shift >>> 7
        ;
    }
};
/**
 * A cache to store strings temporarily
 */ const _strBuffer = new Uint8Array(30000);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str)=>{
    if (str.length < _maxStrBSize) {
        // We can encode the string into the existing buffer
        /* c8 ignore next */ const written = _stringJs.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
        writeVarUint(encoder, written);
        for(let i = 0; i < written; i++)write(encoder, _strBuffer[i]);
    } else writeVarUint8Array(encoder, _stringJs.encodeUtf8(str));
};
const _writeVarStringPolyfill = (encoder, str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    writeVarUint(encoder, len);
    for(let i = 0; i < len; i++)write(encoder, /** @type {number} */ encodedString.codePointAt(i));
};
const writeVarString = _stringJs.utf8TextEncoder && /** @type {any} */ _stringJs.utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeTerminatedString = (encoder, str)=>writeTerminatedUint8Array(encoder, _stringJs.encodeUtf8(str));
const writeTerminatedUint8Array = (encoder, buf)=>{
    for(let i = 0; i < buf.length; i++){
        const b = buf[i];
        if (b === 0 || b === 1) write(encoder, 1);
        write(encoder, buf[i]);
    }
    write(encoder, 0);
};
const writeBinaryEncoder = (encoder, append)=>writeUint8Array(encoder, toUint8Array(append));
const writeUint8Array = (encoder, uint8Array)=>{
    const bufferLen = encoder.cbuf.length;
    const cpos = encoder.cpos;
    const leftCopyLen = _mathJs.min(bufferLen - cpos, uint8Array.length);
    const rightCopyLen = uint8Array.length - leftCopyLen;
    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
    encoder.cpos += leftCopyLen;
    if (rightCopyLen > 0) {
        // Still something to write, write right half..
        // Append new buffer
        encoder.bufs.push(encoder.cbuf);
        // must have at least size of remaining buffer
        encoder.cbuf = new Uint8Array(_mathJs.max(bufferLen * 2, rightCopyLen));
        // copy array
        encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
        encoder.cpos = rightCopyLen;
    }
};
const writeVarUint8Array = (encoder, uint8Array)=>{
    writeVarUint(encoder, uint8Array.byteLength);
    writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len)=>{
    verifyLen(encoder, len);
    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
    encoder.cpos += len;
    return dview;
};
const writeFloat32 = (encoder, num)=>writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num)=>writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigInt64(0, num, false);
const writeBigUint64 = (encoder, num)=>/** @type {any} */ writeOnDataView(encoder, 8).setBigUint64(0, num, false);
const floatTestBed = new DataView(new ArrayBuffer(4));
/**
 * Check if a number can be encoded as a 32 bit float.
 *
 * @param {number} num
 * @return {boolean}
 */ const isFloat32 = (num)=>{
    floatTestBed.setFloat32(0, num);
    return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data)=>{
    switch(typeof data){
        case 'string':
            // TYPE 119: STRING
            write(encoder, 119);
            writeVarString(encoder, data);
            break;
        case 'number':
            if (_numberJs.isInteger(data) && _mathJs.abs(data) <= _binaryJs.BITS31) {
                // TYPE 125: INTEGER
                write(encoder, 125);
                writeVarInt(encoder, data);
            } else if (isFloat32(data)) {
                // TYPE 124: FLOAT32
                write(encoder, 124);
                writeFloat32(encoder, data);
            } else {
                // TYPE 123: FLOAT64
                write(encoder, 123);
                writeFloat64(encoder, data);
            }
            break;
        case 'bigint':
            // TYPE 122: BigInt
            write(encoder, 122);
            writeBigInt64(encoder, data);
            break;
        case 'object':
            if (data === null) // TYPE 126: null
            write(encoder, 126);
            else if (_arrayJs.isArray(data)) {
                // TYPE 117: Array
                write(encoder, 117);
                writeVarUint(encoder, data.length);
                for(let i = 0; i < data.length; i++)writeAny(encoder, data[i]);
            } else if (data instanceof Uint8Array) {
                // TYPE 116: ArrayBuffer
                write(encoder, 116);
                writeVarUint8Array(encoder, data);
            } else {
                // TYPE 118: Object
                write(encoder, 118);
                const keys = Object.keys(data);
                writeVarUint(encoder, keys.length);
                for(let i = 0; i < keys.length; i++){
                    const key = keys[i];
                    writeVarString(encoder, key);
                    writeAny(encoder, data[key]);
                }
            }
            break;
        case 'boolean':
            // TYPE 120/121: boolean (true/false)
            write(encoder, data ? 120 : 121);
            break;
        default:
            // TYPE 127: undefined
            write(encoder, 127);
    }
};
class RleEncoder extends Encoder {
    /**
   * @param {function(Encoder, T):void} writer
   */ constructor(writer){
        super();
        /**
     * The writer
     */ this.w = writer;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    /**
   * @param {T} v
   */ write(v) {
        if (this.s === v) this.count++;
        else {
            if (this.count > 0) // flush counter, unless this is the first value (count = 0)
            writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
            ;
            this.count = 1;
            // write first value
            this.w(this, v);
            this.s = v;
        }
    }
}
class IntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @param {number} v
   */ write(v) {
        writeVarInt(this, v - this.s);
        this.s = v;
    }
}
class RleIntDiffEncoder extends Encoder {
    /**
   * @param {number} start
   */ constructor(start){
        super();
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v && this.count > 0) this.count++;
        else {
            if (this.count > 0) // flush counter, unless this is the first value (count = 0)
            writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw
            ;
            this.count = 1;
            // write first value
            writeVarInt(this, v - this.s);
            this.s = v;
        }
    }
}
/**
 * @param {UintOptRleEncoder} encoder
 */ const flushUintOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set sign to positive
        // case 2: write several values. set sign to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
        if (encoder.count > 1) writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
        ;
    }
};
class UintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s === v) this.count++;
        else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class IncUintOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.s + this.count === v) this.count++;
        else {
            flushUintOptRleEncoder(this);
            this.count = 1;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushUintOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
/**
 * @param {IntDiffOptRleEncoder} encoder
 */ const flushIntDiffOptRleEncoder = (encoder)=>{
    if (encoder.count > 0) {
        //          31 bit making up the diff | wether to write the counter
        // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)
        const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
        // flush counter, unless this is the first value (count = 0)
        // case 1: just a single value. set first bit to positive
        // case 2: write several values. set first bit to negative to indicate that there is a length coming
        writeVarInt(encoder.encoder, encodedDiff);
        if (encoder.count > 1) writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw
        ;
    }
};
class IntDiffOptRleEncoder {
    constructor(){
        this.encoder = new Encoder();
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @param {number} v
   */ write(v) {
        if (this.diff === v - this.s) {
            this.s = v;
            this.count++;
        } else {
            flushIntDiffOptRleEncoder(this);
            this.count = 1;
            this.diff = v - this.s;
            this.s = v;
        }
    }
    /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */ toUint8Array() {
        flushIntDiffOptRleEncoder(this);
        return toUint8Array(this.encoder);
    }
}
class StringEncoder {
    constructor(){
        /**
     * @type {Array<string>}
     */ this.sarr = [];
        this.s = '';
        this.lensE = new UintOptRleEncoder();
    }
    /**
   * @param {string} string
   */ write(string) {
        this.s += string;
        if (this.s.length > 19) {
            this.sarr.push(this.s);
            this.s = '';
        }
        this.lensE.write(string.length);
    }
    toUint8Array() {
        const encoder = new Encoder();
        this.sarr.push(this.s);
        this.s = '';
        writeVarString(encoder, this.sarr.join(''));
        writeUint8Array(encoder, this.lensE.toUint8Array());
        return toUint8Array(encoder);
    }
}

},{"./math.js":"jhXHz","./number.js":"cNQGC","./binary.js":"g6CPb","./string.js":"cA9Az","./array.js":"ef0AT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cNQGC":[function(require,module,exports,__globalThis) {
/**
 * Utility helpers for working with numbers.
 *
 * @module number
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_SAFE_INTEGER", ()=>MAX_SAFE_INTEGER);
parcelHelpers.export(exports, "MIN_SAFE_INTEGER", ()=>MIN_SAFE_INTEGER);
parcelHelpers.export(exports, "LOWEST_INT32", ()=>LOWEST_INT32);
parcelHelpers.export(exports, "HIGHEST_INT32", ()=>HIGHEST_INT32);
parcelHelpers.export(exports, "HIGHEST_UINT32", ()=>HIGHEST_UINT32);
parcelHelpers.export(exports, "isInteger", ()=>isInteger);
parcelHelpers.export(exports, "isNaN", ()=>isNaN);
parcelHelpers.export(exports, "parseInt", ()=>parseInt);
parcelHelpers.export(exports, "countBits", ()=>countBits);
var _mathJs = require("./math.js");
var _binaryJs = require("./binary.js");
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
const LOWEST_INT32 = -2147483648;
const HIGHEST_INT32 = _binaryJs.BITS31;
const HIGHEST_UINT32 = _binaryJs.BITS32;
const isInteger = Number.isInteger || ((num)=>typeof num === 'number' && isFinite(num) && _mathJs.floor(num) === num);
const isNaN = Number.isNaN;
const parseInt = Number.parseInt;
const countBits = (n)=>{
    n &= _binaryJs.BITS32;
    let count = 0;
    while(n){
        n &= n - 1;
        count++;
    }
    return count;
};

},{"./math.js":"jhXHz","./binary.js":"g6CPb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g6CPb":[function(require,module,exports,__globalThis) {
/* eslint-env browser */ /**
 * Binary data constants.
 *
 * @module binary
 */ /**
 * n-th bit activated.
 *
 * @type {number}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BIT1", ()=>BIT1);
parcelHelpers.export(exports, "BIT2", ()=>BIT2);
parcelHelpers.export(exports, "BIT3", ()=>BIT3);
parcelHelpers.export(exports, "BIT4", ()=>BIT4);
parcelHelpers.export(exports, "BIT5", ()=>BIT5);
parcelHelpers.export(exports, "BIT6", ()=>BIT6);
parcelHelpers.export(exports, "BIT7", ()=>BIT7);
parcelHelpers.export(exports, "BIT8", ()=>BIT8);
parcelHelpers.export(exports, "BIT9", ()=>BIT9);
parcelHelpers.export(exports, "BIT10", ()=>BIT10);
parcelHelpers.export(exports, "BIT11", ()=>BIT11);
parcelHelpers.export(exports, "BIT12", ()=>BIT12);
parcelHelpers.export(exports, "BIT13", ()=>BIT13);
parcelHelpers.export(exports, "BIT14", ()=>BIT14);
parcelHelpers.export(exports, "BIT15", ()=>BIT15);
parcelHelpers.export(exports, "BIT16", ()=>BIT16);
parcelHelpers.export(exports, "BIT17", ()=>BIT17);
parcelHelpers.export(exports, "BIT18", ()=>BIT18);
parcelHelpers.export(exports, "BIT19", ()=>BIT19);
parcelHelpers.export(exports, "BIT20", ()=>BIT20);
parcelHelpers.export(exports, "BIT21", ()=>BIT21);
parcelHelpers.export(exports, "BIT22", ()=>BIT22);
parcelHelpers.export(exports, "BIT23", ()=>BIT23);
parcelHelpers.export(exports, "BIT24", ()=>BIT24);
parcelHelpers.export(exports, "BIT25", ()=>BIT25);
parcelHelpers.export(exports, "BIT26", ()=>BIT26);
parcelHelpers.export(exports, "BIT27", ()=>BIT27);
parcelHelpers.export(exports, "BIT28", ()=>BIT28);
parcelHelpers.export(exports, "BIT29", ()=>BIT29);
parcelHelpers.export(exports, "BIT30", ()=>BIT30);
parcelHelpers.export(exports, "BIT31", ()=>BIT31);
parcelHelpers.export(exports, "BIT32", ()=>BIT32);
parcelHelpers.export(exports, "BITS0", ()=>BITS0);
parcelHelpers.export(exports, "BITS1", ()=>BITS1);
parcelHelpers.export(exports, "BITS2", ()=>BITS2);
parcelHelpers.export(exports, "BITS3", ()=>BITS3);
parcelHelpers.export(exports, "BITS4", ()=>BITS4);
parcelHelpers.export(exports, "BITS5", ()=>BITS5);
parcelHelpers.export(exports, "BITS6", ()=>BITS6);
parcelHelpers.export(exports, "BITS7", ()=>BITS7);
parcelHelpers.export(exports, "BITS8", ()=>BITS8);
parcelHelpers.export(exports, "BITS9", ()=>BITS9);
parcelHelpers.export(exports, "BITS10", ()=>BITS10);
parcelHelpers.export(exports, "BITS11", ()=>BITS11);
parcelHelpers.export(exports, "BITS12", ()=>BITS12);
parcelHelpers.export(exports, "BITS13", ()=>BITS13);
parcelHelpers.export(exports, "BITS14", ()=>BITS14);
parcelHelpers.export(exports, "BITS15", ()=>BITS15);
parcelHelpers.export(exports, "BITS16", ()=>BITS16);
parcelHelpers.export(exports, "BITS17", ()=>BITS17);
parcelHelpers.export(exports, "BITS18", ()=>BITS18);
parcelHelpers.export(exports, "BITS19", ()=>BITS19);
parcelHelpers.export(exports, "BITS20", ()=>BITS20);
parcelHelpers.export(exports, "BITS21", ()=>BITS21);
parcelHelpers.export(exports, "BITS22", ()=>BITS22);
parcelHelpers.export(exports, "BITS23", ()=>BITS23);
parcelHelpers.export(exports, "BITS24", ()=>BITS24);
parcelHelpers.export(exports, "BITS25", ()=>BITS25);
parcelHelpers.export(exports, "BITS26", ()=>BITS26);
parcelHelpers.export(exports, "BITS27", ()=>BITS27);
parcelHelpers.export(exports, "BITS28", ()=>BITS28);
parcelHelpers.export(exports, "BITS29", ()=>BITS29);
parcelHelpers.export(exports, "BITS30", ()=>BITS30);
parcelHelpers.export(exports, "BITS31", ()=>BITS31);
parcelHelpers.export(exports, "BITS32", ()=>BITS32);
const BIT1 = 1;
const BIT2 = 2;
const BIT3 = 4;
const BIT4 = 8;
const BIT5 = 16;
const BIT6 = 32;
const BIT7 = 64;
const BIT8 = 128;
const BIT9 = 256;
const BIT10 = 512;
const BIT11 = 1024;
const BIT12 = 2048;
const BIT13 = 4096;
const BIT14 = 8192;
const BIT15 = 16384;
const BIT16 = 32768;
const BIT17 = 65536;
const BIT18 = 131072;
const BIT19 = 262144;
const BIT20 = 524288;
const BIT21 = 1048576;
const BIT22 = 2097152;
const BIT23 = 4194304;
const BIT24 = 8388608;
const BIT25 = 16777216;
const BIT26 = 33554432;
const BIT27 = 67108864;
const BIT28 = 134217728;
const BIT29 = 268435456;
const BIT30 = 536870912;
const BIT31 = 1073741824;
const BIT32 = -2147483648;
const BITS0 = 0;
const BITS1 = 1;
const BITS2 = 3;
const BITS3 = 7;
const BITS4 = 15;
const BITS5 = 31;
const BITS6 = 63;
const BITS7 = 127;
const BITS8 = 255;
const BITS9 = 511;
const BITS10 = 1023;
const BITS11 = 2047;
const BITS12 = 4095;
const BITS13 = 8191;
const BITS14 = 16383;
const BITS15 = 32767;
const BITS16 = 65535;
const BITS17 = BIT18 - 1;
const BITS18 = BIT19 - 1;
const BITS19 = BIT20 - 1;
const BITS20 = BIT21 - 1;
const BITS21 = BIT22 - 1;
const BITS22 = BIT23 - 1;
const BITS23 = BIT24 - 1;
const BITS24 = BIT25 - 1;
const BITS25 = BIT26 - 1;
const BITS26 = BIT27 - 1;
const BITS27 = BIT28 - 1;
const BITS28 = BIT29 - 1;
const BITS29 = BIT30 - 1;
const BITS30 = BIT31 - 1;
const BITS31 = 0x7FFFFFFF;
const BITS32 = 0xFFFFFFFF;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cA9Az":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromCharCode", ()=>fromCharCode);
parcelHelpers.export(exports, "fromCodePoint", ()=>fromCodePoint);
parcelHelpers.export(exports, "MAX_UTF16_CHARACTER", ()=>MAX_UTF16_CHARACTER);
parcelHelpers.export(exports, "trimLeft", ()=>trimLeft);
parcelHelpers.export(exports, "fromCamelCase", ()=>fromCamelCase);
parcelHelpers.export(exports, "utf8ByteLength", ()=>utf8ByteLength);
parcelHelpers.export(exports, "_encodeUtf8Polyfill", ()=>_encodeUtf8Polyfill);
parcelHelpers.export(exports, "utf8TextEncoder", ()=>utf8TextEncoder);
parcelHelpers.export(exports, "_encodeUtf8Native", ()=>_encodeUtf8Native);
parcelHelpers.export(exports, "encodeUtf8", ()=>encodeUtf8);
parcelHelpers.export(exports, "_decodeUtf8Polyfill", ()=>_decodeUtf8Polyfill);
parcelHelpers.export(exports, "utf8TextDecoder", ()=>utf8TextDecoder);
parcelHelpers.export(exports, "_decodeUtf8Native", ()=>_decodeUtf8Native);
parcelHelpers.export(exports, "decodeUtf8", ()=>decodeUtf8);
parcelHelpers.export(exports, "splice", ()=>splice);
parcelHelpers.export(exports, "repeat", ()=>repeat);
var _arrayJs = require("./array.js");
const fromCharCode = String.fromCharCode;
const fromCodePoint = String.fromCodePoint;
const MAX_UTF16_CHARACTER = fromCharCode(65535);
/**
 * @param {string} s
 * @return {string}
 */ const toLowerCase = (s)=>s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s)=>s.replace(trimLeftRegex, '');
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator)=>trimLeft(s.replace(fromCamelCaseRegex, (match)=>`${separator}${toLowerCase(match)}`));
const utf8ByteLength = (str)=>unescape(encodeURIComponent(str)).length;
const _encodeUtf8Polyfill = (str)=>{
    const encodedString = unescape(encodeURIComponent(str));
    const len = encodedString.length;
    const buf = new Uint8Array(len);
    for(let i = 0; i < len; i++)buf[i] = /** @type {number} */ encodedString.codePointAt(i);
    return buf;
};
const utf8TextEncoder = /** @type {TextEncoder} */ typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;
const _encodeUtf8Native = (str)=>utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
const _decodeUtf8Polyfill = (buf)=>{
    let remainingLen = buf.length;
    let encodedString = '';
    let bufPos = 0;
    while(remainingLen > 0){
        const nextLen = remainingLen < 10000 ? remainingLen : 10000;
        const bytes = buf.subarray(bufPos, bufPos + nextLen);
        bufPos += nextLen;
        // Starting with ES5.1 we can supply a generic array-like object as arguments
        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ bytes);
        remainingLen -= nextLen;
    }
    return decodeURIComponent(escape(encodedString));
};
let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', {
    fatal: true,
    ignoreBOM: true
});
/* c8 ignore start */ if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) // Safari doesn't handle BOM correctly.
// This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.
// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and
// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call
// Another issue is that from then on no BOM chars are recognized anymore
/* c8 ignore next */ utf8TextDecoder = null;
const _decodeUtf8Native = (buf)=>/** @type {TextDecoder} */ utf8TextDecoder.decode(buf);
const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill;
const splice = (str, index, remove, insert = '')=>str.slice(0, index) + insert + str.slice(index + remove);
const repeat = (source, n)=>_arrayJs.unfold(n, ()=>source).join('');

},{"./array.js":"ef0AT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftn2I":[function(require,module,exports,__globalThis) {
/**
 * Efficient schema-less binary decoding with support for variable length encoding.
 *
 * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.
 *
 * Encodes numbers in little-endian order (least to most significant byte order)
 * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
 * which is also used in Protocol Buffers.
 *
 * ```js
 * // encoding step
 * const encoder = encoding.createEncoder()
 * encoding.writeVarUint(encoder, 256)
 * encoding.writeVarString(encoder, 'Hello world!')
 * const buf = encoding.toUint8Array(encoder)
 * ```
 *
 * ```js
 * // decoding step
 * const decoder = decoding.createDecoder(buf)
 * decoding.readVarUint(decoder) // => 256
 * decoding.readVarString(decoder) // => 'Hello world!'
 * decoding.hasContent(decoder) // => false - all data is read
 * ```
 *
 * @module decoding
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A Decoder handles the decoding of an Uint8Array.
 */ parcelHelpers.export(exports, "Decoder", ()=>Decoder);
parcelHelpers.export(exports, "createDecoder", ()=>createDecoder);
parcelHelpers.export(exports, "hasContent", ()=>hasContent);
parcelHelpers.export(exports, "clone", ()=>clone);
parcelHelpers.export(exports, "readUint8Array", ()=>readUint8Array);
parcelHelpers.export(exports, "readVarUint8Array", ()=>readVarUint8Array);
parcelHelpers.export(exports, "readTailAsUint8Array", ()=>readTailAsUint8Array);
parcelHelpers.export(exports, "skip8", ()=>skip8);
parcelHelpers.export(exports, "readUint8", ()=>readUint8);
parcelHelpers.export(exports, "readUint16", ()=>readUint16);
parcelHelpers.export(exports, "readUint32", ()=>readUint32);
parcelHelpers.export(exports, "readUint32BigEndian", ()=>readUint32BigEndian);
parcelHelpers.export(exports, "peekUint8", ()=>peekUint8);
parcelHelpers.export(exports, "peekUint16", ()=>peekUint16);
parcelHelpers.export(exports, "peekUint32", ()=>peekUint32);
parcelHelpers.export(exports, "readVarUint", ()=>readVarUint);
parcelHelpers.export(exports, "readVarInt", ()=>readVarInt);
parcelHelpers.export(exports, "peekVarUint", ()=>peekVarUint);
parcelHelpers.export(exports, "peekVarInt", ()=>peekVarInt);
parcelHelpers.export(exports, "_readVarStringPolyfill", ()=>_readVarStringPolyfill);
parcelHelpers.export(exports, "_readVarStringNative", ()=>_readVarStringNative);
parcelHelpers.export(exports, "readVarString", ()=>readVarString);
parcelHelpers.export(exports, "readTerminatedUint8Array", ()=>readTerminatedUint8Array);
parcelHelpers.export(exports, "readTerminatedString", ()=>readTerminatedString);
parcelHelpers.export(exports, "peekVarString", ()=>peekVarString);
parcelHelpers.export(exports, "readFromDataView", ()=>readFromDataView);
parcelHelpers.export(exports, "readFloat32", ()=>readFloat32);
parcelHelpers.export(exports, "readFloat64", ()=>readFloat64);
parcelHelpers.export(exports, "readBigInt64", ()=>readBigInt64);
parcelHelpers.export(exports, "readBigUint64", ()=>readBigUint64);
parcelHelpers.export(exports, "readAny", ()=>readAny);
/**
 * T must not be null.
 *
 * @template T
 */ parcelHelpers.export(exports, "RleDecoder", ()=>RleDecoder);
parcelHelpers.export(exports, "IntDiffDecoder", ()=>IntDiffDecoder);
parcelHelpers.export(exports, "RleIntDiffDecoder", ()=>RleIntDiffDecoder);
parcelHelpers.export(exports, "UintOptRleDecoder", ()=>UintOptRleDecoder);
parcelHelpers.export(exports, "IncUintOptRleDecoder", ()=>IncUintOptRleDecoder);
parcelHelpers.export(exports, "IntDiffOptRleDecoder", ()=>IntDiffOptRleDecoder);
parcelHelpers.export(exports, "StringDecoder", ()=>StringDecoder);
var _binaryJs = require("./binary.js");
var _mathJs = require("./math.js");
var _numberJs = require("./number.js");
var _stringJs = require("./string.js");
var _errorJs = require("./error.js");
var _encodingJs = require("./encoding.js");
const errorUnexpectedEndOfArray = _errorJs.create('Unexpected end of array');
const errorIntegerOutOfRange = _errorJs.create('Integer out of Range');
class Decoder {
    /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */ constructor(uint8Array){
        /**
     * Decoding target.
     *
     * @type {Uint8Array}
     */ this.arr = uint8Array;
        /**
     * Current decoding position.
     *
     * @type {number}
     */ this.pos = 0;
    }
}
const createDecoder = (uint8Array)=>new Decoder(uint8Array);
const hasContent = (decoder)=>decoder.pos !== decoder.arr.length;
const clone = (decoder, newPos = decoder.pos)=>{
    const _decoder = createDecoder(decoder.arr);
    _decoder.pos = newPos;
    return _decoder;
};
const readUint8Array = (decoder, len)=>{
    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
    decoder.pos += len;
    return view;
};
const readVarUint8Array = (decoder)=>readUint8Array(decoder, readVarUint(decoder));
const readTailAsUint8Array = (decoder)=>readUint8Array(decoder, decoder.arr.length - decoder.pos);
const skip8 = (decoder)=>decoder.pos++;
const readUint8 = (decoder)=>decoder.arr[decoder.pos++];
const readUint16 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
    decoder.pos += 2;
    return uint;
};
const readUint32 = (decoder)=>{
    const uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const readUint32BigEndian = (decoder)=>{
    const uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;
    decoder.pos += 4;
    return uint;
};
const peekUint8 = (decoder)=>decoder.arr[decoder.pos];
const peekUint16 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
const peekUint32 = (decoder)=>decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
const readVarUint = (decoder)=>{
    let num = 0;
    let mult = 1;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        const r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & _binaryJs.BITS7) * mult // shift $r << (7*#iterations) and add it to num
        ;
        mult *= 128 // next iteration, shift 7 "more" to the left
        ;
        if (r < _binaryJs.BIT8) return num;
        /* c8 ignore start */ if (num > _numberJs.MAX_SAFE_INTEGER) throw errorIntegerOutOfRange;
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const readVarInt = (decoder)=>{
    let r = decoder.arr[decoder.pos++];
    let num = r & _binaryJs.BITS6;
    let mult = 64;
    const sign = (r & _binaryJs.BIT7) > 0 ? -1 : 1;
    if ((r & _binaryJs.BIT8) === 0) // don't continue reading
    return sign * num;
    const len = decoder.arr.length;
    while(decoder.pos < len){
        r = decoder.arr[decoder.pos++];
        // num = num | ((r & binary.BITS7) << len)
        num = num + (r & _binaryJs.BITS7) * mult;
        mult *= 128;
        if (r < _binaryJs.BIT8) return sign * num;
        /* c8 ignore start */ if (num > _numberJs.MAX_SAFE_INTEGER) throw errorIntegerOutOfRange;
    /* c8 ignore stop */ }
    throw errorUnexpectedEndOfArray;
};
const peekVarUint = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarUint(decoder);
    decoder.pos = pos;
    return s;
};
const peekVarInt = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarInt(decoder);
    decoder.pos = pos;
    return s;
};
const _readVarStringPolyfill = (decoder)=>{
    let remainingLen = readVarUint(decoder);
    if (remainingLen === 0) return '';
    else {
        let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen
        ;
        if (--remainingLen < 100) while(remainingLen--)encodedString += String.fromCodePoint(readUint8(decoder));
        else while(remainingLen > 0){
            const nextLen = remainingLen < 10000 ? remainingLen : 10000;
            // this is dangerous, we create a fresh array view from the existing buffer
            const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
            decoder.pos += nextLen;
            // Starting with ES5.1 we can supply a generic array-like object as arguments
            encodedString += String.fromCodePoint.apply(null, /** @type {any} */ bytes);
            remainingLen -= nextLen;
        }
        return decodeURIComponent(escape(encodedString));
    }
};
const _readVarStringNative = (decoder)=>/** @type any */ _stringJs.utf8TextDecoder.decode(readVarUint8Array(decoder));
const readVarString = _stringJs.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
const readTerminatedUint8Array = (decoder)=>{
    const encoder = _encodingJs.createEncoder();
    let b;
    while(true){
        b = readUint8(decoder);
        if (b === 0) return _encodingJs.toUint8Array(encoder);
        if (b === 1) b = readUint8(decoder);
        _encodingJs.write(encoder, b);
    }
};
const readTerminatedString = (decoder)=>_stringJs.decodeUtf8(readTerminatedUint8Array(decoder));
const peekVarString = (decoder)=>{
    const pos = decoder.pos;
    const s = readVarString(decoder);
    decoder.pos = pos;
    return s;
};
const readFromDataView = (decoder, len)=>{
    const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
    decoder.pos += len;
    return dv;
};
const readFloat32 = (decoder)=>readFromDataView(decoder, 4).getFloat32(0, false);
const readFloat64 = (decoder)=>readFromDataView(decoder, 8).getFloat64(0, false);
const readBigInt64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigInt64(0, false);
const readBigUint64 = (decoder)=>/** @type {any} */ readFromDataView(decoder, 8).getBigUint64(0, false);
/**
 * @type {Array<function(Decoder):any>}
 */ const readAnyLookupTable = [
    (decoder)=>undefined,
    (decoder)=>null,
    readVarInt,
    readFloat32,
    readFloat64,
    readBigInt64,
    (decoder)=>false,
    (decoder)=>true,
    readVarString,
    (decoder)=>{
        const len = readVarUint(decoder);
        /**
     * @type {Object<string,any>}
     */ const obj = {};
        for(let i = 0; i < len; i++){
            const key = readVarString(decoder);
            obj[key] = readAny(decoder);
        }
        return obj;
    },
    (decoder)=>{
        const len = readVarUint(decoder);
        const arr = [];
        for(let i = 0; i < len; i++)arr.push(readAny(decoder));
        return arr;
    },
    readVarUint8Array // CASE 116: Uint8Array
];
const readAny = (decoder)=>readAnyLookupTable[127 - readUint8(decoder)](decoder);
class RleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */ constructor(uint8Array, reader){
        super(uint8Array);
        /**
     * The reader
     */ this.reader = reader;
        /**
     * Current state
     * @type {T|null}
     */ this.s = null;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = this.reader(this);
            if (hasContent(this)) this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
            ;
            else this.count = -1 // read the current value forever
            ;
        }
        this.count--;
        return /** @type {T} */ this.s;
    }
}
class IntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
    }
    /**
   * @return {number}
   */ read() {
        this.s += readVarInt(this);
        return this.s;
    }
}
class RleIntDiffDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   * @param {number} start
   */ constructor(uint8Array, start){
        super(uint8Array);
        /**
     * Current state
     * @type {number}
     */ this.s = start;
        this.count = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            this.s += readVarInt(this);
            if (hasContent(this)) this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented
            ;
            else this.count = -1 // read the current value forever
            ;
        }
        this.count--;
        return /** @type {number} */ this.s;
    }
}
class UintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = _mathJs.isNegativeZero(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return /** @type {number} */ this.s;
    }
}
class IncUintOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
    }
    read() {
        if (this.count === 0) {
            this.s = readVarInt(this);
            // if the sign is negative, we read the count too, otherwise count is 1
            const isNegative = _mathJs.isNegativeZero(this.s);
            this.count = 1;
            if (isNegative) {
                this.s = -this.s;
                this.count = readVarUint(this) + 2;
            }
        }
        this.count--;
        return /** @type {number} */ this.s++;
    }
}
class IntDiffOptRleDecoder extends Decoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        super(uint8Array);
        /**
     * @type {number}
     */ this.s = 0;
        this.count = 0;
        this.diff = 0;
    }
    /**
   * @return {number}
   */ read() {
        if (this.count === 0) {
            const diff = readVarInt(this);
            // if the first bit is set, we read more data
            const hasCount = diff & 1;
            this.diff = _mathJs.floor(diff / 2) // shift >> 1
            ;
            this.count = 1;
            if (hasCount) this.count = readVarUint(this) + 2;
        }
        this.s += this.diff;
        this.count--;
        return this.s;
    }
}
class StringDecoder {
    /**
   * @param {Uint8Array} uint8Array
   */ constructor(uint8Array){
        this.decoder = new UintOptRleDecoder(uint8Array);
        this.str = readVarString(this.decoder);
        /**
     * @type {number}
     */ this.spos = 0;
    }
    /**
   * @return {string}
   */ read() {
        const end = this.spos + this.decoder.read();
        const res = this.str.slice(this.spos, end);
        this.spos = end;
        return res;
    }
}

},{"./binary.js":"g6CPb","./math.js":"jhXHz","./number.js":"cNQGC","./string.js":"cA9Az","./error.js":"fYL2z","./encoding.js":"9yVNx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fYL2z":[function(require,module,exports,__globalThis) {
/**
 * Error helpers.
 *
 * @module error
 */ /**
 * @param {string} s
 * @return {Error}
 */ /* c8 ignore next */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "methodUnimplemented", ()=>methodUnimplemented);
parcelHelpers.export(exports, "unexpectedCase", ()=>unexpectedCase);
const create = (s)=>new Error(s);
const methodUnimplemented = ()=>{
    throw create('Method unimplemented');
};
const unexpectedCase = ()=>{
    throw create('Unexpected case');
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6PBGY":[function(require,module,exports,__globalThis) {
/**
 * Isomorphic module for true random numbers / buffers / uuids.
 *
 * Attention: falls back to Math.random if the browser does not support crypto.
 *
 * @module random
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "rand", ()=>rand);
parcelHelpers.export(exports, "uint32", ()=>uint32);
parcelHelpers.export(exports, "uint53", ()=>uint53);
parcelHelpers.export(exports, "oneOf", ()=>oneOf);
parcelHelpers.export(exports, "uuidv4", ()=>uuidv4);
var _mathJs = require("./math.js");
var _binaryJs = require("./binary.js");
var _webcrypto = require("lib0/webcrypto");
const rand = Math.random;
const uint32 = ()=>(0, _webcrypto.getRandomValues)(new Uint32Array(1))[0];
const uint53 = ()=>{
    const arr = (0, _webcrypto.getRandomValues)(new Uint32Array(8));
    return (arr[0] & _binaryJs.BITS21) * (_binaryJs.BITS32 + 1) + (arr[1] >>> 0);
};
const oneOf = (arr)=>arr[_mathJs.floor(rand() * arr.length)];
// @ts-ignore
const uuidv4Template = "10000000-1000-4000-8000-100000000000";
const uuidv4 = ()=>uuidv4Template.replace(/[018]/g, /** @param {number} c */ (c)=>(c ^ uint32() & 15 >> c / 4).toString(16));

},{"./math.js":"jhXHz","./binary.js":"g6CPb","lib0/webcrypto":"7Hw8h","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Hw8h":[function(require,module,exports,__globalThis) {
/* eslint-env browser */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subtle", ()=>subtle);
parcelHelpers.export(exports, "getRandomValues", ()=>getRandomValues);
const subtle = crypto.subtle;
const getRandomValues = crypto.getRandomValues.bind(crypto);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6ECaa":[function(require,module,exports,__globalThis) {
/**
 * Utility helpers to work with promises.
 *
 * @module promise
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "createEmpty", ()=>createEmpty);
parcelHelpers.export(exports, "all", ()=>all);
parcelHelpers.export(exports, "reject", ()=>reject);
parcelHelpers.export(exports, "resolve", ()=>resolve);
parcelHelpers.export(exports, "resolveWith", ()=>resolveWith);
parcelHelpers.export(exports, "until", ()=>until);
parcelHelpers.export(exports, "untilAsync", ()=>untilAsync);
parcelHelpers.export(exports, "wait", ()=>wait);
parcelHelpers.export(exports, "isPromise", ()=>isPromise);
var _timeJs = require("./time.js");
const create = (f)=>/** @type {Promise<T>} */ new Promise(f);
const createEmpty = (f)=>new Promise(f);
const all = Promise.all.bind(Promise);
const reject = (reason)=>Promise.reject(reason);
const resolve = (res)=>Promise.resolve(res);
const resolveWith = (res)=>Promise.resolve(res);
const until = (timeout, check, intervalResolution = 10)=>create((resolve, reject)=>{
        const startTime = _timeJs.getUnixTime();
        const hasTimeout = timeout > 0;
        const untilInterval = ()=>{
            if (check()) {
                clearInterval(intervalHandle);
                resolve();
            } else if (hasTimeout) /* c8 ignore else */ {
                if (_timeJs.getUnixTime() - startTime > timeout) {
                    clearInterval(intervalHandle);
                    reject(new Error('Timeout'));
                }
            }
        };
        const intervalHandle = setInterval(untilInterval, intervalResolution);
    });
const untilAsync = async (check, timeout = 0, intervalResolution = 10)=>{
    const startTime = _timeJs.getUnixTime();
    const noTimeout = timeout <= 0;
    // eslint-disable-next-line no-unmodified-loop-condition
    while(noTimeout || _timeJs.getUnixTime() - startTime <= timeout){
        if (await check()) return;
        await wait(intervalResolution);
    }
    throw new Error('Timeout');
};
const wait = (timeout)=>create((resolve, _reject)=>setTimeout(resolve, timeout));
const isPromise = (p)=>p instanceof Promise || p && p.then && p.catch && p.finally;

},{"./time.js":"gZsVK","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZsVK":[function(require,module,exports,__globalThis) {
/**
 * Utility module to work with time.
 *
 * @module time
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDate", ()=>getDate);
parcelHelpers.export(exports, "getUnixTime", ()=>getUnixTime);
parcelHelpers.export(exports, "humanizeDuration", ()=>humanizeDuration);
var _metricJs = require("./metric.js");
var _mathJs = require("./math.js");
const getDate = ()=>new Date();
const getUnixTime = Date.now;
const humanizeDuration = (d)=>{
    if (d < 60000) {
        const p = _metricJs.prefix(d, -1);
        return _mathJs.round(p.n * 100) / 100 + p.prefix + 's';
    }
    d = _mathJs.floor(d / 1000);
    const seconds = d % 60;
    const minutes = _mathJs.floor(d / 60) % 60;
    const hours = _mathJs.floor(d / 3600) % 24;
    const days = _mathJs.floor(d / 86400);
    if (days > 0) return days + 'd' + (hours > 0 || minutes > 30 ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '');
    if (hours > 0) /* c8 ignore next */ return hours + 'h' + (minutes > 0 || seconds > 30 ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '');
    return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '');
};

},{"./metric.js":"gre3X","./math.js":"jhXHz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gre3X":[function(require,module,exports,__globalThis) {
/**
 * Utility module to convert metric values.
 *
 * @module metric
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "yotta", ()=>yotta);
parcelHelpers.export(exports, "zetta", ()=>zetta);
parcelHelpers.export(exports, "exa", ()=>exa);
parcelHelpers.export(exports, "peta", ()=>peta);
parcelHelpers.export(exports, "tera", ()=>tera);
parcelHelpers.export(exports, "giga", ()=>giga);
parcelHelpers.export(exports, "mega", ()=>mega);
parcelHelpers.export(exports, "kilo", ()=>kilo);
parcelHelpers.export(exports, "hecto", ()=>hecto);
parcelHelpers.export(exports, "deca", ()=>deca);
parcelHelpers.export(exports, "deci", ()=>deci);
parcelHelpers.export(exports, "centi", ()=>centi);
parcelHelpers.export(exports, "milli", ()=>milli);
parcelHelpers.export(exports, "micro", ()=>micro);
parcelHelpers.export(exports, "nano", ()=>nano);
parcelHelpers.export(exports, "pico", ()=>pico);
parcelHelpers.export(exports, "femto", ()=>femto);
parcelHelpers.export(exports, "atto", ()=>atto);
parcelHelpers.export(exports, "zepto", ()=>zepto);
parcelHelpers.export(exports, "yocto", ()=>yocto);
parcelHelpers.export(exports, "prefix", ()=>prefix);
var _mathJs = require("./math.js");
const yotta = 1e24;
const zetta = 1e21;
const exa = 1e18;
const peta = 1e15;
const tera = 1e12;
const giga = 1e9;
const mega = 1e6;
const kilo = 1e3;
const hecto = 1e2;
const deca = 10;
const deci = 0.1;
const centi = 0.01;
const milli = 1e-3;
const micro = 1e-6;
const nano = 1e-9;
const pico = 1e-12;
const femto = 1e-15;
const atto = 1e-18;
const zepto = 1e-21;
const yocto = 1e-24;
const prefixUp = [
    '',
    'k',
    'M',
    'G',
    'T',
    'P',
    'E',
    'Z',
    'Y'
];
const prefixDown = [
    '',
    'm',
    "\u03BC",
    'n',
    'p',
    'f',
    'a',
    'z',
    'y'
];
const prefix = (n, baseMultiplier = 0)=>{
    const nPow = n === 0 ? 0 : _mathJs.log10(n);
    let mult = 0;
    while(nPow < mult * 3 && baseMultiplier > -8){
        baseMultiplier--;
        mult--;
    }
    while(nPow >= 3 + mult * 3 && baseMultiplier < 8){
        baseMultiplier++;
        mult++;
    }
    const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];
    return {
        n: _mathJs.round((mult > 0 ? n / _mathJs.exp10(mult * 3) : n * _mathJs.exp10(mult * -3)) * 1e12) / 1e12,
        prefix
    };
};

},{"./math.js":"jhXHz","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bzhu":[function(require,module,exports,__globalThis) {
/**
 * Utility functions to work with buffers (Uint8Array).
 *
 * @module buffer
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createUint8ArrayFromLen", ()=>createUint8ArrayFromLen);
parcelHelpers.export(exports, "createUint8ArrayViewFromArrayBuffer", ()=>createUint8ArrayViewFromArrayBuffer);
parcelHelpers.export(exports, "createUint8ArrayFromArrayBuffer", ()=>createUint8ArrayFromArrayBuffer);
parcelHelpers.export(exports, "toBase64", ()=>toBase64);
parcelHelpers.export(exports, "fromBase64", ()=>fromBase64);
parcelHelpers.export(exports, "toBase64UrlEncoded", ()=>toBase64UrlEncoded);
parcelHelpers.export(exports, "fromBase64UrlEncoded", ()=>fromBase64UrlEncoded);
parcelHelpers.export(exports, "toHexString", ()=>toHexString);
parcelHelpers.export(exports, "fromHexString", ()=>fromHexString);
parcelHelpers.export(exports, "copyUint8Array", ()=>copyUint8Array);
parcelHelpers.export(exports, "encodeAny", ()=>encodeAny);
parcelHelpers.export(exports, "decodeAny", ()=>decodeAny);
parcelHelpers.export(exports, "shiftNBitsLeft", ()=>shiftNBitsLeft);
var _stringJs = require("./string.js");
var _environmentJs = require("./environment.js");
var _arrayJs = require("./array.js");
var _mathJs = require("./math.js");
var _encodingJs = require("./encoding.js");
var _decodingJs = require("./decoding.js");
var Buffer = require("6475e0e5014d10a8").Buffer;
const createUint8ArrayFromLen = (len)=>new Uint8Array(len);
const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length)=>new Uint8Array(buffer, byteOffset, length);
const createUint8ArrayFromArrayBuffer = (buffer)=>new Uint8Array(buffer);
/* c8 ignore start */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Browser = (bytes)=>{
    let s = '';
    for(let i = 0; i < bytes.byteLength; i++)s += _stringJs.fromCharCode(bytes[i]);
    // eslint-disable-next-line no-undef
    return btoa(s);
};
/* c8 ignore stop */ /**
 * @param {Uint8Array} bytes
 * @return {string}
 */ const toBase64Node = (bytes)=>Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64');
/* c8 ignore start */ /**
 * @param {string} s
 * @return {Uint8Array}
 */ const fromBase64Browser = (s)=>{
    // eslint-disable-next-line no-undef
    const a = atob(s);
    const bytes = createUint8ArrayFromLen(a.length);
    for(let i = 0; i < a.length; i++)bytes[i] = a.charCodeAt(i);
    return bytes;
};
/* c8 ignore stop */ /**
 * @param {string} s
 */ const fromBase64Node = (s)=>{
    const buf = Buffer.from(s, 'base64');
    return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
const toBase64 = _environmentJs.isBrowser ? toBase64Browser : toBase64Node;
const fromBase64 = _environmentJs.isBrowser ? fromBase64Browser : fromBase64Node;
const toBase64UrlEncoded = (buf)=>toBase64(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
const fromBase64UrlEncoded = (base64)=>fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'));
const toHexString = (buf)=>_arrayJs.map(buf, (b)=>b.toString(16).padStart(2, '0')).join('');
const fromHexString = (hex)=>{
    const hlen = hex.length;
    const buf = new Uint8Array(_mathJs.ceil(hlen / 2));
    for(let i = 0; i < hlen; i += 2)buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16);
    return buf;
};
const copyUint8Array = (uint8Array)=>{
    const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
    newBuf.set(uint8Array);
    return newBuf;
};
const encodeAny = (data)=>_encodingJs.encode((encoder)=>_encodingJs.writeAny(encoder, data));
const decodeAny = (buf)=>_decodingJs.readAny(_decodingJs.createDecoder(buf));
const shiftNBitsLeft = (bs, N)=>{
    if (N === 0) return bs;
    bs = new Uint8Array(bs);
    bs[0] <<= N;
    for(let i = 1; i < bs.length; i++){
        bs[i - 1] |= bs[i] >>> 8 - N;
        bs[i] <<= N;
    }
    return bs;
};

},{"6475e0e5014d10a8":"fCgem","./string.js":"cA9Az","./environment.js":"h8wYT","./array.js":"ef0AT","./math.js":"jhXHz","./encoding.js":"9yVNx","./decoding.js":"ftn2I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fCgem":[function(require,module,exports,__globalThis) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ 'use strict';
const base64 = require("9c62938f1dccc73c");
const ieee754 = require("aceacb6a4531a9d2");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
 ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) throw new RangeError('The value "' + length + '" is invalid for option "size"');
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') throw new TypeError('The "string" argument must be of type string. Received type number');
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192 // not used by this implementation
;
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') return fromString(value, encodingOrOffset);
    if (ArrayBuffer.isView(value)) return fromArrayView(value);
    if (value == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) return fromArrayBuffer(value, encodingOrOffset, length);
    if (typeof value === 'number') throw new TypeError('The "value" argument must not be of type number. Received type number');
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') throw new TypeError('"size" argument must be of type number');
    else if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) return createBuffer(size);
    if (fill !== undefined) // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8';
    if (!Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1)buf[i] = array[i] & 255;
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
    if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let buf;
    if (byteOffset === undefined && length === undefined) buf = new Uint8Array(array);
    else if (length === undefined) buf = new Uint8Array(array, byteOffset);
    else buf = new Uint8Array(array, byteOffset, length);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) return buf;
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) return createBuffer(0);
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) return fromArrayLike(obj.data);
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + ' bytes');
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) length = 0;
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i)if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
    if (list.length === 0) return Buffer.alloc(0);
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i)length += list[i].length;
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else Uint8Array.prototype.set.call(buffer, buf, pos);
        } else if (!Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
        else buf.copy(buffer, pos);
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) return string.length;
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
    if (typeof string !== 'string') throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'ascii':
        case 'latin1':
        case 'binary':
            return len;
        case 'utf8':
        case 'utf-8':
            return utf8ToBytes(string).length;
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return len * 2;
        case 'hex':
            return len >>> 1;
        case 'base64':
            return base64ToBytes(string).length;
        default:
            if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
            ;
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) start = 0;
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) return '';
    if (end === undefined || end > this.length) end = this.length;
    if (end <= 0) return '';
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) return '';
    if (!encoding) encoding = 'utf8';
    while(true)switch(encoding){
        case 'hex':
            return hexSlice(this, start, end);
        case 'utf8':
        case 'utf-8':
            return utf8Slice(this, start, end);
        case 'ascii':
            return asciiSlice(this, start, end);
        case 'latin1':
        case 'binary':
            return latin1Slice(this, start, end);
        case 'base64':
            return base64Slice(this, start, end);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return utf16leSlice(this, start, end);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');
    for(let i = 0; i < len; i += 2)swap(this, i, i + 1);
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) target = Buffer.from(target, target.offset, target.byteLength);
    if (!Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    if (start === undefined) start = 0;
    if (end === undefined) end = target ? target.length : 0;
    if (thisStart === undefined) thisStart = 0;
    if (thisEnd === undefined) thisEnd = this.length;
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError('out of range index');
    if (thisStart >= thisEnd && start >= end) return 0;
    if (thisStart >= thisEnd) return -1;
    if (start >= end) return 1;
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i)if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff;
    else if (byteOffset < -2147483648) byteOffset = -2147483648;
    byteOffset = +byteOffset // Coerce to Number.
    ;
    if (numberIsNaN(byteOffset)) // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') val = Buffer.from(val, encoding);
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) return -1;
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        ;
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            else return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) return -1;
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) return buf[i];
        else return buf.readUInt16BE(i * indexSize);
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++)if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++)if (read(arr, i + j) !== read(val, j)) {
                found = false;
                break;
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) length = remaining;
    else {
        length = Number(length);
        if (length > remaining) length = remaining;
    }
    const strLen = string.length;
    if (length > strLen / 2) length = strLen / 2;
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError('Attempt to write outside buffer bounds');
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;)switch(encoding){
        case 'hex':
            return hexWrite(this, string, offset, length);
        case 'utf8':
        case 'utf-8':
            return utf8Write(this, string, offset, length);
        case 'ascii':
        case 'latin1':
        case 'binary':
            return asciiWrite(this, string, offset, length);
        case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return ucs2Write(this, string, offset, length);
        default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) return base64.fromByteArray(buf);
    else return base64.fromByteArray(buf.slice(start, end));
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) codePoint = firstByte;
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) codePoint = tempCodePoint;
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) codePoint = tempCodePoint;
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) codePoint = tempCodePoint;
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    ;
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len)res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i] & 0x7F);
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i)ret += String.fromCharCode(buf[i]);
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i)out += hexSliceLookupTable[buf[i]];
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2)res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) start = len;
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) end = len;
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100))val += this[offset + --byteLength] * mul;
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const lo = first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 256 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100))val += this[offset + i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100))val += this[offset + --i] * mul;
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = this[offset + 4] + this[offset + 5] * 256 + this[offset + 6] * 2 ** 16 + (last << 24 // Overflow
    );
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 256 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) boundsError(offset, this.length - 8);
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 256 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 256 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100))this[offset + i] = value / mul & 0xFF;
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) sub = 1;
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -340282346638528860000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) throw new RangeError('targetStart out of bounds');
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) end = target.length - targetStart + start;
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
    else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') throw new TypeError('encoding must be a string');
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) throw new TypeError('Unknown encoding: ' + encoding);
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
        }
    } else if (typeof val === 'number') val = val & 255;
    else if (typeof val === 'boolean') val = Number(val);
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) throw new RangeError('Out of range index');
    if (end <= start) return this;
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') for(i = start; i < end; ++i)this[i] = val;
    else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        for(i = 0; i < end - start; ++i)this[i + start] = bytes[i % len];
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack // eslint-disable-line no-unused-expressions
            ;
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) return `${name} is outside of buffer bounds`;
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) received = addNumericalSeparator(String(input));
    else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) received = addNumericalSeparator(received);
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3)res = `_${val.slice(i - 3, i)}${res}`;
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) boundsError(offset, buf.length - (byteLength + 1));
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            else range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
        } else range = `>= ${min}${n} and <= ${max}${n}`;
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0)str = str + '=';
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) // valid bmp char, but last char was a lead
        {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else throw new Error('Invalid code point');
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i)// Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j)table[i16 + j] = alphabet[i] + alphabet[j];
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}

},{"9c62938f1dccc73c":"eIiSV","aceacb6a4531a9d2":"cO95r"}],"eIiSV":[function(require,module,exports,__globalThis) {
'use strict';
exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4');
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength)parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}

},{}],"cO95r":[function(require,module,exports,__globalThis) {
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);
    if (e === 0) e = 1 - eBias;
    else if (e === eMax) return m ? NaN : (s ? -1 : 1) * Infinity;
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) value += rt / c;
        else value += rt * Math.pow(2, 1 - eBias);
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);
    buffer[offset + i - d] |= s * 128;
};

},{}],"h8wYT":[function(require,module,exports,__globalThis) {
/**
 * Isomorphic module to work access the environment (query params, env variables).
 *
 * @module environment
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isNode", ()=>isNode);
parcelHelpers.export(exports, "isBrowser", ()=>isBrowser);
parcelHelpers.export(exports, "isMac", ()=>isMac);
parcelHelpers.export(exports, "hasParam", ()=>hasParam);
parcelHelpers.export(exports, "getParam", ()=>getParam);
parcelHelpers.export(exports, "getVariable", ()=>getVariable);
parcelHelpers.export(exports, "getConf", ()=>getConf);
parcelHelpers.export(exports, "ensureConf", ()=>ensureConf);
parcelHelpers.export(exports, "hasConf", ()=>hasConf);
parcelHelpers.export(exports, "production", ()=>production);
parcelHelpers.export(exports, "supportsColor", ()=>supportsColor);
var _mapJs = require("./map.js");
var _stringJs = require("./string.js");
var _conditionsJs = require("./conditions.js");
var _storageJs = require("./storage.js");
var _functionJs = require("./function.js");
var process = require("2cfb8bcef1022e2a");
const isNode = typeof process !== 'undefined' && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode;
const isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
/**
 * @type {Map<string,string>}
 */ let params;
const args = [];
/* c8 ignore start */ const computeParams = ()=>{
    if (params === undefined) {
        if (isNode) {
            params = _mapJs.create();
            const pargs = process.argv;
            let currParamName = null;
            for(let i = 0; i < pargs.length; i++){
                const parg = pargs[i];
                if (parg[0] === '-') {
                    if (currParamName !== null) params.set(currParamName, '');
                    currParamName = parg;
                } else if (currParamName !== null) {
                    params.set(currParamName, parg);
                    currParamName = null;
                } else args.push(parg);
            }
            if (currParamName !== null) params.set(currParamName, '');
        // in ReactNative for example this would not be true (unless connected to the Remote Debugger)
        } else if (typeof location === 'object') {
            params = _mapJs.create(); // eslint-disable-next-line no-undef
            (location.search || '?').slice(1).split('&').forEach((kv)=>{
                if (kv.length !== 0) {
                    const [key, value] = kv.split('=');
                    params.set(`--${_stringJs.fromCamelCase(key, '-')}`, value);
                    params.set(`-${_stringJs.fromCamelCase(key, '-')}`, value);
                }
            });
        } else params = _mapJs.create();
    }
    return params;
};
const hasParam = (name)=>computeParams().has(name);
const getParam = (name, defaultVal)=>computeParams().get(name) || defaultVal;
const getVariable = (name)=>isNode ? _conditionsJs.undefinedToNull(process.env[name.toUpperCase().replaceAll('-', '_')]) : _conditionsJs.undefinedToNull(_storageJs.varStorage.getItem(name));
const getConf = (name)=>computeParams().get('--' + name) || getVariable(name);
const ensureConf = (name)=>{
    const c = getConf(name);
    if (c == null) throw new Error(`Expected configuration "${name.toUpperCase().replaceAll('-', '_')}"`);
    return c;
};
const hasConf = (name)=>hasParam('--' + name) || getVariable(name) !== null;
const production = hasConf('production');
/* c8 ignore next 2 */ const forceColor = isNode && _functionJs.isOneOf(undefined, [
    'true',
    '1',
    '2'
]);
const supportsColor = forceColor || !hasParam('--no-colors') && // @todo deprecate --no-colors
!hasConf('no-color') && (!isNode || process.stdout.isTTY) && (!isNode || hasParam('--color') || getVariable('COLORTERM') !== null || (getVariable('TERM') || '').includes('color')) /* c8 ignore stop */ ;

},{"2cfb8bcef1022e2a":"d5jf4","./map.js":"eE1vX","./string.js":"cA9Az","./conditions.js":"dJDk6","./storage.js":"9FcRV","./function.js":"1O0Qj","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d5jf4":[function(require,module,exports,__globalThis) {
// shim for using process in browser
var process = module.exports = {};
// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function() {
    try {
        if (typeof setTimeout === 'function') cachedSetTimeout = setTimeout;
        else cachedSetTimeout = defaultSetTimout;
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') cachedClearTimeout = clearTimeout;
        else cachedClearTimeout = defaultClearTimeout;
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) //normal enviroments in sane situations
    return setTimeout(fun, 0);
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) //normal enviroments in sane situations
    return clearTimeout(marker);
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
    if (!draining || !currentQueue) return;
    draining = false;
    if (currentQueue.length) queue = currentQueue.concat(queue);
    else queueIndex = -1;
    if (queue.length) drainQueue();
}
function drainQueue() {
    if (draining) return;
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while(len){
        currentQueue = queue;
        queue = [];
        while(++queueIndex < len)if (currentQueue) currentQueue[queueIndex].run();
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) runTimeout(drainQueue);
};
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
    return [];
};
process.binding = function(name) {
    throw new Error('process.binding is not supported');
};
process.cwd = function() {
    return '/';
};
process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() {
    return 0;
};

},{}],"dJDk6":[function(require,module,exports,__globalThis) {
/**
 * Often used conditions.
 *
 * @module conditions
 */ /**
 * @template T
 * @param {T|null|undefined} v
 * @return {T|null}
 */ /* c8 ignore next */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "undefinedToNull", ()=>undefinedToNull);
const undefinedToNull = (v)=>v === undefined ? null : v;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9FcRV":[function(require,module,exports,__globalThis) {
/* eslint-env browser */ /**
 * Isomorphic variable storage.
 *
 * Uses LocalStorage in the browser and falls back to in-memory storage.
 *
 * @module storage
 */ /* c8 ignore start */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "varStorage", ()=>varStorage);
parcelHelpers.export(exports, "onChange", ()=>onChange);
parcelHelpers.export(exports, "offChange", ()=>offChange);
class VarStoragePolyfill {
    constructor(){
        this.map = new Map();
    }
    /**
   * @param {string} key
   * @param {any} newValue
   */ setItem(key, newValue) {
        this.map.set(key, newValue);
    }
    /**
   * @param {string} key
   */ getItem(key) {
        return this.map.get(key);
    }
}
/* c8 ignore stop */ /**
 * @type {any}
 */ let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
/* c8 ignore start */ try {
    // if the same-origin rule is violated, accessing localStorage might thrown an error
    if (typeof localStorage !== 'undefined' && localStorage) {
        _localStorage = localStorage;
        usePolyfill = false;
    }
} catch (e) {}
const varStorage = _localStorage;
const onChange = (eventHandler)=>usePolyfill || addEventListener('storage', /** @type {any} */ eventHandler);
const offChange = (eventHandler)=>usePolyfill || removeEventListener('storage', /** @type {any} */ eventHandler);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1O0Qj":[function(require,module,exports,__globalThis) {
/**
 * Common functions and function call helpers.
 *
 * @module function
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "callAll", ()=>callAll);
parcelHelpers.export(exports, "nop", ()=>nop);
parcelHelpers.export(exports, "apply", ()=>apply);
parcelHelpers.export(exports, "id", ()=>id);
parcelHelpers.export(exports, "equalityStrict", ()=>equalityStrict);
parcelHelpers.export(exports, "equalityFlat", ()=>equalityFlat);
parcelHelpers.export(exports, "equalityDeep", ()=>equalityDeep);
parcelHelpers.export(exports, "isOneOf", ()=>isOneOf);
parcelHelpers.export(exports, "isArray", ()=>isArray);
parcelHelpers.export(exports, "isString", ()=>isString);
parcelHelpers.export(exports, "isNumber", ()=>isNumber);
parcelHelpers.export(exports, "is", ()=>is);
parcelHelpers.export(exports, "isTemplate", ()=>isTemplate);
var _arrayJs = require("./array.js");
var _objectJs = require("./object.js");
const callAll = (fs, args, i = 0)=>{
    try {
        for(; i < fs.length; i++)fs[i](...args);
    } finally{
        if (i < fs.length) callAll(fs, args, i + 1);
    }
};
const nop = ()=>{};
const apply = (f)=>f();
const id = (a)=>a;
const equalityStrict = (a, b)=>a === b;
const equalityFlat = (a, b)=>a === b || a != null && b != null && a.constructor === b.constructor && (_arrayJs.isArray(a) && _arrayJs.equalFlat(a, /** @type {Array<T>} */ b) || typeof a === 'object' && _objectJs.equalFlat(a, b));
const equalityDeep = (a, b)=>{
    if (a == null || b == null) return equalityStrict(a, b);
    if (a.constructor !== b.constructor) return false;
    if (a === b) return true;
    switch(a.constructor){
        case ArrayBuffer:
            a = new Uint8Array(a);
            b = new Uint8Array(b);
        // eslint-disable-next-line no-fallthrough
        case Uint8Array:
            if (a.byteLength !== b.byteLength) return false;
            for(let i = 0; i < a.length; i++){
                if (a[i] !== b[i]) return false;
            }
            break;
        case Set:
            if (a.size !== b.size) return false;
            for (const value of a){
                if (!b.has(value)) return false;
            }
            break;
        case Map:
            if (a.size !== b.size) return false;
            for (const key of a.keys()){
                if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) return false;
            }
            break;
        case Object:
            if (_objectJs.length(a) !== _objectJs.length(b)) return false;
            for(const key in a){
                if (!_objectJs.hasProperty(a, key) || !equalityDeep(a[key], b[key])) return false;
            }
            break;
        case Array:
            if (a.length !== b.length) return false;
            for(let i = 0; i < a.length; i++){
                if (!equalityDeep(a[i], b[i])) return false;
            }
            break;
        default:
            return false;
    }
    return true;
};
const isOneOf = (value, options)=>options.includes(value);
const isArray = _arrayJs.isArray;
const isString = (s)=>s && s.constructor === String;
const isNumber = (n)=>n != null && n.constructor === Number;
const is = (n, T)=>n && n.constructor === T;
const isTemplate = (T)=>/**
   * @param {any} n
   * @return {n is InstanceType<TYPE>}
   **/ (n)=>n && n.constructor === T;

},{"./array.js":"ef0AT","./object.js":"4uXcx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4uXcx":[function(require,module,exports,__globalThis) {
/**
 * Utility functions for working with EcmaScript objects.
 *
 * @module object
 */ /**
 * @return {Object<string,any>} obj
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "assign", ()=>assign);
parcelHelpers.export(exports, "keys", ()=>keys);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "map", ()=>map);
parcelHelpers.export(exports, "length", ()=>length);
parcelHelpers.export(exports, "size", ()=>size);
parcelHelpers.export(exports, "some", ()=>some);
parcelHelpers.export(exports, "isEmpty", ()=>isEmpty);
parcelHelpers.export(exports, "every", ()=>every);
parcelHelpers.export(exports, "hasProperty", ()=>hasProperty);
parcelHelpers.export(exports, "equalFlat", ()=>equalFlat);
parcelHelpers.export(exports, "freeze", ()=>freeze);
parcelHelpers.export(exports, "deepFreeze", ()=>deepFreeze);
const create = ()=>Object.create(null);
const assign = Object.assign;
const keys = Object.keys;
const forEach = (obj, f)=>{
    for(const key in obj)f(obj[key], key);
};
const map = (obj, f)=>{
    const results = [];
    for(const key in obj)results.push(f(obj[key], key));
    return results;
};
const length = (obj)=>keys(obj).length;
const size = (obj)=>keys(obj).length;
const some = (obj, f)=>{
    for(const key in obj){
        if (f(obj[key], key)) return true;
    }
    return false;
};
const isEmpty = (obj)=>{
    // eslint-disable-next-line
    for(const _k in obj)return false;
    return true;
};
const every = (obj, f)=>{
    for(const key in obj){
        if (!f(obj[key], key)) return false;
    }
    return true;
};
const hasProperty = (obj, key)=>Object.prototype.hasOwnProperty.call(obj, key);
const equalFlat = (a, b)=>a === b || size(a) === size(b) && every(a, (val, key)=>(val !== undefined || hasProperty(b, key)) && b[key] === val);
const freeze = Object.freeze;
const deepFreeze = (o)=>{
    for(const key in o){
        const c = o[key];
        if (typeof c === 'object' || typeof c === 'function') deepFreeze(o[key]);
    }
    return freeze(o);
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klpvH":[function(require,module,exports,__globalThis) {
/**
 * Isomorphic logging module with support for colors!
 *
 * @module logging
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BOLD", ()=>(0, _loggingCommonJs.BOLD));
parcelHelpers.export(exports, "UNBOLD", ()=>(0, _loggingCommonJs.UNBOLD));
parcelHelpers.export(exports, "BLUE", ()=>(0, _loggingCommonJs.BLUE));
parcelHelpers.export(exports, "GREY", ()=>(0, _loggingCommonJs.GREY));
parcelHelpers.export(exports, "GREEN", ()=>(0, _loggingCommonJs.GREEN));
parcelHelpers.export(exports, "RED", ()=>(0, _loggingCommonJs.RED));
parcelHelpers.export(exports, "PURPLE", ()=>(0, _loggingCommonJs.PURPLE));
parcelHelpers.export(exports, "ORANGE", ()=>(0, _loggingCommonJs.ORANGE));
parcelHelpers.export(exports, "UNCOLOR", ()=>(0, _loggingCommonJs.UNCOLOR));
parcelHelpers.export(exports, "print", ()=>print);
parcelHelpers.export(exports, "warn", ()=>warn);
parcelHelpers.export(exports, "printError", ()=>printError);
parcelHelpers.export(exports, "printImg", ()=>printImg);
parcelHelpers.export(exports, "printImgBase64", ()=>printImgBase64);
parcelHelpers.export(exports, "group", ()=>group);
parcelHelpers.export(exports, "groupCollapsed", ()=>groupCollapsed);
parcelHelpers.export(exports, "groupEnd", ()=>groupEnd);
parcelHelpers.export(exports, "printDom", ()=>printDom);
parcelHelpers.export(exports, "printCanvas", ()=>printCanvas);
parcelHelpers.export(exports, "vconsoles", ()=>vconsoles);
/* c8 ignore start */ parcelHelpers.export(exports, "VConsole", ()=>VConsole);
parcelHelpers.export(exports, "createVConsole", ()=>createVConsole);
parcelHelpers.export(exports, "createModuleLogger", ()=>createModuleLogger);
var _environmentJs = require("./environment.js");
var _setJs = require("./set.js");
var _pairJs = require("./pair.js");
var _domJs = require("./dom.js");
var _jsonJs = require("./json.js");
var _mapJs = require("./map.js");
var _eventloopJs = require("./eventloop.js");
var _mathJs = require("./math.js");
var _loggingCommonJs = require("./logging.common.js");
/**
 * @type {Object<Symbol,pair.Pair<string,string>>}
 */ const _browserStyleMap = {
    [_loggingCommonJs.BOLD]: _pairJs.create('font-weight', 'bold'),
    [_loggingCommonJs.UNBOLD]: _pairJs.create('font-weight', 'normal'),
    [_loggingCommonJs.BLUE]: _pairJs.create('color', 'blue'),
    [_loggingCommonJs.GREEN]: _pairJs.create('color', 'green'),
    [_loggingCommonJs.GREY]: _pairJs.create('color', 'grey'),
    [_loggingCommonJs.RED]: _pairJs.create('color', 'red'),
    [_loggingCommonJs.PURPLE]: _pairJs.create('color', 'purple'),
    [_loggingCommonJs.ORANGE]: _pairJs.create('color', 'orange'),
    [_loggingCommonJs.UNCOLOR]: _pairJs.create('color', 'black')
};
/**
 * @param {Array<string|Symbol|Object|number|function():any>} args
 * @return {Array<string|object|number>}
 */ /* c8 ignore start */ const computeBrowserLoggingArgs = (args)=>{
    if (args.length === 1 && args[0]?.constructor === Function) args = /** @type {Array<string|Symbol|Object|number>} */ /** @type {[function]} */ args[0]();
    const strBuilder = [];
    const styles = [];
    const currentStyle = _mapJs.create();
    /**
   * @type {Array<string|Object|number>}
   */ let logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) currentStyle.set(style.left, style.right);
        else {
            if (arg === undefined) break;
            if (arg.constructor === String || arg.constructor === Number) {
                const style = _domJs.mapToStyleString(currentStyle);
                if (i > 0 || style.length > 0) {
                    strBuilder.push('%c' + arg);
                    styles.push(style);
                } else strBuilder.push(arg);
            } else break;
        }
    }
    if (i > 0) {
        // create logArgs with what we have so far
        logArgs = styles;
        logArgs.unshift(strBuilder.join(''));
    }
    // append the rest
    for(; i < args.length; i++){
        const arg = args[i];
        if (!(arg instanceof Symbol)) logArgs.push(arg);
    }
    return logArgs;
};
/* c8 ignore stop */ /* c8 ignore start */ const computeLoggingArgs = _environmentJs.supportsColor ? computeBrowserLoggingArgs : _loggingCommonJs.computeNoColorLoggingArgs;
const print = (...args)=>{
    console.log(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.print(args));
};
const warn = (...args)=>{
    console.warn(...computeLoggingArgs(args));
    args.unshift(_loggingCommonJs.ORANGE);
    vconsoles.forEach((vc)=>vc.print(args));
};
const printError = (err)=>{
    console.error(err);
    vconsoles.forEach((vc)=>vc.printError(err));
};
const printImg = (url, height)=>{
    if (_environmentJs.isBrowser) console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`);
    vconsoles.forEach((vc)=>vc.printImg(url, height));
};
const printImgBase64 = (base64, height)=>printImg(`data:image/gif;base64,${base64}`, height);
const group = (...args)=>{
    console.group(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.group(args));
};
const groupCollapsed = (...args)=>{
    console.groupCollapsed(...computeLoggingArgs(args));
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupCollapsed(args));
};
const groupEnd = ()=>{
    console.groupEnd();
    /* c8 ignore next */ vconsoles.forEach((vc)=>vc.groupEnd());
};
const printDom = (createNode)=>vconsoles.forEach((vc)=>vc.printDom(createNode()));
const printCanvas = (canvas, height)=>printImg(canvas.toDataURL(), height);
const vconsoles = _setJs.create();
/**
 * @param {Array<string|Symbol|Object|number>} args
 * @return {Array<Element>}
 */ /* c8 ignore start */ const _computeLineSpans = (args)=>{
    const spans = [];
    const currentStyle = new Map();
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        let arg = args[i];
        // @ts-ignore
        const style = _browserStyleMap[arg];
        if (style !== undefined) currentStyle.set(style.left, style.right);
        else {
            if (arg === undefined) arg = 'undefined ';
            if (arg.constructor === String || arg.constructor === Number) {
                // @ts-ignore
                const span = _domJs.element('span', [
                    _pairJs.create('style', _domJs.mapToStyleString(currentStyle))
                ], [
                    _domJs.text(arg.toString())
                ]);
                if (span.innerHTML === '') span.innerHTML = '&nbsp;';
                spans.push(span);
            } else break;
        }
    }
    // append the rest
    for(; i < args.length; i++){
        let content = args[i];
        if (!(content instanceof Symbol)) {
            if (content.constructor !== String && content.constructor !== Number) content = ' ' + _jsonJs.stringify(content) + ' ';
            spans.push(_domJs.element('span', [], [
                _domJs.text(/** @type {string} */ content)
            ]));
        }
    }
    return spans;
};
/* c8 ignore stop */ const lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;';
class VConsole {
    /**
   * @param {Element} dom
   */ constructor(dom){
        this.dom = dom;
        /**
     * @type {Element}
     */ this.ccontainer = this.dom;
        this.depth = 0;
        vconsoles.add(this);
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   * @param {boolean} collapsed
   */ group(args, collapsed = false) {
        _eventloopJs.enqueue(()=>{
            const triangleDown = _domJs.element('span', [
                _pairJs.create('hidden', collapsed),
                _pairJs.create('style', 'color:grey;font-size:120%;')
            ], [
                _domJs.text("\u25BC")
            ]);
            const triangleRight = _domJs.element('span', [
                _pairJs.create('hidden', !collapsed),
                _pairJs.create('style', 'color:grey;font-size:125%;')
            ], [
                _domJs.text("\u25B6")
            ]);
            const content = _domJs.element('div', [
                _pairJs.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)
            ], [
                triangleDown,
                triangleRight,
                _domJs.text(' ')
            ].concat(_computeLineSpans(args)));
            const nextContainer = _domJs.element('div', [
                _pairJs.create('hidden', collapsed)
            ]);
            const nextLine = _domJs.element('div', [], [
                content,
                nextContainer
            ]);
            _domJs.append(this.ccontainer, [
                nextLine
            ]);
            this.ccontainer = nextContainer;
            this.depth++;
            // when header is clicked, collapse/uncollapse container
            _domJs.addEventListener(content, 'click', (_event)=>{
                nextContainer.toggleAttribute('hidden');
                triangleDown.toggleAttribute('hidden');
                triangleRight.toggleAttribute('hidden');
            });
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ groupCollapsed(args) {
        this.group(args, true);
    }
    groupEnd() {
        _eventloopJs.enqueue(()=>{
            if (this.depth > 0) {
                this.depth--;
                // @ts-ignore
                this.ccontainer = this.ccontainer.parentElement.parentElement;
            }
        });
    }
    /**
   * @param {Array<string|Symbol|Object|number>} args
   */ print(args) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                _domJs.element('div', [
                    _pairJs.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)
                ], _computeLineSpans(args))
            ]);
        });
    }
    /**
   * @param {Error} err
   */ printError(err) {
        this.print([
            _loggingCommonJs.RED,
            _loggingCommonJs.BOLD,
            err.toString()
        ]);
    }
    /**
   * @param {string} url
   * @param {number} height
   */ printImg(url, height) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                _domJs.element('img', [
                    _pairJs.create('src', url),
                    _pairJs.create('height', `${_mathJs.round(height * 1.5)}px`)
                ])
            ]);
        });
    }
    /**
   * @param {Node} node
   */ printDom(node) {
        _eventloopJs.enqueue(()=>{
            _domJs.append(this.ccontainer, [
                node
            ]);
        });
    }
    destroy() {
        _eventloopJs.enqueue(()=>{
            vconsoles.delete(this);
        });
    }
}
const createVConsole = (dom)=>new VConsole(dom);
const createModuleLogger = (moduleName)=>_loggingCommonJs.createModuleLogger(print, moduleName);

},{"./environment.js":"h8wYT","./set.js":"iWXeP","./pair.js":"blx5T","./dom.js":"8bgtn","./json.js":"kW79v","./map.js":"eE1vX","./eventloop.js":"4SpJZ","./math.js":"jhXHz","./logging.common.js":"fApod","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"blx5T":[function(require,module,exports,__globalThis) {
/**
 * Working with value pairs.
 *
 * @module pair
 */ /**
 * @template L,R
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Pair", ()=>Pair);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "createReversed", ()=>createReversed);
parcelHelpers.export(exports, "forEach", ()=>forEach);
parcelHelpers.export(exports, "map", ()=>map);
class Pair {
    /**
   * @param {L} left
   * @param {R} right
   */ constructor(left, right){
        this.left = left;
        this.right = right;
    }
}
const create = (left, right)=>new Pair(left, right);
const createReversed = (right, left)=>new Pair(left, right);
const forEach = (arr, f)=>arr.forEach((p)=>f(p.left, p.right));
const map = (arr, f)=>arr.map((p)=>f(p.left, p.right));

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bgtn":[function(require,module,exports,__globalThis) {
/* eslint-env browser */ /**
 * Utility module to work with the DOM.
 *
 * @module dom
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "doc", ()=>doc);
parcelHelpers.export(exports, "createElement", ()=>createElement);
parcelHelpers.export(exports, "createDocumentFragment", ()=>createDocumentFragment);
parcelHelpers.export(exports, "createTextNode", ()=>createTextNode);
parcelHelpers.export(exports, "domParser", ()=>domParser);
parcelHelpers.export(exports, "emitCustomEvent", ()=>emitCustomEvent);
parcelHelpers.export(exports, "setAttributes", ()=>setAttributes);
parcelHelpers.export(exports, "setAttributesMap", ()=>setAttributesMap);
parcelHelpers.export(exports, "fragment", ()=>fragment);
parcelHelpers.export(exports, "append", ()=>append);
parcelHelpers.export(exports, "remove", ()=>remove);
parcelHelpers.export(exports, "addEventListener", ()=>addEventListener);
parcelHelpers.export(exports, "removeEventListener", ()=>removeEventListener);
parcelHelpers.export(exports, "addEventListeners", ()=>addEventListeners);
parcelHelpers.export(exports, "removeEventListeners", ()=>removeEventListeners);
parcelHelpers.export(exports, "element", ()=>element);
parcelHelpers.export(exports, "canvas", ()=>canvas);
parcelHelpers.export(exports, "text", ()=>text);
parcelHelpers.export(exports, "pairToStyleString", ()=>pairToStyleString);
parcelHelpers.export(exports, "pairsToStyleString", ()=>pairsToStyleString);
parcelHelpers.export(exports, "mapToStyleString", ()=>mapToStyleString);
parcelHelpers.export(exports, "querySelector", ()=>querySelector);
parcelHelpers.export(exports, "querySelectorAll", ()=>querySelectorAll);
parcelHelpers.export(exports, "getElementById", ()=>getElementById);
parcelHelpers.export(exports, "parseFragment", ()=>parseFragment);
parcelHelpers.export(exports, "parseElement", ()=>parseElement);
parcelHelpers.export(exports, "replaceWith", ()=>replaceWith);
parcelHelpers.export(exports, "insertBefore", ()=>insertBefore);
parcelHelpers.export(exports, "appendChild", ()=>appendChild);
parcelHelpers.export(exports, "ELEMENT_NODE", ()=>ELEMENT_NODE);
parcelHelpers.export(exports, "TEXT_NODE", ()=>TEXT_NODE);
parcelHelpers.export(exports, "CDATA_SECTION_NODE", ()=>CDATA_SECTION_NODE);
parcelHelpers.export(exports, "COMMENT_NODE", ()=>COMMENT_NODE);
parcelHelpers.export(exports, "DOCUMENT_NODE", ()=>DOCUMENT_NODE);
parcelHelpers.export(exports, "DOCUMENT_TYPE_NODE", ()=>DOCUMENT_TYPE_NODE);
parcelHelpers.export(exports, "DOCUMENT_FRAGMENT_NODE", ()=>DOCUMENT_FRAGMENT_NODE);
parcelHelpers.export(exports, "checkNodeType", ()=>checkNodeType);
parcelHelpers.export(exports, "isParentOf", ()=>isParentOf);
var _pairJs = require("./pair.js");
var _mapJs = require("./map.js");
const doc = /** @type {Document} */ typeof document !== 'undefined' ? document : {};
const createElement = (name)=>doc.createElement(name);
const createDocumentFragment = ()=>doc.createDocumentFragment();
const createTextNode = (text)=>doc.createTextNode(text);
const domParser = /** @type {DOMParser} */ typeof DOMParser !== 'undefined' ? new DOMParser() : null;
const emitCustomEvent = (el, name, opts)=>el.dispatchEvent(new CustomEvent(name, opts));
const setAttributes = (el, attrs)=>{
    _pairJs.forEach(attrs, (key, value)=>{
        if (value === false) el.removeAttribute(key);
        else if (value === true) el.setAttribute(key, '');
        else // @ts-ignore
        el.setAttribute(key, value);
    });
    return el;
};
const setAttributesMap = (el, attrs)=>{
    attrs.forEach((value, key)=>{
        el.setAttribute(key, value);
    });
    return el;
};
const fragment = (children)=>{
    const fragment = createDocumentFragment();
    for(let i = 0; i < children.length; i++)appendChild(fragment, children[i]);
    return fragment;
};
const append = (parent, nodes)=>{
    appendChild(parent, fragment(nodes));
    return parent;
};
const remove = (el)=>el.remove();
const addEventListener = (el, name, f)=>el.addEventListener(name, f);
const removeEventListener = (el, name, f)=>el.removeEventListener(name, f);
const addEventListeners = (node, listeners)=>{
    _pairJs.forEach(listeners, (name, f)=>addEventListener(node, name, f));
    return node;
};
const removeEventListeners = (node, listeners)=>{
    _pairJs.forEach(listeners, (name, f)=>removeEventListener(node, name, f));
    return node;
};
const element = (name, attrs = [], children = [])=>append(setAttributes(createElement(name), attrs), children);
const canvas = (width, height)=>{
    const c = /** @type {HTMLCanvasElement} */ createElement('canvas');
    c.height = height;
    c.width = width;
    return c;
};
const text = createTextNode;
const pairToStyleString = (pair)=>`${pair.left}:${pair.right};`;
const pairsToStyleString = (pairs)=>pairs.map(pairToStyleString).join('');
const mapToStyleString = (m)=>_mapJs.map(m, (value, key)=>`${key}:${value};`).join('');
const querySelector = (el, query)=>el.querySelector(query);
const querySelectorAll = (el, query)=>el.querySelectorAll(query);
const getElementById = (id)=>/** @type {HTMLElement} */ doc.getElementById(id);
/**
 * @param {string} html
 * @return {HTMLElement}
 */ const _parse = (html)=>domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body;
const parseFragment = (html)=>fragment(/** @type {any} */ _parse(html).childNodes);
const parseElement = (html)=>/** @type HTMLElement */ _parse(html).firstElementChild;
const replaceWith = (oldEl, newEl)=>oldEl.replaceWith(newEl);
const insertBefore = (parent, el, ref)=>parent.insertBefore(el, ref);
const appendChild = (parent, child)=>parent.appendChild(child);
const ELEMENT_NODE = doc.ELEMENT_NODE;
const TEXT_NODE = doc.TEXT_NODE;
const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
const COMMENT_NODE = doc.COMMENT_NODE;
const DOCUMENT_NODE = doc.DOCUMENT_NODE;
const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;
const checkNodeType = (node, type)=>node.nodeType === type;
const isParentOf = (parent, child)=>{
    let p = child.parentNode;
    while(p && p !== parent)p = p.parentNode;
    return p === parent;
} /* c8 ignore stop */ ;

},{"./pair.js":"blx5T","./map.js":"eE1vX","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kW79v":[function(require,module,exports,__globalThis) {
/**
 * JSON utility functions.
 *
 * @module json
 */ /**
 * Transform JavaScript object to JSON.
 *
 * @param {any} object
 * @return {string}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "stringify", ()=>stringify);
parcelHelpers.export(exports, "parse", ()=>parse);
const stringify = JSON.stringify;
const parse = JSON.parse;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4SpJZ":[function(require,module,exports,__globalThis) {
/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */ /**
 * Utility module to work with EcmaScript's event loop.
 *
 * @module eventloop
 */ /**
 * @type {Array<function>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "enqueue", ()=>enqueue);
parcelHelpers.export(exports, "timeout", ()=>timeout);
parcelHelpers.export(exports, "interval", ()=>interval);
parcelHelpers.export(exports, "Animation", ()=>Animation);
parcelHelpers.export(exports, "animationFrame", ()=>animationFrame);
parcelHelpers.export(exports, "idleCallback", ()=>idleCallback);
parcelHelpers.export(exports, "createDebouncer", ()=>createDebouncer);
let queue = [];
const _runQueue = ()=>{
    for(let i = 0; i < queue.length; i++)queue[i]();
    queue = [];
};
const enqueue = (f)=>{
    queue.push(f);
    if (queue.length === 1) setTimeout(_runQueue, 0);
};
/**
 * @typedef {Object} TimeoutObject
 * @property {function} TimeoutObject.destroy
 */ /**
 * @param {function(number):void} clearFunction
 */ const createTimeoutClass = (clearFunction)=>class TT {
        /**
   * @param {number} timeoutId
   */ constructor(timeoutId){
            this._ = timeoutId;
        }
        destroy() {
            clearFunction(this._);
        }
    };
const Timeout = createTimeoutClass(clearTimeout);
const timeout = (timeout, callback)=>new Timeout(setTimeout(callback, timeout));
const Interval = createTimeoutClass(clearInterval);
const interval = (timeout, callback)=>new Interval(setInterval(callback, timeout));
const Animation = createTimeoutClass((arg)=>typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg));
const animationFrame = (cb)=>typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb));
/* c8 ignore next */ // @ts-ignore
const Idle = createTimeoutClass((arg)=>typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg));
const idleCallback = (cb)=>typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb);
const createDebouncer = (timeout)=>{
    let timer = -1;
    return (f)=>{
        clearTimeout(timer);
        if (f) timer = /** @type {any} */ setTimeout(f, timeout);
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fApod":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BOLD", ()=>BOLD);
parcelHelpers.export(exports, "UNBOLD", ()=>UNBOLD);
parcelHelpers.export(exports, "BLUE", ()=>BLUE);
parcelHelpers.export(exports, "GREY", ()=>GREY);
parcelHelpers.export(exports, "GREEN", ()=>GREEN);
parcelHelpers.export(exports, "RED", ()=>RED);
parcelHelpers.export(exports, "PURPLE", ()=>PURPLE);
parcelHelpers.export(exports, "ORANGE", ()=>ORANGE);
parcelHelpers.export(exports, "UNCOLOR", ()=>UNCOLOR);
parcelHelpers.export(exports, "computeNoColorLoggingArgs", ()=>computeNoColorLoggingArgs);
parcelHelpers.export(exports, "createModuleLogger", ()=>createModuleLogger);
var _symbolJs = require("./symbol.js");
var _timeJs = require("./time.js");
var _environmentJs = require("./environment.js");
var _functionJs = require("./function.js");
var _jsonJs = require("./json.js");
const BOLD = _symbolJs.create();
const UNBOLD = _symbolJs.create();
const BLUE = _symbolJs.create();
const GREY = _symbolJs.create();
const GREEN = _symbolJs.create();
const RED = _symbolJs.create();
const PURPLE = _symbolJs.create();
const ORANGE = _symbolJs.create();
const UNCOLOR = _symbolJs.create();
const computeNoColorLoggingArgs = (args)=>{
    if (args.length === 1 && args[0]?.constructor === Function) args = /** @type {Array<string|Symbol|Object|number>} */ /** @type {[function]} */ args[0]();
    const strBuilder = [];
    const logArgs = [];
    // try with formatting until we find something unsupported
    let i = 0;
    for(; i < args.length; i++){
        const arg = args[i];
        if (arg === undefined) break;
        else if (arg.constructor === String || arg.constructor === Number) strBuilder.push(arg);
        else if (arg.constructor === Object) break;
    }
    if (i > 0) // create logArgs with what we have so far
    logArgs.push(strBuilder.join(''));
    // append the rest
    for(; i < args.length; i++){
        const arg = args[i];
        if (!(arg instanceof Symbol)) logArgs.push(arg);
    }
    return logArgs;
};
/* c8 ignore stop */ const loggingColors = [
    GREEN,
    PURPLE,
    ORANGE,
    BLUE
];
let nextColor = 0;
let lastLoggingTime = _timeJs.getUnixTime();
const createModuleLogger = (_print, moduleName)=>{
    const color = loggingColors[nextColor];
    const debugRegexVar = _environmentJs.getVariable('log');
    const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName));
    nextColor = (nextColor + 1) % loggingColors.length;
    moduleName += ': ';
    return !doLogging ? _functionJs.nop : (...args)=>{
        if (args.length === 1 && args[0]?.constructor === Function) args = args[0]();
        const timeNow = _timeJs.getUnixTime();
        const timeDiff = timeNow - lastLoggingTime;
        lastLoggingTime = timeNow;
        _print(color, moduleName, UNCOLOR, ...args.map((arg)=>{
            if (arg != null && arg.constructor === Uint8Array) arg = Array.from(arg);
            const t = typeof arg;
            switch(t){
                case 'string':
                case 'symbol':
                    return arg;
                default:
                    return _jsonJs.stringify(arg);
            }
        }), color, ' +' + timeDiff + 'ms');
    };
} /* c8 ignore stop */ ;

},{"./symbol.js":"c24xy","./time.js":"gZsVK","./environment.js":"h8wYT","./function.js":"1O0Qj","./json.js":"kW79v","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c24xy":[function(require,module,exports,__globalThis) {
/**
 * Utility module to work with EcmaScript Symbols.
 *
 * @module symbol
 */ /**
 * Return fresh symbol.
 *
 * @return {Symbol}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "create", ()=>create);
parcelHelpers.export(exports, "isSymbol", ()=>isSymbol);
const create = Symbol;
const isSymbol = (s)=>typeof s === 'symbol';

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aFgMm":[function(require,module,exports,__globalThis) {
/**
 * Utility module to create and manipulate Iterators.
 *
 * @module iterator
 */ /**
 * @template T,R
 * @param {Iterator<T>} iterator
 * @param {function(T):R} f
 * @return {IterableIterator<R>}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mapIterator", ()=>mapIterator);
parcelHelpers.export(exports, "createIterator", ()=>createIterator);
parcelHelpers.export(exports, "iteratorFilter", ()=>iteratorFilter);
parcelHelpers.export(exports, "iteratorMap", ()=>iteratorMap);
const mapIterator = (iterator, f)=>({
        [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next () {
            const r = iterator.next();
            return {
                value: r.done ? undefined : f(r.value),
                done: r.done
            };
        }
    });
const createIterator = (next)=>({
        /**
   * @return {IterableIterator<T>}
   */ [Symbol.iterator] () {
            return this;
        },
        // @ts-ignore
        next
    });
const iteratorFilter = (iterator, filter)=>createIterator(()=>{
        let res;
        do res = iterator.next();
        while (!res.done && !filter(res.value));
        return res;
    });
const iteratorMap = (iterator, fmap)=>createIterator(()=>{
        const { done, value } = iterator.next();
        return {
            done,
            value: done ? undefined : fmap(value)
        };
    });

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g8NHk":[function(require,module,exports,__globalThis) {
/**
 * @module provider/websocket
 */ /* eslint-env browser */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messageSync", ()=>messageSync);
parcelHelpers.export(exports, "messageQueryAwareness", ()=>messageQueryAwareness);
parcelHelpers.export(exports, "messageAwareness", ()=>messageAwareness);
parcelHelpers.export(exports, "messageAuth", ()=>messageAuth);
/**
 * Websocket Provider for Yjs. Creates a websocket connection to sync the shared document.
 * The document name is attached to the provided url. I.e. the following example
 * creates a websocket connection to http://localhost:1234/my-document-name
 *
 * @example
 *   import * as Y from 'yjs'
 *   import { WebsocketProvider } from 'y-websocket'
 *   const doc = new Y.Doc()
 *   const provider = new WebsocketProvider('http://localhost:1234', 'my-document-name', doc)
 *
 * @extends {ObservableV2<{ 'connection-close': (event: CloseEvent | null,  provider: WebsocketProvider) => any, 'status': (event: { status: 'connected' | 'disconnected' | 'connecting' }) => any, 'connection-error': (event: Event, provider: WebsocketProvider) => any, 'sync': (state: boolean) => any }>}
 */ parcelHelpers.export(exports, "WebsocketProvider", ()=>WebsocketProvider);
var _yjs = require("yjs"); // eslint-disable-line
var _broadcastchannel = require("lib0/broadcastchannel");
var _time = require("lib0/time");
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _sync = require("y-protocols/sync");
var _auth = require("y-protocols/auth");
var _awareness = require("y-protocols/awareness");
var _observable = require("lib0/observable");
var _math = require("lib0/math");
var _url = require("lib0/url");
var _environment = require("lib0/environment");
var process = require("43b6cd2f9b5e450b");
const messageSync = 0;
const messageQueryAwareness = 3;
const messageAwareness = 1;
const messageAuth = 2;
/**
 *                       encoder,          decoder,          provider,          emitSynced, messageType
 * @type {Array<function(encoding.Encoder, decoding.Decoder, WebsocketProvider, boolean,    number):void>}
 */ const messageHandlers = [];
messageHandlers[messageSync] = (encoder, decoder, provider, emitSynced, _messageType)=>{
    _encoding.writeVarUint(encoder, messageSync);
    const syncMessageType = _sync.readSyncMessage(decoder, encoder, provider.doc, provider);
    if (emitSynced && syncMessageType === _sync.messageYjsSyncStep2 && !provider.synced) provider.synced = true;
};
messageHandlers[messageQueryAwareness] = (encoder, _decoder, provider, _emitSynced, _messageType)=>{
    _encoding.writeVarUint(encoder, messageAwareness);
    _encoding.writeVarUint8Array(encoder, _awareness.encodeAwarenessUpdate(provider.awareness, Array.from(provider.awareness.getStates().keys())));
};
messageHandlers[messageAwareness] = (_encoder, decoder, provider, _emitSynced, _messageType)=>{
    _awareness.applyAwarenessUpdate(provider.awareness, _decoding.readVarUint8Array(decoder), provider);
};
messageHandlers[messageAuth] = (_encoder, decoder, provider, _emitSynced, _messageType)=>{
    _auth.readAuthMessage(decoder, provider.doc, (_ydoc, reason)=>permissionDeniedHandler(provider, reason));
};
// @todo - this should depend on awareness.outdatedTime
const messageReconnectTimeout = 30000;
/**
 * @param {WebsocketProvider} provider
 * @param {string} reason
 */ const permissionDeniedHandler = (provider, reason)=>console.warn(`Permission denied to access ${provider.url}.\n${reason}`);
/**
 * @param {WebsocketProvider} provider
 * @param {Uint8Array} buf
 * @param {boolean} emitSynced
 * @return {encoding.Encoder}
 */ const readMessage = (provider, buf, emitSynced)=>{
    const decoder = _decoding.createDecoder(buf);
    const encoder = _encoding.createEncoder();
    const messageType = _decoding.readVarUint(decoder);
    const messageHandler = provider.messageHandlers[messageType];
    if (/** @type {any} */ messageHandler) messageHandler(encoder, decoder, provider, emitSynced, messageType);
    else console.error('Unable to compute message');
    return encoder;
};
/**
 * Outsource this function so that a new websocket connection is created immediately.
 * I suspect that the `ws.onclose` event is not always fired if there are network issues.
 *
 * @param {WebsocketProvider} provider
 * @param {WebSocket} ws
 * @param {CloseEvent | null} event
 */ const closeWebsocketConnection = (provider, ws, event)=>{
    if (ws === provider.ws) {
        provider.emit('connection-close', [
            event,
            provider
        ]);
        provider.ws = null;
        ws.close();
        provider.wsconnecting = false;
        if (provider.wsconnected) {
            provider.wsconnected = false;
            provider.synced = false;
            // update awareness (all users except local left)
            _awareness.removeAwarenessStates(provider.awareness, Array.from(provider.awareness.getStates().keys()).filter((client)=>client !== provider.doc.clientID), provider);
            provider.emit('status', [
                {
                    status: 'disconnected'
                }
            ]);
        } else provider.wsUnsuccessfulReconnects++;
        // Start with no reconnect timeout and increase timeout by
        // using exponential backoff starting with 100ms
        setTimeout(setupWS, _math.min(_math.pow(2, provider.wsUnsuccessfulReconnects) * 100, provider.maxBackoffTime), provider);
    }
};
/**
 * @param {WebsocketProvider} provider
 */ const setupWS = (provider)=>{
    if (provider.shouldConnect && provider.ws === null) {
        const websocket = new provider._WS(provider.url, provider.protocols);
        websocket.binaryType = 'arraybuffer';
        provider.ws = websocket;
        provider.wsconnecting = true;
        provider.wsconnected = false;
        provider.synced = false;
        websocket.onmessage = (event)=>{
            provider.wsLastMessageReceived = _time.getUnixTime();
            const encoder = readMessage(provider, new Uint8Array(event.data), true);
            if (_encoding.length(encoder) > 1) websocket.send(_encoding.toUint8Array(encoder));
        };
        websocket.onerror = (event)=>{
            provider.emit('connection-error', [
                event,
                provider
            ]);
        };
        websocket.onclose = (event)=>{
            closeWebsocketConnection(provider, websocket, event);
        };
        websocket.onopen = ()=>{
            provider.wsLastMessageReceived = _time.getUnixTime();
            provider.wsconnecting = false;
            provider.wsconnected = true;
            provider.wsUnsuccessfulReconnects = 0;
            provider.emit('status', [
                {
                    status: 'connected'
                }
            ]);
            // always send sync step 1 when connected
            const encoder = _encoding.createEncoder();
            _encoding.writeVarUint(encoder, messageSync);
            _sync.writeSyncStep1(encoder, provider.doc);
            websocket.send(_encoding.toUint8Array(encoder));
            // broadcast local awareness state
            if (provider.awareness.getLocalState() !== null) {
                const encoderAwarenessState = _encoding.createEncoder();
                _encoding.writeVarUint(encoderAwarenessState, messageAwareness);
                _encoding.writeVarUint8Array(encoderAwarenessState, _awareness.encodeAwarenessUpdate(provider.awareness, [
                    provider.doc.clientID
                ]));
                websocket.send(_encoding.toUint8Array(encoderAwarenessState));
            }
        };
        provider.emit('status', [
            {
                status: 'connecting'
            }
        ]);
    }
};
/**
 * @param {WebsocketProvider} provider
 * @param {ArrayBuffer} buf
 */ const broadcastMessage = (provider, buf)=>{
    const ws = provider.ws;
    if (provider.wsconnected && ws && ws.readyState === ws.OPEN) ws.send(buf);
    if (provider.bcconnected) _broadcastchannel.publish(provider.bcChannel, buf, provider);
};
class WebsocketProvider extends (0, _observable.ObservableV2) {
    /**
   * @param {string} serverUrl
   * @param {string} roomname
   * @param {Y.Doc} doc
   * @param {object} opts
   * @param {boolean} [opts.connect]
   * @param {awarenessProtocol.Awareness} [opts.awareness]
   * @param {Object<string,string>} [opts.params] specify url parameters
   * @param {Array<string>} [opts.protocols] specify websocket protocols
   * @param {typeof WebSocket} [opts.WebSocketPolyfill] Optionall provide a WebSocket polyfill
   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds
   * @param {number} [opts.maxBackoffTime] Maximum amount of time to wait before trying to reconnect (we try to reconnect using exponential backoff)
   * @param {boolean} [opts.disableBc] Disable cross-tab BroadcastChannel communication
   */ constructor(serverUrl, roomname, doc, { connect = true, awareness = new _awareness.Awareness(doc), params = {}, protocols = [], WebSocketPolyfill = WebSocket, resyncInterval = -1, maxBackoffTime = 2500, disableBc = false } = {}){
        super();
        // ensure that url is always ends with /
        while(serverUrl[serverUrl.length - 1] === '/')serverUrl = serverUrl.slice(0, serverUrl.length - 1);
        this.serverUrl = serverUrl;
        this.bcChannel = serverUrl + '/' + roomname;
        this.maxBackoffTime = maxBackoffTime;
        /**
     * The specified url parameters. This can be safely updated. The changed parameters will be used
     * when a new connection is established.
     * @type {Object<string,string>}
     */ this.params = params;
        this.protocols = protocols;
        this.roomname = roomname;
        this.doc = doc;
        this._WS = WebSocketPolyfill;
        this.awareness = awareness;
        this.wsconnected = false;
        this.wsconnecting = false;
        this.bcconnected = false;
        this.disableBc = disableBc;
        this.wsUnsuccessfulReconnects = 0;
        this.messageHandlers = messageHandlers.slice();
        /**
     * @type {boolean}
     */ this._synced = false;
        /**
     * @type {WebSocket?}
     */ this.ws = null;
        this.wsLastMessageReceived = 0;
        /**
     * Whether to connect to other peers or not
     * @type {boolean}
     */ this.shouldConnect = connect;
        /**
     * @type {number}
     */ this._resyncInterval = 0;
        if (resyncInterval > 0) this._resyncInterval = /** @type {any} */ setInterval(()=>{
            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                // resend sync step 1
                const encoder = _encoding.createEncoder();
                _encoding.writeVarUint(encoder, messageSync);
                _sync.writeSyncStep1(encoder, doc);
                this.ws.send(_encoding.toUint8Array(encoder));
            }
        }, resyncInterval);
        /**
     * @param {ArrayBuffer} data
     * @param {any} origin
     */ this._bcSubscriber = (data, origin)=>{
            if (origin !== this) {
                const encoder = readMessage(this, new Uint8Array(data), false);
                if (_encoding.length(encoder) > 1) _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoder), this);
            }
        };
        /**
     * Listens to Yjs updates and sends them to remote peers (ws and broadcastchannel)
     * @param {Uint8Array} update
     * @param {any} origin
     */ this._updateHandler = (update, origin)=>{
            if (origin !== this) {
                const encoder = _encoding.createEncoder();
                _encoding.writeVarUint(encoder, messageSync);
                _sync.writeUpdate(encoder, update);
                broadcastMessage(this, _encoding.toUint8Array(encoder));
            }
        };
        this.doc.on('update', this._updateHandler);
        /**
     * @param {any} changed
     * @param {any} _origin
     */ this._awarenessUpdateHandler = ({ added, updated, removed }, _origin)=>{
            const changedClients = added.concat(updated).concat(removed);
            const encoder = _encoding.createEncoder();
            _encoding.writeVarUint(encoder, messageAwareness);
            _encoding.writeVarUint8Array(encoder, _awareness.encodeAwarenessUpdate(awareness, changedClients));
            broadcastMessage(this, _encoding.toUint8Array(encoder));
        };
        this._exitHandler = ()=>{
            _awareness.removeAwarenessStates(this.awareness, [
                doc.clientID
            ], 'app closed');
        };
        if (_environment.isNode && typeof process !== 'undefined') process.on('exit', this._exitHandler);
        awareness.on('update', this._awarenessUpdateHandler);
        this._checkInterval = /** @type {any} */ setInterval(()=>{
            if (this.wsconnected && messageReconnectTimeout < _time.getUnixTime() - this.wsLastMessageReceived) // no message received in a long time - not even your own awareness
            // updates (which are updated every 15 seconds)
            closeWebsocketConnection(this, /** @type {WebSocket} */ this.ws, null);
        }, messageReconnectTimeout / 10);
        if (connect) this.connect();
    }
    get url() {
        const encodedParams = _url.encodeQueryParams(this.params);
        return this.serverUrl + '/' + this.roomname + (encodedParams.length === 0 ? '' : '?' + encodedParams);
    }
    /**
   * @type {boolean}
   */ get synced() {
        return this._synced;
    }
    set synced(state) {
        if (this._synced !== state) {
            this._synced = state;
            // @ts-ignore
            this.emit('synced', [
                state
            ]);
            this.emit('sync', [
                state
            ]);
        }
    }
    destroy() {
        if (this._resyncInterval !== 0) clearInterval(this._resyncInterval);
        clearInterval(this._checkInterval);
        this.disconnect();
        if (_environment.isNode && typeof process !== 'undefined') process.off('exit', this._exitHandler);
        this.awareness.off('update', this._awarenessUpdateHandler);
        this.doc.off('update', this._updateHandler);
        super.destroy();
    }
    connectBc() {
        if (this.disableBc) return;
        if (!this.bcconnected) {
            _broadcastchannel.subscribe(this.bcChannel, this._bcSubscriber);
            this.bcconnected = true;
        }
        // send sync step1 to bc
        // write sync step 1
        const encoderSync = _encoding.createEncoder();
        _encoding.writeVarUint(encoderSync, messageSync);
        _sync.writeSyncStep1(encoderSync, this.doc);
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderSync), this);
        // broadcast local state
        const encoderState = _encoding.createEncoder();
        _encoding.writeVarUint(encoderState, messageSync);
        _sync.writeSyncStep2(encoderState, this.doc);
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderState), this);
        // write queryAwareness
        const encoderAwarenessQuery = _encoding.createEncoder();
        _encoding.writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderAwarenessQuery), this);
        // broadcast local awareness state
        const encoderAwarenessState = _encoding.createEncoder();
        _encoding.writeVarUint(encoderAwarenessState, messageAwareness);
        _encoding.writeVarUint8Array(encoderAwarenessState, _awareness.encodeAwarenessUpdate(this.awareness, [
            this.doc.clientID
        ]));
        _broadcastchannel.publish(this.bcChannel, _encoding.toUint8Array(encoderAwarenessState), this);
    }
    disconnectBc() {
        // broadcast message with local awareness state set to null (indicating disconnect)
        const encoder = _encoding.createEncoder();
        _encoding.writeVarUint(encoder, messageAwareness);
        _encoding.writeVarUint8Array(encoder, _awareness.encodeAwarenessUpdate(this.awareness, [
            this.doc.clientID
        ], new Map()));
        broadcastMessage(this, _encoding.toUint8Array(encoder));
        if (this.bcconnected) {
            _broadcastchannel.unsubscribe(this.bcChannel, this._bcSubscriber);
            this.bcconnected = false;
        }
    }
    disconnect() {
        this.shouldConnect = false;
        this.disconnectBc();
        if (this.ws !== null) closeWebsocketConnection(this, this.ws, null);
    }
    connect() {
        this.shouldConnect = true;
        if (!this.wsconnected && this.ws === null) {
            setupWS(this);
            this.connectBc();
        }
    }
}

},{"43b6cd2f9b5e450b":"d5jf4","yjs":"gj9M9","lib0/broadcastchannel":"gKGkU","lib0/time":"gZsVK","lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","y-protocols/sync":"kgJVk","y-protocols/auth":"flacp","y-protocols/awareness":"57xPu","lib0/observable":"20Rfd","lib0/math":"jhXHz","lib0/url":"60si9","lib0/environment":"h8wYT","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gKGkU":[function(require,module,exports,__globalThis) {
/* eslint-env browser */ /**
 * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.
 *
 * ```js
 * // In browser window A:
 * broadcastchannel.subscribe('my events', data => console.log(data))
 * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab
 *
 * // In browser window B:
 * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'
 * ```
 *
 * @module broadcastchannel
 */ // @todo before next major: use Uint8Array instead as buffer object
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "subscribe", ()=>subscribe);
parcelHelpers.export(exports, "unsubscribe", ()=>unsubscribe);
parcelHelpers.export(exports, "publish", ()=>publish);
var _mapJs = require("./map.js");
var _setJs = require("./set.js");
var _bufferJs = require("./buffer.js");
var _storageJs = require("./storage.js");
/**
 * @typedef {Object} Channel
 * @property {Set<function(any, any):any>} Channel.subs
 * @property {any} Channel.bc
 */ /**
 * @type {Map<string, Channel>}
 */ const channels = new Map();
/* c8 ignore start */ class LocalStoragePolyfill {
    /**
   * @param {string} room
   */ constructor(room){
        this.room = room;
        /**
     * @type {null|function({data:ArrayBuffer}):void}
     */ this.onmessage = null;
        /**
     * @param {any} e
     */ this._onChange = (e)=>e.key === room && this.onmessage !== null && this.onmessage({
                data: _bufferJs.fromBase64(e.newValue || '')
            });
        _storageJs.onChange(this._onChange);
    }
    /**
   * @param {ArrayBuffer} buf
   */ postMessage(buf) {
        _storageJs.varStorage.setItem(this.room, _bufferJs.toBase64(_bufferJs.createUint8ArrayFromArrayBuffer(buf)));
    }
    close() {
        _storageJs.offChange(this._onChange);
    }
}
/* c8 ignore stop */ // Use BroadcastChannel or Polyfill
/* c8 ignore next */ const BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel;
/**
 * @param {string} room
 * @return {Channel}
 */ const getChannel = (room)=>_mapJs.setIfUndefined(channels, room, ()=>{
        const subs = _setJs.create();
        const bc = new BC(room);
        /**
     * @param {{data:ArrayBuffer}} e
     */ /* c8 ignore next */ bc.onmessage = (e)=>subs.forEach((sub)=>sub(e.data, 'broadcastchannel'));
        return {
            bc,
            subs
        };
    });
const subscribe = (room, f)=>{
    getChannel(room).subs.add(f);
    return f;
};
const unsubscribe = (room, f)=>{
    const channel = getChannel(room);
    const unsubscribed = channel.subs.delete(f);
    if (unsubscribed && channel.subs.size === 0) {
        channel.bc.close();
        channels.delete(room);
    }
    return unsubscribed;
};
const publish = (room, data, origin = null)=>{
    const c = getChannel(room);
    c.bc.postMessage(data);
    c.subs.forEach((sub)=>sub(data, origin));
};

},{"./map.js":"eE1vX","./set.js":"iWXeP","./buffer.js":"3bzhu","./storage.js":"9FcRV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kgJVk":[function(require,module,exports,__globalThis) {
/**
 * @module sync-protocol
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messageYjsSyncStep1", ()=>messageYjsSyncStep1);
parcelHelpers.export(exports, "messageYjsSyncStep2", ()=>messageYjsSyncStep2);
parcelHelpers.export(exports, "messageYjsUpdate", ()=>messageYjsUpdate);
parcelHelpers.export(exports, "writeSyncStep1", ()=>writeSyncStep1);
parcelHelpers.export(exports, "writeSyncStep2", ()=>writeSyncStep2);
parcelHelpers.export(exports, "readSyncStep1", ()=>readSyncStep1);
parcelHelpers.export(exports, "readSyncStep2", ()=>readSyncStep2);
parcelHelpers.export(exports, "writeUpdate", ()=>writeUpdate);
parcelHelpers.export(exports, "readUpdate", ()=>readUpdate);
parcelHelpers.export(exports, "readSyncMessage", ()=>readSyncMessage);
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _yjs = require("yjs");
const messageYjsSyncStep1 = 0;
const messageYjsSyncStep2 = 1;
const messageYjsUpdate = 2;
const writeSyncStep1 = (encoder, doc)=>{
    _encoding.writeVarUint(encoder, messageYjsSyncStep1);
    const sv = _yjs.encodeStateVector(doc);
    _encoding.writeVarUint8Array(encoder, sv);
};
const writeSyncStep2 = (encoder, doc, encodedStateVector)=>{
    _encoding.writeVarUint(encoder, messageYjsSyncStep2);
    _encoding.writeVarUint8Array(encoder, _yjs.encodeStateAsUpdate(doc, encodedStateVector));
};
const readSyncStep1 = (decoder, encoder, doc)=>writeSyncStep2(encoder, doc, _decoding.readVarUint8Array(decoder));
const readSyncStep2 = (decoder, doc, transactionOrigin)=>{
    try {
        _yjs.applyUpdate(doc, _decoding.readVarUint8Array(decoder), transactionOrigin);
    } catch (error) {
        // This catches errors that are thrown by event handlers
        console.error('Caught error while handling a Yjs update', error);
    }
};
const writeUpdate = (encoder, update)=>{
    _encoding.writeVarUint(encoder, messageYjsUpdate);
    _encoding.writeVarUint8Array(encoder, update);
};
const readUpdate = readSyncStep2;
const readSyncMessage = (decoder, encoder, doc, transactionOrigin)=>{
    const messageType = _decoding.readVarUint(decoder);
    switch(messageType){
        case messageYjsSyncStep1:
            readSyncStep1(decoder, encoder, doc);
            break;
        case messageYjsSyncStep2:
            readSyncStep2(decoder, doc, transactionOrigin);
            break;
        case messageYjsUpdate:
            readUpdate(decoder, doc, transactionOrigin);
            break;
        default:
            throw new Error('Unknown message type');
    }
    return messageType;
};

},{"lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","yjs":"gj9M9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"flacp":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "messagePermissionDenied", ()=>messagePermissionDenied);
parcelHelpers.export(exports, "writePermissionDenied", ()=>writePermissionDenied);
parcelHelpers.export(exports, "readAuthMessage", ()=>readAuthMessage);
var _yjs = require("yjs"); // eslint-disable-line
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
const messagePermissionDenied = 0;
const writePermissionDenied = (encoder, reason)=>{
    _encoding.writeVarUint(encoder, messagePermissionDenied);
    _encoding.writeVarString(encoder, reason);
};
const readAuthMessage = (decoder, y, permissionDeniedHandler)=>{
    switch(_decoding.readVarUint(decoder)){
        case messagePermissionDenied:
            permissionDeniedHandler(y, _decoding.readVarString(decoder));
    }
};

},{"yjs":"gj9M9","lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"57xPu":[function(require,module,exports,__globalThis) {
/**
 * @module awareness-protocol
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "outdatedTimeout", ()=>outdatedTimeout);
/**
 * @typedef {Object} MetaClientState
 * @property {number} MetaClientState.clock
 * @property {number} MetaClientState.lastUpdated unix timestamp
 */ /**
 * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information
 * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of
 * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.
 *
 * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override
 * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is
 * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that
 * a remote client is offline, it may propagate a message with
 * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a
 * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.
 *
 * Before a client disconnects, it should propagate a `null` state with an updated clock.
 *
 * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.
 *
 * @extends {Observable<string>}
 */ parcelHelpers.export(exports, "Awareness", ()=>Awareness);
parcelHelpers.export(exports, "removeAwarenessStates", ()=>removeAwarenessStates);
parcelHelpers.export(exports, "encodeAwarenessUpdate", ()=>encodeAwarenessUpdate);
parcelHelpers.export(exports, "modifyAwarenessUpdate", ()=>modifyAwarenessUpdate);
parcelHelpers.export(exports, "applyAwarenessUpdate", ()=>applyAwarenessUpdate);
var _encoding = require("lib0/encoding");
var _decoding = require("lib0/decoding");
var _time = require("lib0/time");
var _math = require("lib0/math");
var _observable = require("lib0/observable");
var _function = require("lib0/function");
var _yjs = require("yjs"); // eslint-disable-line
const outdatedTimeout = 30000;
class Awareness extends (0, _observable.Observable) {
    /**
   * @param {Y.Doc} doc
   */ constructor(doc){
        super();
        this.doc = doc;
        /**
     * @type {number}
     */ this.clientID = doc.clientID;
        /**
     * Maps from client id to client state
     * @type {Map<number, Object<string, any>>}
     */ this.states = new Map();
        /**
     * @type {Map<number, MetaClientState>}
     */ this.meta = new Map();
        this._checkInterval = /** @type {any} */ setInterval(()=>{
            const now = _time.getUnixTime();
            if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ this.meta.get(this.clientID).lastUpdated) // renew local clock
            this.setLocalState(this.getLocalState());
            /**
       * @type {Array<number>}
       */ const remove = [];
            this.meta.forEach((meta, clientid)=>{
                if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) remove.push(clientid);
            });
            if (remove.length > 0) removeAwarenessStates(this, remove, 'timeout');
        }, _math.floor(outdatedTimeout / 10));
        doc.on('destroy', ()=>{
            this.destroy();
        });
        this.setLocalState({});
    }
    destroy() {
        this.emit('destroy', [
            this
        ]);
        this.setLocalState(null);
        super.destroy();
        clearInterval(this._checkInterval);
    }
    /**
   * @return {Object<string,any>|null}
   */ getLocalState() {
        return this.states.get(this.clientID) || null;
    }
    /**
   * @param {Object<string,any>|null} state
   */ setLocalState(state) {
        const clientID = this.clientID;
        const currLocalMeta = this.meta.get(clientID);
        const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1;
        const prevState = this.states.get(clientID);
        if (state === null) this.states.delete(clientID);
        else this.states.set(clientID, state);
        this.meta.set(clientID, {
            clock,
            lastUpdated: _time.getUnixTime()
        });
        const added = [];
        const updated = [];
        const filteredUpdated = [];
        const removed = [];
        if (state === null) removed.push(clientID);
        else if (prevState == null) {
            if (state != null) added.push(clientID);
        } else {
            updated.push(clientID);
            if (!_function.equalityDeep(prevState, state)) filteredUpdated.push(clientID);
        }
        if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) this.emit('change', [
            {
                added,
                updated: filteredUpdated,
                removed
            },
            'local'
        ]);
        this.emit('update', [
            {
                added,
                updated,
                removed
            },
            'local'
        ]);
    }
    /**
   * @param {string} field
   * @param {any} value
   */ setLocalStateField(field, value) {
        const state = this.getLocalState();
        if (state !== null) this.setLocalState({
            ...state,
            [field]: value
        });
    }
    /**
   * @return {Map<number,Object<string,any>>}
   */ getStates() {
        return this.states;
    }
}
const removeAwarenessStates = (awareness, clients, origin)=>{
    const removed = [];
    for(let i = 0; i < clients.length; i++){
        const clientID = clients[i];
        if (awareness.states.has(clientID)) {
            awareness.states.delete(clientID);
            if (clientID === awareness.clientID) {
                const curMeta = /** @type {MetaClientState} */ awareness.meta.get(clientID);
                awareness.meta.set(clientID, {
                    clock: curMeta.clock + 1,
                    lastUpdated: _time.getUnixTime()
                });
            }
            removed.push(clientID);
        }
    }
    if (removed.length > 0) {
        awareness.emit('change', [
            {
                added: [],
                updated: [],
                removed
            },
            origin
        ]);
        awareness.emit('update', [
            {
                added: [],
                updated: [],
                removed
            },
            origin
        ]);
    }
};
const encodeAwarenessUpdate = (awareness, clients, states = awareness.states)=>{
    const len = clients.length;
    const encoder = _encoding.createEncoder();
    _encoding.writeVarUint(encoder, len);
    for(let i = 0; i < len; i++){
        const clientID = clients[i];
        const state = states.get(clientID) || null;
        const clock = /** @type {MetaClientState} */ awareness.meta.get(clientID).clock;
        _encoding.writeVarUint(encoder, clientID);
        _encoding.writeVarUint(encoder, clock);
        _encoding.writeVarString(encoder, JSON.stringify(state));
    }
    return _encoding.toUint8Array(encoder);
};
const modifyAwarenessUpdate = (update, modify)=>{
    const decoder = _decoding.createDecoder(update);
    const encoder = _encoding.createEncoder();
    const len = _decoding.readVarUint(decoder);
    _encoding.writeVarUint(encoder, len);
    for(let i = 0; i < len; i++){
        const clientID = _decoding.readVarUint(decoder);
        const clock = _decoding.readVarUint(decoder);
        const state = JSON.parse(_decoding.readVarString(decoder));
        const modifiedState = modify(state);
        _encoding.writeVarUint(encoder, clientID);
        _encoding.writeVarUint(encoder, clock);
        _encoding.writeVarString(encoder, JSON.stringify(modifiedState));
    }
    return _encoding.toUint8Array(encoder);
};
const applyAwarenessUpdate = (awareness, update, origin)=>{
    const decoder = _decoding.createDecoder(update);
    const timestamp = _time.getUnixTime();
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    const len = _decoding.readVarUint(decoder);
    for(let i = 0; i < len; i++){
        const clientID = _decoding.readVarUint(decoder);
        let clock = _decoding.readVarUint(decoder);
        const state = JSON.parse(_decoding.readVarString(decoder));
        const clientMeta = awareness.meta.get(clientID);
        const prevState = awareness.states.get(clientID);
        const currClock = clientMeta === undefined ? 0 : clientMeta.clock;
        if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
            if (state === null) {
                // never let a remote client remove this local state
                if (clientID === awareness.clientID && awareness.getLocalState() != null) // remote client removed the local state. Do not remote state. Broadcast a message indicating
                // that this client still exists by increasing the clock
                clock++;
                else awareness.states.delete(clientID);
            } else awareness.states.set(clientID, state);
            awareness.meta.set(clientID, {
                clock,
                lastUpdated: timestamp
            });
            if (clientMeta === undefined && state !== null) added.push(clientID);
            else if (clientMeta !== undefined && state === null) removed.push(clientID);
            else if (state !== null) {
                if (!_function.equalityDeep(state, prevState)) filteredUpdated.push(clientID);
                updated.push(clientID);
            }
        }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) awareness.emit('change', [
        {
            added,
            updated: filteredUpdated,
            removed
        },
        origin
    ]);
    if (added.length > 0 || updated.length > 0 || removed.length > 0) awareness.emit('update', [
        {
            added,
            updated,
            removed
        },
        origin
    ]);
};

},{"lib0/encoding":"9yVNx","lib0/decoding":"ftn2I","lib0/time":"gZsVK","lib0/math":"jhXHz","lib0/observable":"20Rfd","lib0/function":"1O0Qj","yjs":"gj9M9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"60si9":[function(require,module,exports,__globalThis) {
/**
 * Utility module to work with urls.
 *
 * @module url
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "decodeQueryParams", ()=>decodeQueryParams);
parcelHelpers.export(exports, "encodeQueryParams", ()=>encodeQueryParams);
var _objectJs = require("./object.js");
const decodeQueryParams = (url)=>{
    /**
   * @type {Object<string,string>}
   */ const query = {};
    const urlQuerySplit = url.split('?');
    const pairs = urlQuerySplit[urlQuerySplit.length - 1].split('&');
    for(let i = 0; i < pairs.length; i++){
        const item = pairs[i];
        if (item.length > 0) {
            const pair = item.split('=');
            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
        }
    }
    return query;
};
const encodeQueryParams = (params)=>_objectJs.map(params, (val, key)=>`${encodeURIComponent(key)}=${encodeURIComponent(val)}`).join('&');

},{"./object.js":"4uXcx","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"82TGT":[function(require,module,exports,__globalThis) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
}
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */ function arrayIncludesWith(array, value, comparator) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (comparator(value, array[index])) return true;
    }
    return false;
}
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while(++index < length)result[index] = iteratee(array[index], index, array);
    return result;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) return baseFindIndex(array, baseIsNaN, fromIndex);
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) return index;
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {}
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Symbol = root.Symbol, getPrototype = overArg(Object.getPrototypeOf, Object), propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, 'Map'), nativeCreate = getNative(Object, 'create');
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache;
    while(++index < length)this.add(values[index]);
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */ function baseDifference(array, values, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) return result;
    if (iteratee) values = arrayMap(values, baseUnary(iteratee));
    if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
    } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
    }
    outer: while(++index < length){
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while(valuesIndex--){
                if (values[valuesIndex] === computed) continue outer;
            }
            result.push(value);
        } else if (!includes(values, computed, comparator)) result.push(value);
    }
    return result;
}
/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */ function baseFlatten(array, depth, predicate, isStrict, result) {
    var index = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while(++index < length){
        var value = array[index];
        if (depth > 0 && predicate(value)) {
            if (depth > 1) // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
            else arrayPush(result, value);
        } else if (!isStrict) result[result.length] = value;
    }
    return result;
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeysIn(object) {
    if (!isObject(object)) return nativeKeysIn(object);
    var isProto = isPrototype(object), result = [];
    for(var key in object)if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) result.push(key);
    return result;
}
/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */ function basePick(object, props) {
    object = Object(object);
    return basePickBy(object, props, function(value, key) {
        return key in object;
    });
}
/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */ function basePickBy(object, props, predicate) {
    var index = -1, length = props.length, result = {};
    while(++index < length){
        var key = props[index], value = object[key];
        if (predicate(value, key)) result[key] = value;
    }
    return result;
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeysIn(object) {
    return baseGetAllKeys(object, keysIn, getSymbolsIn);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
    var result = [];
    while(object){
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
    }
    return result;
};
/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */ function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function nativeKeysIn(object) {
    var result = [];
    if (object != null) for(var key in Object(object))result.push(key);
    return result;
}
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) return value;
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + '';
        } catch (e) {}
    }
    return '';
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */ function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */ var omit = baseRest(function(object, props) {
    if (object == null) return {};
    props = arrayMap(baseFlatten(props, 1), toKey);
    return basePick(object, baseDifference(getAllKeysIn(object), props));
});
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
module.exports = omit;

},{}],"bAVQb":[function(require,module,exports,__globalThis) {
/* eslint-disable no-param-reassign */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-unused-expressions */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _base = require("./base");
var _baseDefault = parcelHelpers.interopDefault(_base);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class node extends (0, _baseDefault.default) {
    constructor(options){
        super();
        this._lock = null;
        this._openLock = null;
        this.lm = null;
        this.options = {
            id: (0, _utilsDefault.default).guid(),
            name: '',
            text: '',
            image: '',
            groupId: null,
            xPos: 0,
            yPos: 0,
            height: 10,
            width: 10,
            borderStyle: 'solid',
            borderWidth: 1,
            borderColor: '#000',
            borderOpacity: 1,
            lineColor: '#000000',
            lineOpacity: 1,
            lineEffect: '',
            lineType: 'bezier',
            lineCurveType: 'cubic',
            lineCurviness: 0.2,
            lineWidth: 5,
            opacity: 1,
            textOpacity: 1,
            showDelete: true,
            showAddAndDeleteConditionally: false,
            showResize: true,
            showAdd: true,
            showRelationshipConnector: true,
            showRelationshipDelete: true,
            showRelationshipProperties: true,
            showRelationshipReassign: true,
            showRotate: true,
            showMenu: true,
            showColorTab: true,
            showTextTab: true,
            showAITab: true,
            showShapeTab: true,
            showImageTab: true,
            showEffectTab: true,
            spaceBetweenNodesWhenAdding: 30,
            disableMenuAsTemplate: false,
            disableDrag: false,
            allowDrag: true,
            allowMenu: true,
            allowContext: true,
            allowResize: true,
            isLocked: false,
            isComment: false,
            backgroundColor: '90-#031634-#2D579A',
            foregroundColor: '#fff',
            isCategory: false,
            humanTouch: false,
            categoryName: '',
            fontSize: 18,
            fontFamily: 'Roboto',
            shapeHint: 'rectangle',
            vectorPath: '',
            rotate: {
                rotationAngle: 0
            },
            textXAlign: 'middle',
            textYAlign: 'middle',
            link: {
                show: false,
                type: '',
                data: '',
                thumbnail: {
                    width: 175,
                    height: 175
                }
            },
            filters: {
                vect: null,
                text: null
            },
            ai: {
                textToChildNodes: '',
                textToImage: ''
            }
        };
        Object.assign(this.options, options);
        if (this.options.name === '') this.options.name = this.options.id;
        this.constants = {
            statusPanelAtRest: 33,
            statusPanelExpanded: 200
        };
    }
    // get vect() {
    //   return this.vect;
    // }
    // get text() {
    //   return this.text;
    // }
    // get link() {
    //   return this.link;
    // }
    // set vect(val) {
    //   this.vect = val;
    // }
    // set text(val) {
    //   this.text = val;
    // }
    // set link(val) {
    //   this.link = val;
    // }
    _url(opt) {
        return this.options.ajax.rootUrl + this.options.ajax.urlFlavor + opt;
    }
    del() {
        const _unlinkId = this.options.id;
        this.slate.nodes.closeAllMenus();
        this.slate.nodes.closeAllLineOptions();
        this.relationships.removeAll();
        this.slate.options.allowDrag = true;
        // unlink any links
        this.slate.nodes.allNodes.forEach((nd)=>{
            if (nd.options.link && nd.options.link.show && nd.options.link.data === _unlinkId) {
                Object.assign(nd.options.link, {
                    show: false,
                    type: '',
                    data: ''
                });
                nd.link.hide();
            }
        });
        this.slate.nodes.remove(this);
    }
    getTransformString(opts = {}) {
        const _transforms = [];
        let rotationTransform;
        if (opts.action === 'resize') {
            const resizeTransform = `s${opts.sx},${opts.sy}`;
            _transforms.push(resizeTransform);
        }
        if (opts.rotate) rotationTransform = `R${opts.rotate.rotationAngle}, ${opts.rotate.point.x}, ${opts.rotate.point.y}`;
        else if (this.options.rotate.rotationAngle) rotationTransform = `R${this.options.rotate.rotationAngle}, ${this.options.rotate.point.x - (opts.dx || 0)}, ${this.options.rotate.point.y - (opts.dy || 0)}`;
        if (rotationTransform) _transforms.push(rotationTransform);
        if (opts.action === 'translate') {
            const translationTransform = `T${opts.dx}, ${opts.dy}`;
            // console.log("node transform string ", translationTransform);
            _transforms.push(translationTransform);
        }
        return _transforms.join(' ');
    }
    rotateMoveVector({ dx, dy }) {
        const _rotationAngle = -this.options.rotate.rotationAngle * Math.PI / 180 // conversion to radians
        ;
        return {
            dx: dx * Math.cos(_rotationAngle) - dy * Math.sin(_rotationAngle),
            dy: dx * Math.sin(_rotationAngle) + dy * Math.cos(_rotationAngle)
        };
    }
    translateWith({ dx, dy }) {
        // need a rotateMoveVector for both the vect and the text
        const newMoveVector = this.rotateMoveVector({
            dx,
            dy
        });
        const translateContext = {
            action: 'translate',
            dx: newMoveVector.dx,
            dy: newMoveVector.dy
        };
        const transformString = this.getTransformString(translateContext);
        // during movement, the only thing that is updated is the transform property on
        // both the text and vect -- the actual attr update happens at the "up" in the
        // relationships.js module -- and the transform("") there causes these transient
        // transforms to be removed and replaced with the permanent attr updates.
        // note the "up" function there calls into the utils.transformPath on Slatebox.js
        // proper where the transform("") and the attr permanent record is done.
        this.vect.transform(transformString);
        this.text.transform(transformString);
        this.setPosition({
            x: this.vect.ox + dx,
            y: this.vect.oy + dy
        });
    }
    debugPosition() {
        const coords = `${this.options.id}\n x: ${this.options.xPos}, y: ${this.options.yPos}`;
        this.editor.set(coords);
    }
    setPosition(p, blnKeepMenusOpen, activeNode, opts = {}) {
        this.options.xPos = p.x;
        this.options.yPos = p.y;
        const lc = this.linkCoords();
        // not setting the text attr here -- this is
        // this.text.attr(this.textCoords(p));
        // this.text.attr(this.textCoords({x: this.options.xPos, y: this.options.yPos = p.y });
        this.link.transform([
            't',
            lc.x,
            ',',
            lc.y,
            's',
            '.8',
            ',',
            '.8',
            'r',
            '180'
        ].join());
        // close all open menus
        if (blnKeepMenusOpen !== true) {
            this.slate.nodes.closeAllMenus({
                exception: activeNode
            });
            this.slate.nodes.closeAllLineOptions();
        }
    }
    setStartDrag() {
        this.slate.options.allowDrag = false;
        // this.slate.stopEditing();
        this.connectors && this.connectors.reset();
        this.context && this.context.remove();
    }
    setEndDrag() {
        if (this.slate && this.slate.options.enabled) // could be null in case of the tempNode
        this.slate.options.allowDrag = true;
        this.slate.displayLocks();
    }
    png(withNodes, cb) {
        const self = this;
        const nodes = withNodes?.length > 0 ? withNodes : [
            self.options.id
        ];
        self.slate.png({
            nodes,
            noBackground: true,
            asBinary: true
        }, (blob)=>{
            cb(blob);
        });
    }
    svg(withNodes, cb) {
        const self = this;
        const nodes = withNodes?.length > 0 ? withNodes : [
            self.options.id
        ];
        self.slate.svg({
            nodes,
            noBackground: true
        }, (svg)=>{
            cb(svg);
        });
    }
    serialize(lineWidthOverride) {
        const self = this;
        const jsonNode = {};
        Object.assign(jsonNode, {
            options: self.options
        });
        jsonNode.relationships = {
            associations: []
        } // , children: []
        ;
        self.relationships.associations.forEach((association)=>{
            jsonNode.relationships.associations.push(self._bindRel(association, lineWidthOverride));
        });
        return jsonNode;
    }
    _bindRel(obj, lineWidthOverride) {
        return {
            childId: obj.child.options.id,
            parentId: obj.parent.options.id,
            isStraightLine: obj.blnStraight,
            lineColor: obj.lineColor,
            lineEffect: obj.lineEffect,
            lineOpacity: obj.lineOpacity,
            lineType: obj.lineType,
            lineCurviness: obj.lineCurviness,
            lineCurveType: obj.lineCurveType,
            lineWidth: lineWidthOverride || obj.lineWidth
        };
    }
    addRelationships(json, cb) {
        // add parents
        const self = this;
        const _lines = [];
        if (json.relationships) // add associations
        {
            if (json.relationships && json.relationships.associations && json.relationships.associations.forEach) json.relationships.associations.forEach((association)=>{
                const _pr = association;
                let _pn = null;
                self.slate.nodes.allNodes.forEach((node)=>{
                    if (node.options.id === _pr.parentId && self.options.id !== node.options.id) _pn = node;
                });
                if (_pn) {
                    const _conn = _pn.relationships.addAssociation(self, _pr);
                    _lines.push(_conn.line);
                }
            });
        }
        cb?.apply(self, [
            _lines
        ]);
    }
    toFront() {
        this.relationships?.associations?.forEach((assoc)=>{
            assoc.line.toFront();
        });
        this.vect.toFront();
        this.text.toFront();
        this.link.toFront();
        this.slate?.grid.toBack();
        this.slate?.canvas.bgToBack();
        this.slate.reorderNodes();
    }
    toBack() {
        this.link.toBack();
        this.text.toBack();
        this.vect.toBack();
        this.relationships?.associations?.forEach((assoc)=>{
            assoc.line.toBack();
        });
        this.slate?.grid.toBack();
        this.slate?.canvas.bgToBack();
        this.slate.reorderNodes();
    }
    hide() {
        this.vect.hide();
        this.text.hide();
        this.options.link.show && this.link.hide();
    }
    show() {
        this.vect.show();
        this.text.show();
        this.options.link.show && this.link.show();
    }
    applyFilters(filter) {
        const self = this;
        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile()) {
            if (filter) {
                // presumes that the filter has been added to the slate
                if (!self.options.filters[filter.apply]) self.options.filters[filter.apply] = {};
                self.options.filters[filter.apply] = filter.id;
            }
            Object.keys(self.options?.filters).forEach((key)=>{
                if (self[key]) {
                    if (self.options.filters[key]) self[key].attr('filter', `url(#${self.options.filters[key]})`);
                    else self[key].attr('filter', '');
                }
            });
        }
    }
    toggleFilters(blnHide) {
        const self = this;
        if (!(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile()) Object.keys(self.options?.filters).forEach((key)=>{
            if (self[key]) {
                if (self.options.filters[key]) {
                    if (blnHide) self[key].attr('filter', '');
                    else self[key].attr('filter', `url(#${self.options.filters[key]})`);
                }
            }
        });
    }
    applyBorder(pkg) {
        // first update the border prop if used
        if (pkg) this.options[pkg.prop] = pkg.val;
        // next define the full suite
        const vectOpts = {
            stroke: this.options.borderColor,
            'stroke-dasharray': this.options.borderStyle || null,
            'stroke-width': this.options.borderWidth != null ? this.options.borderWidth : 1,
            'stroke-opacity': this.options.borderOpacity != null ? this.options.borderOpacity : 1,
            'stroke-linecap': 'round'
        };
        if (this.vect) this.vect.attr(vectOpts);
        return vectOpts;
    }
    // returns an invisible path with the correct position of a path being dragged. MAKE SURE TO REMOVE IT AFTER YOU ARE DONE WITH IT or there will be a growing number of invisible paths rendering the slate unusable
    getTempPathWithCorrectPositionFor({ pathElement, dx, dy, rotationAngle }) {
        const tempPath = this.slate.paper.path(pathElement.attr('path').toString()).attr({
            opacity: 0
        });
        const _transforms = [];
        const bb = tempPath.getBBox();
        if (dx != null && dy != null) {
            if (this.options.rotate.rotationAngle) {
                const newMoveVector = this.rotateMoveVector({
                    dx,
                    dy
                });
                _transforms.push(`T${newMoveVector.dx},${newMoveVector.dy}`);
            } else _transforms.push(`T${dx},${dy}`);
        }
        if (rotationAngle != null) _transforms.push(`r${rotationAngle}, ${bb.cx}, ${bb.cy}`);
        else if (this.options.rotate.rotationAngle) _transforms.push(`r${this.options.rotate.rotationAngle}, ${this.options.rotate.point.x}, ${this.options.rotate.point.y}`);
        tempPath.transform('');
        const transformPath = (0, _getTransformedPathDefault.default)(tempPath.attr('path').toString(), _transforms);
        tempPath.attr({
            path: transformPath
        });
        return tempPath;
    }
    hideOwnMenus() {
        this.link.hide();
        this.menu.hide();
    // this._lock && this._lock.hide();
    // this._openLock && this._openLock.hide();
    }
    spin(opts) {
        let ii = 0;
        const _aa = opts && opts.angle || 280;
        const _dur = opts && opts.duration || 5000;
        function _spinner(_angle) {
            ii++;
            const _ra = ii % 2 === 0 ? this.options.rotate.rotationAngle - _angle : this.options.rotate.rotationAngle + _angle;
            const _rotate = {
                rotate: this.options.rotate,
                rotationAngle: _ra
            };
            this.rotate.animateSet(_rotate, {
                duration: _dur,
                cb: ()=>{
                    _spinner(_aa);
                }
            });
        }
        _spinner(_aa);
    }
    move(pkg) {
        const _mPkg = {
            dur: pkg.dur || 500,
            moves: [
                {
                    id: this.options.id,
                    x: pkg.x,
                    y: pkg.y
                }
            ]
        };
        const _pkg = this.slate.nodes.nodeMovePackage(_mPkg);
        this.slate.nodes.moveNodes(_pkg, {
            animate: true,
            cb: ()=>{
                pkg.cb && pkg.cb();
            }
        });
    }
    zoom(zoomPercent, duration, cb) {
        /*
    var _startZoom = this.slate.options.viewPort.zoom.w;
    var _targetZoom = this.slate.options.viewPort.originalWidth * (100 / parseInt(zoomPercent));
    var _zoomDif = Math.abs(_targetZoom - _startZoom);
    */ // UNTIL PAN AND ZOOM WORKS CORRECTLY, THIS WILL
        // ALWAYS BE A SIMPLE PROXY TO ZOOMING THE SLATE
        this.slate.canvas.zoom({
            dur: duration,
            zoomPercent,
            callbacks: {
                during (percentComplete, easing) {
                // additional calcs
                },
                after (zoomVal) {
                    cb && cb.apply(this, [
                        {
                            id: this.options.id,
                            operation: 'zoom',
                            zoomLevel: zoomVal
                        }
                    ]);
                }
            }
        });
    }
    position(location, cb, easing, dur) {
        const self = this;
        easing = easing || 'easeTo' // 'swingFromTo'
        ;
        dur = dur || 500;
        const _vpt = self.vect.getBBox();
        const zr = self.slate.options.viewPort.zoom.r;
        const d = (0, _utilsDefault.default).getDimensions(self.slate.options.container);
        const cw = d.width;
        const ch = d.height;
        const nw = self.options.width * zr;
        const nh = self.options.height * zr;
        const pad = 10;
        // get upper left coords
        let _x = _vpt.x * zr;
        let _y = _vpt.y * zr;
        switch(location){
            case 'lowerright':
                _x = _x - (cw - nw) - pad;
                _y = _y - (ch - nh) - pad;
                break;
            case 'lowerleft':
                _x -= pad;
                _y = _y - (ch - nh) - pad;
                break;
            case 'upperright':
                _x = _x - (cw - nw) - pad;
                _y -= pad;
                break;
            case 'upperleft':
                _x -= pad;
                _y -= pad;
                break;
            default:
                // center
                _x -= cw / 2 - nw / 2;
                _y -= ch / 2 - nh / 2;
                break;
        }
        if (_x === self.slate.options.viewPort.left && _y === self.slate.options.viewPort.top) cb.apply();
        else self.slate.canvas.move({
            x: _x,
            y: _y,
            dur,
            callbacks: {
                after () {
                    cb?.apply(self, [
                        {
                            id: self.options.id,
                            operation: 'position',
                            location,
                            easing
                        }
                    ]);
                }
            },
            isAbsolute: true,
            easing
        });
    }
    toggleImage(opts) {
        if (this.options.vectorPath && this.options.remoteImage) {
            if (opts.active) {
                const _svgAsImage = this.options.remoteImage;
                this.hidden = {
                    vectorPath: this.options.vectorPath
                };
                this.shapes.set({
                    shape: 'rect',
                    keepResizerOpen: opts.keepResizerOpen
                });
                this.images.set(_svgAsImage, this.options.width, this.options.height, opts.keepResizerOpen);
                this.text && this.text.hide();
            } else if (this.hidden) {
                this.images.set('', this.options.width, this.options.height);
                this.customShapes.set(this.hidden.vectorPath);
                if (opts.width && opts.height) this.resize.set(opts.width, opts.height);
                this.text && this.text.show();
                this.relationships.showOwn();
                setTimeout(()=>{
                    this.menu.show();
                }, 100);
                delete this.hidden;
            }
        }
    }
    disable() {
        this.options.allowMenu = false;
        this.options.allowDrag = false;
        this.hideOwnMenus();
        if (this.slate.options.showLocks && this.options.isLocked) this.showLock();
    // this.relationships.unwireHoverEvents();
    }
    enable() {
        this.options.allowMenu = true // _prevAllowMenu || true;
        ;
        this.options.allowDrag = true // _prevAllowDrag || true;
        ;
        this.hideLock();
    // this.relationships.wireHoverEvents();
    }
    showLock() {
        const self = this;
        const _vpt = self.vect.getBBox();
        const r = self.slate.paper;
        if (!self._lock && self.slate.options.showLocks) self._lock = r.lockClosed().transform([
            't',
            _vpt.x2 - 10,
            ',',
            _vpt.y2 - 10,
            's',
            0.9,
            0.9
        ].join()).attr({
            fill: '#fff',
            stroke: '#000'
        });
        return self._lock;
    }
    mark() {
        const self = this;
        if (!self.marker) {
            const rect = self.vect.getBBox();
            const z = self.slate.options.viewPort.zoom.r;
            const padding = 10;
            const clr = (0, _utilsDefault.default).whiteOrBlack(self.slate.options.containerStyle.backgroundColor);
            self.marker = self.slate.paper.rect(rect.x - padding, rect.y - padding, rect.width + padding * 2, rect.height + padding * 2).attr({
                'stroke-dasharray': '-',
                fill: clr,
                opacity: 0.5
            });
            self.marker.toBack();
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
    }
    unmark() {
        const self = this;
        self.marker?.remove();
        delete self.marker;
    }
    hideLock() {
        this.hideOpenLock();
        this._lock && this._lock.remove();
        this._lock = null;
        this.slate && this.slate.unglow();
    }
    showOpenLock() {
        const self = this;
        const _vpt = this.vect.getBBox();
        const r = this.slate.paper;
        self._openLock = r.lockOpen().transform([
            't',
            _vpt.x2 - 10,
            ',',
            _vpt.y2 - 10,
            's',
            0.9,
            0.9
        ].join()).attr({
            fill: '#fff',
            stroke: '#000'
        });
        self._openLock.mouseover((e)=>{
            self._openLock.attr({
                'stroke-width': '2px',
                'stroke-color': '#000'
            });
            self._openLock.style.cursor = 'pointer';
        });
        self._openLock.mouseout(()=>{
            self.hideOpenLock();
            self.showLock();
        });
        self._openLock.mousedown(()=>{
            self.enable();
            self.options.isLocked = false;
            const pkg = {
                type: 'onNodeUnlocked',
                data: {
                    id: self.options.id
                }
            };
            self.context.broadcast(pkg);
        });
        return self._openLock;
    }
    hideOpenLock() {
        this._openLock && this._openLock.remove();
        this._openLock = null;
    }
    initLock() {
        if (this.vect && this.options.isLocked) this.showLock();
    }
    offset() {
        let _x = this.options.xPos - this.slate.options.viewPort.left;
        let _y = this.options.yPos - this.slate.options.viewPort.top;
        if (this.options.vectorPath === 'ellipse') {
            _x -= this.options.width / 2;
            _y -= this.options.height / 2;
        }
        return {
            x: _x,
            y: _y
        };
    }
    textCoords(opts = {}) {
        const _useX = opts.x || this.vect.ox || 0;
        const _useY = opts.y || this.vect.oy || 0;
        // these are the center defaults
        // start
        let _offsetX = this.options?.textOffset?.x || 0;
        // middle
        let _offsetY = this.options?.textOffset?.y || 0;
        const bbox = this.vect.getBBox();
        const _scale = 1;
        switch(this.options.textXAlign){
            case 'end':
                _offsetX = _offsetX * _scale + this.options.textOffset.width;
                break;
            case 'middle':
                _offsetX = _offsetX * _scale + this.options.textOffset.width / 2;
                break;
            default:
                break;
        }
        switch(this.options.textYAlign){
            case 'hanging':
                _offsetY = _offsetY * _scale - bbox.height / 2;
                break;
            case 'baseline':
                _offsetY = _offsetY * _scale + bbox.height / 2;
                break;
            default:
                break;
        }
        const tx = _useX + _offsetX;
        const ty = _useY + _offsetY;
        const _tc = {
            x: tx,
            y: ty
        };
        return _tc;
    }
    linkCoords() {
        let x = this.options.xPos - 20;
        let y = this.options.yPos + this.options.height / 2 - 22;
        if (this.vect.type !== 'rect') {
            y = this.options.yPos + this.options.height / 2 - 22;
            x = this.options.xPos - 20;
        }
        return {
            x,
            y
        };
    }
    _rotate(_opts) {
        const opts = {
            angle: 0,
            cb: null,
            dur: 0
        };
        Object.assign(opts, _opts);
        const ta = [
            'r',
            opts.angle
        ].join('');
        if (opts.dur === 0) {
            this.vect.transform(ta);
            this.text.transform(ta);
            if (this.options.link.show) this.link.transform(ta);
            opts.cb && opts.cb();
        } else {
            const lm = this.slate.paper.set();
            lm.push(this.vect);
            lm.push(this.text);
            if (this.options.link.show) lm.push(this.link);
            lm.animate({
                transform: ta
            }, opts.dur, '>', ()=>{
                opts.cb && opts.cb();
            });
        }
    }
}
exports.default = node;

},{"./base":"cmkOb","../helpers/getTransformedPath":"6wubb","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cmkOb":[function(require,module,exports,__globalThis) {
/* eslint-disable new-cap */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
const availablePlugins = {};
class base {
    constructor(initPayload){
        // register any plugins
        if (this.constructor.name !== 'plugin') this.registerPlugins(initPayload);
    }
    registerPlugins(initPayload) {
        const root = this.constructor.name;
        // console.log("registering plugins ", root, base.plugins, base.plugins[root]);
        if (availablePlugins[root]) availablePlugins[root].forEach((p)=>{
            const { name, plugin } = p;
            if (!this.plugins) this.plugins = {};
            this.plugins[name] = new plugin(initPayload);
        });
    }
    static registerPlugin(details) {
        if (!details.name || !details.plugin) throw new Error('Plugins must provide a name and a plugin (class definition)');
        const root = Object.getPrototypeOf(details.plugin).name;
        // console.log("creating plugin root ", root);
        if (!availablePlugins[root]) availablePlugins[root] = [];
        availablePlugins[root] = [
            ...availablePlugins[root],
            details
        ];
    }
}
exports.default = base;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6wl7A":[function(require,module,exports,__globalThis) {
/* eslint-disable new-cap */ /* eslint-disable class-methods-use-this */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _getTransformedPath = require("../helpers/getTransformedPath");
var _getTransformedPathDefault = parcelHelpers.interopDefault(_getTransformedPath);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _getDepCoords = require("../helpers/getDepCoords");
var _getDepCoordsDefault = parcelHelpers.interopDefault(_getDepCoords);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _editor = require("../node/editor");
var _editorDefault = parcelHelpers.interopDefault(_editor);
var _relationships = require("../node/relationships");
var _relationshipsDefault = parcelHelpers.interopDefault(_relationships);
var _rotate = require("../node/rotate");
var _rotateDefault = parcelHelpers.interopDefault(_rotate);
var _menu = require("../node/menu");
var _menuDefault = parcelHelpers.interopDefault(_menu);
var _connectors = require("../node/connectors");
var _connectorsDefault = parcelHelpers.interopDefault(_connectors);
var _resize = require("../node/resize");
var _resizeDefault = parcelHelpers.interopDefault(_resize);
var _images = require("../node/images");
var _imagesDefault = parcelHelpers.interopDefault(_images);
var _shapes = require("../node/shapes");
var _shapesDefault = parcelHelpers.interopDefault(_shapes);
var _customShapes = require("../node/customShapes");
var _customShapesDefault = parcelHelpers.interopDefault(_customShapes);
var _colorPicker = require("../node/colorPicker");
var _colorPickerDefault = parcelHelpers.interopDefault(_colorPicker);
var _context = require("../node/context");
var _contextDefault = parcelHelpers.interopDefault(_context);
var _lineOptions = require("../node/lineOptions");
var _lineOptionsDefault = parcelHelpers.interopDefault(_lineOptions);
var _gridLines = require("../node/gridLines");
var _gridLinesDefault = parcelHelpers.interopDefault(_gridLines);
var _links = require("../node/links");
var _linksDefault = parcelHelpers.interopDefault(_links);
class nodeController {
    constructor(slate1){
        this.slate = slate1;
        this.ensureBe = null;
        this.allNodes = [];
    }
    _refreshBe() {
        const self = this;
        window.clearTimeout(self.ensureBe);
        self.ensureBe = window.setTimeout(()=>{
            self.slate.birdsEye?.refresh(false);
        }, 10);
    }
    _getParentChild(obj) {
        let _parent;
        let _child;
        this.allNodes.forEach((node)=>{
            if (node.options.id === obj.parent) _parent = node;
            else if (node.options.id === obj.child) _child = node;
        });
        return {
            p: _parent,
            c: _child
        };
    }
    static remove(a, obj) {
        return a.filter((ax)=>ax.options.id !== obj.options.id);
    }
    copyNodePositions(source, useMainCanvas = false) {
        const self = this;
        source.forEach((src)=>{
            // if (src.options.id !== self.tempNodeId) {
            let cn = self.allNodes.find((n)=>n.options.id === src.options.id);
            if (!cn) {
                self.add(src);
                cn = self.allNodes.find((n)=>n.options.id === src.options.id);
            }
            cn.setPosition({
                x: src.options.xPos,
                y: src.options.yPos
            });
            const opts = {};
            if (useMainCanvas) {
                const tempPath = self.slate.paper.path(cn.vect.attr('path')) // Meteor.currentSlate.paper
                ;
                opts.boundingClientRect = tempPath[0].getBoundingClientRect();
                tempPath.remove();
            }
            cn.rotate.applyImageRotation(opts);
        // }
        });
        (0, _lodashInvokeDefault.default)(self.allNodes.map((n)=>n.relationships), 'refresh');
    }
    packageLayout() {
        const self = this;
        const knownGraphVizShapes = [
            'rect',
            'rectangle',
            'circle',
            'star',
            'trapezium',
            'triangle',
            'pentagon',
            'parallelogram',
            'octagon',
            'hexagon',
            'rarrow',
            'larrow'
        ];
        const eligibleNodes = self.slate.options.disableAutoLayoutOfManuallyPositionedNodes ? self.allNodes.filter((nn)=>!nn.options.humanTouch) : self.allNodes;
        // package up all the unique associations and the width/height of every node
        let associations = eligibleNodes.map((nx)=>nx.relationships.associations.map((a)=>{
                return {
                    parentId: a.parent.options.id,
                    childId: a.child.options.id,
                    lineWidth: a.lineWidth,
                    lineType: a.lineType,
                    lineCurveType: a.lineCurveType,
                    lineCurviness: a.lineCurviness,
                    lineOpacity: a.lineOpacity,
                    showParentArrow: a.showParentArrow,
                    showChildArrow: a.showChildArrow
                };
            })).flat();
        const nodes = {};
        eligibleNodes.forEach((nx)=>{
            if (!nodes[nx.options.id]) nodes[nx.options.id] = {
                width: +nx.options.width,
                height: +nx.options.height,
                shape: knownGraphVizShapes.includes(nx.options.shapeHint) || 'polygon',
                color: nx.options.backgroundColor,
                textColor: nx.options.foregroundColor,
                text: nx.options.text,
                groupId: nx.options.groupId
            };
        });
        const subgraphs = {};
        eligibleNodes.forEach((nx)=>{
            if (!subgraphs[nx.options.groupId]) subgraphs[nx.options.groupId] = [];
            subgraphs[nx.options.groupId].push(nx.options.id);
        });
        return {
            layoutType: self.slate.options.layoutType,
            associations,
            nodes,
            uniqueIds: Object.keys(nodes),
            subgraphs
        };
    }
    applyLayout(layout, cb) {
        const self = this;
        // console.log('received layout', layout)
        /*
    "exportNodes": {
      "010C580B": {
        "x": "279.5",
        "y": "322"
      },
      "ad79211ead0a": {
        "x": "183.5",
        "y": "186"
      },
      "c2134651593b": {
        "x": "376.5",
        "y": "186"
      },
      "0bad6428b74a": {
        "x": "87.5",
        "y": "50"
      },
      "2aab8002c94c": {
        "x": "280.5",
        "y": "50"
      }
    }
    */ const orient = self.slate.getOrientation(null, true) // - always pin to no zoom (1)
        ;
        const allMoves = [];
        self.allNodes.forEach((n, i)=>{
            if (layout.exportNodes?.[n.options.id]) {
                let { x, y } = layout.exportNodes[n.options.id];
                x = parseFloat(x);
                y = parseFloat(y);
                // console.log(
                //   'target aquired',
                //   n.options.id,
                //   x,
                //   y,
                //   x * -2 + x,
                //   y * -2 + y,
                //   n.options.xPos,
                //   n.options.yPos
                // )
                allMoves.push({
                    id: n.options.id,
                    x: orient.left - x - n.options.xPos + orient.width,
                    y: orient.top - y - n.options.yPos + orient.height
                });
            }
        });
        let batchSize = 6;
        if (self.allNodes.length > 15) batchSize = 12;
        if (layout.allAtOnce || self.slate.nodes.allNodes.length > 12) batchSize = 1;
        const batches = (0, _utilsDefault.default).chunk((0, _lodashClonedeepDefault.default)(allMoves), Math.ceil(allMoves.length / batchSize));
        // console.log(
        //   'received layout2',
        //   batchSize,
        //   allMoves.length,
        //   self.allNodes.length,
        //   batches.length
        // )
        const sendMove = (batch)=>{
            let dur = 300;
            if (layout.allAtOnce) dur = 0;
            const pkg = self.slate.nodes.nodeMovePackage({
                dur,
                moves: batch
            });
            self.slate.collab?.exe({
                type: 'onNodesMove',
                data: pkg
            });
            if (batches.length > 0) setTimeout(()=>{
                sendMove(batches.pop());
            }, 250);
            else {
                if (layout.skipCenter) self.slate.controller.centerOnNodes({
                    dur: 500
                });
                else self.slate.controller.scaleToFitAndCenter();
                // finally invoke toFront for all nodes
                self.slate.nodes.allNodes.forEach((n)=>n.toBack());
                cb && cb();
            }
        };
        // kick it off
        sendMove(batches.pop());
    }
    getStickies(blnEmpty) {
        // stickies
        const stickies = slate.nodes.allNodes.filter((n)=>n?.options?.filters?.vect === 'postItNote' && n?.options?.disableDrag === false && n?.options?.text?.length > blnEmpty ? 10000 : 0).map((n)=>({
                xPos: n.options.xPos,
                yPos: n.options.yPos,
                width: n.options.width,
                height: n.options.height,
                id: n.options.id
            }));
    }
    getProjectNameNode() {
        return this.slate.nodes.allNodes.find((n)=>n.options.text.match(/project name/gi));
    }
    parseTemplateIntoCategories() {
        const categories = slate.nodes.allNodes.filter((n)=>n.options.isCategory && n.options.categoryName?.length).map((nx)=>({
                xPos: nx.options.xPos,
                yPos: nx.options.yPos,
                width: nx.options.width,
                height: nx.options.height,
                categoryName: nx.options.categoryName
            }));
        // console.log(
        //   'rectnagles, categories',
        //   slate?.nodes?.allNodes?.length,
        //   rectangles,
        //   categories
        // )
        const matched = {};
        categories.forEach((categ)=>{
            if (!matched[categ.categoryName]) matched[categ.categoryName] = {
                top: categ.yPos,
                left: categ.xPos,
                bottom: categ.yPos + categ.height,
                right: categ.xPos + categ.width
            };
        });
        return matched;
    }
    addRange(_nodes, cb) {
        const self = this;
        _nodes.forEach((node)=>{
            self.add(node);
        });
        cb?.();
        return self;
    }
    removeRange(_nodes) {
        const self = this;
        _nodes.forEach((node)=>{
            self.allNodes = nodeController.remove(self.allNodes, node);
        });
        return self;
    }
    add(nodes, useMainCanvas, cb) {
        const self = this;
        if (!Array.isArray(nodes)) nodes = [
            nodes
        ];
        nodes.forEach((node)=>{
            node.slate = self.slate // parent
            ;
            self.allNodes.push(node);
            self.addToCanvas(node, useMainCanvas);
        });
        cb?.();
    }
    remove(nodes) {
        const self = this;
        if (!Array.isArray(nodes)) nodes = [
            nodes
        ];
        nodes.forEach((node)=>{
            self.allNodes = nodeController.remove(self.allNodes, node);
            node.slate = null;
            self.removeFromCanvas(node);
        });
    }
    nodeMovePackage(opts = {}) {
        // if exporting a move package with moves applied (e.g., you're
        // planning on manipulating the slate programmatically and this is
        // not an export bound for collaboration (at first)) -- then we need
        // to apply the final results to a copy of the slate because they are need
        // for the calculations below, and those calcs are mutable, so they
        // cannot be applied to the current slate.
        let _use = this.slate;
        let divCopy = null;
        if (opts && opts.moves) {
            divCopy = document.createElement('div');
            const _did = `copy_${(0, _utilsDefault.default).guid()}`;
            divCopy.setAttribute('id', _did);
            divCopy.setAttribute('style', `width:1px;height:1px;display:none;`);
            document.body.appendChild(divCopy);
            _use = this.slate.copy({
                container: _did,
                moves: opts.moves
            });
        }
        const nds = opts?.nodes || _use.nodes.allNodes;
        const _ret = {
            dur: opts ? opts.dur : 300,
            easing: opts ? opts.easing : '>',
            textPositions: (()=>nds.map((node)=>({
                        id: node.options.id,
                        textPosition: {
                            x: node.text.attrs.x,
                            y: node.text.attrs.y,
                            transform: node.getTransformString()
                        }
                    })))(),
            nodeOptions: nds.map((node)=>{
                return {
                    id: node.options.id,
                    vectorPath: node.options.vectorPath,
                    xPos: node.options.xPos,
                    yPos: node.options.yPos
                };
            }),
            associations: (()=>{
                const assoc = [];
                if (opts.relationships && opts.nodes) opts.relationships.forEach((a)=>{
                    assoc.push({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr('path').toString(),
                        id: a.line.id
                    });
                });
                else _use.nodes.allNodes.forEach((node)=>{
                    node.relationships.associations.forEach((a)=>{
                        assoc.push({
                            parentId: a.parent.options.id,
                            childId: a.child.options.id,
                            linePath: a.line.attr('path').toString(),
                            id: a.line.id
                        });
                    });
                });
                return (0, _lodashUniqDefault.default)(assoc, (a)=>a.id);
            })()
        };
        if (divCopy) document.body.removeChild(divCopy);
        return _ret;
    }
    moveNodes(pkg, options = {}) {
        this.closeAllLineOptions();
        this.closeAllMenus();
        // _node.hideOwnMenus();
        const allAssoc = [];
        this.allNodes.forEach((node)=>{
            node.relationships.associations.forEach((a)=>{
                allAssoc.push(a);
            });
        });
        const uniqAssoc = (0, _lodashUniqDefault.default)(allAssoc, (a)=>a.id);
        const p = pkg.data || pkg;
        const d = p.dur || 300;
        const e = p.easing || '>';
        const { associations, nodeOptions, textPositions } = p;
        let cntr = 0;
        function _potentiallyFinalize(isAssoc) {
            cntr += 1;
            if (associations.length === nodeOptions.length && cntr === nodeOptions.length && options.cb) {
                options.cb();
                delete options.cb;
            }
        }
        nodeOptions.forEach((opts)=>{
            const nodeObject = this.allNodes.find((node)=>node.options.id === opts.id);
            if (nodeObject) {
                Object.assign(nodeObject.options, opts);
                const dps = (0, _getDepCoordsDefault.default)({
                    x: opts.xPos,
                    y: opts.yPos
                }, nodeObject.options);
                const { lx, ty } = dps;
                const currentTextPosition = textPositions.find((tp)=>tp.id === opts.id);
                if (options.animate) {
                    nodeObject.text.animate(currentTextPosition.textPosition, d, e);
                    nodeObject.link.animate({
                        x: lx,
                        y: ty
                    }, d, e);
                } else {
                    nodeObject.text.attr(currentTextPosition.textPosition);
                    nodeObject.link.attr({
                        x: lx,
                        y: ty
                    });
                }
                if (this.slate.options.debugMode && !this.slate.options.isbirdsEye) nodeObject.debugPosition();
                if (options.animate) {
                    if (nodeObject) nodeObject.vect.animate({
                        path: opts.vectorPath,
                        transform: nodeObject.getTransformString()
                    }, d, e, ()=>{
                        nodeObject.vect.attr({
                            path: opts.vectorPath
                        });
                        nodeObject.images.imageSizeCorrection();
                        _potentiallyFinalize();
                    });
                } else {
                    if (nodeObject) nodeObject.vect.attr({
                        path: opts.vectorPath
                    });
                    let rotationOptions = {};
                    if (options.useMainCanvas) {
                        const tempPath = this.slate.paper.path(nodeObject.vect.attr('path')) // Meteor.currentSlate.paper.
                        ;
                        rotationOptions = {
                            boundingClientRect: tempPath[0].getBoundingClientRect()
                        };
                        tempPath.remove();
                    }
                    nodeObject.rotate.applyImageRotation(rotationOptions);
                    nodeObject.images.imageSizeCorrection();
                    _potentiallyFinalize();
                }
            }
        });
        // this is important only when collaboration is active
        const ensureRefreshed = ()=>{
            const currentCollaborators = this.slate.collab.currentCollaborators();
            if (currentCollaborators.length > 1) nodeOptions.forEach((opts)=>{
                const nodeObject = this.allNodes.find((node)=>node.options.id === opts.id);
                nodeObject.relationships.refreshOwnRelationships();
            });
        };
        associations.forEach((assoc, aCnt)=>{
            const a = uniqAssoc.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId);
            if (a) {
                if (options.animate) a.line.animate({
                    path: assoc.linePath
                }, d, e, ()=>{
                    a.line.attr({
                        path: assoc.linePath
                    });
                    if (aCnt + 1 === associations.length) ensureRefreshed();
                });
                else {
                    a.line.attr({
                        path: assoc.linePath
                    });
                    if (aCnt + 1 === associations.length) ensureRefreshed();
                }
            }
        });
        this.slate.birdsEye?.refresh(true);
    }
    getRelevantAssociationsWith(nodes) {
        const _relationshipsToTranslate = [];
        const _relationshipsToRefresh = [];
        nodes.forEach((node)=>{
            const otherSelectedNodes = nodes.filter((n)=>n.options.id !== node.options.id);
            node.relationships.associations.forEach((assoc)=>{
                if (otherSelectedNodes.map((n)=>n.relationships.associations).some((associations)=>associations.find((a)=>a.id === assoc.id))) {
                    if (!_relationshipsToTranslate.some((r)=>r.id === assoc.id)) _relationshipsToTranslate.push(assoc) // connections which move with both nodes
                    ;
                } else if (!_relationshipsToRefresh.some((r)=>r.id === assoc.id)) _relationshipsToRefresh.push(assoc) // connections which move on one end only
                ;
            });
        });
        return {
            relationshipsToRefresh: _relationshipsToRefresh,
            relationshipsToTranslate: _relationshipsToTranslate
        };
    }
    translateRelationships(relationships, { dx, dy }) {
        relationships.forEach((r)=>{
            r.line.transform(`T${dx}, ${dy}`);
        });
    }
    saveRelationships(relationships, { dx, dy }) {
        relationships.forEach((r)=>{
            const newLinePath = (0, _utilsDefault.default)._transformPath(r.line.attr('path').toString(), `T${dx},${dy}`).toString();
            r.line.attr({
                path: newLinePath
            });
            r.line.transform('');
        });
    }
    removeRelationship(rm) {
        const pc = this._getParentChild(rm);
        const _parent = pc.p;
        const _child = pc.c;
        if (_parent && _child) {
            // _parent.relationships.removeChild(_child);
            // _child.relationships.removeParent(_parent);
            _parent.relationships.removeAssociation(_child);
            _child.relationships.removeAssociation(_parent);
        }
    }
    refreshAllRelationships() {
        this.allNodes.forEach((node)=>{
            node.relationships.refreshOwnRelationships();
        });
    }
    addRelationship(add) {
        const pc = this._getParentChild(add);
        const _parent = pc.p;
        const _child = pc.c;
        if (_parent && _child) switch(add.type){
            case 'association':
                _parent.relationships.addAssociation(_child, add.options);
                break;
            default:
                break;
        }
    }
    closeAllLineOptions(exception) {
        this.allNodes.forEach((node)=>{
            node.relationships.associations.forEach((association)=>{
                if (association.id !== exception) node.lineOptions?.hide(association.id);
            });
        });
    }
    closeAllMenus({ exception, nodes } = {}) {
        (nodes || this.allNodes).forEach((node)=>{
            if (node.options.id !== exception) {
                node.menu.hide();
                node.lineOptions?.hideAll();
                node.resize?.hide();
                node.rotate?.hide();
            }
        });
    }
    closeAllConnectors() {
        this.allNodes.forEach((node)=>{
            node.connectors?.remove();
            node.resize?.hide();
            node.rotate?.hide();
        });
    }
    one(id) {
        let cn = null;
        this.allNodes.forEach((node)=>{
            if (node.options.id === id) cn = node;
        });
        return cn;
    }
    removeFromCanvas(_node) {
        [
            'vect',
            'text',
            'link'
        ].forEach((tt)=>{
            _node[tt].remove();
        });
        this._refreshBe();
    }
    addToCanvas(_node, useMainCanvas) {
        _node.slate = this.slate;
        let vect = null;
        let link = null;
        const vectOpt = {
            fill: _node.options.backgroundColor || '#fff',
            'fill-opacity': _node.options.opacity != null ? _node.options.opacity : 1
        };
        Object.assign(vectOpt, _node.applyBorder());
        const _x = _node.options.xPos;
        const _y = _node.options.yPos;
        const paperToUse = this.slate.paper;
        const percent = 1;
        const _width = _node.options.width;
        const _height = _node.options.height;
        const _transforms = [
            `T${_x * percent}, ${_y * percent}`,
            `s${_width / 150 * percent}, ${_height / 100 * percent}, ${_x}, ${_y}`
        ];
        _node.options.isEllipse = _node.options.isEllipse || _node.options.vectorPath === 'ellipse';
        let potentiallyResize = false;
        switch(_node.options.vectorPath){
            case 'ellipse':
                _node.options.vectorPath = (0, _getTransformedPathDefault.default)('M150,50 a75,50 0 1,1 0,-1 z', _transforms);
                break;
            case 'rectangle':
                _node.options.vectorPath = (0, _getTransformedPathDefault.default)('M1,1 h150 v100 h-150 v-100 z', _transforms);
                break;
            case 'roundedrectangle':
                _node.options.vectorPath = (0, _getTransformedPathDefault.default)('M1,1 h130 a10,10 0 0 1 10,10 v80 a10,10 0 0 1 -10,10 h-130 a10,10 0 0 1 -10,-10 v-80 a10,10 0 0 1 10,-10 z', _transforms);
                break;
            default:
                potentiallyResize = true;
                break;
        }
        if (_node.options.vectorPath === 'M2,12 L22,12') vectOpt['stroke-dasharray'] = '2px';
        vect = vect ? vect : paperToUse.path(_node.options.vectorPath).attr(vectOpt);
        vect.node.style.cursor = 'pointer';
        // need to set in case toback or tofront is called and the load order changes in the context plugin
        const allowDragRider = _node.options.disableDrag ? 'nodrag_' : '';
        vect.node.setAttribute('rel', `${allowDragRider}${_node.options.id}`);
        vect.data({
            id: _node.options.id
        });
        _node.vect = vect;
        // _node.vect.ox = _x;
        // _node.vect.oy = _y;
        // get the text coords before the transform is applied
        // var tc = _node.textCoords();
        _node.vect.transform(_node.getTransformString());
        // update xPos, yPos in case it is different than actual
        const bbox = vect.getBBox();
        _node.options.xPos = bbox.x;
        _node.options.yPos = bbox.y;
        if (!_node.options.origVectWidth && _node.options.shapeHint === 'custom') _node.options.origVectWidth = bbox.width;
        if (!_node.options.origVectHeight && _node.options.shapeHint === 'custom') _node.options.origVectHeight = bbox.height;
        const lc = _node.linkCoords();
        // apply the text coords prior to transform
        // text = paperToUse.text(tc.x, tc.y, (_node.options.text || '')).attr({ "font-size": _node.options.fontSize + "pt", fill: _node.options.foregroundColor || "#000" });
        link = paperToUse.linkArrow().transform([
            't',
            lc.x,
            ',',
            lc.y,
            's',
            '.8',
            ',',
            '.8',
            'r',
            '180'
        ].join()).attr({
            cursor: 'pointer'
        });
        // create and set editor
        _node.editor = new (0, _editorDefault.default)(this.slate, _node);
        _node.editor.set() // creates and sets the text
        ;
        _node.text.transform(_node.getTransformString());
        // set link
        _node.link = link;
        _node.both = new _node.slate.paper.set();
        _node.both.push(_node.vect);
        _node.both.push(_node.text);
        // relationships
        _node.relationships = new (0, _relationshipsDefault.default)(this.slate, _node);
        _node.relationships.wireDragEvents();
        // rotate
        _node.rotate = new (0, _rotateDefault.default)(this.slate, _node);
        // connectors
        _node.connectors = new (0, _connectorsDefault.default)(this.slate, _node);
        // menu
        _node.menu = new (0, _menuDefault.default)(this.slate, _node);
        // resizer
        _node.resize = new (0, _resizeDefault.default)(this.slate, _node);
        // images
        _node.images = new (0, _imagesDefault.default)(this.slate, _node);
        // context
        _node.context = new (0, _contextDefault.default)(this.slate, _node);
        // lineOptions
        _node.lineOptions = new (0, _lineOptionsDefault.default)(this.slate, _node);
        // shapes
        _node.shapes = new (0, _shapesDefault.default)(this.slate, _node);
        // customShapes
        _node.customShapes = new (0, _customShapesDefault.default)(this.slate, _node);
        // colorPicker
        _node.colorPicker = new (0, _colorPickerDefault.default)(this.slate, _node);
        // gridLines
        _node.gridLines = new (0, _gridLinesDefault.default)(this.slate, _node);
        //links
        _node.links = new (0, _linksDefault.default)(this.slate, _node);
        if (_node.options.image && !_node.options.imageOrigHeight) _node.options.imageOrigHeight = _node.options.height;
        if (_node.options.image && !_node.options.imageOrigWidth) _node.options.imageOrigWidth = _node.options.width;
        if (_node.options.image && _node.options.image !== '') _node.images.set(_node.options.image, _node.options.imageOrigWidth, _node.options.imageOrigHeight, useMainCanvas);
        if (!_node.options.link || !_node.options.link.show) _node.link.hide();
        //
        if (potentiallyResize) _node.resize.set(_width, _height);
        // apply any node filters to vect and/or text
        _node.applyFilters();
        this._refreshBe();
        return vect;
    }
}
exports.default = nodeController;

},{"lodash.uniq":"iDalh","lodash.invoke":"6VYuy","lodash.clonedeep":"i3u1q","../helpers/getTransformedPath":"6wubb","../helpers/refreshRelationships":"1UeYf","../helpers/getDepCoords":"hVTn1","../helpers/utils":"8QI6M","../node/editor":"klp05","../node/relationships":"8zQA0","../node/rotate":"6en3b","../node/menu":"91LgF","../node/connectors":"h710n","../node/resize":"4vYbQ","../node/images":"jLcMC","../node/shapes":"kA5hP","../node/customShapes":"edbtN","../node/colorPicker":"jJAST","../node/context":"185nI","../node/lineOptions":"c3gfk","../node/gridLines":"6cFRW","../node/links":"4BxQS","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6VYuy":[function(require,module,exports,__globalThis) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var global = arguments[3];
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0;
/** `Object#toString` result references. */ var funcTag = '[object Function]', genTag = '[object GeneratorFunction]', symbolTag = '[object Symbol]';
/** Used to match property names within property paths. */ var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match backslashes in property paths. */ var reEscapeChar = /\\(\\)?/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */ function apply(func, thisArg, args) {
    switch(args.length){
        case 0:
            return func.call(thisArg);
        case 1:
            return func.call(thisArg, args[0]);
        case 2:
            return func.call(thisArg, args[0], args[1]);
        case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {}
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Symbol = root.Symbol, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max;
/* Built-in method references that are verified to be native. */ var Map = getNative(root, 'Map'), nativeCreate = getNative(Object, 'create');
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */ function baseGet(object, path) {
    path = isKey(path, object) ? [
        path
    ] : castPath(path);
    var index = 0, length = path.length;
    while(object != null && index < length)object = object[toKey(path[index++])];
    return index && index == length ? object : undefined;
}
/**
 * The base implementation of `_.invoke` without support for individual
 * method arguments.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {Array} args The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 */ function baseInvoke(object, path, args) {
    if (!isKey(path, object)) {
        path = castPath(path);
        object = parent(object, path);
        path = last(path);
    }
    var func = object == null ? object : object[toKey(path)];
    return func == null ? undefined : apply(func, object, args);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */ function baseRest(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while(++index < length)array[index] = args[start + index];
        index = -1;
        var otherArgs = Array(start + 1);
        while(++index < start)otherArgs[index] = args[index];
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
    };
}
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */ function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) start = -start > length ? 0 : length + start;
    end = end > length ? length : end;
    if (end < 0) end += length;
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while(++index < length)result[index] = array[index + start];
    return result;
}
/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */ function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') return value;
    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : '';
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */ function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */ function isKey(value, object) {
    if (isArray(value)) return false;
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) return true;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */ function parent(object, path) {
    return path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
}
/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */ var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) result.push('');
    string.replace(rePropName, function(match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
});
/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */ function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) return value;
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + '';
        } catch (e) {}
    }
    return '';
}
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */ function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : undefined;
}
/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */ function memoize(func, resolver) {
    if (typeof func != 'function' || resolver && typeof resolver != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) return cache.get(key);
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
}
// Assign cache to `_.memoize`.
memoize.Cache = MapCache;
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */ function toString(value) {
    return value == null ? '' : baseToString(value);
}
/**
 * Invokes the method at `path` of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the method to invoke.
 * @param {...*} [args] The arguments to invoke the method with.
 * @returns {*} Returns the result of the invoked method.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
 *
 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
 * // => [2, 3]
 */ var invoke = baseRest(baseInvoke);
module.exports = invoke;

},{}],"1UeYf":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>refreshRelationships);
var _closestPoint = require("./closestPoint");
var _closestPointDefault = parcelHelpers.interopDefault(_closestPoint);
var _getHorizontalCurve = require("./getHorizontalCurve");
var _getHorizontalCurveDefault = parcelHelpers.interopDefault(_getHorizontalCurve);
var _getCorrectMidPoints = require("./getCorrectMidPoints");
var _getCorrectMidPointsDefault = parcelHelpers.interopDefault(_getCorrectMidPoints);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
function refreshRelationships({ relationships, nodes, dx = 0, dy = 0 }) {
    relationships.forEach((r)=>{
        const midPoints = (0, _getCorrectMidPointsDefault.default)(r);
        let tempOriginNode;
        let tempEndNode;
        let linePath;
        if (nodes.some((n)=>n.options.id === r.parent.options.id)) {
            tempOriginNode = r.parent.getTempPathWithCorrectPositionFor({
                pathElement: r.parent.vect,
                dx,
                dy
            });
            tempEndNode = r.child.getTempPathWithCorrectPositionFor({
                // this one is all about rotation
                pathElement: r.child.vect,
                dx: 0,
                dy: 0
            });
            const childPathContext = (0, _closestPointDefault.default)(tempEndNode || r.child.vect, midPoints.parent);
            const pointOnChildPath = childPathContext.bestPoint;
            const parentPathContext = (0, _closestPointDefault.default)(tempOriginNode || r.parent.vect, pointOnChildPath);
            const pointOnParentPath = parentPathContext.bestPoint;
            // console.log('getHorizontalCurve1', r.parent.options.width)
            linePath = (0, _getHorizontalCurveDefault.default)(pointOnParentPath, pointOnChildPath, r.lineCurviness, r.lineType, r.lineCurveType, r.parent.options.width, {
                x: r.parent.options.xPos,
                y: r.parent.options.yPos
            });
        } else {
            tempEndNode = r.child.getTempPathWithCorrectPositionFor({
                pathElement: r.child.vect,
                dx,
                dy
            });
            tempOriginNode = r.parent.getTempPathWithCorrectPositionFor({
                // this one is all about rotation
                pathElement: r.parent.vect,
                dx: 0,
                dy: 0
            });
            const childPathContext = (0, _closestPointDefault.default)(tempEndNode || r.child.vect, midPoints.parent);
            const pointOnChildPath = childPathContext.bestPoint;
            const parentPathContext = (0, _closestPointDefault.default)(tempOriginNode || r.parent.vect, pointOnChildPath);
            const pointOnParentPath = parentPathContext.bestPoint;
            // console.log('getHorizontalCurve2', r.parent.options.width)
            linePath = (0, _getHorizontalCurveDefault.default)(pointOnParentPath, pointOnChildPath, r.lineCurviness, r.lineType, r.lineCurveType, r.parent.options.width, {
                x: r.parent.options.xPos,
                y: r.parent.options.yPos
            });
        }
        const _attr = {
            stroke: r.lineColor,
            fill: 'none',
            'stroke-width': r.lineWidth,
            'fill-opacity': r.lineOpacity,
            opacity: r.lineOpacity,
            filter: !(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile() && r.lineEffect ? `url(#${r.lineEffect})` : ''
        };
        // stop connection re-draws when shift+alt drag until the move is up because the lines are hidden anyways
        if (!(r.isAlt && r.isShift) || r.isAlt && r.isShift && r.isUp) _attr.path = linePath;
        if (r.showChildArrow) Object.assign(_attr, {
            'arrow-end': 'classic'
        });
        else Object.assign(_attr, {
            'arrow-end': 'none'
        });
        if (r.showParentArrow) Object.assign(_attr, {
            'arrow-start': 'classic'
        });
        else Object.assign(_attr, {
            'arrow-start': 'none'
        });
        r.line.attr(_attr);
        if (tempOriginNode) tempOriginNode.remove();
        if (tempEndNode) tempEndNode.remove();
    });
    // always push the grid back
    if (nodes.length > 0) {
        nodes[0].slate?.grid?.toBack();
        nodes[0].slate?.canvas?.bgToBack();
    }
}

},{"./closestPoint":"6gfM6","./getHorizontalCurve":"dzUMr","./getCorrectMidPoints":"b3ZJc","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6gfM6":[function(require,module,exports,__globalThis) {
/* eslint-disable no-sequences */ /* eslint-disable no-unused-expressions */ /* eslint-disable no-cond-assign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>closestPoint);
function closestPoint(pathNode, point) {
    const pathLength = pathNode.getTotalLength();
    let precision = 32 // increase this value for better performance at a risk of worse point approximation; in future this should be scaled according to number of path segments (there could be a better solution)
    ;
    let best;
    let bestLength;
    let bestDistance = Infinity;
    function distance2(p) {
        // squared distance between two points
        const dx = p.x - point.x;
        const dy = p.y - point.y;
        return dx * dx + dy * dy;
    }
    function pointAtLength(val, mode) {
        const getPAL = pathNode.getPointAtLength(val);
        return getPAL;
    }
    // linear scan for coarse approximation
    for(let scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision)if ((scanDistance = distance2(scan = pointAtLength(scanLength, 'course'))) < bestDistance) best = scan, bestLength = scanLength, bestDistance = scanDistance;
    // binary search for precise estimate
    precision /= 2;
    while(precision > 0.5){
        let before;
        let after;
        let beforeLength;
        let afterLength;
        let beforeDistance;
        let afterDistance;
        if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = distance2(before = pointAtLength(beforeLength, 'before'))) < bestDistance) best = before, bestLength = beforeLength, bestDistance = beforeDistance;
        else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = distance2(after = pointAtLength(afterLength, 'after'))) < bestDistance) best = after, bestLength = afterLength, bestDistance = afterDistance;
        else precision /= 2;
    }
    return {
        bestPoint: best,
        bestLength
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dzUMr":[function(require,module,exports,__globalThis) {
// returns a horizontally curved line
// export default function getHorizontalCurve(originPoint, endPoint) {
//   const x1 = originPoint.x
//   const y1 = originPoint.y
//   const x2 = endPoint.x
//   const y2 = endPoint.y
//   const middlePointX = (x1 + x2) / 2
//   return [
//     'M',
//     x1.toFixed(2),
//     y1.toFixed(2),
//     'C',
//     middlePointX.toFixed(2),
//     y1.toFixed(2),
//     middlePointX.toFixed(2),
//     y2.toFixed(2),
//     x2.toFixed(2),
//     y2.toFixed(2),
//   ].join(' ')
// }
// Function to generate a horizontally curved line or a right-angle connection
// Function to generate a dynamically curved line with the last segment straight towards the end point
// Function to generate a dynamically curved line with the last segment straight towards the end point
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getHorizontalCurve);
function getHorizontalCurve(originPoint, endPoint, curveSwoop = 0.5, lineType = 'bezier', curveType = 'quadratic', parentWidth = 0, parentXY = {
    x: 0,
    y: 0
}) {
    const x1 = originPoint.x;
    const y1 = originPoint.y;
    let x2 = endPoint.x;
    let y2 = endPoint.y;
    const dx = Math.abs(x2 - x1);
    const dy = Math.abs(y2 - y1);
    if (lineType === 'bezier') {
        const distance = Math.sqrt(dx * dx + dy * dy);
        const swoop = distance * curveSwoop;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        // Calculate the parent's true center point
        const roundedParentCenterX = Math.ceil((parentXY?.x || x1) + parentWidth / 2) // Since x1 is the connection point, subtract half width to get center
        ;
        // Round values for stability
        const roundedChildX = Math.ceil(x2);
        // Determine curve direction based on child position relative to parent center
        const curveDirection = roundedChildX >= roundedParentCenterX + 2 ? 1 : -1;
        // console.log('Values:', {
        //   childX: roundedChildX,
        //   parentCenterX: roundedParentCenterX,
        //   curveDirection,
        //   parentWidth,
        //   parentXY,
        // })
        if (curveType === 'quadratic') {
            const controlDistance = distance * 0.6;
            const midX = x1 + (x2 - x1) * (controlDistance / distance);
            const midY = y1 + (y2 - y1) * (controlDistance / distance);
            const perpAngle = angle + Math.PI / 2 * curveDirection;
            const adjustedSwoop = swoop;
            const controlX = midX + Math.cos(perpAngle) * adjustedSwoop;
            const controlY = midY + Math.sin(perpAngle) * adjustedSwoop;
            return [
                'M',
                x1.toFixed(2),
                y1.toFixed(2),
                'Q',
                controlX.toFixed(2),
                controlY.toFixed(2),
                x2.toFixed(2),
                y2.toFixed(2)
            ].join(' ');
        } else {
            // Enhanced S-curve for cubic
            const firstThird = 0.25;
            const secondThird = 0.75;
            const firstX = x1 + (x2 - x1) * firstThird;
            const firstY = y1 + (y2 - y1) * firstThird;
            const secondX = x1 + (x2 - x1) * secondThird;
            const secondY = y1 + (y2 - y1) * secondThird;
            const perpAngle = angle + Math.PI / 2 * curveDirection;
            const firstSwoop = swoop * 1.2;
            const secondSwoop = swoop * 0.8;
            const controlX1 = firstX + Math.cos(perpAngle) * firstSwoop;
            const controlY1 = firstY + Math.sin(perpAngle) * firstSwoop;
            const controlX2 = secondX - Math.cos(perpAngle) * secondSwoop;
            const controlY2 = secondY - Math.sin(perpAngle) * secondSwoop;
            return [
                'M',
                x1.toFixed(2),
                y1.toFixed(2),
                'C',
                controlX1.toFixed(2),
                controlY1.toFixed(2),
                controlX2.toFixed(2),
                controlY2.toFixed(2),
                x2.toFixed(2),
                y2.toFixed(2)
            ].join(' ');
        }
    } else if (lineType === 'orthogonal') {
        // For orthogonal lines, use the same direction logic
        const angleDegrees = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
        // Determine if we should go vertical first or horizontal first
        const verticalFirst = Math.abs(angleDegrees) > 45;
        return verticalFirst ? [
            'M',
            x1.toFixed(2),
            y1.toFixed(2),
            'L',
            x1.toFixed(2),
            y2.toFixed(2),
            'L',
            x2.toFixed(2),
            y2.toFixed(2)
        ].join(' ') : [
            'M',
            x1.toFixed(2),
            y1.toFixed(2),
            'L',
            x2.toFixed(2),
            y1.toFixed(2),
            'L',
            x2.toFixed(2),
            y2.toFixed(2)
        ].join(' ');
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"b3ZJc":[function(require,module,exports,__globalThis) {
/* eslint-disable no-lonely-if */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getCorrectMidPoints);
function getCorrectMidPoints(opts = {}) {
    const originBB = opts.parent ? opts.parent.vect.getBBox() : opts.parent.vect.getBBox();
    const endBB = opts.child ? opts.child.vect.getBBox() : opts.child.vect.getBBox();
    function inn(val) {
        return !Number.isNaN(parseFloat(val)) && Number.isFinite(val);
    }
    const pcx = inn(originBB.cx) && originBB.cx;
    const pcy = inn(originBB.cy) && originBB.cy;
    const ccx = inn(endBB.cx) && endBB.cx;
    const ccy = inn(endBB.cy) && endBB.cy;
    let relevantParentMiddlePoint;
    const px1 = originBB.x;
    const py1 = originBB.y;
    const px2 = originBB.x2;
    const py2 = originBB.y;
    const px3 = originBB.x2;
    const py3 = originBB.y2;
    const px4 = originBB.x;
    const py4 = originBB.y2;
    /*
    generic line equation
    y = ((y2-y1)/(x2-x1)) * (x-x1) + y1

    line 1: line passing through upper left corner and bottom right corner
    y = ((py3 - py1)/(px3 - px1)) * (x - px1) + py1

    line 2: line passing through bottom left corner and upper right corner
    y = ((py2 - py4)/(px2 - px4)) * (x - px4) + py4
   */ // NOTE: comments below apply to a Cartesian coordinate system; the svg coordinate system is slightly different with (0,0) in upper left corner of the plane
    // it means that regular above means below here
    if (ccy >= (py3 - py1) / (px3 - px1) * (ccx - px1) + py1) {
        // means that child center point is above line 1
        if (ccy >= (py2 - py4) / (px2 - px4) * (ccx - px4) + py4) // means that child center point is above line 2
        relevantParentMiddlePoint = {
            x: pcx,
            y: py3
        };
        else // means that child center point is either below line 2 or is on line 2
        relevantParentMiddlePoint = {
            x: px1,
            y: pcy
        };
    } else // means that child center point is below line 1
    if (ccy >= (py2 - py4) / (px2 - px4) * (ccx - px4) + py4) // means that child center point is above line 2
    relevantParentMiddlePoint = {
        x: px2,
        y: pcy
    };
    else // means that child center point is either below line 2 or is on line 2
    relevantParentMiddlePoint = {
        x: pcx,
        y: py1
    };
    let relevantChildMiddlePoint;
    const cx1 = endBB.x;
    const cy1 = endBB.y;
    const cx2 = endBB.x2;
    const cy2 = endBB.y;
    const cx3 = endBB.x2;
    const cy3 = endBB.y2;
    const cx4 = endBB.x;
    const cy4 = endBB.y2;
    /*
   generic line equation
   y = ((y2-y1)/(x2-x1)) * (x-x1) + y1

   line 1: line passing through upper left corner and bottom right corner
   y = ((cy3 - cy1)/(cx3 - cx1)) * (x - cx1) + cy1

   line 2: line passing through bottom left corner and upper right corner
   y = ((cy2 - cy4)/(cx2 - cx4)) * (x - cx4) + cy4
   */ // NOTE: comments below apply to a Cartesian coordinate system; the svg coordinate system is slightly different with (0,0) in upper left corner of the plane
    // it means that regular above means below here
    if (pcy >= (cy3 - cy1) / (cx3 - cx1) * (pcx - cx1) + cy1) {
        // means that child center point is above line 1
        if (pcy >= (cy2 - cy4) / (cx2 - cx4) * (pcx - cx4) + cy4) // means that child center point is above line 2
        relevantChildMiddlePoint = {
            x: ccx,
            y: cy3
        };
        else // means that child center point is either below line 2 or is on line 2
        relevantChildMiddlePoint = {
            x: cx1,
            y: ccy
        };
    } else // means that child center point is below line 1
    if (pcy >= (cy2 - cy4) / (cx2 - cx4) * (pcx - cx4) + cy4) // means that child center point is above line 2
    relevantChildMiddlePoint = {
        x: cx2,
        y: ccy
    };
    else // means that child center point is either below line 2 or is on line 2
    relevantChildMiddlePoint = {
        x: ccx,
        y: cy1
    };
    return {
        child: relevantChildMiddlePoint,
        parent: relevantParentMiddlePoint
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hVTn1":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>getDepCoords);
function getDepCoords(p, options) {
    let lx = p.x - 5;
    let tx = p.x + options.width / 2;
    let ty = p.y + options.height / 2;
    if (options.vectorPath === 'ellipse') {
        lx = p.cx - 5;
        tx = p.cx;
        ty = p.cy;
    }
    return {
        lx,
        tx,
        ty
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klp05":[function(require,module,exports,__globalThis) {
/* eslint-disable no-param-reassign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class editor {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    setTextOffset() {
        if (this.node.options.allowDrag) {
            this.node.options.textBounds = this.node.vect.getBBox();
            this.node.options.textOffset = {
                x: this.node.options.textBounds.cx - this.node.options.textBounds.width / 2 - this.node.options.xPos,
                y: this.node.options.textBounds.cy - this.node.options.yPos,
                width: this.node.options.textBounds.width,
                height: this.node.options.textBounds.height
            };
        }
    }
    set(t, s, f, c, opacity, ta, tb, isCategory) {
        const tempShim = `\xa7` // utils.guid().substring(3);
        ;
        if (!t && t !== '') t = this.node.options.text || tempShim;
        if (!s) s = this.node.options.fontSize || 12;
        if (opacity == null) opacity = this.node.options.textOpacity || 1;
        if (!f) f = this.node.options.fontFamily || 'Roboto';
        if (!c) c = this.node.options.foregroundColor || '#000';
        if (!ta) ta = this.node.options.textXAlign || 'middle';
        if (!tb) tb = this.node.options.textYAlign || 'middle';
        // ensure text is always legible if it is set to the same as background
        if (c === this.node.options.backgroundColor) c = (0, _utilsDefault.default).whiteOrBlack(this.node.options.backgroundColor);
        this.node.options.text = t;
        this.node.options.fontSize = s;
        this.node.options.fontFamily = f;
        this.node.options.foregroundColor = c;
        this.node.options.textOpacity = opacity;
        this.node.options.textXAlign = ta;
        this.node.options.textYAlign = tb;
        if (this.slate.options.autoResizeNodesBasedOnText && !this.node.options.ignoreTextFit) {
            let widthScalar = 1;
            let heightScalar = 1;
            let nodebb = this.node.vect.getBBox();
            if (this.node.options.text !== tempShim) {
                const textDimens = (0, _utilsDefault.default).getTextWidth(this.node.options.text, `${this.node.options.fontSize}pt ${this.node.options.fontFamily}`);
                const { transWidth, transHeight } = (0, _utilsDefault.default).obtainProportionateWidthAndHeightForResizing(0, 0, textDimens.width, textDimens.height, this.node.options.origVectWidth, this.node.options.origVectHeight, this.slate.isCtrl, this.node.options.shapeHint === 'custom');
                widthScalar = transWidth / nodebb.width;
                heightScalar = transHeight / nodebb.height;
            }
            const scaledVectPath = (0, _raphaelSvg.Raphael).transformPath(this.node.options.vectorPath, `s${widthScalar}, ${heightScalar}`).toString();
            this.node.options.vectorPath = scaledVectPath;
            this.node.vect.attr({
                path: scaledVectPath
            });
            nodebb = this.node.vect.getBBox();
            this.node.options.width = nodebb.width;
            this.node.options.height = nodebb.height;
            this.node.options.xPos = nodebb.x;
            this.node.options.yPos = nodebb.y;
            this.node.relationships && this.node.relationships.refreshOwnRelationships();
        }
        let coords = null;
        this.setTextOffset();
        coords = this.node.textCoords();
        if (!this.node.text) {
            this.node.text = this.slate.paper.text(this.node.options.xPos + coords.x, this.node.options.yPos + coords.y, t);
            const dragRider = this.node.options.disableDrag ? 'nodrag_' : '';
            this.node.text.node.setAttribute('rel', `${dragRider}text-${this.node.options.id}`);
        }
        coords = this.node.textCoords({
            x: this.node.options.xPos,
            y: this.node.options.yPos
        });
        this.node.text.attr(coords);
        this.node.text.attr({
            text: t
        });
        this.node.text.attr({
            'font-size': `${s}pt`
        });
        this.node.text.attr({
            'font-family': f
        });
        this.node.text.attr({
            fill: c
        });
        this.node.text.attr({
            'text-anchor': ta
        });
        this.node.text.attr({
            'text-baseline': tb
        });
        this.node.text.attr({
            'fill-opacity': opacity
        });
        this.node.text.attr({
            class: 'slatebox-text'
        });
        const noSelect = [
            '-webkit-user-select',
            '-moz-user-select',
            '-ms-user-select',
            'user-select'
        ].map((sx)=>`${sx}: none;`).join(' ');
        this.node.text.attr({
            style: noSelect
        });
        if (tempShim === t) {
            this.node.options.text = '';
            this.node.text.attr({
                text: ''
            });
        } else setTimeout(()=>{
            this.node.text.attr({
                text: t
            });
        }, 10);
    }
}
exports.default = editor;

},{"../helpers/utils":"8QI6M","../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8zQA0":[function(require,module,exports,__globalThis) {
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _getHorizontalCurve = require("../helpers/getHorizontalCurve");
var _getHorizontalCurveDefault = parcelHelpers.interopDefault(_getHorizontalCurve);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class relationships {
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.PATH_COMPLEXITY_LIMIT = 100000;
        self.associations = [];
        self._isLastAlt = false;
        self._isLastShift = false;
        self.selectedNodes = [];
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self._dx = 0;
        self._dy = 0;
        self.collabSent = null;
        self.slate.draggingNode = false;
        self.ft = null;
        self.kdTree = null;
        self.gracefulClear = null;
        self.dragEvents = {
            move (dx, dy) {
                if (!self.slate.isShift) self.enactMove(dx, dy);
            },
            async up () {
                if (!self.slate.isShift) self.finishDrag(true);
            },
            dragger (x, y, e) {
                if (!self.slate.canvas.isDragging) {
                    self.slate.nodes.closeAllMenus();
                    if (self.slate.isShift) {
                        if (!self.slate.candidatesForSelection[self.node.options.id]) {
                            self.slate.candidatesForSelection[self.node.options.id] = true;
                            self.slate.multiSelection.add(self.node);
                        } else {
                            delete self.slate.candidatesForSelection[self.node.options.id];
                            self.slate.multiSelection.remove(self.node);
                        }
                        (0, _utilsDefault.default).stopEvent(e);
                    } else {
                        self.slate.multiSelection.clear();
                        self.slate.candidatesForSelection = {};
                        self.node.toggleImage({
                            active: true
                        });
                        // hide filters
                        self.slate.toggleFilters(true) //, self.node.options.id
                        ;
                        // self.slate.canvas._bg?.hide();
                        if (self.node.events?.onClick) self.node.events.onClick.apply(self, [
                            function() {
                                self._initDrag(self, e);
                            }
                        ]);
                        else self._initDrag(self, e);
                    }
                }
            }
        };
    }
    showMenu(e) {
        const self = this;
        self.slate.nodes.closeAllMenus({
            exception: self.node.options.id
        });
        self.slate.enable();
        if (self.node?.menu?.show && self.node.options.allowMenu && !self.node.menu.isOpen()) {
            if (self.node?.options.groupId) self.slate.multiSelection.showGroup(self.node?.options.groupId);
            self.node.menu.show();
        }
        (0, _utilsDefault.default).stopEvent(e);
    }
    finishDrag(blnBroadcast) {
        const self = this;
        self.slate.draggingNode = false;
        self.selectedNodes.forEach((nd)=>{
            // the transformPath here converts the transient transforms that happened during the movement
            // to become permanent on the "attr" properties.
            (0, _utilsDefault.default).transformPath(nd, `T${self._dx},${self._dy}`);
            nd.vect.currentDx = 0;
            nd.vect.currentDy = 0;
            if (self.slate.options.debugMode) nd.debugPosition();
            if (!self.slate.keyboardActive) nd.editor.setTextOffset();
        });
        (0, _refreshRelationshipsDefault.default)({
            relationships: self.relationshipsToRefresh,
            nodes: self.selectedNodes,
            dx: 0,
            dy: 0
        });
        self.slate.nodes.saveRelationships(self.relationshipsToTranslate, {
            dx: self._dx,
            dy: self._dy
        });
        if (blnBroadcast) {
            self.send({
                nodes: self.selectedNodes,
                relationships: self.relationshipsToRefresh.concat(self.relationshipsToTranslate)
            });
            self.selectedNodes.forEach((n)=>{
                n.relationships.showAll(true);
            });
            if (self.foreignPoints?.length > 0) {
                self.kdTree.dispose();
                delete self.foreignPoints;
                clearTimeout(self.gracefulClear);
                self.gracefulClear = setTimeout(()=>{
                    self.node.gridLines.clear();
                }, 200);
            }
        }
        // console.log("here we go", self.selectedNodes);
        // self.slate.canvas._bg?.show();
        // finish drag
        self.slate.toggleFilters(false);
        self.showMenu();
    }
    enactMove(dx, dy) {
        const self = this;
        dx = Math.ceil(dx);
        dy = Math.ceil(dy);
        // adjust the dx and dy if snapping to grid
        // if (slate.options.viewPort.showGrid && slate.options.viewPort.snapToGrid) {
        //   let gridSize = slate.options.viewPort.gridSize || 10;
        //   dx = Math.round(dx / gridSize) * gridSize;
        //   dy = Math.round(dy / gridSize) * gridSize;
        // }
        const z = self.slate.options.viewPort.zoom.r;
        dx += dx / z - dx;
        dy += dy / z - dy;
        self.selectedNodes.forEach((nd, i)=>{
            nd.vect.currentDx = dx;
            nd.vect.currentDy = dy;
            nd.translateWith({
                dx,
                dy
            });
            // console.log("yPos ", i, node.options.yPos);
            // only snap and show guidelines for primary moving node, none of its children
            if (i === 0 && nd.options.id !== self.slate.tempNodeId && !self.slate.keyboardActive) {
                // const nbb = node.vect.getBBox();
                const nearest = self.kdTree.knn([
                    nd.options.xPos,
                    nd.options.yPos
                ], 2) // , 1);
                ;
                nearest.forEach((n)=>{
                    ({ dx, dy } = self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox));
                });
            }
        });
        self.slate.nodes.translateRelationships(self.relationshipsToTranslate, {
            dx,
            dy
        });
        (0, _refreshRelationshipsDefault.default)({
            relationships: self.relationshipsToRefresh,
            nodes: self.selectedNodes,
            dx,
            dy
        });
        self._dx = dx;
        self._dy = dy;
    }
    _broadcast(pkg) {
        this.slate.collab?.send(pkg);
    }
    _hitTest(mp) {
        const self = this;
        let overNode = null;
        const off = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        self.slate.nodes.allNodes.forEach((nd)=>{
            if (nd.options.id !== self.slate.tempNodeId && nd.options.id !== self.node.options.id && nd.options.allowContext && nd.options.allowResize) {
                const _bb = nd.vect.getBBox();
                const _zr = self.slate.options.viewPort.zoom.r;
                const xp = self.slate.options.viewPort.left + mp.x - off.left;
                const yp = self.slate.options.viewPort.top + mp.y - off.top;
                const c = {
                    x: xp + (xp / _zr - xp),
                    y: yp + (yp / _zr - yp)
                };
                if (c.x > _bb.x && c.x < _bb.x + _bb.width && c.y > _bb.y && c.y < _bb.y + _bb.height) overNode = nd;
            }
        });
        return overNode;
    }
    _remove(associations, type, obj) {
        const _na = [];
        const self = this;
        associations.forEach((association)=>{
            if (association[type].options.id === obj.options.id) self.removeRelationship(association);
            else _na.push(association);
        });
        return _na;
    }
    _initDrag(vect, e) {
        const self = this;
        self.selectedNodes = [];
        self.relationshipsToRefresh = [];
        self.relationshipsToTranslate = [];
        self.collabSent = false;
        self.slate.draggingNode = true;
        self._dx = 0;
        self._dy = 0;
        self.node.options.humanTouch = true;
        self.slate.multiSelection?.end();
        if (self.slate.options.linking) self.slate.options.linking.onNode.apply(vect, [
            self
        ]);
        else if (self.node.options.allowDrag && !self.node.options.disableDrag) {
            self.selectedNodes = self.getSelectedNodes();
            const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
            self.relationshipsToTranslate = _associations.relationshipsToTranslate;
            self.relationshipsToRefresh = _associations.relationshipsToRefresh;
            self.selectedNodes.forEach((n)=>{
                n.setStartDrag();
                n.vect.ox = n.options.xPos;
                n.vect.oy = n.options.yPos;
            });
            const selectedIds = self.selectedNodes.map((n)=>n.options.id);
            self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>selectedIds.indexOf(n.options.id) === -1).map((n)=>({
                    id: n.options.id,
                    bbox: n.vect.getBBox(),
                    point: [
                        n.options.xPos,
                        n.options.yPos
                    ]
                }));
            self.kdTree = (0, _staticKdtreeDefault.default)(self.foreignPoints.map((fp)=>fp.point));
            self.conditionallyHideAll();
        } else (0, _utilsDefault.default).stopEvent(e);
    }
    async initiateTempNode(e, _parent, _assocPkg) {
        const self = this;
        const mp = (0, _utilsDefault.default).mousePos(e);
        const _slate = _parent.slate;
        const off = (0, _utilsDefault.default).positionedOffset(_slate.options.container);
        const _zr = self.slate.options.viewPort.zoom.r;
        const xp = _slate.options.viewPort.left + mp.x - off.left;
        const yp = _slate.options.viewPort.top + mp.y - off.top;
        const _xPos = xp + (xp / _zr - xp);
        const _yPos = yp + (yp / _zr - yp);
        const _path = (0, _utilsDefault.default)._transformPath((0, _sbIconsDefault.default).icons.handle, `T${_xPos - 15}, ${_yPos - 15}`);
        const _tempNode = new (0, _nodeDefault.default)({
            id: self.slate.tempNodeId,
            xPos: _xPos,
            yPos: _yPos,
            lineColor: '#990000',
            backgroundColor: '#ffffff',
            vectorPath: _path,
            width: 30,
            height: 30
        });
        _slate.nodes.add(_tempNode, true);
        const _tempRelationship = _parent.relationships.addAssociation(_tempNode, _assocPkg, true);
        _tempRelationship.hoveredOver = null;
        _tempRelationship.lastHoveredOver = null;
        // initiates the drag
        _tempNode.vect.start(e) // , off.x, off.y);
        ;
        _slate.options.allowDrag = false;
        _tempNode.vect.mousemove((ex)=>{
            // is there a current hit?
            if (_tempRelationship.hoveredOver === null) {
                _tempRelationship.hoveredOver = self._hitTest((0, _utilsDefault.default).mousePos(ex));
                if (_tempRelationship.hoveredOver !== null) // yes, currently over a node -- scale it
                _tempRelationship.hoveredOver.vect.animate({
                    'stroke-width': 5
                }, 500, ()=>{
                    _tempRelationship.hoveredOver.vect.animate({
                        'stroke-width': self.node.options.borderWidth
                    }, 500, ()=>{
                        _tempRelationship.hoveredOver = null;
                    });
                });
            }
        });
        _tempNode.vect.mouseup((ex)=>{
            _parent.relationships.removeAssociation(_tempNode);
            _tempNode.slate.nodes.remove(_tempNode);
            const overNode = self._hitTest((0, _utilsDefault.default).mousePos(ex));
            if (overNode !== null) {
                // overNode.vect.transform("s1,1,");
                // check if overNode has any parents
                const _relevantAssociations = overNode.relationships.associations.filter((association)=>overNode.options.id === association.child.options.id);
                overNode.options.parents = _relevantAssociations.map((a1)=>a1.parent.options.id);
                // check if the two nodes are already associated -- multiple associations between two nodes are currently not supported
                const relevantAssociation = _parent.relationships.associations.find((association)=>association.child.options.id === overNode.options.id && association.parent.options.id === _parent.options.id || association.parent.options.id === overNode.options.id && association.child.options.id === _parent.options.id);
                if (!relevantAssociation) {
                    _parent.relationships.addAssociation(overNode, _assocPkg);
                    const _pkgx = {
                        type: 'addRelationship',
                        data: {
                            type: 'association',
                            parent: _parent.options.id,
                            child: overNode.options.id
                        }
                    };
                    self.slate.birdsEye?.relationshipsChanged(_pkgx);
                    self._broadcast(_pkgx);
                }
            }
            if (self.slate.options.enabled) _parent.slate.options.allowDrag = true;
        });
    }
    _visibility(action) {
        if (this.node.options.id !== this.slate.tempNodeId) for(let i = this.associations.length; i < this.associations.length; i += 1)this.associations[i].line[action]();
    }
    removeAll() {
        const self = this;
        self.associations.forEach((association)=>{
            association.child.relationships.removeAssociation(self.node) // .parent);
            ;
            association.parent.relationships.removeAssociation(self.node);
            self.removeRelationship(association);
        });
        self.associations = [];
    }
    removeAssociation(_node) {
        this.associations = this._remove(this.associations, 'child', _node);
        this.associations = this._remove(this.associations, 'parent', _node);
        return this;
    }
    setKeys({ isShift, isAlt }) {
        this._isLastShift = isShift;
        this._isLastAlt = isAlt;
    }
    addAssociation(_node, assocPkg) {
        assocPkg = assocPkg || {};
        // make sure this doesn't already exist
        let _connection = this.associations.find((a1)=>a1.child.options.id === _node.options.id);
        if (!_connection) {
            const _copts = {
                id: (0, _utilsDefault.default).guid(),
                parent: this.node,
                child: _node,
                lineColor: assocPkg.lineColor || this.node.options.lineColor,
                lineWidth: assocPkg.lineWidth || this.node.options.lineWidth,
                lineType: assocPkg.lineType || this.node.options.lineType,
                lineCurveType: assocPkg.lineCurveType || this.node.options.lineCurveType,
                lineCurviness: assocPkg.lineCurviness || this.node.options.lineCurviness,
                lineOpacity: assocPkg.lineOpacity != null ? assocPkg.lineOpacity : this.node.options.lineOpacity,
                lineEffect: assocPkg.lineEffect || this.node.options.lineEffect,
                lockedEndpoint: assocPkg.lockedEndpoint || this.node.options.lockedEndpoint,
                blnStraight: assocPkg.isStraightLine || false,
                showParentArrow: assocPkg.showParentArrow || false,
                showChildArrow: assocPkg.showChildArrow || true
            };
            _connection = this.createNewRelationship(_copts);
            _connection.line.toBack();
            this.associations.push(_connection);
            _node.relationships.associations.push(_connection);
            this.wireLineEvents(_connection);
        }
        _node.slate.allLines.push(_connection) // helper for managing raw line attrs
        ;
        return _connection;
    }
    createNewRelationship(opts) {
        const { paper } = this.slate;
        const association = {
            parent: null,
            child: null,
            lineColor: '#fff',
            lineOpacity: 1,
            lineEffect: '',
            lineWidth: 20,
            lineType: 'bezier',
            lineCurveType: 'cubic',
            lineCurviness: 0.2,
            blnStraight: false,
            showParentArrow: false,
            showChildArrow: true
        };
        Object.assign(association, opts);
        const _attr = {
            stroke: association.lineColor,
            class: 'association',
            fill: 'none',
            'stroke-width': association.lineWidth,
            'fill-opacity': association.lineOpacity,
            filter: association.lineEffect && !(0, _utilsDefault.default).isSafari() && !(0, _utilsDefault.default).isMobile() ? `url(#${association.lineEffect})` : '',
            opacity: association.lineOpacity
        };
        // these two generic points will be adjusted after the line is created
        const origPoint = {
            x: 1,
            y: 1
        };
        const endPoint = {
            x: 200,
            y: 200
        };
        if (!association.line) {
            Object.assign(association, {
                line: paper.path((0, _getHorizontalCurveDefault.default)(origPoint, endPoint, association.lineCurviness, association.lineType, association.lineCurveType)).attr(_attr)
            });
            association.line.node.setAttribute('rel', `association-${association.parent.options.id}-${association.child.options.id}`);
        }
        if (association.child && association.parent) (0, _refreshRelationshipsDefault.default)({
            relationships: [
                association
            ],
            nodes: [
                association.parent
            ]
        });
        return association;
    }
    removeRelationship(association) {
        const self = this;
        self.node.slate?.allLines.splice(self.slate?.allLines.findIndex((l)=>l.id === association.id));
        association.line.remove();
    }
    wireLineEvents(c) {
        const self = this;
        if (self.node.options.allowMenu) {
            c.line.node.style.cursor = 'pointer';
            c.line.mousedown((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                self.node.lineOptions.show(e, c);
            });
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
    }
    getSelectedNodes() {
        const self = this;
        self.selectedNodes = [];
        if (self.node.options.isLocked === false) {
            self.selectedNodes.push(self.node);
            this.syncAssociations(self.node, (c, a1)=>{
                if (!self.selectedNodes.some((n)=>n.options.id === c.options.id) && c.options.isLocked === false) self.selectedNodes.push(c);
            });
        }
        return self.selectedNodes;
    }
    syncAssociations(nd, cb) {
        const self = this;
        if (!self.slate.isCtrl || self.slate.isCtrl && self.slate.isShift) nd.relationships.associations.forEach((a1)=>{
            if (a1.child.options.id !== self.node.options.id && a1.child.options.id !== nd.options.id) {
                if (cb) cb(a1.child, a1);
                if (self.slate.isCtrl && self.slate.isShift) self.syncAssociations(a1.child, cb);
            }
        });
    }
    updateAssociationsWith(opts) {
        const conditionalSet = {};
        if (opts.conditional) {
            opts.conditional.forEach((setContext, i)=>{
                conditionalSet[i] = setContext;
            });
            delete opts.conditional;
        }
        this.associations.forEach((a1)=>{
            Object.assign(a1, opts);
            Object.keys(conditionalSet).forEach((sc)=>{
                const setContext = conditionalSet[sc];
                if (setContext.condition(a1, setContext.data)) a1[setContext.key] = setContext.getValue(a1, setContext.data);
            });
        });
    }
    updateSingleAssociationWith(key, opts) {
        const association = this.associations.find(a, key);
        if (association) Object.assign(association, opts);
    }
    send(opts) {
        if (this.node.context && !this.node.context.isVisible() && this.node.options.allowDrag && !this.node.options.disableDrag) {
            const pkg = {
                type: 'onNodesMove'
            };
            if (opts.nodes && opts.relationships) pkg.data = this.slate.nodes.nodeMovePackage({
                nodes: opts.nodes,
                relationships: opts.relationships,
                dur: 300
            });
            else pkg.data = this.slate.nodes.nodeMovePackage({
                dur: 300
            });
            this.slate.collab?.send(pkg);
            this.slate.birdsEye?.nodeChanged(pkg);
            this.collabSent = true;
        }
    }
    conditionallyHideAll() {
        const self = this;
        if (self.node.options.id !== self.slate.tempNodeId) {
            const exceeds = self.node.options.vectorPath.length > self.PATH_COMPLEXITY_LIMIT;
            if (exceeds) self.hideAll(true);
            self.associations.forEach((a1)=>{
                const cexceed = exceeds || a1.child.options.vectorPath.length > self.PATH_COMPLEXITY_LIMIT;
                a1.child.relationships.hideAll(cexceed);
            });
        }
    }
    hideAll(_blnOverride) {
        if (this.slate.isAlt && this.slate.isShift || _blnOverride) this._visibility('hide');
    }
    hideOwn() {
        this.associations.forEach((association)=>{
            association.line.hide();
        });
    }
    showOwn() {
        this.associations.forEach((association)=>{
            association.line.show();
        });
    }
    showAll(_blnOverride) {
        if (this._isLastAlt && this._isLastShift || _blnOverride) this._visibility('show');
    }
    refreshOwnRelationships() {
        (0, _refreshRelationshipsDefault.default)({
            relationships: this.associations,
            nodes: [
                this.node
            ]
        });
    }
    wireDragEvents() {
        const self = this;
        function showText() {
            self.slate.events?.onTextPaneRequested?.apply(this, [
                self.node,
                ()=>{}
            ]);
        }
        if (!self.slate.isReadOnly() && (!self.slate.isCommentOnly() || self.slate.isCommentOnly() && self.node.options.isComment)) {
            self.node.vect.drag(self.dragEvents.move, self.dragEvents.dragger, self.dragEvents.up);
            self.node.text.mousedown((e)=>{
                self.node.vect.start(e);
            });
            self.node.vect.dblclick(()=>{
                showText();
            });
            self.node.text.dblclick(()=>{
                showText();
            });
        }
    }
}
exports.default = relationships;

},{"static-kdtree":"i8GTt","../helpers/refreshRelationships":"1UeYf","../helpers/getHorizontalCurve":"dzUMr","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i8GTt":[function(require,module,exports,__globalThis) {
"use strict";
module.exports = createKDTree;
module.exports.deserialize = deserializeKDTree;
var ndarray = require("56ffc39bd4963f65");
var ndselect = require("16a6ab361ede6e90");
var pack = require("bbe191e4ce289018");
var ops = require("57e5497dd202c34a");
var ndscratch = require("e791068dba03be58");
var pool = require("b6d5133cd896236");
var inorderTree = require("2fe4779a6e794c93");
var bits = require("1dba2711fd8d0fea");
var KDTHeap = require("21c7575bab5643eb");
function KDTree(points, ids, n, d) {
    this.points = points;
    this.ids = ids;
    this.dimension = d;
    this.length = n;
}
var proto = KDTree.prototype;
proto.serialize = function() {
    if (this.length > 0) return {
        p: Array.prototype.slice.call(this.points.data, 0, this.length * this.dimension),
        i: Array.prototype.slice.call(this.ids, 0, this.length)
    };
    else return {
        d: this.dimension
    };
};
//Range query
proto.range = function kdtRangeQuery(lo, hi, visit) {
    var n = this.length;
    if (n < 1) return;
    //Check degenerate case
    var d = this.dimension;
    for(var i = 0; i < d; ++i){
        if (hi[i] < lo[i]) return;
    }
    var points = this.points;
    var ids = this.ids;
    //Walk tree in level order, skipping subtrees which do not intersect range
    var visitRange = ndscratch.malloc([
        n,
        2,
        d
    ]);
    var visitIndex = pool.mallocInt32(n);
    var rangeData = visitRange.data;
    var pointData = points.data;
    var visitCount = 1;
    var visitTop = 0;
    var retval;
    visitIndex[0] = 0;
    pack(lo, visitRange.pick(0, 0));
    pack(hi, visitRange.pick(0, 1));
    while(visitTop < visitCount){
        var idx = visitIndex[visitTop];
        var k = bits.log2(idx + 1) % d;
        var loidx = visitRange.index(visitTop, 0, 0);
        var hiidx = visitRange.index(visitTop, 1, 0);
        var pidx = points.index(idx, 0);
        var visitPoint = true;
        for(var i = 0; i < d; ++i){
            var pc = pointData[pidx + i];
            if (pc < rangeData[loidx + i] || rangeData[hiidx + i] < pc) {
                visitPoint = false;
                break;
            }
        }
        if (visitPoint) {
            retval = visit(ids[idx]);
            if (retval !== undefined) break;
        }
        //Visit children
        var pk = pointData[pidx + k];
        var hk = rangeData[hiidx + k];
        var lk = rangeData[loidx + k];
        if (lk <= pk) {
            var left = 2 * idx + 1;
            if (left < n) {
                visitIndex[visitCount] = left;
                var y = visitRange.index(visitCount, 0, 0);
                for(var i = 0; i < d; ++i)rangeData[y + i] = rangeData[loidx + i];
                var z = visitRange.index(visitCount, 1, 0);
                for(var i = 0; i < d; ++i)rangeData[z + i] = rangeData[hiidx + i];
                rangeData[z + k] = Math.min(hk, pk);
                visitCount += 1;
            }
        }
        if (pk <= hk) {
            var right = 2 * (idx + 1);
            if (right < n) {
                visitIndex[visitCount] = right;
                var y = visitRange.index(visitCount, 0, 0);
                for(var i = 0; i < d; ++i)rangeData[y + i] = rangeData[loidx + i];
                var z = visitRange.index(visitCount, 1, 0);
                for(var i = 0; i < d; ++i)rangeData[z + i] = rangeData[hiidx + i];
                rangeData[y + k] = Math.max(lk, pk);
                visitCount += 1;
            }
        }
        //Increment pointer
        visitTop += 1;
    }
    ndscratch.free(visitRange);
    pool.free(visitIndex);
    return retval;
};
proto.rnn = function(point, radius, visit) {
    if (radius < 0) return;
    var n = this.length;
    if (n < 1) return;
    var d = this.dimension;
    var points = this.points;
    var ids = this.ids;
    //Walk tree in level order, skipping subtrees which do not intersect sphere
    var visitDistance = ndscratch.malloc([
        n,
        d
    ]);
    var visitIndex = pool.mallocInt32(n);
    var distanceData = visitDistance.data;
    var pointData = points.data;
    var visitCount = 1;
    var visitTop = 0;
    var r2 = radius * radius;
    var retval;
    //Initialize top of queue
    visitIndex[0] = 0;
    for(var i = 0; i < d; ++i)visitDistance.set(0, i, 0);
    //Walk over queue
    while(visitTop < visitCount){
        var idx = visitIndex[visitTop];
        var pidx = points.index(idx, 0);
        //Check if point in sphere
        var d2 = 0.0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 <= r2) {
            retval = visit(ids[idx]);
            if (retval !== undefined) break;
        }
        //Visit children
        var k = bits.log2(idx + 1) % d;
        var ds = 0.0;
        var didx = visitDistance.index(visitTop, 0);
        for(var i = 0; i < d; ++i)if (i !== k) ds += distanceData[didx + i];
        //Handle split axis
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = distanceData[didx + k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        if (d2l <= r2) {
            var left = 2 * idx + 1;
            if (left < n) {
                visitIndex[visitCount] = left;
                var y = visitDistance.index(visitCount, 0);
                for(var i = 0; i < d; ++i)distanceData[y + i] = distanceData[didx + i];
                distanceData[y + k] = lk;
                visitCount += 1;
            }
        }
        if (d2h <= r2) {
            var right = 2 * (idx + 1);
            if (right < n) {
                visitIndex[visitCount] = right;
                var y = visitDistance.index(visitCount, 0);
                for(var i = 0; i < d; ++i)distanceData[y + i] = distanceData[didx + i];
                distanceData[y + k] = hk;
                visitCount += 1;
            }
        }
        //Increment pointer
        visitTop += 1;
    }
    ndscratch.free(visitDistance);
    pool.free(visitIndex);
    return retval;
};
proto.nn = function(point, maxDistance) {
    var n = this.length;
    if (n < 1) return -1;
    if (typeof maxDistance === "number") {
        if (maxDistance < 0) return -1;
    } else maxDistance = Infinity;
    var d = this.dimension;
    var points = this.points;
    var pointData = points.data;
    var dataVector = pool.mallocFloat64(d);
    var toVisit = new KDTHeap(n, d + 1);
    var index = toVisit.index;
    var data = toVisit.data;
    index[0] = 0;
    for(var i = 0; i <= d; ++i)data[i] = 0;
    toVisit.count += 1;
    var nearest = -1;
    var nearestD = maxDistance;
    while(toVisit.count > 0){
        if (data[0] >= nearestD) break;
        var idx = index[0];
        var pidx = points.index(idx, 0);
        var d2 = 0.0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 < nearestD) {
            nearestD = d2;
            nearest = idx;
        }
        //Compute distance bounds for children
        var k = bits.log2(idx + 1) % d;
        var ds = 0;
        for(var i = 0; i < d; ++i){
            var dd = data[i + 1];
            if (i !== k) ds += dd;
            dataVector[i] = dd;
        }
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = dataVector[k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        toVisit.pop();
        if (d2l < nearestD) {
            var left = 2 * idx + 1;
            if (left < n) {
                var vcount = toVisit.count;
                index[vcount] = left;
                var vptr = vcount * (d + 1);
                data[vptr] = d2l;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = lk;
                toVisit.push();
            }
        }
        if (d2h < nearestD) {
            var right = 2 * (idx + 1);
            if (right < n) {
                var vcount = toVisit.count;
                index[vcount] = right;
                var vptr = vcount * (d + 1);
                data[vptr] = d2h;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = hk;
                toVisit.push();
            }
        }
    }
    pool.freeFloat64(dataVector);
    toVisit.dispose();
    if (nearest < 0) return -1;
    return this.ids[nearest];
};
proto.knn = function(point, maxPoints, maxDistance) {
    //Check degenerate cases
    if (typeof maxDistance === "number") {
        if (maxDistance < 0) return [];
    } else maxDistance = Infinity;
    var n = this.length;
    if (n < 1) return [];
    if (typeof maxPoints === "number") {
        if (maxPoints <= 0) return [];
        maxPoints = Math.min(maxPoints, n) | 0;
    } else maxPoints = n;
    var ids = this.ids;
    var d = this.dimension;
    var points = this.points;
    var pointData = points.data;
    var dataVector = pool.mallocFloat64(d);
    //List of closest points
    var closestPoints = new KDTHeap(maxPoints, 1);
    var cl_index = closestPoints.index;
    var cl_data = closestPoints.data;
    var toVisit = new KDTHeap(n, d + 1);
    var index = toVisit.index;
    var data = toVisit.data;
    index[0] = 0;
    for(var i = 0; i <= d; ++i)data[i] = 0;
    toVisit.count += 1;
    var nearest = -1;
    var nearestD = maxDistance;
    while(toVisit.count > 0){
        if (data[0] >= nearestD) break;
        var idx = index[0];
        var pidx = points.index(idx, 0);
        var d2 = 0.0;
        for(var i = 0; i < d; ++i)d2 += Math.pow(point[i] - pointData[pidx + i], 2);
        if (d2 < nearestD) {
            if (closestPoints.count >= maxPoints) closestPoints.pop();
            var pcount = closestPoints.count;
            cl_index[pcount] = idx;
            cl_data[pcount] = -d2;
            closestPoints.push();
            if (closestPoints.count >= maxPoints) nearestD = -cl_data[0];
        }
        //Compute distance bounds for children
        var k = bits.log2(idx + 1) % d;
        var ds = 0;
        for(var i = 0; i < d; ++i){
            var dd = data[i + 1];
            if (i !== k) ds += dd;
            dataVector[i] = dd;
        }
        var qk = point[k];
        var pk = pointData[pidx + k];
        var dk = dataVector[k];
        var lk = dk;
        var hk = dk;
        if (qk < pk) hk = Math.max(dk, Math.pow(pk - qk, 2));
        else lk = Math.max(dk, Math.pow(pk - qk, 2));
        var d2l = lk + ds;
        var d2h = hk + ds;
        toVisit.pop();
        if (d2l < nearestD) {
            var left = 2 * idx + 1;
            if (left < n) {
                var vcount = toVisit.count;
                index[vcount] = left;
                var vptr = vcount * (d + 1);
                data[vptr] = d2l;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = lk;
                toVisit.push();
            }
        }
        if (d2h < nearestD) {
            var right = 2 * (idx + 1);
            if (right < n) {
                var vcount = toVisit.count;
                index[vcount] = right;
                var vptr = vcount * (d + 1);
                data[vptr] = d2h;
                for(var i = 1; i <= d; ++i)data[vptr + i] = dataVector[i - 1];
                data[vptr + k + 1] = hk;
                toVisit.push();
            }
        }
    }
    pool.freeFloat64(dataVector);
    toVisit.dispose();
    //Sort result
    var result = new Array(closestPoints.count);
    var ids = this.ids;
    for(var i = closestPoints.count - 1; i >= 0; --i){
        result[i] = ids[cl_index[0]];
        closestPoints.pop();
    }
    closestPoints.dispose();
    return result;
};
proto.dispose = function kdtDispose() {
    pool.free(this.points.data);
    pool.freeInt32(this.ids);
    this.points = null;
    this.ids = null;
    this.length = 0;
};
function Queue() {
    this.data = [];
    this.offset = 0;
}
Queue.prototype.size = function() {
    return this.data.length - this.offset;
};
Queue.prototype.push = function(item) {
    return this.data.push(item);
};
Queue.prototype.pop = function() {
    if (this.size() === 0) return undefined;
    var ret = this.data[this.offset];
    this.offset++;
    if (this.data.length > 1024 && this.offset * 2 > this.data.length) {
        this.data = this.data.slice(this.offset);
        this.offset = 0;
    }
    return ret;
};
function createKDTree(points) {
    var n, d, indexed;
    if (Array.isArray(points)) {
        n = points.length;
        if (n === 0) return new KDTree(null, null, 0, 0);
        d = points[0].length;
        indexed = ndarray(pool.mallocDouble(n * (d + 1)), [
            n,
            d + 1
        ]);
        pack(points, indexed.hi(n, d));
    } else {
        n = points.shape[0];
        d = points.shape[1];
        //Round up data type size
        var type = points.dtype;
        if (type === "int8" || type === "int16" || type === "int32") type = "int32";
        else if (type === "uint8" || type === "uint8_clamped" || type === "buffer" || type === "uint16" || type === "uint32") type = "uint32";
        else if (type === "float32") type = "float32";
        else type = "float64";
        indexed = ndarray(pool.malloc(n * (d + 1), type), [
            n,
            d + 1
        ]);
        ops.assign(indexed.hi(n, d), points);
    }
    for(var i = 0; i < n; ++i)indexed.set(i, d, i);
    var pointArray = ndscratch.malloc([
        n,
        d
    ], points.dtype);
    var indexArray = pool.mallocInt32(n);
    var pointer = 0;
    var pointData = pointArray.data;
    var arrayData = indexed.data;
    var l2_n = bits.log2(bits.nextPow2(n));
    var sel_cmp = ndselect.compile(indexed.order, true, indexed.dtype);
    //Walk tree in level order
    var toVisit = new Queue();
    toVisit.push(indexed);
    while(pointer < n){
        var head = toVisit.pop();
        var array = head;
        var nn = array.shape[0] | 0;
        //Find median
        if (nn > 1) {
            var k = bits.log2(pointer + 1) % d;
            var median;
            var n_2 = inorderTree.root(nn);
            median = sel_cmp(array, n_2, function(a, b) {
                return a.get(k) - b.get(k);
            });
            //Copy into new array
            var pptr = pointArray.index(pointer, 0);
            var mptr = median.offset;
            for(var i = 0; i < d; ++i)pointData[pptr++] = arrayData[mptr++];
            indexArray[pointer] = arrayData[mptr];
            pointer += 1;
            //Queue new items
            toVisit.push(array.hi(n_2));
            if (nn > 2) toVisit.push(array.lo(n_2 + 1));
        } else {
            //Copy into new array
            var mptr = array.offset;
            var pptr = pointArray.index(pointer, 0);
            for(var i = 0; i < d; ++i)pointData[pptr + i] = arrayData[mptr++];
            indexArray[pointer] = arrayData[mptr];
            pointer += 1;
        }
    }
    //Release indexed
    pool.free(indexed.data);
    return new KDTree(pointArray, indexArray, n, d);
}
function deserializeKDTree(data) {
    var points = data.p;
    var ids = data.i;
    if (points) {
        var nd = points.length;
        var pointArray = pool.mallocFloat64(nd);
        for(var i = 0; i < nd; ++i)pointArray[i] = points[i];
        var n = ids.length;
        var idArray = pool.mallocInt32(n);
        for(var i = 0; i < n; ++i)idArray[i] = ids[i];
        var d = nd / n | 0;
        return new KDTree(ndarray(pointArray, [
            n,
            d
        ]), idArray, n, d);
    } else return new KDTree(null, null, 0, data.d);
}

},{"56ffc39bd4963f65":"1nDU8","16a6ab361ede6e90":"6mCoB","bbe191e4ce289018":"48txd","57e5497dd202c34a":"kXyuI","e791068dba03be58":"7acsC","b6d5133cd896236":"1RryJ","2fe4779a6e794c93":"7V1A8","1dba2711fd8d0fea":"9kWjw","21c7575bab5643eb":"epTUT"}],"1nDU8":[function(require,module,exports,__globalThis) {
var iota = require("291764fc3ebef119");
var isBuffer = require("1241284d4b1d2198");
var hasTypedArrays = typeof Float64Array !== "undefined";
function compare1st(a, b) {
    return a[0] - b[0];
}
function order() {
    var stride = this.stride;
    var terms = new Array(stride.length);
    var i;
    for(i = 0; i < terms.length; ++i)terms[i] = [
        Math.abs(stride[i]),
        i
    ];
    terms.sort(compare1st);
    var result = new Array(terms.length);
    for(i = 0; i < result.length; ++i)result[i] = terms[i][1];
    return result;
}
function compileConstructor(dtype, dimension) {
    var className = [
        "View",
        dimension,
        "d",
        dtype
    ].join("");
    if (dimension < 0) className = "View_Nil" + dtype;
    var useGetters = dtype === "generic";
    if (dimension === -1) {
        //Special case for trivial arrays
        var code = "function " + className + "(a){this.data=a;};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new " + className + "(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_" + className + "(a){return new " + className + "(a);}";
        var procedure = new Function(code);
        return procedure();
    } else if (dimension === 0) {
        //Special case for 0d arrays
        var code = "function " + className + "(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto=" + className + ".prototype;\
proto.dtype='" + dtype + "';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function " + className + "_copy() {\
return new " + className + "(this.data,this.offset)\
};\
proto.pick=function " + className + "_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function " + className + "_get(){\
return " + (useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};\
proto.set=function " + className + "_set(v){\
return " + (useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "\
};\
return function construct_" + className + "(a,b,c,d){return new " + className + "(a,d)}";
        var procedure = new Function("TrivialArray", code);
        return procedure(CACHED_CONSTRUCTORS[dtype][0]);
    }
    var code = [
        "'use strict'"
    ];
    //Create constructor for view
    var indices = iota(dimension);
    var args = indices.map(function(i) {
        return "i" + i;
    });
    var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i;
    }).join("+");
    var shapeArg = indices.map(function(i) {
        return "b" + i;
    }).join(",");
    var strideArg = indices.map(function(i) {
        return "c" + i;
    }).join(",");
    code.push("function " + className + "(a," + shapeArg + "," + strideArg + ",d){this.data=a", "this.shape=[" + shapeArg + "]", "this.stride=[" + strideArg + "]", "this.offset=d|0}", "var proto=" + className + ".prototype", "proto.dtype='" + dtype + "'", "proto.dimension=" + dimension);
    //view.size:
    code.push("Object.defineProperty(proto,'size',{get:function " + className + "_size(){\
return " + indices.map(function(i) {
        return "this.shape[" + i + "]";
    }).join("*"), "}})");
    //view.order:
    if (dimension === 1) code.push("proto.order=[0]");
    else {
        code.push("Object.defineProperty(proto,'order',{get:");
        if (dimension < 4) {
            code.push("function " + className + "_order(){");
            if (dimension === 2) code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})");
            else if (dimension === 3) code.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})");
        } else code.push("ORDER})");
    }
    //view.set(i0, ..., v):
    code.push("proto.set=function " + className + "_set(" + args.join(",") + ",v){");
    if (useGetters) code.push("return this.data.set(" + index_str + ",v)}");
    else code.push("return this.data[" + index_str + "]=v}");
    //view.get(i0, ...):
    code.push("proto.get=function " + className + "_get(" + args.join(",") + "){");
    if (useGetters) code.push("return this.data.get(" + index_str + ")}");
    else code.push("return this.data[" + index_str + "]}");
    //view.index:
    code.push("proto.index=function " + className + "_index(", args.join(), "){return " + index_str + "}");
    //view.hi():
    code.push("proto.hi=function " + className + "_hi(" + args.join(",") + "){return new " + className + "(this.data," + indices.map(function(i) {
        return [
            "(typeof i",
            i,
            "!=='number'||i",
            i,
            "<0)?this.shape[",
            i,
            "]:i",
            i,
            "|0"
        ].join("");
    }).join(",") + "," + indices.map(function(i) {
        return "this.stride[" + i + "]";
    }).join(",") + ",this.offset)}");
    //view.lo():
    var a_vars = indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    });
    var c_vars = indices.map(function(i) {
        return "c" + i + "=this.stride[" + i + "]";
    });
    code.push("proto.lo=function " + className + "_lo(" + args.join(",") + "){var b=this.offset,d=0," + a_vars.join(",") + "," + c_vars.join(","));
    for(var i = 0; i < dimension; ++i)code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){\
d=i" + i + "|0;\
b+=c" + i + "*d;\
a" + i + "-=d}");
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "c" + i;
    }).join(",") + ",b)}");
    //view.step():
    code.push("proto.step=function " + className + "_step(" + args.join(",") + "){var " + indices.map(function(i) {
        return "a" + i + "=this.shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i + "=this.stride[" + i + "]";
    }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
    for(var i = 0; i < dimension; ++i)code.push("if(typeof i" + i + "==='number'){\
d=i" + i + "|0;\
if(d<0){\
c+=b" + i + "*(a" + i + "-1);\
a" + i + "=ceil(-a" + i + "/d)\
}else{\
a" + i + "=ceil(a" + i + "/d)\
}\
b" + i + "*=d\
}");
    code.push("return new " + className + "(this.data," + indices.map(function(i) {
        return "a" + i;
    }).join(",") + "," + indices.map(function(i) {
        return "b" + i;
    }).join(",") + ",c)}");
    //view.transpose():
    var tShape = new Array(dimension);
    var tStride = new Array(dimension);
    for(var i = 0; i < dimension; ++i){
        tShape[i] = "a[i" + i + "]";
        tStride[i] = "b[i" + i + "]";
    }
    code.push("proto.transpose=function " + className + "_transpose(" + args + "){" + args.map(function(n, idx) {
        return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)";
    }).join(";"), "var a=this.shape,b=this.stride;return new " + className + "(this.data," + tShape.join(",") + "," + tStride.join(",") + ",this.offset)}");
    //view.pick():
    code.push("proto.pick=function " + className + "_pick(" + args + "){var a=[],b=[],c=this.offset");
    for(var i = 0; i < dimension; ++i)code.push("if(typeof i" + i + "==='number'&&i" + i + ">=0){c=(c+this.stride[" + i + "]*i" + i + ")|0}else{a.push(this.shape[" + i + "]);b.push(this.stride[" + i + "])}");
    code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}");
    //Add return statement
    code.push("return function construct_" + className + "(data,shape,stride,offset){return new " + className + "(data," + indices.map(function(i) {
        return "shape[" + i + "]";
    }).join(",") + "," + indices.map(function(i) {
        return "stride[" + i + "]";
    }).join(",") + ",offset)}");
    //Compile procedure
    var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"));
    return procedure(CACHED_CONSTRUCTORS[dtype], order);
}
function arrayDType(data) {
    if (isBuffer(data)) return "buffer";
    if (hasTypedArrays) switch(Object.prototype.toString.call(data)){
        case "[object Float64Array]":
            return "float64";
        case "[object Float32Array]":
            return "float32";
        case "[object Int8Array]":
            return "int8";
        case "[object Int16Array]":
            return "int16";
        case "[object Int32Array]":
            return "int32";
        case "[object Uint8Array]":
            return "uint8";
        case "[object Uint16Array]":
            return "uint16";
        case "[object Uint32Array]":
            return "uint32";
        case "[object Uint8ClampedArray]":
            return "uint8_clamped";
        case "[object BigInt64Array]":
            return "bigint64";
        case "[object BigUint64Array]":
            return "biguint64";
    }
    if (Array.isArray(data)) return "array";
    return "generic";
}
var CACHED_CONSTRUCTORS = {
    "float32": [],
    "float64": [],
    "int8": [],
    "int16": [],
    "int32": [],
    "uint8": [],
    "uint16": [],
    "uint32": [],
    "array": [],
    "uint8_clamped": [],
    "bigint64": [],
    "biguint64": [],
    "buffer": [],
    "generic": []
};
function wrappedNDArrayCtor(data, shape, stride, offset) {
    if (data === undefined) {
        var ctor = CACHED_CONSTRUCTORS.array[0];
        return ctor([]);
    } else if (typeof data === "number") data = [
        data
    ];
    if (shape === undefined) shape = [
        data.length
    ];
    var d = shape.length;
    if (stride === undefined) {
        stride = new Array(d);
        for(var i = d - 1, sz = 1; i >= 0; --i){
            stride[i] = sz;
            sz *= shape[i];
        }
    }
    if (offset === undefined) {
        offset = 0;
        for(var i = 0; i < d; ++i)if (stride[i] < 0) offset -= (shape[i] - 1) * stride[i];
    }
    var dtype = arrayDType(data);
    var ctor_list = CACHED_CONSTRUCTORS[dtype];
    while(ctor_list.length <= d + 1)ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));
    var ctor = ctor_list[d + 1];
    return ctor(data, shape, stride, offset);
}
module.exports = wrappedNDArrayCtor;

},{"291764fc3ebef119":"hvCq1","1241284d4b1d2198":"9JmUB"}],"hvCq1":[function(require,module,exports,__globalThis) {
"use strict";
function iota(n) {
    var result = new Array(n);
    for(var i = 0; i < n; ++i)result[i] = i;
    return result;
}
module.exports = iota;

},{}],"9JmUB":[function(require,module,exports,__globalThis) {
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ // The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function(obj) {
    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}
// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],"6mCoB":[function(require,module,exports,__globalThis) {
"use strict";
module.exports = ndSelect;
module.exports.compile = lookupCache;
//Macros
var ARRAY = "a";
var RANK = "K";
var CMP = "C";
var DATA = "d";
var OFFSET = "o";
var RND = "R";
var TMP = "T";
var LO = "L";
var HI = "H";
var PIVOT = "X";
function SHAPE(i) {
    return "s" + i;
}
function STRIDE(i) {
    return "t" + i;
}
function STEP(i) {
    return "u" + i;
}
function STEP_CMP(i) {
    return "v" + i;
}
function INDEX(i) {
    return "i" + i;
}
function PICK(i) {
    return "p" + i;
}
function PTR(i) {
    return "x" + i;
}
//Create new order where index 0 is slowest index
function permuteOrder(order) {
    var norder = order.slice();
    norder.splice(order.indexOf(0), 1);
    norder.unshift(0);
    return norder;
}
//Generate quick select procedure
function compileQuickSelect(order, useCompare, dtype) {
    order = permuteOrder(order);
    var dimension = order.length;
    var useGetter = dtype === "generic";
    var funcName = "ndSelect" + dtype + order.join("_") + "_" + (useCompare ? "cmp" : "lex");
    var code = [];
    //Get arguments for code
    var args = [
        ARRAY,
        RANK
    ];
    if (useCompare) args.push(CMP);
    //Unpack ndarray variables
    var vars = [
        DATA + "=" + ARRAY + ".data",
        OFFSET + "=" + ARRAY + ".offset|0",
        RND + "=Math.random",
        TMP
    ];
    for(var i = 0; i < 2; ++i)vars.push(PTR(i) + "=0");
    for(var i = 0; i < dimension; ++i)vars.push(SHAPE(i) + "=" + ARRAY + ".shape[" + i + "]|0", STRIDE(i) + "=" + ARRAY + ".stride[" + i + "]|0", INDEX(i) + "=0");
    for(var i = 1; i < dimension; ++i)if (i > 1) vars.push(STEP_CMP(i) + "=(" + STRIDE(i) + "-" + SHAPE(i - 1) + "*" + STRIDE(i - 1) + ")|0", STEP(order[i]) + "=(" + STRIDE(order[i]) + "-" + SHAPE(order[i - 1]) + "*" + STRIDE(order[i - 1]) + ")|0");
    else vars.push(STEP_CMP(i) + "=" + STRIDE(i), STEP(order[i]) + "=" + STRIDE(order[i]));
    if (useCompare) for(var i = 0; i < 2; ++i)vars.push(PICK(i) + "=" + ARRAY + ".pick(0)");
    vars.push(PIVOT + "=0", LO + "=0", HI + "=" + SHAPE(order[0]) + "-1");
    function compare(out, i0, i1) {
        if (useCompare) code.push(PICK(0), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");", PICK(1), ".offset=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");", out, "=", CMP, "(", PICK(0), ",", PICK(1), ");");
        else {
            code.push(PTR(0), "=", OFFSET, "+", STRIDE(0), "*(", i0, ");", PTR(1), "=", OFFSET, "+", STRIDE(0), "*(", i1, ");");
            if (dimension > 1) code.push("_cmp:");
            for(var i = dimension - 1; i > 0; --i)code.push("for(", INDEX(i), "=0;", INDEX(i), "<", SHAPE(i), ";", INDEX(i), "++){");
            if (useGetter) code.push(out, "=", DATA, ".get(", PTR(0), ")-", DATA, ".get(", PTR(1), ");");
            else code.push(out, "=", DATA, "[", PTR(0), "]-", DATA, "[", PTR(1), "];");
            if (dimension > 1) code.push("if(", out, ")break _cmp;");
            for(var i = 1; i < dimension; ++i)code.push(PTR(0), "+=", STEP_CMP(i), ";", PTR(1), "+=", STEP_CMP(i), "}");
        }
    }
    function swap(i0, i1) {
        code.push(PTR(0), "=", OFFSET, "+", STRIDE(order[0]), "*(", i0, ");", PTR(1), "=", OFFSET, "+", STRIDE(order[0]), "*(", i1, ");");
        for(var i = dimension - 1; i > 0; --i)code.push("for(", INDEX(order[i]), "=0;", INDEX(order[i]), "<", SHAPE(order[i]), ";", INDEX(order[i]), "++){");
        if (useGetter) code.push(TMP, "=", DATA, ".get(", PTR(0), ");", DATA, ".set(", PTR(0), ",", DATA, ".get(", PTR(1), "));", DATA, ".set(", PTR(1), ",", TMP, ");");
        else code.push(TMP, "=", DATA, "[", PTR(0), "];", DATA, "[", PTR(0), "]=", DATA, "[", PTR(1), "];", DATA, "[", PTR(1), "]=", TMP, ";");
        for(var i = 1; i < dimension; ++i)code.push(PTR(0), "+=", STEP(order[i]), ";", PTR(1), "+=", STEP(order[i]), "}");
    }
    code.push("while(", LO, "<", HI, "){", PIVOT, "=(", RND, "()*(", HI, "-", LO, "+1)+", LO, ")|0;");
    //Partition array by pivot
    swap(PIVOT, HI) // Store pivot temporarily at the end of the array
    ;
    code.push(PIVOT, "=", LO, ";", "for(", INDEX(0), "=", LO, ";", INDEX(0), "<", HI, ";", INDEX(0), "++){") // Loop over other elements (unequal to the pivot), note that HI now points to the pivot
    ;
    compare(TMP, INDEX(0), HI) // Lexicographical compare of element with pivot
    ;
    code.push("if(", TMP, "<0){");
    swap(PIVOT, INDEX(0)) // Swap current element with element at index PIVOT if it is less than the pivot
    ;
    code.push(PIVOT, "++;");
    code.push("}}");
    swap(PIVOT, HI) // Store pivot right after all elements that are less than the pivot (implying that all elements >= the pivot are behind the pivot)
    ;
    //Check pivot bounds
    code.push("if(", PIVOT, "===", RANK, "){", LO, "=", PIVOT, ";", "break;", "}else if(", RANK, "<", PIVOT, "){", HI, "=", PIVOT, "-1;", "}else{", LO, "=", PIVOT, "+1;", "}", "}");
    if (useCompare) code.push(PICK(0), ".offset=", OFFSET, "+", LO, "*", STRIDE(0), ";", "return ", PICK(0), ";");
    else code.push("return ", ARRAY, ".pick(", LO, ");");
    //Compile and link js together
    var procCode = [
        "'use strict';function ",
        funcName,
        "(",
        args,
        "){",
        "var ",
        vars.join(),
        ";",
        code.join(""),
        "};return ",
        funcName
    ].join("");
    var proc = new Function(procCode);
    return proc();
}
var CACHE = {};
function lookupCache(order, useCompare, dtype) {
    var typesig = order.join() + useCompare + dtype;
    var proc = CACHE[typesig];
    if (proc) return proc;
    return CACHE[typesig] = compileQuickSelect(order, useCompare, dtype);
}
function ndSelect(array, k, compare) {
    k |= 0;
    if (array.dimension === 0 || array.shape[0] <= k || k < 0) return null;
    var useCompare = !!compare;
    var proc = lookupCache(array.order, useCompare, array.dtype);
    if (useCompare) return proc(array, k, compare);
    else return proc(array, k);
}

},{}],"48txd":[function(require,module,exports,__globalThis) {
"use strict";
var ndarray = require("7871a0abdaf74ad1");
var do_convert = require("6880363315b7fa08");
module.exports = function convert(arr, result) {
    var shape = [], c = arr, sz = 1;
    while(Array.isArray(c)){
        shape.push(c.length);
        sz *= c.length;
        c = c[0];
    }
    if (shape.length === 0) return ndarray();
    if (!result) result = ndarray(new Float64Array(sz), shape);
    do_convert(result, arr);
    return result;
};

},{"7871a0abdaf74ad1":"1nDU8","6880363315b7fa08":"kOMeM"}],"kOMeM":[function(require,module,exports,__globalThis) {
module.exports = require("2b9d3126a0b5ee34")({
    "args": [
        "array",
        "scalar",
        "index"
    ],
    "pre": {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    "body": {
        "body": "{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}",
        "args": [
            {
                "name": "_inline_1_arg0_",
                "lvalue": true,
                "rvalue": false,
                "count": 1
            },
            {
                "name": "_inline_1_arg1_",
                "lvalue": false,
                "rvalue": true,
                "count": 1
            },
            {
                "name": "_inline_1_arg2_",
                "lvalue": false,
                "rvalue": true,
                "count": 4
            }
        ],
        "thisVars": [],
        "localVars": [
            "_inline_1_i",
            "_inline_1_v"
        ]
    },
    "post": {
        "body": "{}",
        "args": [],
        "thisVars": [],
        "localVars": []
    },
    "funcName": "convert",
    "blockSize": 64
});

},{"2b9d3126a0b5ee34":"7GqVQ"}],"7GqVQ":[function(require,module,exports,__globalThis) {
"use strict";
var createThunk = require("1b3ac231c79cadda");
function Procedure() {
    this.argTypes = [];
    this.shimArgs = [];
    this.arrayArgs = [];
    this.arrayBlockIndices = [];
    this.scalarArgs = [];
    this.offsetArgs = [];
    this.offsetArgIndex = [];
    this.indexArgs = [];
    this.shapeArgs = [];
    this.funcName = "";
    this.pre = null;
    this.body = null;
    this.post = null;
    this.debug = false;
}
function compileCwise(user_args) {
    //Create procedure
    var proc = new Procedure();
    //Parse blocks
    proc.pre = user_args.pre;
    proc.body = user_args.body;
    proc.post = user_args.post;
    //Parse arguments
    var proc_args = user_args.args.slice(0);
    proc.argTypes = proc_args;
    for(var i = 0; i < proc_args.length; ++i){
        var arg_type = proc_args[i];
        if (arg_type === "array" || typeof arg_type === "object" && arg_type.blockIndices) {
            proc.argTypes[i] = "array";
            proc.arrayArgs.push(i);
            proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0);
            proc.shimArgs.push("array" + i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) throw new Error("cwise: pre() block may not reference array args");
            if (i < proc.post.args.length && proc.post.args[i].count > 0) throw new Error("cwise: post() block may not reference array args");
        } else if (arg_type === "scalar") {
            proc.scalarArgs.push(i);
            proc.shimArgs.push("scalar" + i);
        } else if (arg_type === "index") {
            proc.indexArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].count > 0) throw new Error("cwise: pre() block may not reference array index");
            if (i < proc.body.args.length && proc.body.args[i].lvalue) throw new Error("cwise: body() block may not write to array index");
            if (i < proc.post.args.length && proc.post.args[i].count > 0) throw new Error("cwise: post() block may not reference array index");
        } else if (arg_type === "shape") {
            proc.shapeArgs.push(i);
            if (i < proc.pre.args.length && proc.pre.args[i].lvalue) throw new Error("cwise: pre() block may not write to array shape");
            if (i < proc.body.args.length && proc.body.args[i].lvalue) throw new Error("cwise: body() block may not write to array shape");
            if (i < proc.post.args.length && proc.post.args[i].lvalue) throw new Error("cwise: post() block may not write to array shape");
        } else if (typeof arg_type === "object" && arg_type.offset) {
            proc.argTypes[i] = "offset";
            proc.offsetArgs.push({
                array: arg_type.array,
                offset: arg_type.offset
            });
            proc.offsetArgIndex.push(i);
        } else throw new Error("cwise: Unknown argument type " + proc_args[i]);
    }
    //Make sure at least one array argument was specified
    if (proc.arrayArgs.length <= 0) throw new Error("cwise: No array arguments specified");
    //Make sure arguments are correct
    if (proc.pre.args.length > proc_args.length) throw new Error("cwise: Too many arguments in pre() block");
    if (proc.body.args.length > proc_args.length) throw new Error("cwise: Too many arguments in body() block");
    if (proc.post.args.length > proc_args.length) throw new Error("cwise: Too many arguments in post() block");
    //Check debug flag
    proc.debug = !!user_args.printCode || !!user_args.debug;
    //Retrieve name
    proc.funcName = user_args.funcName || "cwise";
    //Read in block size
    proc.blockSize = user_args.blockSize || 64;
    return createThunk(proc);
}
module.exports = compileCwise;

},{"1b3ac231c79cadda":"fBD3l"}],"fBD3l":[function(require,module,exports,__globalThis) {
"use strict";
// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }
var compile = require("dbf125f9d3121fe");
function createThunk(proc) {
    var code = [
        "'use strict'",
        "var CACHED={}"
    ];
    var vars = [];
    var thunkName = proc.funcName + "_cwise_thunk";
    //Build thunk
    code.push([
        "return function ",
        thunkName,
        "(",
        proc.shimArgs.join(","),
        "){"
    ].join(""));
    var typesig = [];
    var string_typesig = [];
    var proc_args = [
        [
            "array",
            proc.arrayArgs[0],
            ".shape.slice(",
            Math.max(0, proc.arrayBlockIndices[0]),
            proc.arrayBlockIndices[0] < 0 ? "," + proc.arrayBlockIndices[0] + ")" : ")"
        ].join("")
    ];
    var shapeLengthConditions = [], shapeConditions = [];
    // Process array arguments
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        var j = proc.arrayArgs[i];
        vars.push([
            "t",
            j,
            "=array",
            j,
            ".dtype,",
            "r",
            j,
            "=array",
            j,
            ".order"
        ].join(""));
        typesig.push("t" + j);
        typesig.push("r" + j);
        string_typesig.push("t" + j);
        string_typesig.push("r" + j + ".join()");
        proc_args.push("array" + j + ".data");
        proc_args.push("array" + j + ".stride");
        proc_args.push("array" + j + ".offset|0");
        if (i > 0) {
            shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0]) - Math.abs(proc.arrayBlockIndices[i])));
            shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0, proc.arrayBlockIndices[i]) + "]");
        }
    }
    // Check for shape equality
    if (proc.arrayArgs.length > 1) {
        code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')");
        code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {");
        code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')");
        code.push("}");
    }
    // Process scalar arguments
    for(var i = 0; i < proc.scalarArgs.length; ++i)proc_args.push("scalar" + proc.scalarArgs[i]);
    // Check for cached function (and if not present, generate it)
    vars.push([
        "type=[",
        string_typesig.join(","),
        "].join()"
    ].join(""));
    vars.push("proc=CACHED[type]");
    code.push("var " + vars.join(","));
    code.push([
        "if(!proc){",
        "CACHED[type]=proc=compile([",
        typesig.join(","),
        "])}",
        "return proc(",
        proc_args.join(","),
        ")}"
    ].join(""));
    if (proc.debug) console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------");
    //Compile thunk
    var thunk = new Function("compile", code.join("\n"));
    return thunk(compile.bind(undefined, proc));
}
module.exports = createThunk;

},{"dbf125f9d3121fe":"lX50N"}],"lX50N":[function(require,module,exports,__globalThis) {
"use strict";
var uniq = require("14bb0a1dfafc14aa");
// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, has_index = proc.indexArgs.length > 0, code = [], vars = [], idx = 0, pidx = 0, i, j;
    for(i = 0; i < dimension; ++i)vars.push([
        "i",
        i,
        "=0"
    ].join(""));
    //Compute scan deltas
    for(j = 0; j < nargs; ++j)for(i = 0; i < dimension; ++i){
        pidx = idx;
        idx = order[i];
        if (i === 0) vars.push([
            "d",
            j,
            "s",
            i,
            "=t",
            j,
            "p",
            idx
        ].join(""));
        else vars.push([
            "d",
            j,
            "s",
            i,
            "=(t",
            j,
            "p",
            idx,
            "-s",
            pidx,
            "*t",
            j,
            "p",
            pidx,
            ")"
        ].join(""));
    }
    if (vars.length > 0) code.push("var " + vars.join(","));
    //Scan loop
    for(i = dimension - 1; i >= 0; --i){
        idx = order[i];
        code.push([
            "for(i",
            i,
            "=0;i",
            i,
            "<s",
            idx,
            ";++i",
            i,
            "){"
        ].join(""));
    }
    //Push body of inner loop
    code.push(body);
    //Advance scan pointers
    for(i = 0; i < dimension; ++i){
        pidx = idx;
        idx = order[i];
        for(j = 0; j < nargs; ++j)code.push([
            "p",
            j,
            "+=d",
            j,
            "s",
            i
        ].join(""));
        if (has_index) {
            if (i > 0) code.push([
                "index[",
                pidx,
                "]-=s",
                pidx
            ].join(""));
            code.push([
                "++index[",
                idx,
                "]"
            ].join(""));
        }
        code.push("}");
    }
    return code.join("\n");
}
// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
    var dimension = order.length, nargs = proc.arrayArgs.length, blockSize = proc.blockSize, has_index = proc.indexArgs.length > 0, code = [];
    for(var i = 0; i < nargs; ++i)code.push([
        "var offset",
        i,
        "=p",
        i
    ].join(""));
    //Generate loops for unmatched dimensions
    // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
    // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
    for(var i = matched; i < dimension; ++i){
        code.push([
            "for(var j" + i + "=SS[",
            order[i],
            "]|0;j",
            i,
            ">0;){"
        ].join("")) // Iterate back to front
        ;
        code.push([
            "if(j",
            i,
            "<",
            blockSize,
            "){"
        ].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
        ;
        code.push([
            "s",
            order[i],
            "=j",
            i
        ].join(""));
        code.push([
            "j",
            i,
            "=0"
        ].join(""));
        code.push([
            "}else{s",
            order[i],
            "=",
            blockSize
        ].join(""));
        code.push([
            "j",
            i,
            "-=",
            blockSize,
            "}"
        ].join(""));
        if (has_index) code.push([
            "index[",
            order[i],
            "]=j",
            i
        ].join(""));
    }
    for(var i = 0; i < nargs; ++i){
        var indexStr = [
            "offset" + i
        ];
        for(var j = matched; j < dimension; ++j)indexStr.push([
            "j",
            j,
            "*t",
            i,
            "p",
            order[j]
        ].join(""));
        code.push([
            "p",
            i,
            "=(",
            indexStr.join("+"),
            ")"
        ].join(""));
    }
    code.push(innerFill(order, proc, body));
    for(var i = matched; i < dimension; ++i)code.push("}");
    return code.join("\n");
}
//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
    var matched = 0, dimension = orders[0].length;
    while(matched < dimension){
        for(var j = 1; j < orders.length; ++j){
            if (orders[j][matched] !== orders[0][matched]) return matched;
        }
        ++matched;
    }
    return matched;
}
//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
    var code = block.body;
    var pre = [];
    var post = [];
    for(var i = 0; i < block.args.length; ++i){
        var carg = block.args[i];
        if (carg.count <= 0) continue;
        var re = new RegExp(carg.name, "g");
        var ptrStr = "";
        var arrNum = proc.arrayArgs.indexOf(i);
        switch(proc.argTypes[i]){
            case "offset":
                var offArgIndex = proc.offsetArgIndex.indexOf(i);
                var offArg = proc.offsetArgs[offArgIndex];
                arrNum = offArg.array;
                ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
                ;
            case "array":
                ptrStr = "p" + arrNum + ptrStr;
                var localStr = "l" + i;
                var arrStr = "a" + arrNum;
                if (proc.arrayBlockIndices[arrNum] === 0) {
                    if (carg.count === 1) {
                        if (dtypes[arrNum] === "generic") {
                            if (carg.lvalue) {
                                pre.push([
                                    "var ",
                                    localStr,
                                    "=",
                                    arrStr,
                                    ".get(",
                                    ptrStr,
                                    ")"
                                ].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                                ;
                                code = code.replace(re, localStr);
                                post.push([
                                    arrStr,
                                    ".set(",
                                    ptrStr,
                                    ",",
                                    localStr,
                                    ")"
                                ].join(""));
                            } else code = code.replace(re, [
                                arrStr,
                                ".get(",
                                ptrStr,
                                ")"
                            ].join(""));
                        } else code = code.replace(re, [
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join(""));
                    } else if (dtypes[arrNum] === "generic") {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            ".get(",
                            ptrStr,
                            ")"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) post.push([
                            arrStr,
                            ".set(",
                            ptrStr,
                            ",",
                            localStr,
                            ")"
                        ].join(""));
                    } else {
                        pre.push([
                            "var ",
                            localStr,
                            "=",
                            arrStr,
                            "[",
                            ptrStr,
                            "]"
                        ].join("")) // TODO: Could we optimize by checking for carg.rvalue?
                        ;
                        code = code.replace(re, localStr);
                        if (carg.lvalue) post.push([
                            arrStr,
                            "[",
                            ptrStr,
                            "]=",
                            localStr
                        ].join(""));
                    }
                } else {
                    var reStrArr = [
                        carg.name
                    ], ptrStrArr = [
                        ptrStr
                    ];
                    for(var j = 0; j < Math.abs(proc.arrayBlockIndices[arrNum]); j++){
                        reStrArr.push("\\s*\\[([^\\]]+)\\]");
                        ptrStrArr.push("$" + (j + 1) + "*t" + arrNum + "b" + j) // Matched index times stride
                        ;
                    }
                    re = new RegExp(reStrArr.join(""), "g");
                    ptrStr = ptrStrArr.join("+");
                    if (dtypes[arrNum] === "generic") /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/ throw new Error("cwise: Generic arrays not supported in combination with blocks!");
                    else // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
                    code = code.replace(re, [
                        arrStr,
                        "[",
                        ptrStr,
                        "]"
                    ].join(""));
                }
                break;
            case "scalar":
                code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i));
                break;
            case "index":
                code = code.replace(re, "index");
                break;
            case "shape":
                code = code.replace(re, "shape");
                break;
        }
    }
    return [
        pre.join("\n"),
        code,
        post.join("\n")
    ].join("\n").trim();
}
function typeSummary(dtypes) {
    var summary = new Array(dtypes.length);
    var allEqual = true;
    for(var i = 0; i < dtypes.length; ++i){
        var t = dtypes[i];
        var digits = t.match(/\d+/);
        if (!digits) digits = "";
        else digits = digits[0];
        if (t.charAt(0) === 0) summary[i] = "u" + t.charAt(1) + digits;
        else summary[i] = t.charAt(0) + digits;
        if (i > 0) allEqual = allEqual && summary[i] === summary[i - 1];
    }
    if (allEqual) return summary[0];
    return summary.join("");
}
//Generates a cwise operator
function generateCWiseOp(proc, typesig) {
    //Compute dimension
    // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
    var dimension = typesig[1].length - Math.abs(proc.arrayBlockIndices[0]) | 0;
    var orders = new Array(proc.arrayArgs.length);
    var dtypes = new Array(proc.arrayArgs.length);
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        dtypes[i] = typesig[2 * i];
        orders[i] = typesig[2 * i + 1];
    }
    //Determine where block and loop indices start and end
    var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
    ;
    var loopBegin = [], loopEnd = [] // These indices are iterated over
    ;
    var loopOrders = [] // orders restricted to the loop indices
    ;
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        if (proc.arrayBlockIndices[i] < 0) {
            loopBegin.push(0);
            loopEnd.push(dimension);
            blockBegin.push(dimension);
            blockEnd.push(dimension + proc.arrayBlockIndices[i]);
        } else {
            loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
            ;
            loopEnd.push(proc.arrayBlockIndices[i] + dimension);
            blockBegin.push(0);
            blockEnd.push(proc.arrayBlockIndices[i]);
        }
        var newOrder = [];
        for(var j = 0; j < orders[i].length; j++)if (loopBegin[i] <= orders[i][j] && orders[i][j] < loopEnd[i]) newOrder.push(orders[i][j] - loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
        ;
        loopOrders.push(newOrder);
    }
    //First create arguments for procedure
    var arglist = [
        "SS"
    ] // SS is the overall shape over which we iterate
    ;
    var code = [
        "'use strict'"
    ];
    var vars = [];
    for(var j = 0; j < dimension; ++j)vars.push([
        "s",
        j,
        "=SS[",
        j,
        "]"
    ].join("")) // The limits for each dimension.
    ;
    for(var i = 0; i < proc.arrayArgs.length; ++i){
        arglist.push("a" + i) // Actual data array
        ;
        arglist.push("t" + i) // Strides
        ;
        arglist.push("p" + i) // Offset in the array at which the data starts (also used for iterating over the data)
        ;
        for(var j = 0; j < dimension; ++j)vars.push([
            "t",
            i,
            "p",
            j,
            "=t",
            i,
            "[",
            loopBegin[i] + j,
            "]"
        ].join(""));
        for(var j = 0; j < Math.abs(proc.arrayBlockIndices[i]); ++j)vars.push([
            "t",
            i,
            "b",
            j,
            "=t",
            i,
            "[",
            blockBegin[i] + j,
            "]"
        ].join(""));
    }
    for(var i = 0; i < proc.scalarArgs.length; ++i)arglist.push("Y" + i);
    if (proc.shapeArgs.length > 0) vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
    ;
    if (proc.indexArgs.length > 0) {
        // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
        var zeros = new Array(dimension);
        for(var i = 0; i < dimension; ++i)zeros[i] = "0";
        vars.push([
            "index=[",
            zeros.join(","),
            "]"
        ].join(""));
    }
    for(var i = 0; i < proc.offsetArgs.length; ++i){
        var off_arg = proc.offsetArgs[i];
        var init_string = [];
        for(var j = 0; j < off_arg.offset.length; ++j){
            if (off_arg.offset[j] === 0) continue;
            else if (off_arg.offset[j] === 1) init_string.push([
                "t",
                off_arg.array,
                "p",
                j
            ].join(""));
            else init_string.push([
                off_arg.offset[j],
                "*t",
                off_arg.array,
                "p",
                j
            ].join(""));
        }
        if (init_string.length === 0) vars.push("q" + i + "=0");
        else vars.push([
            "q",
            i,
            "=",
            init_string.join("+")
        ].join(""));
    }
    //Prepare this variables
    var thisVars = uniq([].concat(proc.pre.thisVars).concat(proc.body.thisVars).concat(proc.post.thisVars));
    vars = vars.concat(thisVars);
    if (vars.length > 0) code.push("var " + vars.join(","));
    for(var i = 0; i < proc.arrayArgs.length; ++i)code.push("p" + i + "|=0");
    //Inline prelude
    if (proc.pre.body.length > 3) code.push(processBlock(proc.pre, proc, dtypes));
    //Process body
    var body = processBlock(proc.body, proc, dtypes);
    var matched = countMatches(loopOrders);
    if (matched < dimension) code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
    ;
    else code.push(innerFill(loopOrders[0], proc, body));
    //Inline epilog
    if (proc.post.body.length > 3) code.push(processBlock(proc.post, proc, dtypes));
    if (proc.debug) console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------");
    var loopName = [
        proc.funcName || "unnamed",
        "_cwise_loop_",
        orders[0].join("s"),
        "m",
        matched,
        typeSummary(dtypes)
    ].join("");
    var f = new Function([
        "function ",
        loopName,
        "(",
        arglist.join(","),
        "){",
        code.join("\n"),
        "} return ",
        loopName
    ].join(""));
    return f();
}
module.exports = generateCWiseOp;

},{"14bb0a1dfafc14aa":"itPtS"}],"itPtS":[function(require,module,exports,__globalThis) {
"use strict";
function unique_pred(list, compare) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i){
        b = a;
        a = list[i];
        if (compare(a, b)) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique_eq(list) {
    var ptr = 1, len = list.length, a = list[0], b = list[0];
    for(var i = 1; i < len; ++i, b = a){
        b = a;
        a = list[i];
        if (a !== b) {
            if (i === ptr) {
                ptr++;
                continue;
            }
            list[ptr++] = a;
        }
    }
    list.length = ptr;
    return list;
}
function unique(list, compare, sorted) {
    if (list.length === 0) return list;
    if (compare) {
        if (!sorted) list.sort(compare);
        return unique_pred(list, compare);
    }
    if (!sorted) list.sort();
    return unique_eq(list);
}
module.exports = unique;

},{}],"kXyuI":[function(require,module,exports,__globalThis) {
"use strict";
var compile = require("79fc6cf2b6fc441b");
var EmptyProc = {
    body: "",
    args: [],
    thisVars: [],
    localVars: []
};
function fixup(x) {
    if (!x) return EmptyProc;
    for(var i = 0; i < x.args.length; ++i){
        var a = x.args[i];
        if (i === 0) x.args[i] = {
            name: a,
            lvalue: true,
            rvalue: !!x.rvalue,
            count: x.count || 1
        };
        else x.args[i] = {
            name: a,
            lvalue: false,
            rvalue: true,
            count: 1
        };
    }
    if (!x.thisVars) x.thisVars = [];
    if (!x.localVars) x.localVars = [];
    return x;
}
function pcompile(user_args) {
    return compile({
        args: user_args.args,
        pre: fixup(user_args.pre),
        body: fixup(user_args.body),
        post: fixup(user_args.proc),
        funcName: user_args.funcName
    });
}
function makeOp(user_args) {
    var args = [];
    for(var i = 0; i < user_args.args.length; ++i)args.push("a" + i);
    var wrapper = new Function("P", [
        "return function ",
        user_args.funcName,
        "_ndarrayops(",
        args.join(","),
        ") {P(",
        args.join(","),
        ");return a0}"
    ].join(""));
    return wrapper(pcompile(user_args));
}
var assign_ops = {
    add: "+",
    sub: "-",
    mul: "*",
    div: "/",
    mod: "%",
    band: "&",
    bor: "|",
    bxor: "^",
    lshift: "<<",
    rshift: ">>",
    rrshift: ">>>"
};
(function() {
    for(var id in assign_ops){
        var op = assign_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a" + op + "=b"
            },
            rvalue: true,
            funcName: id + "eq"
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a" + op + "=s"
            },
            rvalue: true,
            funcName: id + "seq"
        });
    }
})();
var unary_ops = {
    not: "!",
    bnot: "~",
    neg: "-",
    recip: "1.0/"
};
(function() {
    for(var id in unary_ops){
        var op = unary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=" + op + "b"
            },
            funcName: id
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array"
            ],
            body: {
                args: [
                    "a"
                ],
                body: "a=" + op + "a"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
    }
})();
var binary_ops = {
    and: "&&",
    or: "||",
    eq: "===",
    neq: "!==",
    lt: "<",
    gt: ">",
    leq: "<=",
    geq: ">="
};
(function() {
    for(var id in binary_ops){
        var op = binary_ops[id];
        exports[id] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=b" + op + "c"
            },
            funcName: id
        });
        exports[id + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "b",
                    "s"
                ],
                body: "a=b" + op + "s"
            },
            funcName: id + "s"
        });
        exports[id + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=a" + op + "b"
            },
            rvalue: true,
            count: 2,
            funcName: id + "eq"
        });
        exports[id + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            body: {
                args: [
                    "a",
                    "s"
                ],
                body: "a=a" + op + "s"
            },
            rvalue: true,
            count: 2,
            funcName: id + "seq"
        });
    }
})();
var math_unary = [
    "abs",
    "acos",
    "asin",
    "atan",
    "ceil",
    "cos",
    "exp",
    "floor",
    "log",
    "round",
    "sin",
    "sqrt",
    "tan"
];
(function() {
    for(var i = 0; i < math_unary.length; ++i){
        var f = math_unary[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a"
                ],
                body: "a=this_f(a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
    }
})();
var math_comm = [
    "max",
    "min",
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_comm.length; ++i){
        var f = math_comm[i];
        exports[f] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f
        });
        exports[f + "s"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(b,c)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "s"
        });
        exports[f + "eq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "eq"
        });
        exports[f + "seq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(a,b)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "seq"
        });
    }
})();
var math_noncomm = [
    "atan2",
    "pow"
];
(function() {
    for(var i = 0; i < math_noncomm.length; ++i){
        var f = math_noncomm[i];
        exports[f + "op"] = makeOp({
            args: [
                "array",
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "op"
        });
        exports[f + "ops"] = makeOp({
            args: [
                "array",
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b",
                    "c"
                ],
                body: "a=this_f(c,b)",
                thisVars: [
                    "this_f"
                ]
            },
            funcName: f + "ops"
        });
        exports[f + "opeq"] = makeOp({
            args: [
                "array",
                "array"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opeq"
        });
        exports[f + "opseq"] = makeOp({
            args: [
                "array",
                "scalar"
            ],
            pre: {
                args: [],
                body: "this_f=Math." + f,
                thisVars: [
                    "this_f"
                ]
            },
            body: {
                args: [
                    "a",
                    "b"
                ],
                body: "a=this_f(b,a)",
                thisVars: [
                    "this_f"
                ]
            },
            rvalue: true,
            count: 2,
            funcName: f + "opseq"
        });
    }
})();
exports.any = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(a){return true}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return false"
    },
    funcName: "any"
});
exports.all = compile({
    args: [
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(!x){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "all"
});
exports.sum = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s+=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "sum"
});
exports.prod = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=1"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "this_s*=a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "prod"
});
exports.norm2squared = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm2squared"
});
exports.norm2 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        body: "this_s+=a*a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return Math.sqrt(this_s)"
    },
    funcName: "norm2"
});
exports.norminf = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 4
            }
        ],
        body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norminf"
});
exports.norm1 = compile({
    args: [
        "array"
    ],
    pre: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "this_s=0"
    },
    body: {
        args: [
            {
                name: "a",
                lvalue: false,
                rvalue: true,
                count: 3
            }
        ],
        body: "this_s+=a<0?-a:a",
        localVars: [],
        thisVars: [
            "this_s"
        ]
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [
            "this_s"
        ],
        body: "return this_s"
    },
    funcName: "norm1"
});
exports.sup = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.inf = compile({
    args: [
        "array"
    ],
    pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [
            {
                "name": "_inline_1_arg0_",
                "lvalue": false,
                "rvalue": true,
                "count": 2
            }
        ],
        thisVars: [
            "this_h"
        ],
        localVars: []
    },
    post: {
        body: "return this_h",
        args: [],
        thisVars: [
            "this_h"
        ],
        localVars: []
    }
});
exports.argmin = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.argmax = compile({
    args: [
        "index",
        "array",
        "shape"
    ],
    pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
            {
                name: "_inline_0_arg0_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg1_",
                lvalue: false,
                rvalue: false,
                count: 0
            },
            {
                name: "_inline_0_arg2_",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: []
    },
    body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
            {
                name: "_inline_1_arg0_",
                lvalue: false,
                rvalue: true,
                count: 2
            },
            {
                name: "_inline_1_arg1_",
                lvalue: false,
                rvalue: true,
                count: 2
            }
        ],
        thisVars: [
            "this_i",
            "this_v"
        ],
        localVars: [
            "_inline_1_k"
        ]
    },
    post: {
        body: "{return this_i}",
        args: [],
        thisVars: [
            "this_i"
        ],
        localVars: []
    }
});
exports.random = makeOp({
    args: [
        "array"
    ],
    pre: {
        args: [],
        body: "this_f=Math.random",
        thisVars: [
            "this_f"
        ]
    },
    body: {
        args: [
            "a"
        ],
        body: "a=this_f()",
        thisVars: [
            "this_f"
        ]
    },
    funcName: "random"
});
exports.assign = makeOp({
    args: [
        "array",
        "array"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assign"
});
exports.assigns = makeOp({
    args: [
        "array",
        "scalar"
    ],
    body: {
        args: [
            "a",
            "b"
        ],
        body: "a=b"
    },
    funcName: "assigns"
});
exports.equals = compile({
    args: [
        "array",
        "array"
    ],
    pre: EmptyProc,
    body: {
        args: [
            {
                name: "x",
                lvalue: false,
                rvalue: true,
                count: 1
            },
            {
                name: "y",
                lvalue: false,
                rvalue: true,
                count: 1
            }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
    },
    post: {
        args: [],
        localVars: [],
        thisVars: [],
        body: "return true"
    },
    funcName: "equals"
});

},{"79fc6cf2b6fc441b":"7GqVQ"}],"7acsC":[function(require,module,exports,__globalThis) {
"use strict";
var ndarray = require("1022cfeb42e4d237");
var ops = require("7b525c95be7aa4b3");
var pool = require("d481b23e4a057541");
function clone(array) {
    var dtype = array.dtype;
    if (dtype === "generic" || dtype === "array") dtype = "double";
    var data = pool.malloc(array.size, dtype);
    var result = ndarray(data, array.shape);
    ops.assign(result, array);
    return result;
}
exports.clone = clone;
function malloc(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    return ndarray(pool.malloc(sz, dtype), shape, stride, 0);
}
exports.malloc = malloc;
function free(array) {
    if (array.dtype === "generic" || array.dtype === "array") return;
    pool.free(array.data);
}
exports.free = free;
function zeros(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i)buf[i] = 0;
    return ndarray(buf, shape, stride, 0);
}
exports.zeros = zeros;
function ones(shape, dtype) {
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(var i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(var i = 0; i < sz; ++i)buf[i] = 1;
    return ndarray(buf, shape, stride, 0);
}
exports.ones = ones;
function eye(shape, dtype) {
    var i, offset;
    if (!dtype) dtype = "double";
    var sz = 1;
    var stride = new Array(shape.length);
    for(i = shape.length - 1; i >= 0; --i){
        stride[i] = sz;
        sz *= shape[i];
    }
    var buf = pool.malloc(sz, dtype);
    for(i = 0; i < sz; ++i)buf[i] = 0;
    var mindim = Infinity;
    var offsum = 0;
    for(i = shape.length - 1; i >= 0; i--){
        offsum += stride[i];
        mindim = Math.min(mindim, shape[i]);
    }
    for(i = 0, offset = 0; i < mindim; i++, offset += offsum)buf[offset] = 1;
    return ndarray(buf, shape, stride, 0);
}
exports.eye = eye;

},{"1022cfeb42e4d237":"1nDU8","7b525c95be7aa4b3":"kXyuI","d481b23e4a057541":"1RryJ"}],"1RryJ":[function(require,module,exports,__globalThis) {
var global = arguments[3];
'use strict';
var bits = require("3eb05de2c0cfab98");
var dup = require("d2c8ae35a091f669");
var Buffer = require("128e674301e79368").Buffer;
//Legacy pool support
if (!global.__TYPEDARRAY_POOL) global.__TYPEDARRAY_POOL = {
    UINT8: dup([
        32,
        0
    ]),
    UINT16: dup([
        32,
        0
    ]),
    UINT32: dup([
        32,
        0
    ]),
    BIGUINT64: dup([
        32,
        0
    ]),
    INT8: dup([
        32,
        0
    ]),
    INT16: dup([
        32,
        0
    ]),
    INT32: dup([
        32,
        0
    ]),
    BIGINT64: dup([
        32,
        0
    ]),
    FLOAT: dup([
        32,
        0
    ]),
    DOUBLE: dup([
        32,
        0
    ]),
    DATA: dup([
        32,
        0
    ]),
    UINT8C: dup([
        32,
        0
    ]),
    BUFFER: dup([
        32,
        0
    ])
};
var hasUint8C = typeof Uint8ClampedArray !== 'undefined';
var hasBigUint64 = typeof BigUint64Array !== 'undefined';
var hasBigInt64 = typeof BigInt64Array !== 'undefined';
var POOL = global.__TYPEDARRAY_POOL;
//Upgrade pool
if (!POOL.UINT8C) POOL.UINT8C = dup([
    32,
    0
]);
if (!POOL.BIGUINT64) POOL.BIGUINT64 = dup([
    32,
    0
]);
if (!POOL.BIGINT64) POOL.BIGINT64 = dup([
    32,
    0
]);
if (!POOL.BUFFER) POOL.BUFFER = dup([
    32,
    0
]);
//New technique: Only allocate from ArrayBufferView and Buffer
var DATA = POOL.DATA, BUFFER = POOL.BUFFER;
exports.free = function free(array) {
    if (Buffer.isBuffer(array)) BUFFER[bits.log2(array.length)].push(array);
    else {
        if (Object.prototype.toString.call(array) !== '[object ArrayBuffer]') array = array.buffer;
        if (!array) return;
        var n = array.length || array.byteLength;
        var log_n = bits.log2(n) | 0;
        DATA[log_n].push(array);
    }
};
function freeArrayBuffer(buffer) {
    if (!buffer) return;
    var n = buffer.length || buffer.byteLength;
    var log_n = bits.log2(n);
    DATA[log_n].push(buffer);
}
function freeTypedArray(array) {
    freeArrayBuffer(array.buffer);
}
exports.freeUint8 = exports.freeUint16 = exports.freeUint32 = exports.freeBigUint64 = exports.freeInt8 = exports.freeInt16 = exports.freeInt32 = exports.freeBigInt64 = exports.freeFloat32 = exports.freeFloat = exports.freeFloat64 = exports.freeDouble = exports.freeUint8Clamped = exports.freeDataView = freeTypedArray;
exports.freeArrayBuffer = freeArrayBuffer;
exports.freeBuffer = function freeBuffer(array) {
    BUFFER[bits.log2(array.length)].push(array);
};
exports.malloc = function malloc(n, dtype) {
    if (dtype === undefined || dtype === 'arraybuffer') return mallocArrayBuffer(n);
    else switch(dtype){
        case 'uint8':
            return mallocUint8(n);
        case 'uint16':
            return mallocUint16(n);
        case 'uint32':
            return mallocUint32(n);
        case 'int8':
            return mallocInt8(n);
        case 'int16':
            return mallocInt16(n);
        case 'int32':
            return mallocInt32(n);
        case 'float':
        case 'float32':
            return mallocFloat(n);
        case 'double':
        case 'float64':
            return mallocDouble(n);
        case 'uint8_clamped':
            return mallocUint8Clamped(n);
        case 'bigint64':
            return mallocBigInt64(n);
        case 'biguint64':
            return mallocBigUint64(n);
        case 'buffer':
            return mallocBuffer(n);
        case 'data':
        case 'dataview':
            return mallocDataView(n);
        default:
            return null;
    }
    return null;
};
function mallocArrayBuffer(n) {
    var n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var d = DATA[log_n];
    if (d.length > 0) return d.pop();
    return new ArrayBuffer(n);
}
exports.mallocArrayBuffer = mallocArrayBuffer;
function mallocUint8(n) {
    return new Uint8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocUint8 = mallocUint8;
function mallocUint16(n) {
    return new Uint16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocUint16 = mallocUint16;
function mallocUint32(n) {
    return new Uint32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocUint32 = mallocUint32;
function mallocInt8(n) {
    return new Int8Array(mallocArrayBuffer(n), 0, n);
}
exports.mallocInt8 = mallocInt8;
function mallocInt16(n) {
    return new Int16Array(mallocArrayBuffer(2 * n), 0, n);
}
exports.mallocInt16 = mallocInt16;
function mallocInt32(n) {
    return new Int32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocInt32 = mallocInt32;
function mallocFloat(n) {
    return new Float32Array(mallocArrayBuffer(4 * n), 0, n);
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat;
function mallocDouble(n) {
    return new Float64Array(mallocArrayBuffer(8 * n), 0, n);
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble;
function mallocUint8Clamped(n) {
    if (hasUint8C) return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n);
    else return mallocUint8(n);
}
exports.mallocUint8Clamped = mallocUint8Clamped;
function mallocBigUint64(n) {
    if (hasBigUint64) return new BigUint64Array(mallocArrayBuffer(8 * n), 0, n);
    else return null;
}
exports.mallocBigUint64 = mallocBigUint64;
function mallocBigInt64(n) {
    if (hasBigInt64) return new BigInt64Array(mallocArrayBuffer(8 * n), 0, n);
    else return null;
}
exports.mallocBigInt64 = mallocBigInt64;
function mallocDataView(n) {
    return new DataView(mallocArrayBuffer(n), 0, n);
}
exports.mallocDataView = mallocDataView;
function mallocBuffer(n) {
    n = bits.nextPow2(n);
    var log_n = bits.log2(n);
    var cache = BUFFER[log_n];
    if (cache.length > 0) return cache.pop();
    return new Buffer(n);
}
exports.mallocBuffer = mallocBuffer;
exports.clearCache = function clearCache() {
    for(var i = 0; i < 32; ++i){
        POOL.UINT8[i].length = 0;
        POOL.UINT16[i].length = 0;
        POOL.UINT32[i].length = 0;
        POOL.INT8[i].length = 0;
        POOL.INT16[i].length = 0;
        POOL.INT32[i].length = 0;
        POOL.FLOAT[i].length = 0;
        POOL.DOUBLE[i].length = 0;
        POOL.BIGUINT64[i].length = 0;
        POOL.BIGINT64[i].length = 0;
        POOL.UINT8C[i].length = 0;
        DATA[i].length = 0;
        BUFFER[i].length = 0;
    }
};

},{"3eb05de2c0cfab98":"9kWjw","d2c8ae35a091f669":"VRu11","128e674301e79368":"fCgem"}],"9kWjw":[function(require,module,exports,__globalThis) {
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */ "use strict";
"use restrict";
//Number of bits in an integer
var INT_BITS = 32;
//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 0x7fffffff;
exports.INT_MIN = -1 << INT_BITS - 1;
//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
    return (v > 0) - (v < 0);
};
//Computes absolute value of integer
exports.abs = function(v) {
    var mask = v >> INT_BITS - 1;
    return (v ^ mask) - mask;
};
//Computes minimum of integers x and y
exports.min = function(x, y) {
    return y ^ (x ^ y) & -(x < y);
};
//Computes maximum of integers x and y
exports.max = function(x, y) {
    return x ^ (x ^ y) & -(x < y);
};
//Checks if a number is a power of two
exports.isPow2 = function(v) {
    return !(v & v - 1) && !!v;
};
//Computes log base 2 of v
exports.log2 = function(v) {
    var r, shift;
    r = (v > 0xFFFF) << 4;
    v >>>= r;
    shift = (v > 0xFF) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 0xF) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 0x3) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
};
//Computes log base 10 of v
exports.log10 = function(v) {
    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};
//Counts number of bits
exports.popCount = function(v) {
    v = v - (v >>> 1 & 0x55555555);
    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
};
//Counts number of trailing zeros
function countTrailingZeros(v) {
    var c = 32;
    v &= -v;
    if (v) c--;
    if (v & 0x0000FFFF) c -= 16;
    if (v & 0x00FF00FF) c -= 8;
    if (v & 0x0F0F0F0F) c -= 4;
    if (v & 0x33333333) c -= 2;
    if (v & 0x55555555) c -= 1;
    return c;
}
exports.countTrailingZeros = countTrailingZeros;
//Rounds to next power of 2
exports.nextPow2 = function(v) {
    v += v === 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
};
//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v - (v >>> 1);
};
//Computes parity of word
exports.parity = function(v) {
    v ^= v >>> 16;
    v ^= v >>> 8;
    v ^= v >>> 4;
    v &= 0xf;
    return 0x6996 >>> v & 1;
};
var REVERSE_TABLE = new Array(256);
(function(tab) {
    for(var i = 0; i < 256; ++i){
        var v = i, r = i, s = 7;
        for(v >>>= 1; v; v >>>= 1){
            r <<= 1;
            r |= v & 1;
            --s;
        }
        tab[i] = r << s & 0xff;
    }
})(REVERSE_TABLE);
//Reverse bits in a 32 bit word
exports.reverse = function(v) {
    return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
};
//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
    x &= 0xFFFF;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y &= 0xFFFF;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
};
//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
    v = v >>> n & 0x55555555;
    v = (v | v >>> 1) & 0x33333333;
    v = (v | v >>> 2) & 0x0F0F0F0F;
    v = (v | v >>> 4) & 0x00FF00FF;
    v = (v | v >>> 16) & 0x000FFFF;
    return v << 16 >> 16;
};
//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
    x &= 0x3FF;
    x = (x | x << 16) & 4278190335;
    x = (x | x << 8) & 251719695;
    x = (x | x << 4) & 3272356035;
    x = (x | x << 2) & 1227133513;
    y &= 0x3FF;
    y = (y | y << 16) & 4278190335;
    y = (y | y << 8) & 251719695;
    y = (y | y << 4) & 3272356035;
    y = (y | y << 2) & 1227133513;
    x |= y << 1;
    z &= 0x3FF;
    z = (z | z << 16) & 4278190335;
    z = (z | z << 8) & 251719695;
    z = (z | z << 4) & 3272356035;
    z = (z | z << 2) & 1227133513;
    return x | z << 2;
};
//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
    v = v >>> n & 1227133513;
    v = (v | v >>> 2) & 3272356035;
    v = (v | v >>> 4) & 251719695;
    v = (v | v >>> 8) & 4278190335;
    v = (v | v >>> 16) & 0x3FF;
    return v << 22 >> 22;
};
//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
    var t = v | v - 1;
    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],"VRu11":[function(require,module,exports,__globalThis) {
"use strict";
function dupe_array(count, value, i) {
    var c = count[i] | 0;
    if (c <= 0) return [];
    var result = new Array(c), j;
    if (i === count.length - 1) for(j = 0; j < c; ++j)result[j] = value;
    else for(j = 0; j < c; ++j)result[j] = dupe_array(count, value, i + 1);
    return result;
}
function dupe_number(count, value) {
    var result, i;
    result = new Array(count);
    for(i = 0; i < count; ++i)result[i] = value;
    return result;
}
function dupe(count, value) {
    if (typeof value === "undefined") value = 0;
    switch(typeof count){
        case "number":
            if (count > 0) return dupe_number(count | 0, value);
            break;
        case "object":
            if (typeof count.length === "number") return dupe_array(count, value, 0);
            break;
    }
    return [];
}
module.exports = dupe;

},{}],"7V1A8":[function(require,module,exports,__globalThis) {
"use strict";
var bits = require("97d3e112e4bf25e7");
function rootInorder(n) {
    var ptree = (bits.nextPow2(n + 1) >>> 1) - 1;
    var f = n - ptree;
    if (bits.nextPow2(f) - 1 >= ptree) return ptree;
    return (ptree >>> 1) + f;
}
exports.root = rootInorder;
function beginInorder(n) {
    return 0;
}
exports.begin = beginInorder;
function endInorder(n) {
    return n - 1;
}
exports.end = endInorder;
//This is really horrible because n is not necessarily a power of 2
// If it was, we could just do:
//
//    height = bits.countTrailingZeros(~x)
//
// Instead, we just binary search because doing the right thing here is way too complicated.
function heightInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return heightInorder(n - r - 1, x - r - 1);
    else if (x === r) return bits.log2(n);
    return heightInorder(r, x);
}
exports.height = heightInorder;
function prevInorder(n, x) {
    return Math.max(x - 1, 0);
}
exports.prev = prevInorder;
function nextInorder(n, x) {
    return Math.min(x + 1, n - 1);
}
exports.next = nextInorder;
//The version for n = (1<<k)-1:
//
//  parent = (x & ~(1<<(h+1))) + (1<<h)
//
function parentInorder(n, x) {
    if (n <= 0) return -1;
    var r = rootInorder(n);
    if (x > r) {
        var q = parentInorder(n - r - 1, x - r - 1);
        if (q < 0) return r;
        else return q + r + 1;
    } else if (x === r) return -1;
    var q = parentInorder(r, x);
    if (q < 0) return r;
    return q;
}
exports.parent = parentInorder;
//Again, we get screwed because n is not a power of two -1.  If it was, we could do:
//
//    left = x - (1 << (h-1) )
//
// Where h is the height of the node
//
function leftInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return leftInorder(n - r - 1, x - r - 1) + r + 1;
    else if (x === r) return rootInorder(x);
    return leftInorder(r, x);
}
exports.left = leftInorder;
//for power of two minus one:
//
//    right = x + (1<<(h-1))
//
function rightInorder(n, x) {
    if (n <= 0) return 0;
    var r = rootInorder(n);
    if (x > r) return rightInorder(n - r - 1, x - r - 1) + r + 1;
    else if (x === r) return rootInorder(n - r - 1) + r + 1;
    return rightInorder(r, x);
}
exports.right = rightInorder;
function leafInorder(n, x) {
    return heightInorder(n, x) === 0;
}
exports.leaf = leafInorder;
function loInorder(n, x) {
    n |= 0;
    x |= 0;
    var l = 0;
    while(n > 1){
        var r = rootInorder(n);
        if (x > r) {
            l += r + 1;
            n -= r + 1;
            x -= r + 1;
        } else if (x === r) break;
        else n = r;
    }
    return l;
}
exports.lo = loInorder;
function hiInorder(n, x) {
    n |= 0;
    x |= 0;
    var l = 0;
    while(n > 1){
        var r = rootInorder(n);
        if (x > r) {
            l += r + 1;
            n -= r + 1;
            x -= r + 1;
        } else if (x === r) {
            l += n - 1;
            break;
        } else n = r;
    }
    return l;
}
exports.hi = hiInorder;

},{"97d3e112e4bf25e7":"aFqxf"}],"aFqxf":[function(require,module,exports,__globalThis) {
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */ "use strict";
"use restrict";
//Number of bits in an integer
var INT_BITS = 32;
//Constants
exports.INT_BITS = INT_BITS;
exports.INT_MAX = 0x7fffffff;
exports.INT_MIN = -1 << INT_BITS - 1;
//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
    return (v > 0) - (v < 0);
};
//Computes absolute value of integer
exports.abs = function(v) {
    var mask = v >> INT_BITS - 1;
    return (v ^ mask) - mask;
};
//Computes minimum of integers x and y
exports.min = function(x, y) {
    return y ^ (x ^ y) & -(x < y);
};
//Computes maximum of integers x and y
exports.max = function(x, y) {
    return x ^ (x ^ y) & -(x < y);
};
//Checks if a number is a power of two
exports.isPow2 = function(v) {
    return !(v & v - 1) && !!v;
};
//Computes log base 2 of v
exports.log2 = function(v) {
    var r, shift;
    r = (v > 0xFFFF) << 4;
    v >>>= r;
    shift = (v > 0xFF) << 3;
    v >>>= shift;
    r |= shift;
    shift = (v > 0xF) << 2;
    v >>>= shift;
    r |= shift;
    shift = (v > 0x3) << 1;
    v >>>= shift;
    r |= shift;
    return r | v >> 1;
};
//Computes log base 10 of v
exports.log10 = function(v) {
    return v >= 1000000000 ? 9 : v >= 100000000 ? 8 : v >= 10000000 ? 7 : v >= 1000000 ? 6 : v >= 100000 ? 5 : v >= 10000 ? 4 : v >= 1000 ? 3 : v >= 100 ? 2 : v >= 10 ? 1 : 0;
};
//Counts number of bits
exports.popCount = function(v) {
    v = v - (v >>> 1 & 0x55555555);
    v = (v & 0x33333333) + (v >>> 2 & 0x33333333);
    return (v + (v >>> 4) & 0xF0F0F0F) * 0x1010101 >>> 24;
};
//Counts number of trailing zeros
function countTrailingZeros(v) {
    var c = 32;
    v &= -v;
    if (v) c--;
    if (v & 0x0000FFFF) c -= 16;
    if (v & 0x00FF00FF) c -= 8;
    if (v & 0x0F0F0F0F) c -= 4;
    if (v & 0x33333333) c -= 2;
    if (v & 0x55555555) c -= 1;
    return c;
}
exports.countTrailingZeros = countTrailingZeros;
//Rounds to next power of 2
exports.nextPow2 = function(v) {
    v += v === 0;
    --v;
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v + 1;
};
//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
    v |= v >>> 1;
    v |= v >>> 2;
    v |= v >>> 4;
    v |= v >>> 8;
    v |= v >>> 16;
    return v - (v >>> 1);
};
//Computes parity of word
exports.parity = function(v) {
    v ^= v >>> 16;
    v ^= v >>> 8;
    v ^= v >>> 4;
    v &= 0xf;
    return 0x6996 >>> v & 1;
};
var REVERSE_TABLE = new Array(256);
(function(tab) {
    for(var i = 0; i < 256; ++i){
        var v = i, r = i, s = 7;
        for(v >>>= 1; v; v >>>= 1){
            r <<= 1;
            r |= v & 1;
            --s;
        }
        tab[i] = r << s & 0xff;
    }
})(REVERSE_TABLE);
//Reverse bits in a 32 bit word
exports.reverse = function(v) {
    return REVERSE_TABLE[v & 0xff] << 24 | REVERSE_TABLE[v >>> 8 & 0xff] << 16 | REVERSE_TABLE[v >>> 16 & 0xff] << 8 | REVERSE_TABLE[v >>> 24 & 0xff];
};
//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
    x &= 0xFFFF;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y &= 0xFFFF;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
};
//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
    v = v >>> n & 0x55555555;
    v = (v | v >>> 1) & 0x33333333;
    v = (v | v >>> 2) & 0x0F0F0F0F;
    v = (v | v >>> 4) & 0x00FF00FF;
    v = (v | v >>> 16) & 0x000FFFF;
    return v << 16 >> 16;
};
//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
    x &= 0x3FF;
    x = (x | x << 16) & 4278190335;
    x = (x | x << 8) & 251719695;
    x = (x | x << 4) & 3272356035;
    x = (x | x << 2) & 1227133513;
    y &= 0x3FF;
    y = (y | y << 16) & 4278190335;
    y = (y | y << 8) & 251719695;
    y = (y | y << 4) & 3272356035;
    y = (y | y << 2) & 1227133513;
    x |= y << 1;
    z &= 0x3FF;
    z = (z | z << 16) & 4278190335;
    z = (z | z << 8) & 251719695;
    z = (z | z << 4) & 3272356035;
    z = (z | z << 2) & 1227133513;
    return x | z << 2;
};
//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
    v = v >>> n & 1227133513;
    v = (v | v >>> 2) & 3272356035;
    v = (v | v >>> 4) & 251719695;
    v = (v | v >>> 8) & 4278190335;
    v = (v | v >>> 16) & 0x3FF;
    return v << 22 >> 22;
};
//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
    var t = v | v - 1;
    return t + 1 | (~t & -~t) - 1 >>> countTrailingZeros(v) + 1;
};

},{}],"epTUT":[function(require,module,exports,__globalThis) {
"use strict";
module.exports = KDTHeap;
var pool = require("e29e78138d3ce401");
function heapParent(i) {
    if (i & 1) return i - 1 >> 1;
    return (i >> 1) - 1;
}
function KDTHeap(n, d) {
    this.count = 0;
    this.dataSize = d;
    this.index = pool.mallocInt32(n);
    this.data = pool.mallocFloat64(n * d);
}
var proto = KDTHeap.prototype;
proto.heapSwap = function(_i, _j) {
    var data = this.data;
    var index = this.index;
    var d = this.dataSize;
    var tmp = index[_i];
    index[_i] = index[_j];
    index[_j] = tmp;
    var aptr = d * _i;
    var bptr = d * _j;
    for(var _k = 0; _k < d; ++_k){
        var t2 = data[aptr];
        data[aptr] = data[bptr];
        data[bptr] = t2;
        aptr += 1;
        bptr += 1;
    }
};
proto.heapUp = function(i) {
    var d = this.dataSize;
    var index = this.index;
    var data = this.data;
    var w = data[d * i];
    while(i > 0){
        var parent = heapParent(i);
        if (parent >= 0) {
            var pw = data[d * parent];
            if (w < pw) {
                this.heapSwap(i, parent);
                i = parent;
                continue;
            }
        }
        break;
    }
};
proto.heapDown = function(i) {
    var d = this.dataSize;
    var index = this.index;
    var data = this.data;
    var count = this.count;
    var w = data[d * i];
    while(true){
        var tw = w;
        var left = 2 * i + 1;
        var right = 2 * (i + 1);
        var next = i;
        if (left < count) {
            var lw = data[d * left];
            if (lw < tw) {
                next = left;
                tw = lw;
            }
        }
        if (right < count) {
            var rw = data[d * right];
            if (rw < tw) next = right;
        }
        if (next === i) break;
        this.heapSwap(i, next);
        i = next;
    }
};
//Clear item from top of heap
proto.pop = function() {
    this.count -= 1;
    this.heapSwap(0, this.count);
    this.heapDown(0);
};
//Assume object already written to data
proto.push = function() {
    this.heapUp(this.count);
    this.count += 1;
};
proto.dispose = function() {
    pool.freeInt32(this.index);
    pool.freeFloat64(this.data);
};

},{"e29e78138d3ce401":"1RryJ"}],"6en3b":[function(require,module,exports,__globalThis) {
/* eslint-disable no-use-before-define */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class rotate {
    static getRotationAngle(origPoint, newPoint, centerPoint) {
        const vx = origPoint.x - centerPoint.x;
        const vy = origPoint.y - centerPoint.y;
        const ux = newPoint.x - centerPoint.x;
        const uy = newPoint.y - centerPoint.y;
        const magnitudeV = Math.sqrt(vx ** 2 + vy ** 2);
        const magnitudeU = Math.sqrt(ux ** 2 + uy ** 2);
        let angleDegrees;
        if (vx === 0 && vy === 0 || ux === 0 && uy === 0 || vx === ux && vy === uy) ;
        else {
            const cosine = (vx * ux + vy * uy) / (magnitudeV * magnitudeU);
            const angleRadians = Math.acos(cosine);
            angleDegrees = angleRadians * 180 / Math.PI // unsigned angle
            ;
            const detVxU = vx * uy - vy * ux // cross product of V and U (VxU)
            ;
            if (detVxU < 0) angleDegrees = -angleDegrees // add negative sign
            ;
        }
        return angleDegrees;
    }
    set(rotateAngle) {
        const self = this;
        const useRotationAngle = rotateAngle || self.rotationAngle;
        self.rotate.transform(`R${self.rotationAngle}, ${self.origCenter.x}, ${self.origCenter.y}`);
        const rotationContext = {
            rotate: {
                rotationAngle: (self.node.options.rotate.rotationAngle + useRotationAngle) % 360,
                point: self.origCenter
            }
        };
        const transformString = self.node.getTransformString(rotationContext);
        self.node.vect.transform(transformString);
        self.node.text.transform(transformString);
    }
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.rotate = null;
        self.rotateTemp = null;
        self._dragAllowed = false;
        self._isResizing = false;
        self._initPosFix = false;
        self.origCenter = {} // during rotation raphael changes the center point of bbox for some reason
        ;
        self.rotationAngle = null;
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.selectedNodes = [];
        self.rotateEvents = {
            start () {
                const s = this;
                self.selectedNodes = self.node.relationships.getSelectedNodes();
                const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
                self.relationshipsToTranslate = _associations.relationshipsToTranslate;
                self.relationshipsToRefresh = _associations.relationshipsToRefresh;
                self.slate.isBeingResized = true;
                self._initPosFix = false;
                self.rotateTemp.attr({
                    x: self.rotateTemp.attr('x') - 1000,
                    y: self.rotateTemp.attr('y') - 1000,
                    width: 10000,
                    height: 10000
                });
                self.rotate.ox = self.rotate.attr('x');
                self.rotate.oy = self.rotate.attr('y');
                self.node.relationships.updateAssociationsWith({
                    activeNode: self.node.options.id,
                    currentDx: 0,
                    currentDy: 0,
                    action: 'rotate'
                });
                self._isResizing = true;
                const tempPath = self.slate.paper.path(self.node.vect.attr('path'));
                const noRotationBB = tempPath.getBBox();
                if (!self.node.options.rotate?.point || Object.entries(self.node.options.rotate.point).length === 0) self.node.options.rotate.point = {
                    x: noRotationBB.cx,
                    y: noRotationBB.cy
                };
                tempPath.remove();
                self.slate.multiSelection?.end();
                s.ox = noRotationBB.x;
                s.oy = noRotationBB.y;
                self.origCenter = self.node.options.rotate.point;
                self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>n.options.id !== self.node.options.id).map((n)=>({
                        id: n.options.id,
                        bbox: n.vect.getBBox(),
                        point: [
                            n.options.xPos,
                            n.options.yPos
                        ]
                    }));
                self.kdTree = (0, _staticKdtreeDefault.default)(self.foreignPoints.map((fp)=>fp.point));
                self.node.setStartDrag();
                self.node.connectors.remove();
                self.node.resize.hide();
                self._dragAllowed = self.slate.options.allowDrag;
                self.slate.disable(false, true);
                self.slate.toggleFilters(true, self.node.options.id);
            },
            move (dx, dy) {
                const s = this;
                try {
                    // for snapping
                    const nearest = self.kdTree.knn([
                        node.options.xPos,
                        node.options.yPos
                    ], 5);
                    nearest.forEach((n)=>{
                        self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox, false, 200);
                    });
                    /*
          Rotation angle is obtained using vector properties. Further explanation can be found here: https://stackoverflow.com/questions/10507620/finding-the-angle-between-vectors
          Vectors are of form:
          v = <vx, vy>
          u = <ux, uy>
          Notation explanation:
          ||v|| - magnitude of vector v
          v . u - dot product of vectors u and v (commutative)
          v x u - cross product of vectors v and u (not commutative!); for 2D vectors it is essentially the determinant of a 2D matrix created by v and u
    
          cos(angle) = (v . u)/(||v|| * ||u||)
          angle = arccos((v . u)/(||v|| * ||u||))
          angle is unsigned, i.e. it assumes values 0 and PI radians
    
          If v x u < 0 then the angle needs a negative sign; otherwise the sign is already correct.
    
          If either vector is a 0 vector, i.e. v = <0, 0> or u = <0, 0> then the angle between v and u does not exist
          and the function will return an undefined angle.
    
          The returned angle is converted to degrees and is between -180 and 180.
          */ self.rotationAngle = rotate.getRotationAngle({
                        x: s.ox,
                        y: s.oy
                    }, {
                        x: s.ox + dx,
                        y: s.oy + dy
                    }, self.origCenter);
                    if (self.rotationAngle) // const _ra = Math.abs(Math.ceil(self.node.vect.matrix.split().rotate));
                    // const _ra = Math.abs(Math.ceil(self.rotationAngle)); //
                    // if (!self.node.snappedAt && ([0, 45, 90, 135, 180, 225, 270].indexOf(_ra) > -1)) { //% 45 === 0 || _ra === 0 || (_ra + 1) % 270 === 0)) {
                    //   console.log("snapped ra is ", self.node.options.rotate.rotationAngle, self.rotationAngle, _ra, self.node.vect.matrix.split().rotate);
                    //   //self.rotationAngle = _ra;
                    //   //self.rotationAngle = Math.abs(Math.ceil(self.rotationAngle));
                    //   self.node.snappedAt = _ra; // self.rotationAngle;
                    //   _rta();
                    // } else if (self.rotationAngle >= self.node.snappedAt + 25 || self.rotationAngle <= self.node.snappedAt - 25) {
                    //   delete self.node.snappedAt;
                    // }
                    {
                        if (!self.node.snappedAt) self.set();
                    }
                } catch (err) {
                    finalize();
                }
            },
            up () {
                finalize();
                self.slate.toggleFilters(false, self.node.options.id);
            }
        };
        function finalize() {
            const _ran = self.node.snappedAt || self.rotationAngle;
            if (_ran) {
                const rotationContext = {
                    rotationAngle: (self.node.options.rotate.rotationAngle + _ran) % 360,
                    point: self.origCenter
                };
                Object.assign(self.node.options.rotate, rotationContext);
                const bb = self.node.vect.getBBox();
                self.node.options.width = bb.width;
                self.node.options.height = bb.height;
                self.rotateTemp.remove();
                self.node.relationships.updateAssociationsWith({
                    rotationAngle: self.node.options.rotate.rotationAngle
                });
                self.node.gridLines.clear();
                delete self.foreignPoints;
                delete self.kdTree;
                delete self.node.snappedAt;
            }
            self.slate.isBeingResized = false;
            self.node.menu.hide();
            self._isResizing = false;
            self.slate.enable(false, true);
            self.node.setEndDrag();
            self.node.relationships.refreshOwnRelationships();
            self.node.relationships.showOwn();
            self.rotate.remove();
            if (self.node.events?.onRotated?.apply) self.node.events?.onRotated?.apply(self, [
                _self.send
            ]);
            else self.send();
        }
    }
    show(x, y) {
        const self = this;
        if (self.node.options.allowResize) {
            self.rotateTemp?.remove();
            const r = self.slate.paper;
            self.rotate = r.path('M16.659,24c-5.078,0-9.213-3.987-9.475-9h2.975l-4.5-5l-4.5,5h3.025 c0.264,6.671,5.74,12,12.475,12c3.197,0,6.104-1.21,8.315-3.185l-2.122-2.122C21.188,23.127,19.027,24,16.659,24z M29.133,14c-0.265-6.669-5.74-12-12.475-12c-3.197,0-6.104,1.21-8.315,3.185   l2.122,2.122C12.129,5.873,14.29,5,16.659,5c5.077,0,9.213,3.987,9.475,9h-2.975l4.5,5l4.5-5H29.133z').attr({
                fill: '#fff',
                stroke: '#000',
                x: x - 5,
                y: y - 5
            });
            let rotatePathBB = self.rotate.getBBox();
            const rotatePathString = (0, _utilsDefault.default)._transformPath(self.rotate.attr('path'), `T${x - rotatePathBB.x - 15},${y - rotatePathBB.y - 15}`);
            self.rotate.attr({
                path: rotatePathString
            });
            rotatePathBB = self.rotate.getBBox();
            self.rotateTemp = r.rect(rotatePathBB.x, rotatePathBB.y, rotatePathBB.width, rotatePathBB.height).attr({
                fill: '#f00',
                opacity: 0.00000001
            }).toFront();
            self.rotate.mouseover((e)=>{
                self.rotate.attr({
                    cursor: 'alias'
                });
            });
            self.rotateTemp.mouseover((e)=>{
                self.rotateTemp.attr({
                    cursor: 'alias'
                });
            });
            self.rotateTemp.drag(self.rotateEvents.move, self.rotateEvents.start, self.rotateEvents.up);
        }
        return self.rotate;
    }
    hide() {
        this.rotate?.remove();
        this.rotateTemp?.remove();
    }
    send() {
        // broadcast change to birdsEye and collaborators
        const pkg = {
            type: 'onNodeRotated',
            data: {
                id: this.node.options.id,
                rotate: this.node.options.rotate,
                textOffset: this.node.options.textOffset,
                imageOrigWidth: this.node.options.imageOrigWidth,
                imageOrigHeight: this.node.options.imageOrigHeight,
                associations: this.node.relationships.associations.map((a)=>({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr('path').toString()
                    }))
            }
        };
        this.slate.birdsEye?.nodeChanged(pkg);
        this.slate.collab?.send(pkg);
    }
    applyImageRotation(opts = {}) {
        const { r } = this.slate.options.viewPort.zoom;
        this.node.vect.transform('');
        this.node.text.transform('');
        const boundingClientRect = opts.boundingClientRect || this.node.vect[0].getBoundingClientRect();
        // clone current node to get actual dimensions with no hidden transforms (transform("") doesn't affect bbox -- it still has dimensions as if transforms were still there)
        const tempPath = this.slate.paper.path(this.node.vect.attr('path'));
        const bb = tempPath.getBBox();
        const transformString = this.node.getTransformString(opts);
        this.node.vect.transform(transformString);
        this.node.text.transform(transformString);
        if (this.node.vect.pattern) {
            const img = this.node.vect.pattern.getElementsByTagName('image')[0];
            img.setAttribute('y', (boundingClientRect.height / r - bb.height) / 2 - 4);
            img.setAttribute('x', (boundingClientRect.width / r - bb.width) / 2 - 4);
        }
        tempPath.remove();
    }
    animateSet(data, opts) {
        const self = this;
        const transformString = `...R${data.rotationAngle},${data.rotate.point.x}, ${data.rotate.point.y}`;
        self.node.vect.animate({
            transform: transformString
        }, opts.duration || 500, opts.easing || '>', ()=>{
            const tstr = self.node.getTransformString();
            self.node.vect.transform(tstr);
            // self.node.text.transform(tstr);
            if (opts.cb) opts.cb();
        });
        self.node.text.animate({
            transform: transformString
        }, opts.duration || 500, opts.easing || '>', ()=>{
            const tstr = self.node.getTransformString();
            self.node.text.transform(tstr);
        });
        opts.associations.forEach((assoc)=>{
            const a = self.node.relationships.associations.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId);
            if (a) a.line.animate({
                path: assoc.linePath
            }, opts.duration || 500, opts.easing || '>', ()=>{
                a.line.attr({
                    path: assoc.linePath
                });
            });
        });
    }
}
exports.default = rotate;

},{"static-kdtree":"i8GTt","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"91LgF":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
class menu {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this._m = null;
        this._isOpen = false;
    }
    isOpen() {
        return this._isOpen;
    }
    show() {
        const self = this;
        const r = self.slate.paper;
        if (self._m) {
            (0, _lodashInvokeDefault.default)(self._m, 'remove');
            self._m = null;
        }
        const bb = self.node.vect.getBBox();
        const _x = bb.x;
        const _y = bb.y;
        self._m = r.set();
        self._isOpen = true;
        // right, bottom, and settings connectors
        self.node.connectors.show(_x, _y, self._m, ()=>{
            if (self.slate.events?.onMenuRequested) self.slate.events?.onMenuRequested(self.node, ()=>{});
        });
    }
    hide(exceptionElemId) {
        if (this._m) {
            this._m.forEach((m)=>{
                if (m.id !== exceptionElemId) m.remove();
            });
            this._m.items = exceptionElemId ? null : this._m.items.filter((item)=>item.id !== exceptionElemId);
            this.node?.connectors?.iconBar?.remove();
            if (this.node?.connectors?.iconBar) this.node.connectors.iconBar = null;
        }
        this.node.rotate.hide();
        this._isOpen = false;
    }
}
exports.default = menu;

},{"lodash.invoke":"6VYuy","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"h710n":[function(require,module,exports,__globalThis) {
/* eslint-disable new-cap */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class connectors {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.buttons = null;
        this.iconBar = null;
        this._lastUnpinned = {
            options: {
                xPos: null,
                width: null,
                yPos: null
            }
        };
    }
    _broadcast(skipCenter, options, targetXPos, targetYPos) {
        const self = this;
        const pkg = {
            type: 'onNodeAdded',
            data: {
                id: self.node.options.id,
                skipCenter,
                options,
                targetXPos,
                targetYPos
            }
        };
        this.slate.collab && this.slate.collab.send(pkg);
    }
    remove() {
        const self = this;
        if (self.buttons) Object.keys(self.buttons).forEach((btn)=>{
            self.buttons[btn].remove();
        });
        self.iconBar?.remove();
        self.iconBar = null;
        self.node.menu._isOpen = false;
    }
    removeSettingsButton() {
        this.buttons.setting.remove();
    }
    show(x, y, _m, onSettingsClicked) {
        const self = this;
        const r = self.slate.paper;
        const bb = self.node.vect.getBBox();
        const widthOffset = bb.width / 2;
        const btnAttr = {
            fill: '#fff',
            stroke: '#000'
        };
        function conditionallyShow(nodeType, deleteOverride) {
            switch(nodeType){
                case 'delete':
                    if (self.node.options.showDelete) self.buttons.trash = r.trash().transform([
                        't',
                        x + widthOffset - (deleteOverride || 80),
                        ',',
                        y - 58
                    ].join()).attr({
                        fill: '#fff',
                        stroke: '#f00'
                    });
                    else if (self.node.options.showAddAndDeleteConditionally && self.node.options.copiedFromId) {
                        const copiedTimestamps = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId).map((nx)=>nx.options.copiedAt);
                        if (self.node.options.copiedAt >= Math.max(...copiedTimestamps)) self.buttons.trash = r.trash().transform([
                            't',
                            x + widthOffset - (deleteOverride || 80),
                            ',',
                            y - 58
                        ].join()).attr({
                            fill: '#fff',
                            stroke: '#f00'
                        });
                    }
                    break;
                case 'add':
                    {
                        const copies = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.id).length;
                        if (self.node.options.showAdd || copies === 0 && self.node.options.showAddAndDeleteConditionally && !self.node.options.copiedFromId) self.buttons.unPinned = r.plus().transform([
                            't',
                            x + widthOffset + 40,
                            ',',
                            y - 58
                        ].join()).attr(btnAttr);
                        else if (self.node.options.showAddAndDeleteConditionally && self.node.options.copiedFromId) {
                            const copiedTimestamps = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId).map((nx)=>nx.options.copiedAt);
                            if (self.node.options.copiedAt >= Math.max(...copiedTimestamps)) self.buttons.unPinned = r.plus().transform([
                                't',
                                x + widthOffset + 40,
                                ',',
                                y - 58
                            ].join()).attr(btnAttr);
                        }
                        break;
                    }
                default:
                    break;
            }
        }
        self.buttons = {};
        if (self.slate.isCommentOnly() && self.node.options.isComment || !self.slate.isCommentOnly()) {
            if (self.node.options.showMenu) self.buttons.setting = r.setting().transform([
                't',
                x + widthOffset,
                ',',
                y - 58
            ].join()).attr(btnAttr);
            if (self.node.options.isComment && self.slate.canRemoveComments()) conditionallyShow('delete', 40);
        }
        if (!self.node.options.isLocked && !self.node.options.isComment && !self.slate.isCommentOnly()) {
            conditionallyShow('add');
            conditionallyShow('delete');
            if (self.node.options.showRelationshipConnector) self.buttons.handle = r.handle().transform([
                't',
                x + widthOffset - 40,
                ',',
                y - 58
            ].join()).attr(btnAttr);
        }
        [
            'mousedown'
        ].forEach((eventType)=>{
            if (self.buttons.setting) self.buttons.setting[eventType]((e)=>{
                self.slate.unglow();
                onSettingsClicked.apply(self);
                (0, _utilsDefault.default).stopEvent(e);
                // self.remove();
                if (self.slate.multiSelection) self.slate.multiSelection.end();
                if (self.node.context) self.node.context.remove();
                if (self.node.links) self.node.links.unset();
            });
            if (self.buttons.unPinned) self.buttons.unPinned[eventType](function unp(e) {
                (0, _utilsDefault.default).stopEvent(e);
                this.loop();
                self.slate.unglow();
                self.node.connectors?.addNode();
                self.node.menu?.hide();
                self.node.context?.remove();
            });
            if (self.buttons.trash) self.buttons.trash[eventType]((e)=>{
                const gid = self.node.options.groupId;
                (0, _utilsDefault.default).stopEvent(e);
                self.node.del();
                self.slate.unglow();
                const delPkg = {
                    type: 'onNodeDeleted',
                    data: {
                        id: self.node.options.id,
                        isComment: self.node.options.isComment
                    }
                };
                self.slate.collab?.send(delPkg);
                self.slate.birdsEye?.nodeDeleted(delPkg);
                if (gid) // reselect the group after the node is deleted
                self.slate.multiSelection.showGroup(gid);
            });
            if (self.buttons.handle) self.buttons.handle[eventType]((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                self.slate.unglow();
                self.node.relationships.initiateTempNode(e, self.node, true);
            });
        });
        if (Object.keys(self.buttons).length > 1) {
            const isComment = self.node.options.isComment;
            const barWidth = Object.keys(self.buttons).length * 40;
            // console.log('isComment barWidth', isComment, barWidth, widthOffset)
            if (!self.iconBar) self.iconBar = r.rect(x + widthOffset - (isComment ? 45 : 85), y - 63, barWidth, 43, 3).attr({
                stroke: '#000',
                fill: '#fff'
            }).toFront();
        }
        Object.keys(self.buttons).forEach((btn)=>{
            const button = self.buttons[btn];
            button.toFront();
            _m.push(button);
            button.mouseover(function mo() {
                self.slate.glow(this);
            });
            button.mouseout(()=>{
                self.slate.unglow();
            });
        });
        if (!self.node.options.isLocked && !self.node.options.isComment && !self.slate.isCommentOnly()) {
            if (self.node.options.showResize) {
                const rs = self.node.resize.show(x + bb.width, y + bb.height);
                _m.push(rs);
            }
            if (self.node.options.showRotate) {
                const rotate = self.node.rotate.show(x, y);
                _m.push(rotate);
            }
        }
        return self;
    }
    reset() {
        this._lastUnpinned = {
            options: {
                xPos: null,
                width: null,
                yPos: null
            }
        };
    }
    createNode(skipCenter, options, targetXPos, targetYPos, doBroadcast) {
        const self = this;
        const newNode = new (0, _nodeDefault.default)(options);
        self.slate.nodes.add(newNode);
        (0, _utilsDefault.default).transformPath(newNode, `T${targetXPos - newNode.options.xPos}, ${targetYPos - newNode.options.yPos}`);
        newNode.options.xPos = targetXPos;
        newNode.options.yPos = targetYPos;
        newNode.editor.set();
        // const coords = newNode.textCoords({
        //   x: newNode.options.xPos,
        //   y: newNode.options.yPos,
        // })
        // newNode.editor.setTextOffset()
        // newNode.text.attr(coords)
        self._lastUnpinned = newNode.options;
        if (self.slate.options.mindMapMode) self.node.relationships.addAssociation(newNode);
        self.slate.birdsEye?.refresh(false);
        if (doBroadcast) self._broadcast(skipCenter, options, targetXPos, targetYPos);
        // var _pkg = { type: "addRelationship", data: { type: 'association', parent: self.node.options.id, child: newNode.options.id} };
        // self.slate.collab && self.slate.collab.send(_pkg);
        // fire the editor if the menu can be shown
        if (doBroadcast && newNode.options.showMenu && skipCenter === undefined) newNode.position('center', ()=>{
            // fire event
            self.slate.events?.onTextPaneRequested?.apply(this, [
                newNode,
                (opts)=>{
                // ('changed', opts);
                }
            ]);
        });
        return newNode;
    }
    // eslint-disable-next-line consistent-return
    addNode(skipCenter) {
        const self = this;
        // add new node to the right of this one.
        // const _snap = self.slate.snapshot()
        const copies = self.slate.nodes.allNodes.filter((n)=>n.options.copiedFromId === self.node.options.copiedFromId && n.options.copiedAt >= self.node.options.copiedAt).length;
        if (copies === 1) self.reset();
        const options = JSON.parse(JSON.stringify(self.node.options));
        // assign a new guid to this node and remove the old id from the snapshot
        // otherwise the snapshot contains the previous id, and the node contains
        // the new id -- and the broadcast of the snap for collaboration causes
        // the old id to be assigned to the new node, created duplicate nodes with the same id
        const newId = (0, _utilsDefault.default).guid();
        // let snapNode = _snap.nodes.allNodes.find((n) => n.options.id === options.id)
        // console.log(
        //   'found snapNode',
        //   newId,
        //   options.id,
        //   _snap.nodes.allNodes,
        //   snapNode
        // )
        // snapNode.options.id = newId
        if (!self.node.options.width) {
            const bb = self.node.vect.getBBox();
            self.node.options.width = bb.width;
            self.node.options.height = bb.height;
        }
        options.id = newId;
        const targetXPos = (self._lastUnpinned.xPos || self.node.options.xPos) + (self._lastUnpinned.width || self.node.options.width || 220) + self.node.options.spaceBetweenNodesWhenAdding || 30;
        const targetYPos = self._lastUnpinned.yPos || self.node.options.yPos;
        // console.log(
        //   'targetXPos',
        //   targetXPos,
        //   self._lastUnpinned.width,
        //   self.node.options.width,
        //   self.node.options.spaceBetweenNodesWhenAdding
        // )
        // const textDimens = utils.getTextWidth(
        //   self.node.options.text,
        //   `${self.node.options.fontSize}pt ${self.node.options.fontFamily}`
        // )
        // // don't replace text if the shape is alpha, otherwise the intent here is to copy the text
        // console.log(
        //   'textDimens',
        //   self.node.options.text,
        //   `${self.node.options.fontSize}pt ${self.node.options.fontFamily}`,
        //   textDimens.width,
        //   textDimens.fontBoundingBoxAscent + textDimens.fontBoundingBoxDescent
        // )
        if (options.opacity === 1) options.text = '';
        options.copiedFromId = self.node.options.copiedFromId || self.node.options.id;
        options.copiedAt = new Date().valueOf();
        // use the next theme shape if this slate is set to sync the theme
        if (!self.slate.options.basedOnThemeId) return self.createNode(skipCenter, options, targetXPos, targetYPos, true);
        // adjust the node's shape and color prior to insertion
        self.slate.events.onThemeRequired({
            themeId: self.slate.options.basedOnThemeId
        }, (err, theme)=>{
            if (err) console.error('Unable to apply theme', err);
            else {
                const children = self.slate.findChildren([
                    options.id
                ]);
                let nextChild = children.length + 1;
                if (nextChild > Object.keys(theme.styles).length) nextChild = 1;
                const base = theme.styles[`child_${nextChild}`];
                // if (base && base.opacity === 0) {
                //   // scope the size to just the text if this is opacity-less
                //   base.width = textDimens.width
                //   base.height =
                //     textDimens.fontBoundingBoxAscent +
                //     textDimens.fontBoundingBoxDescent
                //   base.vectorPath = options.vectorPath
                // }
                // console.log(
                //   'modifying options',
                //   options.width,
                //   options.height,
                //   options.vectorPath,
                //   base.width,
                //   base.height
                // )
                if (base) Object.assign(options, (0, _lodashOmitDefault.default)(base, 'vectorPath'));
            }
            return self.createNode(skipCenter, options, targetXPos, targetYPos, true);
        });
    }
}
exports.default = connectors;

},{"../helpers/utils":"8QI6M","../core/node":"bAVQb","lodash.omit":"82TGT","../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4vYbQ":[function(require,module,exports,__globalThis) {
/* eslint-disable no-use-before-define */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashThrottle = require("lodash.throttle");
var _lodashThrottleDefault = parcelHelpers.interopDefault(_lodashThrottle);
var _lodashClone = require("lodash.clone");
var _lodashCloneDefault = parcelHelpers.interopDefault(_lodashClone);
var _staticKdtree = require("static-kdtree");
var _staticKdtreeDefault = parcelHelpers.interopDefault(_staticKdtree);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _sbIcons = require("../helpers/sbIcons");
var _sbIconsDefault = parcelHelpers.interopDefault(_sbIcons);
class resize {
    constructor(slate, node){
        const self = this;
        self.slate = slate;
        self.node = node;
        self.resize = null;
        self.resizeTemp = null;
        self.origX = null;
        self.origY = null;
        self.lastDx = null;
        self.lastDy = null;
        self._minWidth = 5;
        self._minHeight = 5;
        self._dragAllowed = false;
        self._origWidth = null;
        self._origHeight = null;
        self._isResizing = false;
        self.origPath = null;
        self.origPoint = {};
        self.resizeEvents = {
            start () {
                const s = this;
                self.node.toggleImage({
                    active: true,
                    keepResizerOpen: true
                });
                self.origPath = self.node.options.vectorPath;
                self.origPoint = self.node.options.rotate.point;
                self.origX = self.resizeTemp.attr('x');
                self.origY = self.resizeTemp.attr('y');
                self.node.options.hasResized = true;
                // create a huge dragging area in order to prevent mouse from losing focus on the correct element
                self.resizeTemp.attr({
                    x: self.resizeTemp.attr('x') - 1000,
                    y: self.resizeTemp.attr('y') - 1000,
                    width: 10000,
                    height: 10000
                });
                self.slate.isBeingResized = true;
                self.node.relationships.updateAssociationsWith({
                    activeNode: self.node.options.id,
                    currentDx: 0,
                    currentDy: 0,
                    action: 'resize'
                });
                self.lastDx = 0;
                self.lastDy = 0;
                const bbr = self.resize.getBBox();
                self.resize.ox = bbr.x;
                self.resize.oy = bbr.y;
                self._isResizing = true;
                self.slate.multiSelection?.end();
                // the resize coords at the start
                s.ox = s.attr('x');
                s.oy = s.attr('y');
                self.node.setStartDrag();
                self.node.connectors.remove();
                self.node.rotate.hide();
                self._dragAllowed = self.slate.options.allowDrag;
                self.slate.disable(false, true);
                if (self.node.options.text !== ' ') {
                    self._minWidth = 10;
                    self._minHeight = 10;
                }
                self._origWidth = self.node.options.width;
                self._origHeight = self.node.options.height;
                self.foreignPoints = self.slate.nodes.allNodes.filter((n)=>n.options.id !== self.node.options.id).map((n)=>({
                        id: n.options.id,
                        bbox: n.vect.getBBox(),
                        point: [
                            n.options.xPos,
                            n.options.yPos
                        ]
                    }));
                self.kdTree = (0, _staticKdtreeDefault.default)(self.foreignPoints.map((fp)=>fp.point));
                self.node.relationships.conditionallyHideAll();
                self.slate.toggleFilters(false);
            },
            move (dx, dy) {
                const s = this;
                try {
                    const zoomRatio = self.slate.options.viewPort.zoom.r;
                    // for snapping
                    if (self.slate.options.viewPort.showGrid && self.slate.options.viewPort.snapToGrid) {
                        const gridSize = self.slate.options.viewPort.gridSize || 10;
                        dx = Math.round(dx / gridSize) * gridSize;
                        dy = Math.round(dy / gridSize) * gridSize;
                    }
                    dx += dx / zoomRatio - dx;
                    dy += dy / zoomRatio - dy;
                    const nearest = self.kdTree.knn([
                        node.options.xPos,
                        node.options.yPos
                    ], 5);
                    nearest.forEach((n)=>{
                        self.node.gridLines.draw(self.foreignPoints[n].id, dx, dy, self.foreignPoints[n].bbox, false, 200);
                    });
                    // let transWidth = self._origWidth
                    // let transHeight = self._origHeight
                    // if (self.node.options.shapeHint === 'custom') {
                    const { transWidth, transHeight } = (0, _utilsDefault.default).obtainProportionateWidthAndHeightForResizing(dx, dy, self._origWidth, self._origHeight, self.node.options.shapeHint === 'custom' ? self.node.options.origVectWidth : null, self.node.options.shapeHint === 'custom' ? self.node.options.origVectHeight : null, self.slate.isCtrl, self.node.options.shapeHint === 'custom');
                    // }
                    if (transWidth > self._minWidth) s.attr({
                        x: s.ox + dx
                    });
                    else // tx = 0;
                    s.attr({
                        x: s.ox
                    });
                    if (transHeight > self._minHeight) s.attr({
                        y: s.oy + dy
                    });
                    else // ty = 0;
                    s.attr({
                        y: s.oy
                    });
                    // if (transWidth > self._minWidth && transHeight > self._minHeight) {
                    const ts = `T${dx}, ${dy}`;
                    self.resize.transform(ts);
                    // }
                    self.node.events?.onResizing?.apply(self, [
                        transWidth,
                        transHeight
                    ]);
                    self.set(transWidth, transHeight, {
                        isMoving: true,
                        getRotationPoint: self.node.options.rotate.rotationAngle
                    });
                    self.node.images.imageSizeCorrection() // self is a potential performance choke point
                    ;
                    self.lastDx = dx * 2;
                    self.lastDy = dy * 2;
                } catch (err) {
                    finalize();
                }
            },
            async up () {
                self.slate.toggleFilters(false);
                finalize();
            }
        };
        function finalize() {
            // self.resizeTemp.attr({ x: self.origX + self.lastDx, y: self.origY + self.lastDy, width: self.resize.attr("width"), height: self.resize.attr("height") });
            // self.node.options.vectorPath = _optimizedContext.path;
            self.node.vect.attr({
                path: self.node.options.vectorPath
            });
            self.node.relationships.showAll(true);
            self.slate.isBeingResized = false;
            self._isResizing = false;
            self.slate.enable(false, true);
            self.resize.remove();
            self.resizeTemp.remove();
            self.node.setEndDrag();
            // self.node.relationships.wireHoverEvents();
            const _bbox = self.node.vect.getBBox();
            self.node.toggleImage({
                active: false,
                width: _bbox.width,
                height: _bbox.height
            });
            self.node.options.width = _bbox.width;
            self.node.options.height = _bbox.height;
            self.node.options.xPos = _bbox.x;
            self.node.options.yPos = _bbox.y;
            if (self.node.options.image) self.node.options.ignoreTextFit = true;
            else self.node.options.ignoreTextFit = false;
            self.node.editor.setTextOffset();
            self.node.text.attr(self.node.textCoords({
                x: self.node.options.xPos,
                y: self.node.options.yPos
            }));
            self.node.gridLines.clear();
            delete self.foreignPoints;
            delete self.kdTree;
            if (self.node.events && self.node.events?.onResized) self.node.events.onResized.apply(self, [
                self.send
            ]);
            else self.send();
        }
    }
    show(x, y) {
        const self = this;
        if (self.node.options.allowResize) {
            self.resizeTemp?.remove();
            const r = self.slate.paper;
            const resizePath = (0, _utilsDefault.default)._transformPath((0, _sbIconsDefault.default).icons.resize, `t${x - 5},${y - 5} r95`);
            self.resize = r.path(resizePath).attr({
                fill: '#fff',
                stroke: '#000'
            });
            self.resizeTemp = r.rect(x - 6, y - 6, 20, 20).attr({
                fill: '#f00',
                opacity: 0.00000001
            }).toFront();
            self.resizeTemp.mouseover((e)=>{
                self.node.overMenuButton = true;
                self.resizeTemp.attr({
                    cursor: 'pointer'
                });
            });
            self.resizeTemp.mouseout((e)=>{
                self.node.overMenuButton = false;
            });
            self.resizeTemp.drag(self.resizeEvents.move, self.resizeEvents.start, self.resizeEvents.up);
            return self.resize;
        }
    }
    hide() {
        this.resizeTemp?.remove();
        this.resize?.remove();
    }
    send() {
        // broadcast change to birdsEye and collaborators
        const textAttrs = this.node.text.attrs;
        const pkg = {
            type: 'onNodeResized',
            data: {
                id: this.node.options.id,
                textPosition: {
                    x: textAttrs.x,
                    y: textAttrs.y
                },
                rotate: this.node.options.rotate,
                vectorPath: this.node.options.vectorPath,
                associations: this.node.relationships.associations.map((a)=>({
                        parentId: a.parent.options.id,
                        childId: a.child.options.id,
                        linePath: a.line.attr('path').toString()
                    }))
            }
        };
        const currentRotationPoint = (0, _lodashCloneDefault.default)(this.node.options.rotate.point);
        this.slate.birdsEye?.nodeChanged(pkg);
        this.node.options.rotate.point = currentRotationPoint;
        this.slate.collab?.send(pkg);
    }
    lazySend() {
        (0, _lodashThrottleDefault.default)(this.send, 700);
    }
    animateSet(data, opts) {
        const self = this;
        self.node.text.animate(data.textPosition, opts.duration || 500, opts.easing || '>');
        self.node.vect.animate({
            path: data.vectorPath,
            transform: `R${data.rotate.rotationAngle}, ${data.rotate.point.x}, ${data.rotate.point.y}`
        }, opts.duration || 500, opts.easing || '>', ()=>{
            const { image, imageOrigHeight, imageOrigWidth } = self.node.options;
            if (image && !!imageOrigHeight && !!imageOrigWidth) self.node.images.imageSizeCorrection();
        });
        opts.associations.forEach((assoc)=>{
            const a = self.node.relationships.associations.find((ax)=>ax.parent.options.id === assoc.parentId && ax.child.options.id === assoc.childId);
            if (opts.animate) {
                if (a) a.line.animate({
                    path: assoc.linePath
                }, opts.duration || 500, opts.easing || '>', ()=>{
                    a.line.attr({
                        path: assoc.linePath
                    });
                });
            } else if (a) a.line.attr({
                path: assoc.linePath
            });
        });
    }
    // obtainProportionateWidthAndHeightForResizing(
    //   dx,
    //   dy,
    //   origVectWidth,
    //   origVectHeight
    // ) {
    //   let transWidth = (self._origWidth || self.node.options.width) + dx * 2
    //   let transHeight = (self._origHeight || self.node.options.height) + dy * 2
    //   const useOrigVectorWidth = self.node.options.origVectWidth ?? origVectWidth
    //   const useOrigVectorHeight =
    //     self.node.options.origVectHeight ?? origVectHeight
    //   if (!self.slate.isCtrl && useOrigVectorWidth && useOrigVectorHeight) {
    //     const max = Math.max(transWidth, transHeight)
    //     // keep it proportional to the original dimensions unless ctrl is pressed while resizing
    //     if (max === transWidth) {
    //       // change height
    //       transWidth = (useOrigVectorWidth * transHeight) / useOrigVectorHeight
    //     } else {
    //       // change width
    //       transHeight = (useOrigVectorHeight * transWidth) / useOrigVectorWidth
    //     }
    //   }
    //   return { transWidth, transHeight }
    // }
    set(width, height, opts = {}) {
        // let latt, tatt;
        const self = this;
        let pathWithPotentialTransformations = self.node.vect.attr('path').toString();
        if (opts.getRotationPoint) self.origPoint = self.node.options.rotate.point;
        if (self.origPoint && Object.entries(self.origPoint).length > 0 && self.node.options.rotate.rotationAngle > 0) pathWithPotentialTransformations = (0, _raphaelSvg.Raphael).transformPath(pathWithPotentialTransformations, `R${self.node.options.rotate.rotationAngle}, ${self.origPoint.x}, ${self.origPoint.y}`);
        self.node.vect.transform('');
        self.node.text.transform('');
        self.node.vect.attr({
            path: pathWithPotentialTransformations
        });
        self.node.text.attr({
            path: pathWithPotentialTransformations
        });
        const rotationBB = self.node.vect.getBBox();
        let widthScalar = 1;
        let heightScalar = 1;
        if (width > self._minWidth) {
            widthScalar = width / rotationBB.width;
            self.node.options.width = width;
        } else {
            widthScalar = self._minWidth / rotationBB.width;
            self.node.options.width = self._minWidth;
        }
        if (height > self._minHeight) {
            heightScalar = height / rotationBB.height;
            self.node.options.height = height;
        } else {
            heightScalar = self._minHeight / rotationBB.height;
            self.node.options.height = self._minHeight;
        }
        const scaleTransform = `s${widthScalar}, ${heightScalar}`;
        const scaledVectPath = (0, _raphaelSvg.Raphael).transformPath(self.node.vect.attr('path').toString(), scaleTransform).toString();
        pathWithPotentialTransformations = scaledVectPath;
        self.node.vect.attr({
            path: scaledVectPath
        });
        if (self.origPoint && Object.entries(self.origPoint).length > 0 && self.node.options.rotate.rotationAngle > 0) pathWithPotentialTransformations = (0, _raphaelSvg.Raphael).transformPath(pathWithPotentialTransformations, `R${-self.node.options.rotate.rotationAngle}, ${self.origPoint.x}, ${self.origPoint.y}`).toString();
        self.node.vect.attr({
            path: pathWithPotentialTransformations
        });
        self.node.options.vectorPath = pathWithPotentialTransformations;
        const noRotationBB = self.node.vect.getBBox();
        self.node.options.rotate.point = {
            x: noRotationBB.cx,
            y: noRotationBB.cy
        };
        self.node.setPosition({
            x: noRotationBB.x,
            y: noRotationBB.y
        }, true);
        self.node.rotate.applyImageRotation();
        const lc = self.node.linkCoords();
        self.node.link.transform([
            't',
            lc.x,
            ',',
            lc.y,
            's',
            '.8',
            ',',
            '.8',
            'r',
            '180'
        ].join());
        self.node.relationships.refreshOwnRelationships();
        self.node.editor.setTextOffset();
        self.node.text.attr(self.node.textCoords({
            x: self.node.options.xPos,
            y: self.node.options.yPos
        }));
    }
}
exports.default = resize;

},{"lodash.throttle":"bGJVT","lodash.clone":"j9BUC","static-kdtree":"i8GTt","../deps/raphael/raphael.svg":"jK21R","../helpers/utils":"8QI6M","../helpers/sbIcons":"5LoVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bGJVT":[function(require,module,exports,__globalThis) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ var global = arguments[3];
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */ var NAN = 0 / 0;
/** `Object#toString` result references. */ var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeMax = Math.max, nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */ var now = function() {
    return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */ function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;
        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) return trailingEdge(time);
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = undefined;
        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) return invokeFunc(time);
        lastArgs = lastThis = undefined;
        return result;
    }
    function cancel() {
        if (timerId !== undefined) clearTimeout(timerId);
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
    }
    function flush() {
        return timerId === undefined ? result : trailingEdge(now());
    }
    function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === undefined) return leadingEdge(lastCallTime);
            if (maxing) {
                // Handle invocations in a tight loop.
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === undefined) timerId = setTimeout(timerExpired, wait);
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */ function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != 'function') throw new TypeError(FUNC_ERROR_TEXT);
    if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
    });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == 'number') return value;
    if (isSymbol(value)) return NAN;
    if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') return value === 0 ? value : +value;
    value = value.replace(reTrim, '');
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = throttle;

},{}],"j9BUC":[function(require,module,exports,__globalThis) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var global = arguments[3];
var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', promiseTag = '[object Promise]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to match `RegExp` flags from their coerced string values. */ var reFlags = /\w*$/;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values supported by `_.clone`. */ var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Detect free variable `exports`. */ var freeExports = exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && true && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */ function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
}
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */ function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
}
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */ function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while(++index < length){
        if (iteratee(array[index], index, array) === false) break;
    }
    return array;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length)array[offset + index] = values[index];
    return array;
}
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */ function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) accumulator = array[++index];
    while(++index < length)accumulator = iteratee(accumulator, array[index], index, array);
    return accumulator;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n)result[index] = iteratee(index);
    return result;
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') try {
        result = !!(value + '');
    } catch (e) {}
    return result;
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) return false;
    var lastIndex = data.length - 1;
    if (index == lastIndex) data.pop();
    else splice.call(data, index, 1);
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) data.push([
        key,
        value
    ]);
    else data[index][1] = value;
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    this.__data__ = new ListCache(entries);
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    return this.__data__['delete'](key);
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            return this;
        }
        cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value)if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) result.push(key);
    return result;
}
/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */ function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) object[key] = value;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) return length;
    }
    return -1;
}
/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */ function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
}
/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */ function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) result = object ? customizer(value, key, object, stack) : customizer(value);
    if (result !== undefined) return result;
    if (!isObject(value)) return value;
    var isArr = isArray(value);
    if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) return copyArray(value, result);
    } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) return cloneBuffer(value, isDeep);
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (isHostObject(value)) return object ? value : {};
            result = initCloneObject(isFunc ? {} : value);
            if (!isDeep) return copySymbols(value, baseAssign(result, value));
        } else {
            if (!cloneableTags[tag]) return object ? value : {};
            result = initCloneByTag(value, tag, baseClone, isDeep);
        }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) return stacked;
    stack.set(value, result);
    if (!isArr) var props = isFull ? getAllKeys(value) : keys(value);
    arrayEach(props || value, function(subValue, key) {
        if (props) {
            key = subValue;
            subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
}
/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */ function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    return objectToString.call(value);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) return false;
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) return nativeKeys(object);
    var result = [];
    for(var key in Object(object))if (hasOwnProperty.call(object, key) && key != 'constructor') result.push(key);
    return result;
}
/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */ function cloneBuffer(buffer, isDeep) {
    if (isDeep) return buffer.slice();
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
}
/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */ function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array(result).set(new Uint8Array(arrayBuffer));
    return result;
}
/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */ function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */ function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
}
/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */ function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
}
/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */ function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
}
/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */ function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */ function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */ function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while(++index < length)array[index] = source[index];
    return array;
}
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */ function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while(++index < length){
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
        assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
}
/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */ function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) getTag = function(value) {
    var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
    if (ctorString) switch(ctorString){
        case dataViewCtorString:
            return dataViewTag;
        case mapCtorString:
            return mapTag;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag;
        case weakMapCtorString:
            return weakMapTag;
    }
    return result;
};
/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */ function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
    }
    return result;
}
/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneObject(object) {
    return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */ function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch(tag){
        case arrayBufferTag:
            return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
            return new Ctor(+object);
        case dataViewTag:
            return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
            return cloneTypedArray(object, isDeep);
        case mapTag:
            return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
            return new Ctor(object);
        case regexpTag:
            return cloneRegExp(object);
        case setTag:
            return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
            return cloneSymbol(object);
    }
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + '';
        } catch (e) {}
    }
    return '';
}
/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */ function clone(value) {
    return baseClone(value, false, true);
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == 'object';
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = clone;

},{}],"jLcMC":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _emile = require("../deps/emile");
class images {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    getTargetImageDimensions() {
        let transImageHeight;
        let transImageWidth;
        const origImageRatio = this.node.options.imageOrigWidth / this.node.options.imageOrigHeight;
        const noRotationPath = this.slate.paper.path(this.node.vect.attr('path'));
        const noRotationBB = noRotationPath.getBBox();
        const nodeRatio = noRotationBB.width / noRotationBB.height;
        if (origImageRatio < nodeRatio) {
            transImageWidth = noRotationBB.width;
            transImageHeight = noRotationBB.width / origImageRatio;
        } else if (origImageRatio > nodeRatio) {
            transImageHeight = noRotationBB.height;
            transImageWidth = noRotationBB.height * origImageRatio;
        } else {
            transImageWidth = noRotationBB.width;
            transImageHeight = noRotationBB.height;
        }
        noRotationPath.remove();
        return {
            width: transImageWidth,
            height: transImageHeight
        };
    }
    imageSizeCorrection() {
        if (this.node.vect.pattern) {
            const targetImageDimensions = this.getTargetImageDimensions();
            const img = this.node.vect.pattern.getElementsByTagName('image')[0];
            img.setAttribute('height', targetImageDimensions.height);
            img.setAttribute('width', targetImageDimensions.width);
        }
    }
    set(img, w, h, blnKeepResizerOpen) {
        this.node.vect.data({
            relativeFill: true
        });
        this.node.options.image = img;
        this.node.options.origImage = {
            w,
            h
        } // needed for image copying if done later
        ;
        this.node.options.imageOrigHeight = h // for scaling node to image size purposes; this value should never be changed
        ;
        this.node.options.imageOrigWidth = w;
        this.node.options['fill-opacity'] = 1;
        const sz = {
            fill: `url(${this.node.options.image})`,
            'stroke-width': this.node.options.borderWidth,
            stroke: '#000'
        };
        const targetImageDimensions = this.getTargetImageDimensions();
        this.node.vect.imageOrigHeight = targetImageDimensions.height;
        this.node.vect.imageOrigWidth = targetImageDimensions.width;
        this.node.vect.attr({
            'fill-opacity': 1
        }) // IMPORTANT: for some reason Raphael breaks when setting 'sz' object and this at the same time
        ;
        this.node.vect.attr(sz);
        const rotatedBB = this.node.vect.getBBox();
        this.node.options.width = rotatedBB.width;
        this.node.options.height = rotatedBB.height;
        this.node.relationships.refreshOwnRelationships();
        if (blnKeepResizerOpen) {
            this.node.setPosition({
                x: rotatedBB.x,
                y: rotatedBB.y
            }, true);
            this.node.menu?.hide();
            this.node.rotate?.hide();
        } else this.node.setPosition({
            x: rotatedBB.x,
            y: rotatedBB.y
        });
        this.node.connectors?.remove();
    }
}
exports.default = images;

},{"../deps/emile":"dd61Y","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kA5hP":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class shapes {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    async set(pkg = {
        sendCollab: false
    }) {
        this.slate.unglow();
        let _path = '';
        switch(pkg.shape){
            case 'ellipse':
                _path = (0, _utilsDefault.default)._transformPath(`M${this.node.options.xPos + 75},${this.node.options.yPos + 50} m -75,0 a75,50 0 1,0 150,0 a 75,50 0 1,0 -150,0Z`);
                this.node.options.isEllipse = true;
                break;
            case 'rect':
                if (pkg.rx > 0) _path = (0, _utilsDefault.default)._transformPath(`M${this.node.options.xPos},${this.node.options.yPos} h130 a10,10 0 0 1 10,10 v80 a10,10 0 0 1 -10,10 h-130 a10,10 0 0 1 -10,-10 v-80 a10,10 0 0 1 10,-10 z`);
                else _path = (0, _utilsDefault.default)._transformPath(`M${this.node.options.xPos},${this.node.options.yPos} h150 v100 h-150 v-100 z`);
                this.node.options.isEllipse = false;
                break;
            default:
                _path = (0, _utilsDefault.default)._transformPath(pkg.shape, `T${this.node.options.xPos},${this.node.options.yPos}`);
                this.node.options.isEllipse = false;
                break;
        }
        this.node.options.vectorPath = _path;
        this.node.options.shapeHint = pkg.hint;
        this.node.options.origVectWidth = pkg.width;
        this.node.options.origVectHeight = pkg.height;
        this.node.options.width = pkg.width || this.node.options.width;
        this.node.options.height = pkg.height || this.node.options.height;
        this.node.vect.attr({
            path: _path
        });
        this.node.editor.setTextOffset();
        this.node.text.attr(this.node.textCoords({
            x: this.node.options.xPos,
            y: this.node.options.yPos
        }));
        // apply image fill rotation
        if (this.node.vect.pattern) {
            this.node.images.imageSizeCorrection();
            this.node.rotate.applyImageRotation();
        }
        this.node.text.toFront();
        this.node.link.toFront();
        this.node.relationships.refreshOwnRelationships();
        if (pkg.keepResizerOpen) {
            this.node.menu?.hide();
            this.node.rotate?.hide();
        }
        // needed for tofront and toback ops of the context menu
        this.node.vect.data({
            id: this.node.options.id
        });
        this.node.context.create();
        if (pkg.sendCollab) {
            const _pkg = {
                type: 'onNodeShapeChanged',
                data: {
                    id: this.node.options.id,
                    shape: pkg.shape,
                    hint: pkg.hint,
                    width: pkg.width,
                    height: pkg.height,
                    sendCollab: false,
                    rx: pkg.rx
                }
            };
            this.slate.collab?.send(_pkg);
            this.slate.birdsEye?.nodeChanged(_pkg);
        }
    }
}
exports.default = shapes;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edbtN":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class customShapes {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    set(path, width, height, sendCollab) {
        let upath = path;
        if (width && height) {
            // calculate the scale of the path
            const scale = Math.max(this.node.options.width, this.node.options.height) / Math.max(width, height);
            upath = (0, _utilsDefault.default)._transformPath(path, [
                's',
                scale,
                ',',
                scale
            ].join(''));
        }
        this.node.shapes.set({
            shape: upath.toString(),
            sendCollab: sendCollab != null ? sendCollab : true
        });
    }
}
exports.default = customShapes;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJAST":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class colorPicker {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
    }
    set(cast) {
        this.node.options.image = '';
        this.node.options.backgroundColor = cast.color;
        if (cast.opacity != null) this.node.options.opacity = cast.opacity;
        this.node.vect.attr({
            fill: cast.color,
            'fill-opacity': this.node.options.opacity
        });
        if (cast.color === '' && this.node.options.text !== '') {
            this.node.vect.attr({
                stroke: this.node.options.borderColor || '#000'
            });
            this.node.options.borderWidth = 0;
        } else this.node.vect.attr({
            stroke: this.node.options.borderColor || '#000',
            'stroke-width': this.node.options.borderWidth
        });
        this.node.relationships.refreshOwnRelationships();
    }
}
exports.default = colorPicker;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"185nI":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class context {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this._contextMenu = null;
        this._priorAllowDrag = true;
    }
    ctx(e) {
        this._priorAllowDrag = this.node.options.allowDrag;
        this.node.options.allowDrag = false;
        this.remove();
        this.buildContext(e);
        setTimeout(()=>{
            this.node.options.allowDrag = this._priorAllowDrag;
        }, 2);
        return (0, _utilsDefault.default).stopEvent(e);
    }
    create() {
        if (this.node.text && this.node.text.node && this.node.options.allowContext && !this.node.slate.isAlt && !this.node.slate.isShift) {
            this.node.text.node.oncontextmenu = this.ctx;
            this.node.vect.node.oncontextmenu = this.ctx;
        }
    }
    buildContext(e) {
        this._contextMenu = document.createElement('div');
        this._contextMenu.setAttribute('id', `contextMenu_${this.node.options.id}`);
        this._contextMenu.setAttribute('class', 'sb_cm');
        document.body.appendChild(this._contextMenu);
        this.setContext(e);
    }
    menuItems() {
        const tmp = "<div style='padding:5px;' class='sbthis._contextMenuItem' rel='{func}'>{text}</div>";
        let inside = tmp.replace(/{func}/g, 'tofront').replace(/{text}/g, 'to front');
        inside += tmp.replace(/{func}/g, 'toback').replace(/{text}/g, 'to back');
        if (this._priorAllowDrag) inside += tmp.replace(/{func}/g, 'lock').replace(/{text}/g, 'lock');
        else inside += tmp.replace(/{func}/g, 'unlock').replace(/{text}/g, 'unlock');
        inside += tmp.replace(/{func}/g, 'close').replace(/{text}/g, 'close');
        return inside;
    }
    setContext(e) {
        const self = this;
        this._contextMenu.innerHTML = this.menuItems();
        const all = (0, _utilsDefault.default).select('div.contextMenuItem');
        for(let s = all.length; s < all.length; s += 1){
            const elem = all[s];
            elem.onclick = ()=>{
                const act = this.getAttribute('rel');
                let _reorder = false;
                const pkg = {
                    type: '',
                    data: {
                        id: self.node.options.id
                    }
                };
                switch(act){
                    case 'tofront':
                        self.node.toFront();
                        _reorder = true;
                        pkg.type = 'onNodeToFront';
                        break;
                    case 'toback':
                        self.node.toBack();
                        _reorder = true;
                        pkg.type = 'onNodeToBack';
                        break;
                    case 'lock':
                        self.node.options.isLocked = true // self is not a part of the self.node.disable function on purpose
                        ;
                        self.node.disable();
                        pkg.type = 'onNodeLocked';
                        break;
                    case 'unlock':
                        self.node.options.isLocked = false // self is not a part of the self.node.enable function on purpose
                        ;
                        self.node.enable();
                        pkg.type = 'onNodeUnlocked';
                        break;
                    case 'close':
                    default:
                        break;
                }
                if (_reorder) {
                    let zIndex = 0;
                    for(let node = self.node.slate.paper.bottom; node != null; node = node.next)if (node.type === 'ellipse' || node.type === 'rect') {
                        zIndex += 1;
                        const _id = node.data('id');
                        // not all rects have an id (the menu box is a rect, but it has no options.id because it is not a node
                        // so you cannot always show self...
                        if (_id) {
                            const reorderedNode = self.node.slate.nodes.allNodes.find((n)=>n.options.id === _id);
                            reorderedNode.sortorder = zIndex;
                        }
                    }
                    self.node.slate.nodes.allNodes.sort((a, b)=>a.sortorder < b.sortorder ? -1 : 1);
                }
                if (pkg.type !== '') self.broadcast(pkg);
                this.remove();
            };
        }
        const mp = (0, _utilsDefault.default).mousePos(e);
        const _x = mp.x;
        const _y = mp.y;
        this._contextMenu.style.left = `${_x}px`;
        this._contextMenu.style.top = `${_y}px`;
    }
    broadcast(pkg) {
        // broadcast
        if (this.node.slate.collab) this.node.slate.collab.send(pkg);
        if (this.node.slate.birdsEye) this.node.slate.birdsEye.nodeChanged(pkg);
    }
    remove() {
        this.node.slate?.removeContextMenus();
        this._contextMenu = null;
    }
    isVisible() {
        return this._contextMenu !== null;
    }
}
exports.default = context;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c3gfk":[function(require,module,exports,__globalThis) {
/* eslint-disable no-param-reassign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashInvoke = require("lodash.invoke");
var _lodashInvokeDefault = parcelHelpers.interopDefault(_lodashInvoke);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class lineOptions {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.m = {};
    }
    broadcast(pkg) {
        pkg.data.id = this.node.options.id;
        this.slate.collab?.send(pkg);
    }
    set(pkg) {
        const a = this.node.relationships.associations[pkg.index];
        if (pkg.updateChild) a.child.options[pkg.prop] = pkg.val;
        else this.node.options[pkg.prop] = pkg.val;
        if (pkg.val === 'toggle') a[pkg.prop] = a[pkg.prop] ? (pkg.prop, false) : true;
        else a[pkg.prop] = pkg.val;
        (0, _refreshRelationshipsDefault.default)({
            relationships: [
                a
            ],
            nodes: [
                this.node
            ]
        });
    }
    show(e, c) {
        const self = this;
        self.hideAll();
        self.slate.nodes.closeAllLineOptions(c.id);
        const a = self.node.relationships.associations.find((ax)=>ax.id === c.id);
        const r = self.slate.paper;
        const mp = (0, _utilsDefault.default).mousePos(e);
        const off = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        const z = self.slate.options.viewPort.zoom.r;
        const opacity = '1.0';
        let x = (mp.x + self.slate.options.viewPort.left - off.left - 90) / z;
        let y = (mp.y + self.slate.options.viewPort.top - off.top - 30) / z;
        const bb = a.line.getBBox();
        x = bb.cx;
        y = bb.cy;
        self.m[c.id] = r.set();
        const transformToolbar = (xx, yy)=>[
                't',
                x + xx,
                ',',
                y + yy
            ].join();
        const toolbarAttr = {
            fill: '#fff',
            'fill-opacity': opacity,
            stroke: '#333',
            'stroke-width': 1,
            cursor: 'pointer'
        };
        const toolbar = [];
        const reassign = self.node.options.showRelationshipReassign ? r.handle().attr(toolbarAttr).transform(transformToolbar(15, 0)) : null;
        const props = self.node.options.showRelationshipProperties ? r.setting().attr(toolbarAttr).transform(transformToolbar(-15, 0)) : null;
        const del = self.node.options.showRelationshipDelete ? r.trash().transform(transformToolbar(-45, 0)).attr({
            fill: '#fff',
            stroke: '#f00'
        }) : null;
        if (reassign) toolbar.push(reassign);
        if (toolbar) toolbar.push(props);
        if (del) toolbar.push(del);
        const toolbarGlows = [];
        toolbar.forEach((toolbarElem)=>{
            toolbarElem.mouseover(function g() {
                toolbarGlows.push(this.glow());
                (0, _utilsDefault.default).stopEvent(e);
            });
            toolbarElem.mouseout(()=>{
                toolbarGlows.forEach((t)=>{
                    t.remove();
                });
                (0, _utilsDefault.default).stopEvent(e);
            });
        });
        if (props) props.mousedown((ex)=>{
            (0, _utilsDefault.default).stopEvent(ex);
            toolbarGlows.forEach((t)=>{
                t.remove();
            });
            const assoc = self.node.relationships.associations.find((ax)=>ax.id === c.id);
            if (self.slate.events?.onLineMenuRequested) {
                self.hideAll();
                self.slate.events?.onLineMenuRequested(self.node, assoc, ()=>{
                // finished
                });
            }
        });
        function removeRelationship(ex) {
            toolbarGlows.forEach((t)=>{
                t.remove();
            });
            (0, _utilsDefault.default).stopEvent(ex);
            if (self.slate.options.enabled) {
                const pkg = {
                    type: 'removeRelationship',
                    data: {
                        parent: c.parent.options.id,
                        child: c.child.options.id
                    }
                };
                self.slate.nodes.removeRelationship(pkg.data);
                self.slate.birdsEye?.relationshipsChanged(pkg);
                self.broadcast(pkg);
                self.hide(c.id);
            }
        }
        // reassign relationship
        if (reassign) reassign.mousedown(()=>{
            removeRelationship();
            self.node.relationships.initiateTempNode(e, c.parent, {
                showChildArrow: a.showChildArrow,
                showParentArrow: a.showParentArrow
            });
        });
        // remove relationship
        if (del) del.mousedown(()=>{
            removeRelationship();
        });
        toolbar.forEach((toolbarElem)=>{
            self.m[c.id].push(toolbarElem);
        });
        return self;
    }
    hide(id) {
        if (this.m[id]) {
            (0, _lodashInvokeDefault.default)(this.m[id], 'remove');
            this.m[id] = null;
        }
    }
    hideAll() {
        const self = this;
        // self.slate.unglow();
        self.node.relationships.associations.map((r)=>r.id).forEach((id)=>{
            self.hide(id);
        });
    }
}
exports.default = lineOptions;

},{"lodash.invoke":"6VYuy","../helpers/refreshRelationships":"1UeYf","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6cFRW":[function(require,module,exports,__globalThis) {
/* eslint-disable no-param-reassign */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class gridLines {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.guideWings = 20000;
        this.guideAttrs = {
            'stroke-dasharray': '--',
            stroke: '#000'
        };
        this.guideLines = {
            rightVerticals: {},
            leftVerticals: {},
            topHorizontals: {},
            bottomHorizontals: {}
        };
    }
    clear() {
        const self = this;
        [
            'rightVerticals',
            'leftVerticals',
            'topHorizontals',
            'bottomHorizontals'
        ].forEach((p)=>{
            if (self.guideLines[p]) Object.keys(self.guideLines[p]).forEach((k)=>self.guideLines[p][k].remove());
            self.guideLines[p] = {};
        });
    }
    draw(id, dx, dy, bb, translateNode = true, guideVisibleAt = 100, guideSnapAt = 20) {
        const self = this;
        const snapToObjects = self.slate.options.viewPort.snapToObjects != null ? self.slate.options.viewPort.snapToObjects : true;
        let pinnedY = false;
        let pinnedX = false;
        const nbb = self.node.vect.getBBox();
        self.guideAttrs.stroke = (0, _utilsDefault.default).whiteOrBlack(self.slate.options.containerStyle.backgroundColor);
        // RIGHT VERTICAL LINE boundary
        if (nbb.x - bb.x2 < guideVisibleAt && nbb.x - bb.x2 >= 0 || bb.x2 - nbb.x2 < guideVisibleAt && bb.x2 - nbb.x2 >= 0) {
            if (!self.guideLines.rightVerticals[id]) self.guideLines.rightVerticals[id] = self.slate.paper.path(`M ${bb.x2} ${bb.y - self.guideWings} L ${bb.x2} ${bb.y2 + self.guideWings}`).attr(self.guideAttrs);
            pinnedX = nbb.x - bb.x2 < guideSnapAt && nbb.x - bb.x2 >= 0 || bb.x2 - nbb.x2 < guideSnapAt && bb.x2 - nbb.x2 >= 0;
            if (pinnedX && snapToObjects) {
                if (nbb.x - bb.x2 < guideSnapAt && nbb.x - bb.x2 >= 0) dx -= nbb.x - bb.x2;
                else dx += bb.x2 - nbb.x2;
            }
        } else {
            self.guideLines?.rightVerticals[id]?.remove();
            delete self.guideLines?.rightVerticals[id];
        }
        // LEFT VERTICAL LINE boundary
        if (!pinnedX && (bb.x - nbb.x2 < guideVisibleAt && bb.x - nbb.x2 >= 0 || nbb.x - bb.x < guideVisibleAt && nbb.x - bb.x >= 0)) {
            if (!self.guideLines.leftVerticals[id]) self.guideLines.leftVerticals[id] = self.slate.paper.path(`M ${bb.x} ${bb.y - self.guideWings} L ${bb.x} ${bb.y2 + self.guideWings}`).attr(self.guideAttrs);
            pinnedX = bb.x - nbb.x2 < guideSnapAt && bb.x - nbb.x2 >= 0 || nbb.x - bb.x < guideSnapAt && nbb.x - bb.x >= 0;
            if (pinnedX && snapToObjects) {
                if (bb.x - nbb.x2 < guideSnapAt && bb.x - nbb.x2 >= 0) dx += bb.x - nbb.x2;
                else dx -= nbb.x - bb.x;
            }
        } else {
            self.guideLines?.leftVerticals[id]?.remove();
            delete self.guideLines?.leftVerticals[id];
        }
        // TOP HORIZONTAL LINE boundary
        if (bb.y - nbb.y2 < guideVisibleAt && bb.y - nbb.y2 >= 0 || nbb.y - bb.y < guideVisibleAt && nbb.y - bb.y >= 0) {
            if (!self.guideLines.topHorizontals[id]) self.guideLines.topHorizontals[id] = self.slate.paper.path(`M ${bb.x - self.guideWings} ${bb.y} L ${bb.x2 + self.guideWings} ${bb.y}`).attr(self.guideAttrs);
            pinnedY = bb.y - nbb.y2 < guideSnapAt && bb.y - nbb.y2 >= 0 || nbb.y - bb.y < guideSnapAt && nbb.y - bb.y >= 0;
            if (pinnedY && snapToObjects) {
                if (bb.y - nbb.y2 < guideSnapAt && bb.y - nbb.y2 >= 0) // coming from top
                dy += bb.y - nbb.y2;
                else // coming from underneath
                dy -= nbb.y - bb.y;
            }
        } else {
            self.guideLines?.topHorizontals[id]?.remove();
            delete self.guideLines?.topHorizontals[id];
        }
        // BOTTOM HORIZONTAL LINE boundary
        if (!pinnedY && (nbb.y - bb.y2 < guideVisibleAt && nbb.y - bb.y2 >= 0 || bb.y2 - nbb.y2 < guideVisibleAt && bb.y2 - nbb.y2 >= 0)) {
            if (!self.guideLines.bottomHorizontals[id]) self.guideLines.bottomHorizontals[id] = self.slate.paper.path(`M ${bb.x - self.guideWings} ${bb.y2} L ${bb.x2 + self.guideWings} ${bb.y2}`).attr(self.guideAttrs);
            pinnedY = nbb.y - bb.y2 < guideSnapAt && nbb.y - bb.y2 >= 0 || bb.y2 - nbb.y2 < guideSnapAt && bb.y2 - nbb.y2 >= 0;
            if (pinnedY && snapToObjects) {
                if (nbb.y - bb.y2 < guideSnapAt && nbb.y - bb.y2 >= 0) dy -= nbb.y - bb.y2;
                else dy += bb.y2 - nbb.y2;
            }
        } else {
            self.guideLines?.bottomHorizontals[id]?.remove();
            delete self.guideLines?.bottomHorizontals[id];
        }
        if (translateNode && (pinnedX || pinnedY)) self.node.translateWith({
            dx,
            dy
        });
        return {
            dx,
            dy
        };
    }
}
exports.default = gridLines;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BxQS":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
class links {
    constructor(slate, node){
        this.slate = slate;
        this.node = node;
        this.node.link.click((e)=>{
            this.click();
        });
    }
    set(pkg1, sendCollab) {
        // {
        //   type: 'url|currentSlate|externalSlate',
        //   data: 'https://xxx|id_of_node'
        // }
        this.node.options.link = pkg1;
        if (sendCollab) {
            const cpkg = {
                type: 'onNodeLinkAdded',
                data: pkg1
            };
            if (this.slate.collab) this.slate.collab.send(cpkg);
        }
    }
    unset(sendCollab) {
        this.node.options.link = null;
        if (sendCollab) {
            const cpkg = {
                type: 'onNodeLinkRemoved',
                data: pkg
            };
            if (this.slate.collab) this.slate.collab.send(cpkg);
        }
    }
    click() {
        //`url("https://api.miniature.io/?token=ozwPwKuD6CYUiE9K&url=miniature.io?url=${_self._.options.link.data}&size=200")`
        const self = this;
        switch(this.node.options.link.type){
            case 'url':
                window.open(self.node.options.link.data, 'sb_external');
                break;
            case 'externalSlate':
                break;
            case 'currentSlate':
                {
                    const n = self.slate.nodes.one(self.node.options.link.data);
                    n.position('center', ()=>{
                    // done
                    }, 'swingTo', 500);
                    break;
                }
        }
    }
}
exports.default = links;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kpcw7":[function(require,module,exports,__globalThis) {
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashUniq = require("lodash.uniq");
var _lodashUniqDefault = parcelHelpers.interopDefault(_lodashUniq);
var _lodashClonedeep = require("lodash.clonedeep");
var _lodashClonedeepDefault = parcelHelpers.interopDefault(_lodashClonedeep);
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _refreshRelationships = require("../helpers/refreshRelationships");
var _refreshRelationshipsDefault = parcelHelpers.interopDefault(_refreshRelationships);
var _index = require("../index");
class multiSelection {
    constructor(slate){
        const self = this;
        self.slate = slate;
        self.selRect = null // used during selection
        ;
        self.ox = null;
        self.oy = null;
        self._init = null;
        self.marker = null // stays after selection
        ;
        self.selectedNodes = [];
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.origPos = null;
        self.resizer = null;
        self.minSize = 100;
        self._icons = [];
        self.iconBg = null;
        self.moveX = 0;
        self.moveY = 0;
        self.asIndiv = false;
        self.attrs = {
            create: {
                fill: '#fff',
                stroke: '#000'
            },
            mouseOut: {
                fill: '#fff',
                stroke: '#000'
            },
            mouseOver: {
                fill: '#ccc',
                cursor: 'pointer'
            }
        };
    }
    init() {
        const self = this;
        if (self.slate.options.isbirdsEye) return;
        function finalize() {
            // self.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
            self.slate.options.allowDrag = true;
            self.slate.birdsEye?.refresh(true);
            self.selectedNodes.forEach((node)=>{
                (0, _utilsDefault.default).transformPath(node, `T${self.moveX},${self.moveY}`);
                node.vect.currentDx = 0;
                node.vect.currentDy = 0;
            });
            (0, _refreshRelationshipsDefault.default)({
                relationships: self.relationshipsToRefresh,
                nodes: self.selectedNodes,
                moveX: self.moveX,
                moveY: self.moveY
            });
            self.slate.nodes.saveRelationships(self.relationshipsToTranslate, {
                dx: self.moveX,
                dy: self.moveY
            });
            multiSelection.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
            self.broadcastMove();
            self.showIcons();
            self.origPos = self.marker.getBBox();
            self.marker.toBack();
            self.slate?.grid.toBack();
            self.slate?.canvas.bgToBack();
        }
        const c = self.slate.options.container;
        if (self.slate.options.showMultiSelect) {
            self._init = document.createElement('div');
            self._init.setAttribute('class', 'slateMultiSelect');
            self._init.style.position = 'absolute';
            self._init.style.height = '30px';
            self._init.style.left = '10px';
            self._init.style.color = '#081272';
            self._init.style.fontSize = '11pt';
            self._init.style.fontFamily = 'trebuchet ms';
            self._init.style.top = '5px';
            self._init.style.display = 'block';
            self._init.style.padding = '5px';
            self._init.style.margin = '5px;';
            self._init.style.backgroundColor = '#fff';
            self._init.style.cursor = 'pointer';
            self._init.style['user-select'] = 'none';
            self._init.innerHTML = '[multi-select]';
            self._init.style.zIndex = '0';
            c.appendChild(self._init);
            self.markerEvents = {
                init () {
                    self.hideIcons();
                    multiSelection.hideConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh), self.slate.isCtrl);
                    self.moveX = 0;
                    self.moveY = 0;
                    self.slate.options.allowDrag = false;
                    self.marker.ox = self.marker.attr('x');
                    self.marker.oy = self.marker.attr('y');
                    self.selectedNodes.forEach((node)=>{
                        node.unmark();
                        const bb = node.vect.getBBox();
                        node.vect.ox = bb.x;
                        node.vect.oy = bb.y;
                    });
                },
                move (dx, dy) {
                    try {
                        const _zr = self.slate.options.viewPort.zoom.r;
                        dx += dx / _zr - dx;
                        dy += dy / _zr - dy;
                        self.moveX = dx;
                        self.moveY = dy;
                        const att = {
                            x: self.marker.ox + dx,
                            y: self.marker.oy + dy
                        };
                        self.marker.attr(att);
                        self.selectedNodes.forEach((node)=>{
                            node.vect.currentDx = dx;
                            node.vect.currentDy = dy;
                            node.translateWith({
                                dx,
                                dy
                            });
                        });
                        const _nx = self.origPos.x + self.origPos.width + dx - 5;
                        const _ny = self.origPos.y + self.origPos.height + dy - 5;
                        self.resizer.transform([
                            't',
                            _nx,
                            ',',
                            _ny,
                            ' r95 s1.5,1.5'
                        ].join(''));
                    } catch (err) {
                        finalize();
                    }
                },
                up (e) {
                    if (self.asIndiv) self.selectedNodes.forEach((node)=>{
                        node.mark();
                    });
                    finalize(e);
                }
            };
            self.resizeEvents = {
                init () {
                    self.hideIcons();
                    multiSelection.hideConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh), self.slate.isCtrl);
                    self.moveX = 0;
                    self.moveY = 0;
                    self.slate.options.allowDrag = false;
                    self.selectedNodes.forEach((node)=>{
                        node.unmark();
                        const bb = node.vect.getBBox();
                        node.vect.ox = bb.x;
                        node.vect.oy = bb.y;
                    });
                    self.marker.toBack();
                    self.slate?.grid.toBack();
                    self.slate?.canvas.bgToBack();
                },
                move (dx, dy) {
                    const _zr = self.slate.options.viewPort.zoom.r;
                    dx += dx / _zr - dx;
                    dy += dy / _zr - dy;
                    self.moveX = dx;
                    self.moveY = dy;
                    let _width = self.origPos.width + dx * 2;
                    let _height = self.origPos.height + dy * 2;
                    const _nx = self.origPos.x + self.origPos.width + dx - 5;
                    const _ny = self.origPos.y + self.origPos.height + dy - 5;
                    let rw = true;
                    let rh = true;
                    if (_width < self.minSize) {
                        _width = self.minSize;
                        rw = false;
                    }
                    if (_height < self.minSize) {
                        _height = self.minSize;
                        rh = false;
                    }
                    self.resizer.transform([
                        't',
                        _nx,
                        ',',
                        _ny,
                        ' r95 s1.5,1.5'
                    ].join(''));
                    const att = {
                        width: _width,
                        height: _height
                    };
                    if (rw) Object.assign(att, {
                        x: self.origPos.x - dx
                    });
                    if (rh) Object.assign(att, {
                        y: self.origPos.y - dy
                    });
                    self.marker.attr(att);
                },
                up () {
                    multiSelection.showConnections(self.relationshipsToTranslate.concat(self.relationshipsToRefresh));
                    self.selectedNodes.forEach((node)=>{
                        const transWidth = node.options.width + self.moveX;
                        const transHeight = node.options.height + self.moveY;
                        node.resize.set(transWidth, transHeight, {
                            isMoving: true,
                            getRotationPoint: node.options.rotate.rotationAngle
                        });
                        node.images.imageSizeCorrection();
                        if (self.asIndiv) node.mark();
                    });
                    (0, _refreshRelationshipsDefault.default)({
                        relationships: self.relationshipsToRefresh.concat(self.relationshipsToTranslate),
                        nodes: self.selectedNodes,
                        dx: 0,
                        dy: 0
                    });
                    self.broadcastMove();
                    self.origPos = self.marker.getBBox();
                    const _nx = self.origPos.x + self.origPos.width;
                    const _ny = self.origPos.y + self.origPos.height;
                    self.resizer.transform([
                        't',
                        _nx - 5,
                        ',',
                        _ny - 5
                    ].join(''));
                    self.refreshMarker();
                    self.showIcons();
                    self.marker.toBack();
                    self.slate?.grid.toBack();
                    self.slate?.canvas.bgToBack();
                    self.slate.enable();
                }
            };
            (0, _utilsDefault.default).addEvent(self._init, 'click', (e)=>{
                switch(self._init.innerHTML){
                    case '[multi-select]':
                        self.start();
                        break;
                    case 'selecting [click to stop]...':
                        self.end(false);
                        self.endSelection();
                        break;
                    default:
                        break;
                }
            });
        }
    }
    hide() {
        const self = this;
        if (self._init) self._init.style.display = 'none';
    }
    show() {
        const self = this;
        if (self._init) self._init.style.display = 'block';
    }
    add(node) {
        const self = this;
        self.asIndiv = true;
        if (!self.selectedNodes.find((n)=>n.options.id === node.options.id)) self.selectedNodes.push(node);
        self.hideIcons();
        self.prepSelectedNodes();
    }
    clear() {
        const self = this;
        self.asIndiv = false;
        self.selectedNodes.forEach((node)=>{
            node.unmark();
        });
        self.selectedNodes = [];
        self.hideIcons();
        self.prepSelectedNodes();
    }
    remove(node) {
        const self = this;
        node.unmark();
        self.selectedNodes = self.selectedNodes.filter((n)=>n.options.id !== node.options.id);
        self.asIndiv = self.selectedNodes.length > 0;
        self.hideIcons();
        self.prepSelectedNodes();
    }
    start() {
        const self = this;
        self.slate.disable() // options.allowDrag = false;
        ;
        if (self._init) self._init.innerHTML = 'selecting [click to stop]...';
        document.head.insertAdjacentHTML('beforeend', `<style id='svg-no-select-text'>.slatebox-text { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }</style>`);
        // document.head.insertAdjacentHTML("beforeend", `<style id='svg-no-select-text'>svg text { pointer-events: none; }</style>`);
        const c = self.slate.options.container;
        self.slate.onSelectionStart = (e)=>{
            if (self.slate.options.showMultiSelect) {
                self.end();
                const p = self.xy(e);
                self.selRect = self.slate.paper.rect(p.x, p.y, 10, 10).attr({
                    'stroke-dasharray': '-'
                });
                (0, _utilsDefault.default).addEvent(self.slate.canvas.get(), 'mousemove', self._move.bind(self), null);
                (0, _utilsDefault.default).addEvent(self.slate.canvas.get(), 'mouseup', self._mouseUp.bind(self), null, true);
                (0, _utilsDefault.default).addEvent(self.slate.canvas.get(), 'mouseleave', self._select.bind(self), null, true);
                window.addEventListener('beforeunload', self._enableOnRefresh);
                self.ox = p.x;
                self.oy = p.y;
            }
        };
    }
    _enableOnRefresh() {
        const self = this;
        self.relationshipsToTranslate = [];
        self.relationshipsToRefresh = [];
        self.selectedNodes = [];
        self.slate.enable();
        self.broadcastMove() // broadcast an "empty" move to save the enabled state of the slate
        ;
    }
    createCopiedNodes(nodeOptions, assocDetails) {
        const self = this;
        nodeOptions.forEach((n)=>{
            const nn = new (0, _index.Slatebox).node(n);
            self.slate.nodes.add(nn);
        });
        assocDetails.forEach((a)=>{
            const parentNode = self.slate.nodes.one(a.parentNodeId);
            const childNode = self.slate.nodes.one(a.childNodeId);
            const assocPkg = a.assocPkg;
            assocPkg.child = self.slate.nodes.one(a.assocPkg.childId);
            assocPkg.parent = self.slate.nodes.one(a.assocPkg.parentId);
            delete assocPkg.childId;
            delete assocPkg.parentId;
            parentNode.relationships.addAssociation(childNode, assocPkg);
        });
    }
    showIcons() {
        const self = this;
        if (self.marker !== null) {
            const groupIds = (0, _lodashUniqDefault.default)(self.selectedNodes.map((n)=>n.options.groupId));
            const isGrouped = groupIds.length === 1 && groupIds[0] !== null;
            const markerBB = self.marker.getBBox();
            const multiX = markerBB.x + markerBB.width + 45;
            // TODO: decide if you want to use a settings button here
            const showSettings = true;
            const heightSpacer = 50;
            self.iconBg?.remove();
            self.iconBg = self.slate.paper.rect(multiX - 10, markerBB.y + heightSpacer - 10, 50, heightSpacer * 4, 5).attr({
                ...self.attrs.create,
                opacity: 0.3
            }).toBack();
            const del = self.slate.paper.trash().attr({
                fill: '#fff',
                stroke: '#f00'
            }).transform([
                't',
                multiX,
                ',',
                markerBB.y + heightSpacer * 4,
                's',
                ',',
                '1.25',
                '1.25'
            ].join());
            del.mouseover((e)=>{
                del.attr(self.attrs.mouseOver);
                (0, _utilsDefault.default).stopEvent(e);
            });
            del.mouseout((e)=>{
                del.attr({
                    fill: '#fff',
                    stroke: '#f00'
                });
                (0, _utilsDefault.default).stopEvent(e);
            });
            del.mousedown((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                self.del();
            });
            const copy = self.slate.paper.copy().attr(self.attrs.create).transform([
                't',
                multiX,
                ',',
                markerBB.y + heightSpacer * 2,
                's',
                ',',
                '1.25',
                '1.25'
            ].join());
            copy.mouseover((e)=>{
                copy.attr(self.attrs.mouseOver);
                (0, _utilsDefault.default).stopEvent(e);
            });
            copy.mouseout((e)=>{
                copy.attr(self.attrs.mouseOut);
                (0, _utilsDefault.default).stopEvent(e);
            });
            copy.mousedown((e)=>{
                (0, _utilsDefault.default).stopEvent(e);
                const nGroupId = self.selectedNodes[0].options.groupId ? (0, _utilsDefault.default).guid().replace(/-/gi, '').substring(0, 8).toUpperCase() : null;
                const orient = self.slate.getOrientation(self.selectedNodes);
                const pad = 75;
                const relationalMap = {};
                const nodeOptions = [];
                const assocDetails = [];
                self.selectedNodes.forEach((node)=>{
                    const c = (0, _lodashClonedeepDefault.default)(node.options);
                    c.xPos += orient.width + pad;
                    c.groupId = nGroupId;
                    c.id = (0, _utilsDefault.default).guid().replace(/-/gi, '').substring(0, 12);
                    relationalMap[node.options.id] = c.id;
                    c.vectorPath = (0, _utilsDefault.default)._transformPath(c.vectorPath, `T${orient.width + pad},0`);
                    nodeOptions.push(c);
                    const nn = new (0, _index.Slatebox).node(c);
                    self.slate.nodes.add(nn);
                });
                // next add relationships
                const an = self.slate.nodes.allNodes;
                self.selectedNodes.forEach((node)=>{
                    const nn = an.find((n)=>n.options.id === relationalMap[node.options.id]);
                    // with nn as "parent", add all its children
                    node.relationships.associations.filter((a)=>a.parent.options.id === node.options.id).forEach((a)=>{
                        const assocPkg = (0, _lodashClonedeepDefault.default)(a);
                        delete assocPkg.line // ensure new line is created
                        ;
                        assocPkg.id = (0, _utilsDefault.default).guid().replace(/-/gi, '').substring(0, 12);
                        assocPkg.activeNode = relationalMap[assocPkg.activeNode];
                        let childNode = an.find((n)=>n.options.id === relationalMap[a.child.options.id]);
                        if (!childNode) childNode = an.find((n)=>n.options.id === a.child.options.id);
                        const sendAssocPkg = (0, _lodashOmitDefault.default)(assocPkg, [
                            'child',
                            'parent'
                        ]);
                        sendAssocPkg.childId = assocPkg.child.options.id;
                        sendAssocPkg.parentId = assocPkg.parent.options.id;
                        assocDetails.push({
                            parentNodeId: nn.options.id,
                            childNodeId: childNode.options.id,
                            assocPkg: sendAssocPkg
                        });
                        nn.relationships.addAssociation(childNode, assocPkg);
                    });
                });
                // send collaboration info
                const pkg = {
                    type: 'onNodeAdded',
                    data: {
                        multiSelectCopy: true,
                        nodeOptions,
                        assocDetails
                    }
                };
                self.slate.collab.send(pkg);
            });
            self._icons.push(copy);
            if (!isGrouped) {
                const group = self.slate.paper.plus().attr(self.attrs.create).transform([
                    't',
                    multiX,
                    ',',
                    markerBB.y + heightSpacer,
                    's',
                    ',',
                    '1.25',
                    '1.25'
                ].join());
                group.mouseover((e)=>{
                    group.attr(self.attrs.mouseOver);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                group.mouseout((e)=>{
                    group.attr(self.attrs.mouseOut);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                group.mousedown((e)=>{
                    const groupId = (0, _utilsDefault.default).guid().replace(/-/gi, '').substring(0, 8).toUpperCase();
                    self.selectedNodes.forEach((n)=>{
                        n.options.groupId = groupId;
                    });
                    (0, _utilsDefault.default).stopEvent(e);
                    self.endSelection();
                    self.end();
                    self.showGroup(groupId);
                });
                self._icons.push(group);
            } else {
                const ungroup = self.slate.paper.minus().attr(self.attrs.create).transform([
                    't',
                    multiX,
                    ',',
                    markerBB.y + heightSpacer,
                    's',
                    ',',
                    '1.25',
                    '1.25'
                ].join());
                ungroup.mouseover((e)=>{
                    ungroup.attr(self.attrs.mouseOver);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                ungroup.mouseout((e)=>{
                    ungroup.attr(self.attrs.mouseOut);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                ungroup.mousedown((e)=>{
                    self.selectedNodes.forEach((n)=>{
                        n.options.groupId = null;
                    });
                    (0, _utilsDefault.default).stopEvent(e);
                    self.hideIcons();
                    self.showIcons();
                });
                self._icons.push(ungroup);
            }
            if (showSettings) {
                const settings = self.slate.paper.setting().attr(self.attrs.create).transform([
                    't',
                    multiX,
                    ',',
                    markerBB.y + heightSpacer * 3,
                    's',
                    ',',
                    '1.25',
                    '1.25'
                ].join());
                settings.mouseover((e)=>{
                    settings.attr(self.attrs.mouseOver);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                settings.mouseout((e)=>{
                    settings.attr(self.attrs.mouseOut);
                    (0, _utilsDefault.default).stopEvent(e);
                });
                settings.mousedown((e)=>{
                    (0, _utilsDefault.default).stopEvent(e);
                    if (self.slate.events?.onMenuRequested) self.slate.events?.onMenuRequested(self.selectedNodes, ()=>{});
                });
                self._icons.push(settings);
            }
            self._icons.push(del);
        }
    }
    hideIcons() {
        const self = this;
        self.iconBg?.remove();
        self._icons?.forEach((i)=>i.remove());
    }
    isSelecting() {
        const self = this;
        return self.marker !== null;
    }
    del() {
        const self = this;
        self.slate.events.onConfirmRequested(`Confirm Deletion`, `Are you sure you want to remove these ${self.selectedNodes.length} node(s)?`, (blnConfirm)=>{
            if (blnConfirm) {
                self.selectedNodes.forEach((node)=>{
                    node.del();
                    self.slate.unglow();
                    const delPkg = {
                        type: 'onNodeDeleted',
                        data: {
                            id: node.options.id
                        }
                    };
                    self.slate.collab?.send(delPkg);
                    self.slate.birdsEye?.nodeDeleted(delPkg);
                });
                self.end();
            }
        });
    }
    end(hasMarker = true) {
        const self = this;
        if (self.marker !== null || !hasMarker) {
            self.marker?.remove();
            self.resizer?.remove();
            self.marker = null;
            self.slate.enable();
            // self.slate.keyboard && self.slate.keyboard.end();
            self.hideIcons();
            self.selectedNodes.forEach((n)=>{
                n.unmark();
            });
            window.removeEventListener('beforeunload', self._enableOnRefresh);
        }
        if (self.slate.events?.onGroupSelection) self.slate.events?.onGroupSelection([]);
        if (self._init) self._init.innerHTML = '[multi-select]';
    }
    endSelection() {
        const self = this;
        self.selRect?.remove();
        self.showIcons();
        self.slate.options.allowDrag = true;
        self.slate.onSelectionStart = null;
        (0, _utilsDefault.default).removeEvent(self.slate.canvas.get(), 'mousemove', self._move.bind(self));
    }
    xy(e) {
        const self = this;
        const mp = (0, _utilsDefault.default).mousePos(e);
        const off = (0, _utilsDefault.default).positionedOffset(self.slate.options.container);
        const _x = mp.x + self.slate.options.viewPort.left - off.left;
        const _y = mp.y + self.slate.options.viewPort.top - off.top;
        const z = self.slate.options.viewPort.zoom.r;
        return {
            x: _x / z,
            y: _y / z
        };
    }
    _move(e) {
        const self = this;
        if (!self.slate.draggingNode) {
            const p = self.xy(e);
            const height = p.y - self.oy;
            const width = p.x - self.ox;
            if (height > 0) self.selRect.attr({
                height
            });
            else self.selRect.attr({
                y: p.y,
                height: self.oy - p.y
            });
            if (width > 0) self.selRect.attr({
                width
            });
            else self.selRect.attr({
                x: p.x,
                width: self.ox - p.x
            });
        }
    }
    showGroup(groupId) {
        const self = this;
        self.selectedNodes = self.slate.nodes.allNodes.filter((n)=>n.options.groupId === groupId);
        if (self.prepSelectedNodes()) {
            self.refreshMarker();
            self.showIcons();
        }
    }
    refreshMarker() {
        const self = this;
        self.marker?.remove();
        self.resizer?.remove();
        self.iconBg?.remove();
        self.selectedNodes.forEach((n)=>{
            n.unmark();
        });
        const z = self.slate.options.viewPort.zoom.r;
        const orient = self.slate.getOrientation(self.selectedNodes);
        let w = orient.width / z;
        let h = orient.height / z;
        if (w < self.minSize) w = self.minSize;
        if (h < self.minSize) h = self.minSize;
        self.marker = self.slate.paper.rect(orient.left / z, orient.top / z, w, h).attr({
            'stroke-dasharray': '-',
            fill: '#f8f8f8',
            opacity: 0.3
        });
        self.marker.toBack();
        self.slate?.grid.toBack();
        self.slate?.canvas.bgToBack();
        self.origPos = self.marker.getBBox();
        // self.resizer
        const _nx = self.origPos.x + self.origPos.width;
        const _ny = self.origPos.y + self.origPos.height;
        self.resizer = self.slate.paper.resize().transform([
            't',
            _nx - 5,
            ',',
            _ny - 5,
            'r95 s1.5,1.5'
        ].join()).attr({
            fill: '#fff',
            stroke: '#000'
        });
        self.resizer.toFront();
        self.resizer.mouseover((e)=>{
            self.resizer.attr(self.attrs.mouseOver);
            (0, _utilsDefault.default).stopEvent(e);
        }) // self._resizeHover.bind(self));
        ;
        self.resizer.mouseout((e)=>{
            self.resizer.attr(self.attrs.mouseOut);
            (0, _utilsDefault.default).stopEvent(e);
        }) // self._resizeHover.bind(self));
        ;
        // self.resizer.unmouseover(self._resizeHover.bind(self));
        self.marker.drag(self.markerEvents.move, self.markerEvents.init, self.markerEvents.up);
        self.resizer.drag(self.resizeEvents.move, self.resizeEvents.init, self.resizeEvents.up);
        if (self.asIndiv) self.selectedNodes.forEach((n)=>{
            n.mark();
        });
    }
    prepSelectedNodes() {
        const self = this;
        // select relevant connections
        if (self.selectedNodes.length > 1) {
            const _associations = self.slate.nodes.getRelevantAssociationsWith(self.selectedNodes);
            self.relationshipsToTranslate = _associations.relationshipsToTranslate;
            self.relationshipsToRefresh = _associations.relationshipsToRefresh;
            self.refreshMarker();
            self.endSelection();
            // unmark all and remove connectors
            self.slate.nodes.closeAllMenus({
                nodes: self.selectedNodes
            });
            if (self.slate.events?.onGroupSelection) self.slate.events?.onGroupSelection(self.selectedNodes.map((s)=>s.options.id));
        } else if (self.selectedNodes.length === 1) {
            self.selectedNodes[0].menu.show();
            self.slate.enable();
            self.endSelection();
            self.end();
            if (self.slate.events?.onGroupSelection) self.slate.events?.onGroupSelection([]);
            return false;
        } else {
            self.slate.enable();
            self.endSelection();
            self.end();
            if (self.slate.events?.onGroupSelection) self.slate.events?.onGroupSelection([]);
            return true;
        }
        return false;
    }
    _mouseUp(e) {
        const self = this;
        if (self._init) self._init.innerHTML = '[multi-select]';
        this._select(e);
    }
    _select() {
        const self = this;
        const sr = self.selRect.getBBox();
        if (sr) {
            const withinBox = self.slate.nodes.allNodes.filter((n)=>{
                const inRange = n.options.xPos + n.options.width > sr.x && n.options.xPos < sr.x + sr.width && n.options.yPos + n.options.height > sr.y && n.options.yPos < sr.y + sr.height;
                return inRange && !n.options.isLocked;
            });
            // add any groupIds
            const groupIds = (0, _lodashUniqDefault.default)(withinBox.map((n)=>n.options.groupId)).filter((g)=>!!g);
            const alreadySelectedIds = withinBox.map((n)=>n.options.id);
            self.selectedNodes = self.slate.nodes.allNodes.filter((n)=>alreadySelectedIds.includes(n.options.id) || groupIds.includes(n.options.groupId));
            self.prepSelectedNodes();
        }
    }
    static hideConnections(connections, isCtrl) {
        if (!isCtrl) connections.forEach((c)=>{
            c.line.hide();
        });
    }
    static showConnections(connections) {
        connections.forEach((c)=>{
            c.line.show();
        });
    }
    broadcastMove() {
        const self = this;
        const pkg = {
            type: 'onNodesMove',
            data: self.slate.nodes.nodeMovePackage({
                nodes: self.selectedNodes,
                relationships: self.relationshipsToTranslate.concat(self.relationshipsToRefresh)
            })
        };
        self.slate.collab?.send(pkg);
        self.slate.birdsEye?.nodeChanged(pkg);
    }
}
exports.default = multiSelection;

},{"lodash.uniq":"iDalh","lodash.clonedeep":"i3u1q","lodash.omit":"82TGT","../helpers/utils":"8QI6M","../helpers/refreshRelationships":"1UeYf","../index":"8lqZg","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bRqCq":[function(require,module,exports,__globalThis) {
/* eslint-disable new-cap */ /* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _lodashOmit = require("lodash.omit");
var _lodashOmitDefault = parcelHelpers.interopDefault(_lodashOmit);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _slate = require("../core/slate");
var _slateDefault = parcelHelpers.interopDefault(_slate);
class birdsEye {
    constructor(slate){
        this.slate = slate;
        this.be = null;
        this.corner = null;
        this.handle = null;
        this.orx = null;
        this.sp = null;
        this.options = {
            size: 200,
            onHandleMove: null
        };
        this.parentDimen = null;
        this.lastX = null;
        this.lastY = null;
        this.wpadding = null;
        this.hpadding = null;
    }
    setBe() {
        if (this.be) this.be.style.left = `${this.parentDimen.width - this.options.size}px`;
        if (this.be) this.be.style.top = '-2px';
    }
    _hideText() {
        this.corner.nodes.allNodes.forEach((node)=>{
            node.text.hide();
        });
    }
    _wireHandle() {
        const self = this;
        let start = {};
        const init = function hnd() {
            self.handle.ox = this.attr('x');
            self.handle.oy = this.attr('y');
            start = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
            self.slate.toggleFilters(true);
        };
        const move = function mv(x, y) {
            const _zr = self.corner.options.viewPort.originalWidth / self.sp;
            x += x / _zr - x;
            y += y / _zr - y;
            const _mx = self.handle.ox + x;
            const _my = self.handle.oy + y;
            self.handle.attr({
                x: _mx,
                y: _my
            });
            const bb = self.handle.getBBox();
            const _cx = bb.x * self.slate.options.viewPort.zoom.r;
            const _cy = bb.y * self.slate.options.viewPort.zoom.r;
            self.options.onHandleMove?.apply(self, [
                _cx,
                _cy
            ]);
            self.slate.canvas.move({
                x: _cx,
                y: _cy,
                dur: 0,
                isAbsolute: true
            });
            self.lastX = bb.x;
            self.lastY = bb.y;
        };
        const up = ()=>{
            self.refresh();
            const end = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
            self.slate.canvas.broadcast({
                x: start.left - end.left,
                y: start.top - end.top
            });
            self.slate.toggleFilters(false);
        };
        self.handle.drag(move, init, up);
    }
    show(_options) {
        const self = this;
        Object.assign(self.options, _options);
        const c = self.slate.options.container;
        self.parentDimen = (0, _utilsDefault.default).getDimensions(c);
        self.be = document.createElement('div');
        self.be.setAttribute('id', `slatebirdsEye_${self.slate.options.id}`);
        self.be.setAttribute('class', 'slatebirdsEye');
        self.be.style.position = 'absolute';
        self.be.style.height = `${self.options.size}px`;
        self.be.style.width = `${self.options.size}px`;
        self.be.style.border = '2px inset #333';
        self.be.style.backgroundColor = '#fff';
        c.appendChild(self.be);
        self.setBe();
        async function load() {
            self.corner = await new (0, _slateDefault.default)({
                container: `slatebirdsEye_${self.slate.options.id}`,
                viewPort: {
                    allowDrag: false
                },
                allowCollaboration: false,
                showZoom: false,
                showUndoRedo: false,
                showMultiSelect: false,
                showbirdsEye: false,
                showLocks: false,
                imageFolder: '',
                isbirdsEye: true
            }, {
                onNodeDragged () {
                    self.slate.nodes.copyNodePositions(self.corner.nodes.allNodes);
                }
            }).init();
            self.refresh();
            (0, _utilsDefault.default).addEvent(window, 'resize', ()=>{
                const cx = self.slate.options.container;
                self.parentDimen = (0, _utilsDefault.default).getDimensions(cx);
                self.setBe();
            });
        }
        load();
    }
    enabled() {
        return this.corner !== null;
    }
    enable() {
        if (!this.corner) this.show();
        this.be.style.display = 'block';
    }
    disable() {
        this.be.style.display = 'none';
    }
    relationshipsChanged(pkg) {
        if (this.corner) switch(pkg.type){
            case 'removeRelationship':
                this.corner.nodes.removeRelationship(pkg.data);
                break;
            case 'addRelationship':
                var __pkg = JSON.parse(JSON.stringify(pkg));
                Object.assign(__pkg.data, {
                    options: {
                        lineWidth: 1
                    }
                });
                // data: { id: this.slate.options.id, relationships: rels} };
                this.corner.nodes.addRelationship(__pkg.data);
                break;
            default:
                break;
        }
    }
    nodeChanged(pkg) {
        if (this.corner) {
            if (pkg.type === 'onNodesMove') this.corner.nodes.moveNodes(pkg, {
                useMainCanvas: true
            });
            else {
                const _node = this.corner.nodes.one(pkg.data.id);
                if (_node) {
                    const useMainCanvas = true;
                    switch(pkg.type){
                        case 'onNodeShapeChanged':
                            _node.shapes.set(pkg.data);
                            break;
                        case 'onNodeTextChanged':
                            _node.editor.set(pkg.data.text, pkg.data.fontSize, pkg.data.fontFamily, pkg.data.fontColor, pkg.data.textXAlign, pkg.data.textYAlign);
                            break;
                        case 'onNodeColorChanged':
                            _node.colorPicker.set(pkg.data);
                            break;
                        case 'onNodeImageChanged':
                            _node.images.set(pkg.data.img, pkg.data.w, pkg.data.h, useMainCanvas);
                            this.refresh();
                            break;
                        case 'onNodeResized':
                            Object.assign(_node.options, pkg.data);
                            _node.vect.attr({
                                path: pkg.data.vectorPath
                            });
                            if (_node.vect.pattern) _node.images.imageSizeCorrection();
                            this.refresh();
                            break;
                        case 'onNodeRotated':
                            {
                                pkg.data.associations.forEach((association)=>{
                                    const currentAssociation = _node.relationships.associations.find((ass)=>ass.child.options.id === association.childId && ass.parent.options.id === association.parentId);
                                    if (currentAssociation) currentAssociation.line.attr({
                                        path: association.linePath
                                    });
                                });
                                Object.assign(_node.options, (0, _lodashOmitDefault.default)(pkg.data, 'associations'));
                                const tempPath = this.slate.paper.path(_node.vect.attr('path'));
                                tempPath.remove();
                                _node.rotate.applyImageRotation();
                                this.refresh();
                                break;
                            }
                        case 'onNodeToFront':
                            _node.vect.toFront();
                            break;
                        case 'onNodeToBack':
                            _node.vect.toBack();
                            break;
                        case 'onNodeLocked':
                            _node.options.allowDrag = false;
                            break;
                        case 'onNodeUnlocked':
                            _node.options.allowDrag = true;
                            break;
                        case 'changeLineColor':
                            _node.lineOptions.set(pkg.data);
                            break;
                        default:
                            break;
                    }
                }
            }
        }
    }
    nodeDeleted(pkg) {
        if (this.corner) {
            const _node = this.corner.nodes.one(pkg.data.id);
            _node?.del();
        }
    }
    nodeDetatched(pkg) {
        if (this.corner) {
            const _node = this.corner.nodes.one(pkg.data.id);
            _node?.relationships.detatch();
        }
    }
    reload(json) {
        this.handle?.remove();
        this.corner.loadJSON(json);
        this.refresh(true);
    }
    refresh(blnNoAdditions) {
        if (this.corner) {
            const c = this.slate.options.container;
            this.parentDimen = (0, _utilsDefault.default).getDimensions(c);
            this.handle?.remove();
            if (blnNoAdditions === true) {
                this.corner.canvas.move({
                    x: this.slate.options.viewPort.left,
                    y: this.slate.options.viewPort.top,
                    dur: 0,
                    isAbsolute: true
                });
                const useMainCanvas = true;
                this.corner.nodes.copyNodePositions(this.slate.nodes.allNodes, useMainCanvas);
            } else {
                const _export = this.slate.exportDifference(this.corner, 1) // line width override
                ;
                this.corner.loadJSON(_export, true, true, true, true);
            }
            this.orx = this.slate.getOrientation();
            if (this.slate.options.viewPort.left < this.orx.left) this.wpadding = this.slate.options.viewPort.left - this.orx.left;
            else this.wpadding = this.slate.options.viewPort.left - this.orx.left + (this.parentDimen.width - this.orx.width);
            this.hpadding = this.slate.options.viewPort.top - this.orx.top;
            const _pw = Math.max(Math.abs(this.wpadding), this.orx.width < this.parentDimen.width ? this.parentDimen.width - this.orx.width : 0);
            const _ph = Math.max(Math.abs(this.hpadding), this.orx.height < this.parentDimen.height ? this.parentDimen.height - this.orx.height : 0);
            const wp = (this.orx.width + _pw) / this.options.size * this.slate.options.viewPort.width;
            const hp = (this.orx.height + _ph) / this.options.size * this.slate.options.viewPort.height;
            this.sp = Math.max(wp, hp);
            const _r = Math.max(this.slate.options.viewPort.width, this.slate.options.viewPort.height) / this.sp;
            const l = (this.orx.left + (this.wpadding < 0 ? this.wpadding : 0)) * _r - 5;
            const t = (this.orx.top + (this.hpadding < 0 ? this.hpadding : 0)) * _r - 5;
            this.corner.zoom(0, 0, this.sp, this.sp, true);
            this.corner.options.viewPort.zoom.r = this.corner.options.viewPort.originalWidth / this.sp;
            // this.corner.zoom();
            this.corner.canvas.move({
                x: l,
                y: t,
                dur: 0,
                isAbsolute: true
            });
            this.corner.disable();
            const _ix = this.slate.options.viewPort.left / this.slate.options.viewPort.zoom.r;
            const _iy = this.slate.options.viewPort.top / this.slate.options.viewPort.zoom.r;
            const _w = this.parentDimen.width / this.slate.options.viewPort.zoom.r;
            const _h = this.parentDimen.height / this.slate.options.viewPort.zoom.r;
            this.handle = this.corner.paper.rect(_ix, _iy, _w, _h).attr({
                stroke: '#000',
                'stroke-width': 2,
                fill: '#FFEB3A',
                'fill-opacity': '.5'
            });
            this._hideText();
            this._wireHandle();
        }
    }
}
exports.default = birdsEye;

},{"lodash.omit":"82TGT","../helpers/utils":"8QI6M","../core/slate":"khicH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l9OwD":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _wheelGestures = require("wheel-gestures");
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class inertia {
    constructor(slate){
        this.slate = slate;
        this.scale = 1;
        this.wheelEnd = null;
        this.xyOffset = null;
        if (slate.options.viewPort.useInertiaScrolling) this._init();
    }
    setScale(val) {
        this.scale = val;
    }
    _init() {
        const self = this;
        const wheelGestures = (0, _wheelGestures.WheelGestures)({
            momentum: true
        });
        // find and observe the element the user can interact with
        wheelGestures.observe(self.slate.canvas.internal);
        // function scale() {
        //   window.requestAnimationFrame(() => {
        //     const style = { transform: `scale(${self.scale})` } //, "transform-origin": `${self.slate.options.viewPort.left}px ${self.slate.options.viewPort.top}px` };
        //     console.log("ws is now", self.xyOffset);
        //     self.slate.canvas.internal.style["transform-origin"] = `${self.slate.options.viewPort.left + self.xyOffset.x}px ${self.slate.options.viewPort.top + self.xyOffset.y}px`;
        //     self.slate.canvas.internal.style.transform = `scale(${self.slate.options.viewPort.zoom.r})`; // = style;
        //   })
        // }
        // add your event callback
        let start = {};
        wheelGestures.on('wheel', (e)=>{
            if (self.slate.options.allowDrag) {
                if (e.event.ctrlKey) ;
                else {
                    const deltaX = e.event.deltaX * 0.8 // .5 is the modifier to slow self down a bit
                    ;
                    const deltaY = e.event.deltaY * 0.8;
                    if (e.isStart) {
                        start = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
                        // hide filters during dragging
                        self.slate.toggleFilters(true);
                    }
                    self.slate.canvas.move({
                        x: deltaX,
                        y: deltaY,
                        dur: 0,
                        isAbsolute: false
                    });
                    if (e.isEnding) {
                        const end = (0, _utilsDefault.default).positionedOffset(self.slate.canvas.internal);
                        self.slate.birdsEye?.refresh(true);
                        self.slate.canvas.broadcast({
                            x: start.left - end.left,
                            y: start.top - end.top
                        });
                        // show filters after dragging
                        self.slate.toggleFilters(false);
                    }
                }
            }
        });
    }
}
exports.default = inertia;

},{"wheel-gestures":"9N55x","../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9N55x":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "WheelGestures", ()=>WheelGestures);
parcelHelpers.export(exports, "absMax", ()=>absMax);
parcelHelpers.export(exports, "addVectors", ()=>addVectors);
parcelHelpers.export(exports, "average", ()=>average);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "configDefaults", ()=>configDefaults);
parcelHelpers.export(exports, "deepFreeze", ()=>deepFreeze);
parcelHelpers.export(exports, "lastOf", ()=>lastOf);
parcelHelpers.export(exports, "projection", ()=>projection);
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var DECAY = 0.996;
/**
 * movement projection based on velocity
 * @param velocityPxMs
 * @param decay
 */ var projection = function projection(velocityPxMs, decay) {
    if (decay === void 0) decay = DECAY;
    return velocityPxMs * decay / (1 - decay);
};
function lastOf(array) {
    return array[array.length - 1];
}
function average(numbers) {
    return numbers.reduce(function(a, b) {
        return a + b;
    }) / numbers.length;
}
var clamp = function clamp(value, min, max) {
    return Math.min(Math.max(min, value), max);
};
function addVectors(v1, v2) {
    if (v1.length !== v2.length) throw new Error('vectors must be same length');
    return v1.map(function(val, i) {
        return val + v2[i];
    });
}
function absMax(numbers) {
    return Math.max.apply(Math, numbers.map(Math.abs));
} // eslint-disable-next-line @typescript-eslint/ban-types
function deepFreeze(o) {
    Object.freeze(o);
    Object.values(o).forEach(function(value) {
        if (value !== null && typeof value === 'object' && !Object.isFrozen(value)) deepFreeze(value);
    });
    return o;
}
function EventBus() {
    var listeners = {};
    function on(type, listener) {
        listeners[type] = (listeners[type] || []).concat(listener);
        return function() {
            return off(type, listener);
        };
    }
    function off(type, listener) {
        listeners[type] = (listeners[type] || []).filter(function(l) {
            return l !== listener;
        });
    }
    function dispatch(type, data) {
        if (!(type in listeners)) return;
        listeners[type].forEach(function(l) {
            return l(data);
        });
    }
    return deepFreeze({
        on: on,
        off: off,
        dispatch: dispatch
    });
}
function WheelTargetObserver(eventListener) {
    var targets = []; // add event listener to target element
    var observe = function observe(target) {
        target.addEventListener('wheel', eventListener, {
            passive: false
        });
        targets.push(target);
        return function() {
            return unobserve(target);
        };
    }; /// remove event listener from target element
    var unobserve = function unobserve(target) {
        target.removeEventListener('wheel', eventListener);
        targets = targets.filter(function(t) {
            return t !== target;
        });
    }; // stops watching all of its target elements for visibility changes.
    var disconnect = function disconnect() {
        targets.forEach(unobserve);
    };
    return deepFreeze({
        observe: observe,
        unobserve: unobserve,
        disconnect: disconnect
    });
}
var LINE_HEIGHT = 18;
var PAGE_HEIGHT = typeof window !== 'undefined' && window.innerHeight || 800;
var DELTA_MODE_UNIT = [
    1,
    LINE_HEIGHT,
    PAGE_HEIGHT
];
function normalizeWheel(e) {
    var deltaX = e.deltaX * DELTA_MODE_UNIT[e.deltaMode];
    var deltaY = e.deltaY * DELTA_MODE_UNIT[e.deltaMode];
    var deltaZ = (e.deltaZ || 0) * DELTA_MODE_UNIT[e.deltaMode];
    return {
        timeStamp: e.timeStamp,
        axisDelta: [
            deltaX,
            deltaY,
            deltaZ
        ]
    };
}
var reverseAll = [
    -1,
    -1,
    -1
];
function reverseAxisDeltaSign(wheel, reverseSign) {
    if (!reverseSign) return wheel;
    var multipliers = reverseSign === true ? reverseAll : reverseSign.map(function(shouldReverse) {
        return shouldReverse ? -1 : 1;
    });
    return _extends({}, wheel, {
        axisDelta: wheel.axisDelta.map(function(delta, i) {
            return delta * multipliers[i];
        })
    });
}
var DELTA_MAX_ABS = 700;
var clampAxisDelta = function clampAxisDelta(wheel) {
    return _extends({}, wheel, {
        axisDelta: wheel.axisDelta.map(function(delta) {
            return clamp(delta, -DELTA_MAX_ABS, DELTA_MAX_ABS);
        })
    });
};
var __DEV__ = true;
var ACC_FACTOR_MIN = 0.6;
var ACC_FACTOR_MAX = 0.96;
var WHEELEVENTS_TO_MERGE = 2;
var WHEELEVENTS_TO_ANALAZE = 5;
var configDefaults = /*#__PURE__*/ deepFreeze({
    preventWheelAction: true,
    reverseSign: [
        true,
        true,
        false
    ]
});
var WILL_END_TIMEOUT_DEFAULT = 400;
function createWheelGesturesState() {
    return {
        isStarted: false,
        isStartPublished: false,
        isMomentum: false,
        startTime: 0,
        lastAbsDelta: Infinity,
        axisMovement: [
            0,
            0,
            0
        ],
        axisVelocity: [
            0,
            0,
            0
        ],
        accelerationFactors: [],
        scrollPoints: [],
        scrollPointsToMerge: [],
        willEndTimeout: WILL_END_TIMEOUT_DEFAULT
    };
}
function WheelGestures(optionsParam) {
    if (optionsParam === void 0) optionsParam = {};
    var _EventBus = EventBus(), on = _EventBus.on, off = _EventBus.off, dispatch = _EventBus.dispatch;
    var config = configDefaults;
    var state = createWheelGesturesState();
    var currentEvent;
    var negativeZeroFingerUpSpecialEvent = false;
    var prevWheelEventState;
    var feedWheel = function feedWheel(wheelEvents) {
        if (Array.isArray(wheelEvents)) wheelEvents.forEach(function(wheelEvent) {
            return processWheelEventData(wheelEvent);
        });
        else processWheelEventData(wheelEvents);
    };
    var updateOptions = function updateOptions(newOptions) {
        if (newOptions === void 0) newOptions = {};
        if (Object.values(newOptions).some(function(option) {
            return option === undefined || option === null;
        })) {
            __DEV__ && console.error('updateOptions ignored! undefined & null options not allowed');
            return config;
        }
        return config = deepFreeze(_extends({}, configDefaults, config, newOptions));
    };
    var publishWheel = function publishWheel(additionalData) {
        var wheelEventState = _extends({
            event: currentEvent,
            isStart: false,
            isEnding: false,
            isMomentumCancel: false,
            isMomentum: state.isMomentum,
            axisDelta: [
                0,
                0,
                0
            ],
            axisVelocity: state.axisVelocity,
            axisMovement: state.axisMovement,
            get axisMovementProjection () {
                return addVectors(wheelEventState.axisMovement, wheelEventState.axisVelocity.map(function(velocity) {
                    return projection(velocity);
                }));
            }
        }, additionalData);
        dispatch('wheel', _extends({}, wheelEventState, {
            previous: prevWheelEventState
        })); // keep reference without previous, otherwise we would create a long chain
        prevWheelEventState = wheelEventState;
    }; // should prevent when there is mainly movement on the desired axis
    var shouldPreventDefault = function shouldPreventDefault(deltaMaxAbs, axisDelta) {
        var _config = config, preventWheelAction = _config.preventWheelAction;
        var deltaX = axisDelta[0], deltaY = axisDelta[1], deltaZ = axisDelta[2];
        if (typeof preventWheelAction === 'boolean') return preventWheelAction;
        switch(preventWheelAction){
            case 'x':
                return Math.abs(deltaX) >= deltaMaxAbs;
            case 'y':
                return Math.abs(deltaY) >= deltaMaxAbs;
            case 'z':
                return Math.abs(deltaZ) >= deltaMaxAbs;
            default:
                __DEV__ && console.warn('unsupported preventWheelAction value: ' + preventWheelAction, 'warn');
                return false;
        }
    };
    var processWheelEventData = function processWheelEventData(wheelEvent) {
        var _clampAxisDelta = clampAxisDelta(reverseAxisDeltaSign(normalizeWheel(wheelEvent), config.reverseSign)), axisDelta = _clampAxisDelta.axisDelta, timeStamp = _clampAxisDelta.timeStamp;
        var deltaMaxAbs = absMax(axisDelta);
        if (wheelEvent.preventDefault && shouldPreventDefault(deltaMaxAbs, axisDelta)) wheelEvent.preventDefault();
        if (!state.isStarted) start();
        else if (state.isMomentum && deltaMaxAbs > Math.max(2, state.lastAbsDelta * 2)) {
            end(true);
            start();
        } // special finger up event on windows + blink
        if (deltaMaxAbs === 0 && Object.is && Object.is(wheelEvent.deltaX, -0)) {
            negativeZeroFingerUpSpecialEvent = true; // return -> zero delta event should not influence velocity
            return;
        }
        currentEvent = wheelEvent;
        state.axisMovement = addVectors(state.axisMovement, axisDelta);
        state.lastAbsDelta = deltaMaxAbs;
        state.scrollPointsToMerge.push({
            axisDelta: axisDelta,
            timeStamp: timeStamp
        });
        mergeScrollPointsCalcVelocity(); // only wheel event (move) and not start/end get the delta values
        publishWheel({
            axisDelta: axisDelta,
            isStart: !state.isStartPublished
        }); // state.isMomentum ? MOMENTUM_WHEEL : WHEEL, { axisDelta })
        // publish start after velocity etc. have been updated
        state.isStartPublished = true; // calc debounced end function, to recognize end of wheel event stream
        willEnd();
    };
    var mergeScrollPointsCalcVelocity = function mergeScrollPointsCalcVelocity() {
        if (state.scrollPointsToMerge.length === WHEELEVENTS_TO_MERGE) {
            state.scrollPoints.unshift({
                axisDeltaSum: state.scrollPointsToMerge.map(function(b) {
                    return b.axisDelta;
                }).reduce(addVectors),
                timeStamp: average(state.scrollPointsToMerge.map(function(b) {
                    return b.timeStamp;
                }))
            }); // only update velocity after a merged scrollpoint was generated
            updateVelocity(); // reset toMerge array
            state.scrollPointsToMerge.length = 0; // after calculation of velocity only keep the most recent merged scrollPoint
            state.scrollPoints.length = 1;
            if (!state.isMomentum) detectMomentum();
        } else if (!state.isStartPublished) updateStartVelocity();
    };
    var updateStartVelocity = function updateStartVelocity() {
        state.axisVelocity = lastOf(state.scrollPointsToMerge).axisDelta.map(function(d) {
            return d / state.willEndTimeout;
        });
    };
    var updateVelocity = function updateVelocity() {
        // need to have two recent points to calc velocity
        var _state$scrollPoints = state.scrollPoints, latestScrollPoint = _state$scrollPoints[0], prevScrollPoint = _state$scrollPoints[1];
        if (!prevScrollPoint || !latestScrollPoint) return;
         // time delta
        var deltaTime = latestScrollPoint.timeStamp - prevScrollPoint.timeStamp;
        if (deltaTime <= 0) {
            __DEV__ && console.warn('invalid deltaTime');
            return;
        } // calc the velocity per axes
        var velocity = latestScrollPoint.axisDeltaSum.map(function(d) {
            return d / deltaTime;
        }); // calc the acceleration factor per axis
        var accelerationFactor = velocity.map(function(v, i) {
            return v / (state.axisVelocity[i] || 1);
        });
        state.axisVelocity = velocity;
        state.accelerationFactors.push(accelerationFactor);
        updateWillEndTimeout(deltaTime);
    };
    var updateWillEndTimeout = function updateWillEndTimeout(deltaTime) {
        // use current time between events rounded up and increased by a bit as timeout
        var newTimeout = Math.ceil(deltaTime / 10) * 12; // double the timeout, when momentum was not detected yet
        if (!state.isMomentum) newTimeout = Math.max(100, newTimeout * 2);
        state.willEndTimeout = Math.min(1000, Math.round(newTimeout));
    };
    var accelerationFactorInMomentumRange = function accelerationFactorInMomentumRange(accFactor) {
        // when main axis is the the other one and there is no movement/change on the current one
        if (accFactor === 0) return true;
        return accFactor <= ACC_FACTOR_MAX && accFactor >= ACC_FACTOR_MIN;
    };
    var detectMomentum = function detectMomentum() {
        if (state.accelerationFactors.length >= WHEELEVENTS_TO_ANALAZE) {
            if (negativeZeroFingerUpSpecialEvent) {
                negativeZeroFingerUpSpecialEvent = false;
                if (absMax(state.axisVelocity) >= 0.2) {
                    recognizedMomentum();
                    return;
                }
            }
            var recentAccelerationFactors = state.accelerationFactors.slice(WHEELEVENTS_TO_ANALAZE * -1); // check recent acceleration / deceleration factors
            // all recent need to match, if any did not match
            var detectedMomentum = recentAccelerationFactors.every(function(accFac) {
                // when both axis decelerate exactly in the same rate it is very likely caused by momentum
                var sameAccFac = !!accFac.reduce(function(f1, f2) {
                    return f1 && f1 < 1 && f1 === f2 ? 1 : 0;
                }); // check if acceleration factor is within momentum range
                var bothAreInRangeOrZero = accFac.filter(accelerationFactorInMomentumRange).length === accFac.length; // one the requirements must be fulfilled
                return sameAccFac || bothAreInRangeOrZero;
            });
            if (detectedMomentum) recognizedMomentum();
             // only keep the most recent events
            state.accelerationFactors = recentAccelerationFactors;
        }
    };
    var recognizedMomentum = function recognizedMomentum() {
        state.isMomentum = true;
    };
    var start = function start() {
        state = createWheelGesturesState();
        state.isStarted = true;
        state.startTime = Date.now();
        prevWheelEventState = undefined;
        negativeZeroFingerUpSpecialEvent = false;
    };
    var willEnd = function() {
        var willEndId;
        return function() {
            clearTimeout(willEndId);
            willEndId = setTimeout(end, state.willEndTimeout);
        };
    }();
    var end = function end(isMomentumCancel) {
        if (isMomentumCancel === void 0) isMomentumCancel = false;
        if (!state.isStarted) return;
        if (state.isMomentum && isMomentumCancel) publishWheel({
            isEnding: true,
            isMomentumCancel: true
        });
        else publishWheel({
            isEnding: true
        });
        state.isMomentum = false;
        state.isStarted = false;
    };
    var _WheelTargetObserver = WheelTargetObserver(feedWheel), observe = _WheelTargetObserver.observe, unobserve = _WheelTargetObserver.unobserve, disconnect = _WheelTargetObserver.disconnect;
    updateOptions(optionsParam);
    return deepFreeze({
        on: on,
        off: off,
        observe: observe,
        unobserve: unobserve,
        disconnect: disconnect,
        feedWheel: feedWheel,
        updateOptions: updateOptions
    });
}
exports.default = WheelGestures;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2xnBR":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class controller {
    constructor(slate){
        this.slate = slate;
    }
    static perform(pkg, node, op, cb) {
        const det = op.split('@');
        let dur = pkg.defaultDuration || 300;
        const param = det[1];
        switch(det[0]){
            case 'zoom':
                dur = det.length > 2 ? parseFloat(det[2], 10) : pkg.defaultDuration;
                node.zoom(param, dur, cb);
                break;
            case 'position':
                {
                    const ease = det.length > 2 ? det[2] : pkg.defaultEasing;
                    dur = det.length > 3 ? parseFloat(det[3], 10) : pkg.defaultDuration;
                    node.position(param, cb, ease, dur);
                    break;
                }
            default:
                break;
        }
    }
    scaleToFitNodes(_opts) {
        const opts = {
            nodes: null,
            dur: 0,
            cb: null
        };
        Object.assign(opts, _opts);
        const orient = this.slate.getOrientation(opts.nodes);
        const d = (0, _utilsDefault.default).getDimensions(this.slate.options.container);
        const r = this.slate.options.viewPort.zoom.r || 1;
        const widthZoomPercent = parseInt(d.width / (orient.width / r) * 100, 10) // division by r converts it back from the scaled version
        ;
        const heightZoomPercent = parseInt(d.height / (orient.height / r) * 100, 10);
        // zoom canvas
        this.slate.canvas.zoom({
            dur: opts.dur,
            callbacks: {
                after () {
                    if (opts.cb) opts.cb();
                }
            },
            easing: 'easeFromTo',
            zoomPercent: Math.min(widthZoomPercent, heightZoomPercent)
        });
    }
    // useful for centering the canvas on a collection of nodes
    centerOnNodes(_opts) {
        const self = this;
        const opts = {
            nodes: null,
            dur: 500,
            cb: null
        };
        Object.assign(opts, _opts);
        const orient = self.slate.getOrientation(opts.nodes);
        const d = (0, _utilsDefault.default).getDimensions(self.slate.options.container);
        const cw = d.width;
        const ch = d.height;
        const nw = orient.width;
        const nh = orient.height;
        // get upper left coords
        const x = orient.left - (cw / 2 - nw / 2);
        const y = orient.top - (ch / 2 - nh / 2);
        self.slate.canvas.move({
            x,
            y,
            isAbsolute: true,
            dur: opts.dur,
            easing: 'swingFromTo',
            callbacks: {
                after () {
                    setTimeout(()=>{
                        self.slate.birdseye?.refresh(true);
                    }, 100);
                    if (opts.cb) opts.cb();
                }
            }
        });
    }
    // useful for centering the canvas by comparing the viewport's previous width/height to its current width/height
    center(_opts) {
        const self = this;
        const opts = {
            previousWindowSize: {},
            dur: 500,
            cb: null
        };
        Object.assign(opts, _opts);
        const ws = (0, _utilsDefault.default).windowSize();
        this.slate.canvas.move({
            x: (ws.width - opts.previousWindowSize.w) / 2 * -1,
            y: (ws.height - opts.previousWindowSize.h) / 2 * -1,
            duration: opts.dur,
            isAbsolute: false,
            easing: 'swingFromTo',
            callbacks: {
                after: ()=>{
                    self.slate.birdseye?.refresh(true);
                    if (opts.cb) opts.cb();
                }
            }
        });
        return ws;
    }
    // experimental
    bop(opts) {
        const dur = opts && opts.dur && opts.dur !== 0 ? opts.dur : 300;
        const locale = 'center';
        const ease = 'easeTo';
        const presentNodes = _.map(this.slate.nodes.allNodes, (a)=>({
                name: a.options.name,
                operations: [
                    `position@${locale}@${ease}@${dur}`
                ]
            }));
        this.slate.controller.present({
            nodes: presentNodes,
            // eslint-disable-next-line no-unused-vars
            nodeChanged: (node)=>{},
            // eslint-disable-next-line no-unused-vars
            opChanged: (op)=>{},
            complete: ()=>{},
            sync: {
                zoom: true,
                position: true
            }
        });
    }
    // expiremental
    shakeNodes() {
        const self = this;
        let s = 0;
        function move() {
            s += 1;
            const mPkg = {
                dur: 500,
                moves: [
                    {
                        id: '*',
                        x: s % 2 === 0 ? 20 : -20,
                        y: s % 2 === 0 ? -20 : -20
                    }
                ]
            };
            const pkg = self.slate.nodes.nodeMovePackage(mPkg);
            self.slate.nodes.moveNodes(pkg, {
                animate: true,
                cb: ()=>{
                    setTimeout(()=>{
                        move();
                    }, 4000);
                }
            });
        }
        move();
    }
    pulse(opts) {
        let cycles = 0;
        let dur = 10000 // slow
        ;
        let czp;
        let zp;
        function calc() {
            czp = this.slate.options.viewPort.zoom.r * 100;
            zp = {
                in: czp + 5,
                out: czp - 5
            } // nuance;
            ;
            if (opts) {
                switch(opts.speed){
                    case 'fast':
                        dur = 3000;
                        break;
                    default:
                        break;
                }
                switch(opts.subtlety){
                    case 'trump':
                        zp = {
                            in: czp + 60,
                            out: czp - 60
                        };
                        break;
                    default:
                        break;
                }
            }
        }
        function run(zpp, cb) {
            this.slate.canvas.zoom({
                dur,
                callbacks: {
                    after () {
                        if (cb) cb();
                    }
                },
                easing: 'easeFromTo',
                zoomPercent: zpp
            });
        }
        function cycle() {
            run(zp.in, ()=>{
                run(zp.out, ()=>{
                    cycles += 1;
                    if (opts && opts.cycle && cycles >= opts.cycle) {
                        if (opts.cb) opts.cb();
                    } else cycle();
                });
            });
        }
        if (opts && opts.center) this.scaleToFitAndCenter(()=>{
            calc();
            cycle();
        });
        else {
            calc();
            cycle();
        }
    }
    scaleToFitAndCenter(cb, dur) {
        this.slate.controller.scaleToFitNodes({
            dur: dur != null ? dur : 0,
            cb: ()=>{
                this.centerOnNodes({
                    dur: 0
                });
                if (cb) cb();
            }
        });
    }
    present(pkg) {
        const self = this;
        let currentOperations = [];
        let n = null;
        function next() {
            if (currentOperations.length === 0) {
                if (pkg.nodes.length > 0) {
                    const node = pkg.nodes.shift();
                    n = this.slate.nodes.allNodes.find((nx)=>nx.options.name === node.name);
                    currentOperations = node.operations;
                    if (pkg.nodeChanged) pkg.nodeChanged(node);
                }
            }
            if (currentOperations.length > 0) {
                const op = currentOperations.shift();
                if (pkg.opChanged) pkg.opChanged(op);
                controller.perform(pkg, n, op, (p)=>{
                    const sync = pkg.sync !== undefined ? pkg.sync[p.operation] : false;
                    switch(p.operation){
                        case 'zoom':
                            if (sync) this.slate.collab?.send({
                                type: 'onZoom',
                                data: {
                                    id: p.id,
                                    zoomLevel: p.zoomLevel
                                }
                            });
                            break;
                        case 'position':
                            if (sync) this.slate.collab?.send({
                                type: 'onNodePositioned',
                                data: {
                                    id: p.id,
                                    location: p.location,
                                    easing: p.easing
                                }
                            });
                            break;
                        default:
                            break;
                    }
                    next();
                });
            } else if (pkg.complete) pkg.complete();
        }
        next();
    }
}
exports.default = controller;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6TbYF":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class zoomSlider {
    constructor(slate){
        const self = this;
        self.slate = slate;
        self.slider = null;
        self.sliderId = `sb-zoom-slider-${(0, _utilsDefault.default).guid().substring(8)}`;
    }
    setValue(val) {
        if (this.slider) this.slider.setValue(val);
    }
    hide() {
    // this.slider.style.display = 'none'
    }
    show(_options) {
        const self = this;
        // console.log(
        //   'showing zoom',
        //   self.slate.isReadOnly(),
        //   self.slate.isCommentOnly()
        // )
        if (!self.slate.isReadOnly() && !self.slate.isCommentOnly()) {
            self.hide();
            const options = {
                height: 320,
                width: 28,
                offset: {
                    left: 39,
                    top: 85
                },
                slider: {
                    height: 300,
                    min: 6000,
                    max: 200000,
                    set: 5000
                }
            };
            Object.assign(options, _options);
            const c = self.slate.options.container;
            const scx = document.createElement('div');
            scx.setAttribute('id', `slateSlider_${self.slate.options.id}`);
            scx.style.position = 'absolute';
            scx.style.height = `${options.height}px`;
            scx.style.width = `${options.width}px`;
            scx.style.left = `${options.offset.left}px`;
            scx.style.top = `${options.offset.top}px`;
            scx.style.borderRadius = '7px';
            scx.style.border = '1px solid #ccc';
            scx.style.backgroundColor = '#fff';
            c.appendChild(scx);
            self.slider = document.createElement('input');
            self.slider.setAttribute('orient', 'vertical');
            self.slider.setAttribute('type', 'range');
            self.slider.setAttribute('min', '6000');
            self.slider.setAttribute('step', '50');
            self.slider.setAttribute('max', '200000');
            self.slider.setAttribute('value', self.slate.options.viewPort.zoom.w || 50000);
            self.slider.setAttribute('id', self.sliderId);
            self.slider.style['writing-mode'] = 'bt-lr';
            self.slider.style['-webkit-appearance'] = 'slider-vertical';
            self.slider.style.width = `20px`;
            self.slider.style.height = `${options.height - 5}px`;
            self.slider.style.padding = `0 5px`;
            self.slider.style.transform = `rotate(180deg)`;
            self.slider.addEventListener('input', (e)=>{
                const val = parseFloat(e.target.value);
                self.set(val);
                self.slate.birdsEye?.refresh(true);
            });
            self.slider.addEventListener('change', (e)=>{
                const val = parseFloat(e.target.value);
                self.set(val);
                self.slate.collab?.send({
                    type: 'onZoom',
                    data: {
                        zoomLevel: val
                    }
                });
            });
            scx.appendChild(self.slider);
        }
    }
    set(val) {
        const self = this;
        if (self.slider) self.slider.value = val;
        if (self.slate.canvas.resize(val) || !self.slate.canvas.completeInit) {
            self.slate.zoom(0, 0, val, val, false);
            const z = self.slate.options.viewPort.zoom;
            self.slate.options.viewPort.width = z.w;
            self.slate.options.viewPort.height = z.h;
            self.slate.options.viewPort.left = z.l;
            self.slate.options.viewPort.top = z.t;
        }
    }
}
exports.default = zoomSlider;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"78ZfO":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _raphaelSvg = require("../deps/raphael/raphael.svg");
class undoRedo {
    constructor(slate){
        this.slate = slate;
        this.stateSlate = null;
        this.actions = [];
        this.actionIndex = -1;
        this.toolbar = [];
    }
    setVisibility() {
        const self1 = this;
        if (self1.toolbar.length) {
            self1.toolbar[0].data({
                disabled: false
            });
            self1.toolbar[1].data({
                disabled: false
            });
            if (!this.actions[this.actionIndex - 1]) {
                self1.toolbar[0].attr({
                    'fill-opacity': '0.3'
                });
                self1.toolbar[0].data({
                    disabled: true
                });
            } else self1.toolbar[0].attr({
                'fill-opacity': '1.0'
            });
            if (!this.actions[this.actionIndex + 1]) {
                self1.toolbar[1].attr({
                    'fill-opacity': '0.3'
                });
                self1.toolbar[1].data({
                    disabled: true
                });
            } else self1.toolbar[1].attr({
                'fill-opacity': '1.0'
            });
        }
    }
    run() {
        const state = this.actions[this.actionIndex];
        this.slate.loadJSON(state);
        this.slate.birdsEye?.reload(state);
        const pkg = {
            type: 'onSaveRequested'
        };
        if (self.slate.events?.onSlateChanged) self.slate.events.onSlateChanged.apply(self, [
            {
                type: 'custom',
                slate: this.slate,
                pkg
            }
        ]);
    // this.slate.collaboration?.onCollaboration({
    //   type: 'custom',
    //   slate: this.slate,
    //   pkg,
    // })
    }
    undo() {
        if (this.actions[this.actionIndex - 1]) {
            this.actionIndex -= 1;
            this.setVisibility();
            this.run();
        } else this.setVisibility();
    }
    redo() {
        if (this.actions[this.actionIndex + 1]) {
            this.actionIndex += 1;
            this.setVisibility();
            this.run();
        } else this.setVisibility();
    }
    hide() {
        if ((0, _utilsDefault.default).el('slateUndoRedo') !== null) try {
            this.slate.options.container.removeChild((0, _utilsDefault.default).el('slateUndoRedo'));
        } catch (err) {}
    }
    show(_options) {
        const self1 = this;
        self1.hide();
        const options = {
            height: 80,
            width: 130,
            offset: {
                left: 10,
                top: 8
            }
        };
        Object.assign(options, _options);
        const c = self1.slate.options.container;
        const scx = document.createElement('div');
        scx.setAttribute('id', 'slateUndoRedo');
        scx.style.position = 'absolute';
        scx.style.height = `${options.height}px`;
        scx.style.width = `${options.width}px`;
        scx.style.left = `${options.offset.left}px`;
        scx.style.top = `${options.offset.top}px`;
        c.appendChild(scx);
        const x = options.offset.left;
        const y = options.offset.top + 30;
        options.paper = (0, _raphaelSvg.Raphael)('slateUndoRedo', options.width, options.height);
        self1.toolbar = [
            options.paper.undo().data({
                msg: 'Undo',
                width: 50,
                height: 22
            }).attr({
                fill: '#fff',
                cursor: 'pointer'
            }).attr({
                fill: '#333',
                stroke: '#fff'
            }).transform([
                't',
                x,
                ',',
                y,
                's',
                '1.5',
                '1.5'
            ].join()),
            options.paper.redo().data({
                msg: 'Redo',
                width: 50,
                height: 22
            }).attr({
                fill: '#fff',
                cursor: 'pointer'
            }).attr({
                fill: '#333',
                stroke: '#fff'
            }).transform([
                't',
                x + 50,
                ',',
                y,
                's',
                '-1.5',
                '1.5'
            ].join())
        ];
        self1.toolbar.forEach((toolbarElem)=>{
            toolbarElem.mouseover(function m(e) {
                (0, _utilsDefault.default).stopEvent(e);
                self1.slate.multiSelection?.hide();
                // $(e.target).style.cursor = "pointer";
                if (!this.data('disabled')) {
                    self1.slate.glow(this);
                    const text = this.data('msg');
                    self1.slate.addtip(this.tooltip({
                        type: 'text',
                        msg: text
                    }, this.data('width'), this.data('height')));
                }
            });
            toolbarElem.mouseout(function m(e) {
                (0, _utilsDefault.default).stopEvent(e);
                self1.slate.multiSelection?.show();
                self1.slate.unglow();
                this.untooltip();
            });
        });
        self1.toolbar[0].mousedown(function m(e) {
            (0, _utilsDefault.default).stopEvent(e);
            self1.slate.unglow();
            if (!this.data('disabled')) self1.undo();
        });
        self1.toolbar[1].mousedown(function m(e) {
            (0, _utilsDefault.default).stopEvent(e);
            self1.slate.unglow();
            if (!this.data('disabled')) self1.redo();
        });
        // set the buttons both to be disabled
        self1.setVisibility();
        // register the initial state
        setTimeout(()=>{
            self1.snap(true);
        }, 500);
    }
    snap(init) {
        const self1 = this;
        self1.actionIndex += 1;
        if (self1.actionIndex !== self1.actions.length) // work has bene performed, so abandon the forked record
        self1.actions.splice(self1.actionIndex);
        const exp = self1.slate.exportJSON();
        self1.actions.push(exp);
        clearTimeout(self1.saveSnapshot);
        self1.saveSnapshot = setTimeout(async ()=>{
            if (self1.slate.events.onTakeSnapshot) await self1.slate.events.onTakeSnapshot({
                slateId: self1.slate.options.id,
                snapshot: exp
            });
        }, 3000) // once the slate settles for 3 secs, take a snapshot
        ;
        if (!init) self1.setVisibility();
    }
}
exports.default = undoRedo;

},{"../helpers/utils":"8QI6M","../deps/raphael/raphael.svg":"jK21R","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ixIFt":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class grid {
    constructor(slate){
        this.slate = slate;
        this._grid = null;
        if (this.slate.options.viewPort.showGrid) this.show();
    // produce the required grid patterns
    // <defs>
    //   <pattern id="smallGrid" width="10" height="10" patternUnits="userSpaceOnUse">
    //     <path d="M 10 0 L 0 0 0 10" fill="none" stroke="gray" stroke-width="0.5"/>
    //   </pattern>
    //   <pattern id="grid" width="100" height="100" patternUnits="userSpaceOnUse">
    //     <rect width="100" height="100" fill="url(#smallGrid)"/>
    //     <path d="M 100 0 L 0 0 0 100" fill="none" stroke="gray" stroke-width="1"/>
    //   </pattern>
    // </defs>`;
    }
    setGrid() {
        const gbg = this.slate.options.containerStyle.backgroundColor;
        const gridColor = (0, _utilsDefault.default).whiteOrBlack(gbg);
        if (!this.slate.options.viewPort.gridSize) this.slate.options.viewPort.gridSize = 50;
        const { gridSize } = this.slate.options.viewPort;
        this.slate.paper.def({
            tag: 'pattern',
            id: 'sbSmallGrid',
            height: gridSize,
            width: gridSize,
            patternUnits: 'userSpaceOnUse',
            inside: [
                {
                    type: 'path',
                    attrs: {
                        d: `M ${gridSize} 0 L 0 0 0 ${gridSize}`,
                        fill: 'none',
                        stroke: gridColor,
                        'stroke-width': '0.5'
                    }
                }
            ]
        });
        this.slate.paper.def({
            tag: 'pattern',
            id: 'sbGrid',
            height: gridSize * 10,
            width: gridSize * 10,
            patternUnits: 'userSpaceOnUse',
            inside: [
                {
                    type: 'rect',
                    attrs: {
                        width: gridSize * 10,
                        height: gridSize * 10,
                        fill: 'url(#sbSmallGrid)'
                    }
                },
                {
                    type: 'path',
                    attrs: {
                        d: `M ${gridSize * 10} 0 L 0 0 0 ${gridSize * 10}`,
                        fill: 'none',
                        stroke: gridColor,
                        'stroke-width': '0.5'
                    }
                }
            ]
        });
    }
    show() {
        const self = this;
        this.setGrid();
        self._grid = self.slate.paper.rect(0, 0, self.slate.options.viewPort.width, self.slate.options.viewPort.height).attr({
            fill: 'url(#sbGrid)'
        }).toBack();
        self.slate.canvas.bgToBack();
    }
    toBack() {
        this._grid?.toBack();
    }
    destroy() {
        this._grid?.remove();
    }
}
exports.default = grid;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"g3tty":[function(require,module,exports,__globalThis) {
/* eslint-disable new-cap */ /* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
var _node = require("../core/node");
var _nodeDefault = parcelHelpers.interopDefault(_node);
class comments {
    constructor(slate){
        this.slate = slate;
        this.engaged = false;
    }
    engage() {
        const self = this;
        if (!self.engaged) {
            const comment = `M 14.4761 0 H 3.102 C 1.3888 0 0 1.3888 0 3.102 V 8.5307 c 0 1.7132 1.3888 3.102 3.102 3.102 H 9.8297 l 2.803 4.2412 l 0.9018 -4.2412 h 0.9418 c 1.7132 0 3.102 -1.3888 3.102 -3.102 V 3.102 C 17.5781 1.3888 16.1893 0 14.4761 0 z`;
            const svg = self.slate.canvas.internal.querySelector('svg');
            svg.addEventListener('mousedown', (e)=>{
                const mp = (0, _utilsDefault.default).mousePos(e);
                const x = mp.x + self.slate.options.viewPort.left;
                const y = mp.y + self.slate.options.viewPort.top;
                const tpath = (0, _utilsDefault.default)._transformPath(comment, `T${x},${y}s2,2`);
                const pbox = (0, _utilsDefault.default).getBBox({
                    path: tpath
                });
                const commentNodeOpts = {
                    text: '',
                    xPos: x,
                    yPos: y,
                    height: pbox.height,
                    width: pbox.width,
                    vectorPath: tpath,
                    allowMenu: false,
                    allowDrag: true,
                    opacity: 1,
                    borderOpacity: 1,
                    textOpacity: 1
                };
                const commentNode = new (0, _nodeDefault.default)(commentNodeOpts);
                self.slate.nodes.add(commentNode);
            });
            self.engaged = true;
        }
    }
}
exports.default = comments;

},{"../helpers/utils":"8QI6M","../core/node":"bAVQb","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fRVV4":[function(require,module,exports,__globalThis) {
/* eslint-disable no-underscore-dangle */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class keyboard {
    constructor(slate){
        const self1 = this;
        if (!slate.options.isbirdsEye) {
            self1.slate = slate;
            self1.bindGlobalUp = self1.keyUp.bind(self1);
            self1.bindGlobalDown = self1.keyDown.bind(self1);
            self1.span = 0;
            self1.bindGlobal();
        }
    }
    bindGlobal() {
        const self1 = this;
        (0, _utilsDefault.default).addEvent(document, 'keydown', self1.bindGlobalDown);
        (0, _utilsDefault.default).addEvent(document, 'keyup', self1.bindGlobalUp);
    }
    unbindGlobal() {
        const self1 = this;
        (0, _utilsDefault.default).removeEvent(document, 'keydown', self1.bindGlobalDown);
        (0, _utilsDefault.default).removeEvent(document, 'keyup', self1.bindGlobalUp);
    }
    key(e, blnKeyDown) {
        const self1 = this;
        const node = self1.slate.nodes.allNodes.find((n)=>n.menu.isOpen());
        const key = (0, _utilsDefault.default).getKey(e);
        switch(key){
            case 91:
            case 17:
                self1.slate.isCtrl = blnKeyDown;
                break;
            case 16:
                self1.slate.isShift = blnKeyDown;
                break;
            case 18:
                self1.slate.isAlt = blnKeyDown;
                break;
            default:
                break;
        }
        if (node) switch(key){
            case 37:
            case 38:
            case 39:
            case 40:
                if (blnKeyDown) {
                    if (self1.slate.options.viewPort.zoom.r >= 1) self1.span += 1;
                    else if (self1.slate.options.viewPort.zoom.r <= 0.5) self1.span += 5;
                    else self1.span += 2;
                    node.relationships._initDrag(self1, e);
                    if (key === 37) // left
                    node.relationships.enactMove(-self1.span, 0, true);
                    else if (key === 38) // up
                    node.relationships.enactMove(0, -self1.span, true);
                    else if (key === 39) {
                        // right
                        if (self1.slate.isCtrl) node.connectors.addNode(true);
                        else node.relationships.enactMove(self1.span, 0, true);
                    } else if (key === 40) // down
                    node.relationships.enactMove(0, self1.span, true);
                    node.relationships.showMenu();
                } else {
                    self1.span = 0;
                    node.relationships.finishDrag(true);
                }
                break;
            default:
                break;
        }
    }
    keyUp(e) {
        this.key(e, false);
        this.keyboardActive = false;
    }
    keyDown(e) {
        this.key(e, true);
        this.keyboardActive = true;
        // always have an escape hatch
        setTimeout(()=>{
            if (self.slate) {
                self.slate.isCtrl = false;
                self.slate.isShift = false;
                self.slate.isAlt = false;
            }
        }, 5000);
    }
}
exports.default = keyboard;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"JAVXJ":[function(require,module,exports,__globalThis) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _utils = require("../helpers/utils");
var _utilsDefault = parcelHelpers.interopDefault(_utils);
class filters {
    constructor(slate){
        this.slate = slate;
        this.exposeDefaults();
    }
    addDeps(deps) {
        const self = this;
        deps.forEach((d)=>{
            const depDef = {
                id: (0, _utilsDefault.default).guid().substring(10),
                tag: d.type,
                ...d.attrs,
                inside: []
            };
            d.nested.forEach((n)=>{
                depDef.inside.push({
                    type: n.type,
                    attrs: n.attrs
                });
            });
            self.slate.paper.def(depDef);
        });
    }
    add(filter, isDefault) {
        const self = this;
        const filterDef = {
            id: filter.id || (0, _utilsDefault.default).guid().substring(10),
            tag: 'filter',
            filterUnits: 'userSpaceOnUse',
            ...filter.attrs,
            inside: []
        };
        filter.filters.forEach((ff)=>{
            if (ff.nested) filterDef.inside.push({
                type: ff.type,
                nested: ff.nested
            });
            else filterDef.inside.push({
                type: ff.type,
                attrs: ff.attrs
            });
        });
        self.slate.paper.def(filterDef);
        if (!isDefault) {
            if (!self.slate.customFilters) self.slate.customFilters = [];
            self.slate.customFilters.push(filterDef);
        }
        return filter.id;
    }
    remove(id) {
        const self = this;
        self.slate?.filters.splice(self.slate?.filters.findIndex((f)=>f.id === id));
        return true;
    }
    // <feGaussianBlur in="SourceAlpha" stdDeviation="3"/> <\!-- stdDeviation is how much to blur -->
    // <feOffset dx="2" dy="2" result="offsetblur"/> <\!-- how much to offset -->
    // <feComponentTransfer>
    //   <feFuncA type="linear" slope="0.5"/> <\!-- slope is the opacity of the shadow -->
    // </feComponentTransfer>
    // <feMerge>
    //   <feMergeNode/> <\!-- this contains the offset blurred image -->
    //   <feMergeNode in="SourceGraphic"/> <\!-- this contains the element that the filter is applied to -->
    // </feMerge>
    exposeDefaults() {
        const self = this;
        self.availableFilters = {
            embossed: {
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '1.5',
                            in: 'SourceAlpha'
                        }
                    },
                    {
                        type: 'feOffset',
                        attrs: {
                            dx: '1',
                            dy: '1',
                            result: 'offsetblur'
                        }
                    },
                    {
                        type: 'feComponentTransfer',
                        nested: [
                            {
                                type: 'feFuncA',
                                attrs: {
                                    type: 'linear',
                                    slope: '10'
                                }
                            }
                        ]
                    },
                    {
                        type: 'feMerge',
                        nested: [
                            {
                                type: 'feMergeNode',
                                attrs: {}
                            },
                            {
                                type: 'feMergeNode',
                                attrs: {
                                    in: 'SourceGraphic'
                                }
                            }
                        ]
                    }
                ]
            },
            dropShadow: {
                levers: {
                    feDropShadow: {
                        stdDeviation: {
                            label: 'distance',
                            default: 1.5,
                            range: [
                                1,
                                10
                            ]
                        },
                        dx: {
                            label: 'x-displacement',
                            default: 5,
                            range: [
                                1,
                                50
                            ]
                        },
                        dy: {
                            label: 'y-displacement',
                            default: 5,
                            range: [
                                1,
                                50
                            ]
                        }
                    }
                },
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '3',
                            in: 'SourceAlpha'
                        }
                    },
                    {
                        type: 'feOffset',
                        attrs: {
                            dx: '5',
                            dy: '5',
                            result: 'offsetblur'
                        }
                    },
                    {
                        type: 'feComponentTransfer',
                        nested: [
                            {
                                type: 'feFuncA',
                                attrs: {
                                    type: 'linear',
                                    slope: '0.8'
                                }
                            }
                        ]
                    },
                    {
                        type: 'feMerge',
                        nested: [
                            {
                                type: 'feMergeNode',
                                attrs: {}
                            },
                            {
                                type: 'feMergeNode',
                                attrs: {
                                    in: 'SourceGraphic'
                                }
                            }
                        ]
                    }
                ]
            },
            postItNote: {
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '2',
                            in: 'SourceAlpha'
                        }
                    },
                    {
                        type: 'feOffset',
                        attrs: {
                            dx: '0',
                            dy: '4',
                            result: 'offsetblur'
                        }
                    },
                    {
                        type: 'feComponentTransfer',
                        nested: [
                            {
                                type: 'feFuncA',
                                attrs: {
                                    type: 'linear',
                                    slope: '0.5'
                                }
                            }
                        ]
                    },
                    {
                        type: 'feMerge',
                        nested: [
                            {
                                type: 'feMergeNode',
                                attrs: {}
                            },
                            {
                                type: 'feMergeNode',
                                attrs: {
                                    in: 'SourceGraphic'
                                }
                            }
                        ]
                    }
                ]
            },
            tattered: {
                levers: {
                    feDisplacementMap: {
                        scale: {
                            label: 'torn',
                            default: '10',
                            range: [
                                2,
                                50
                            ]
                        }
                    }
                },
                types: [
                    'vect',
                    'line',
                    'image',
                    'text'
                ],
                filters: [
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'turbulence',
                            baseFrequency: '.05 .05',
                            numOctaves: '05',
                            seed: '2',
                            stitchTiles: 'noStitch',
                            result: 'turbulence'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            in: 'SourceGraphic',
                            in2: 'turbulence',
                            scale: '10',
                            xChannelSelector: 'R',
                            yChannelSelector: 'B',
                            result: 'displacementMap'
                        }
                    }
                ]
            },
            blur: {
                levers: {
                    feGaussianBlur: {
                        stdDeviation: {
                            label: 'displacement',
                            default: 2,
                            range: [
                                1,
                                10
                            ]
                        }
                    }
                },
                types: [
                    'vect',
                    'line',
                    'image'
                ],
                filters: [
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '2',
                            in: 'SourceGraphic',
                            edgeMode: 'none'
                        }
                    }
                ]
            },
            outline: {
                levers: {
                    feMorphology: {
                        radius: {
                            label: 'cutout',
                            default: '1',
                            range: [
                                1,
                                10
                            ]
                        }
                    }
                },
                types: [
                    'text',
                    'line'
                ],
                filters: [
                    {
                        type: 'feMorphology',
                        attrs: {
                            operator: 'dilate',
                            radius: '1',
                            in: 'SourceGraphic',
                            result: 'thickness'
                        }
                    },
                    {
                        type: 'feComposite',
                        attrs: {
                            operator: 'out',
                            in: 'thickness',
                            in2: 'SourceGraphic'
                        }
                    }
                ]
            },
            pixelate: {
                levers: {
                    feImage: {
                        width: {
                            label: 'width',
                            default: '8',
                            range: [
                                1,
                                30
                            ]
                        },
                        height: {
                            label: 'height',
                            default: '8',
                            range: [
                                1,
                                30
                            ]
                        }
                    }
                },
                types: [
                    'image'
                ],
                filters: [
                    // https://stackoverflow.com/questions/37451189/can-one-pixelate-images-with-an-svg-filter
                    {
                        type: 'feGaussianBlur',
                        attrs: {
                            stdDeviation: '2',
                            in: 'SourceGraphic',
                            result: 'smoothed'
                        }
                    },
                    {
                        type: 'feImage',
                        attrs: {
                            width: '8',
                            height: '8',
                            'xlink:href': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAIAAAACDbGyAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAWSURBVAgdY1ywgOEDAwKxgJhIgFQ+AP/vCNK2s+8LAAAAAElFTkSuQmCC',
                            result: 'displacement-map'
                        }
                    },
                    {
                        type: 'feTile',
                        attrs: {
                            in: 'displacement-map',
                            result: 'pixelate-map'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            in: 'smoothed',
                            in2: 'pixelate-map',
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '30',
                            result: 'pre-final'
                        }
                    },
                    {
                        type: 'feComposite',
                        attrs: {
                            operator: 'in',
                            in2: 'SourceGraphic'
                        }
                    }
                ]
            },
            posterize: {
                levers: {},
                types: [
                    'image'
                ],
                filters: [
                    {
                        type: 'feComponentTransfer',
                        nested: {
                            feFuncR: {
                                type: 'discrete',
                                tableValues: '.25 .4 .5 .75 1'
                            },
                            feFuncG: {
                                type: 'discrete',
                                tableValues: '.25 .4 .5 .75 1'
                            },
                            feFuncB: {
                                type: 'discrete',
                                tableValues: '.25 .4 .5 .75 1'
                            }
                        }
                    }
                ]
            },
            sketchy: {
                types: [
                    'vect',
                    'line',
                    'text',
                    'image'
                ],
                filters: [
                    {
                        type: 'feTurbulence',
                        attrs: {
                            baseFrequency: '0.01',
                            numOctaves: 2,
                            result: 'turbulence'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            in2: 'turbulence',
                            in: 'SourceGraphic',
                            scale: 15,
                            xChannelSelector: 'R',
                            yChannelSelector: 'G'
                        }
                    }
                ]
            },
            pencil: {
                // https://heredragonsabound.blogspot.com/2020/02/creating-pencil-effect-in-svg.html
                levers: {},
                types: [
                    'vect',
                    'line',
                    'text',
                    'image'
                ],
                filters: [
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'fractalNoise',
                            baseFrequency: '0.03',
                            numOctaves: '3',
                            seed: '1',
                            result: 'f1'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '5',
                            in: 'SourceGraphic',
                            in2: 'f1',
                            result: 'f4'
                        }
                    },
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'fractalNoise',
                            baseFrequency: '0.03',
                            numOctaves: '3',
                            seed: '10',
                            result: 'f2'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '5',
                            in: 'SourceGraphic',
                            in2: 'f2',
                            result: 'f5'
                        }
                    },
                    {
                        type: 'feTurbulence',
                        attrs: {
                            type: 'fractalNoise',
                            baseFrequency: '1.2',
                            numOctaves: '2',
                            seed: '100',
                            result: 'f3'
                        }
                    },
                    {
                        type: 'feDisplacementMap',
                        attrs: {
                            xChannelSelector: 'R',
                            yChannelSelector: 'G',
                            scale: '3',
                            in: 'SourceGraphic',
                            in2: 'f3',
                            result: 'f6'
                        }
                    }
                ]
            }
        };
    }
} // <filter id="f1" x="0" y="0" width="200%" height="200%">
 //   <feOffset result="offOut" in="SourceGraphic" dx="20" dy="20" />
 //   <feBlend in="SourceGraphic" in2="offOut" mode="normal" />
 // </filter>
 // <feBlend>
 // <feColorMatrix>
 // <feComponentTransfer>
 // <feComposite>
 // <feConvolveMatrix>
 // <feDiffuseLighting>
 // <feDisplacementMap>
 // <feDropShadow>
 // <feFlood>
 // <feGaussianBlur>
 // <feImage>
 // <feMerge>
 // <feMorphology>
 // <feOffset>
 // <feSpecularLighting>
 // <feTile>
 // <feTurbulence></feTurbulence>
 // https://github.com/svgdotjs/svg.filter
 // <filter id="displacementFilter">
 //   <feTurbulence type="turbulence" baseFrequency="0.05" numOctaves="5" seed="2" result="turbulence"/>
 //   <feDisplacementMap in2="turbulence" in="SourceGraphic" scale="2"/>
 // </filter>
exports.default = filters;

},{"../helpers/utils":"8QI6M","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c8dkR":[function(require,module,exports,__globalThis) {
var _indexJs = require("../../index.js");
(0, _indexJs.Slatebox).base.registerPlugin({
    name: "attempt",
    opts: {},
    plugin: class extends (0, _indexJs.Slatebox).node {
        doAttempt() {
            console.log("HELLO NODE do I have inherited properties? ", this.disable);
        }
    }
});

},{"../../index.js":"8lqZg"}],"evEf8":[function(require,module,exports,__globalThis) {
var _indexJs = require("../../index.js");
(0, _indexJs.Slatebox).base.registerPlugin({
    name: "attempt",
    opts: {},
    plugin: class extends (0, _indexJs.Slatebox).slate {
        doSecond() {
            console.log("SLATE hello do I have inherited properties? ", this);
        }
    }
});

},{"../../index.js":"8lqZg"}]},["kWC2B","620jy"], "620jy", "parcelRequire94c2")

</script>
  </body>
</html>
